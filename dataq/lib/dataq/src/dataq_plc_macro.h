/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* DataQ plc macros    */

#ifndef dataq_plc_macro_h
#define dataq_plc_macro_h

#include "pwr_dataqclasses.h"

#define DataQBusSplit_exec(tp, o) { \
  o->Data = o->InP->Data; \
  o->Front = o->InP->Front; \
  o->Back = o->InP->Back; \
}

#define DataQBusJoin_exec(tp, o) { \
  o->Out.Data = *o->DataP; \
  o->Out.Front = *o->FrontP; \
  o->Out.Back = *o->BackP; \
}

#define QOrderBusSplit_exec(tp, o) { \
  o->Status = o->InP->Status; \
  o->New = o->InP->New; \
  o->DataR = o->InP->DataR; \
  o->DataW = o->InP->DataW; \
  o->Front = o->InP->Front; \
  o->Back = o->InP->Back; \
}

#define QOrderBusJoin_exec(tp, o) { \
  o->Out.Status = *o->StatusP; \
  o->Out.New = *o->NewP; \
  o->Out.DataR = *o->DataRP; \
  o->Out.DataW = *o->DataWP; \
  o->Out.Front = *o->FrontP; \
  o->Out.Back = *o->BackP; \
}

/*_*
  QDOrder
  @aref qdorder QDOrder
*/

#define QDOrder_exec(o, qo)\
  timer2_scan(tp, o);\
  if (qo->Status) {\
    if (!o->StatusOld) {\
      timer2_in(tp, o);\
    }\
    o->Status = (o->TimerFlag) ? false : true;\
  } else {\
    if (o->Status) {\
      o->TimerCount = 0;\
      o->Status = false;\
    }\
  }\
  o->StatusOld = qo->Status;

/*_*
   QLOrder
   @aref qlorder QLOrder
*/

#define QLOrder_exec(o, qo)\
  timer2_scan(tp, o);\
  if (qo->Status) {\
    if (!o->StatusOld) {\
      timer2_in(tp, o);\
      o->Status = true;\
    } else\
      o->Status = o->TimerFlag;\
  } else {\
    if (o->Status) {\
      o->TimerCount = 0;\
      o->Status = false;\
    }\
  }\
  o->StatusOld = qo->Status;

/*_*
   QPOrder
   @aref qporder QPOrder
*/

#define QPOrder_exec(o, qo)\
  o->Status = (qo->Status && !o->StatusOld);\
  o->StatusOld = qo->Status;

/*_*
   QCOrder
   @aref qcorder QCOrder
*/

#define QCOrder_exec(o, qo, cond)\
  o->Status = qo->Status && (cond);

/*_*
   SOrder
   @aref sorder SOrder
*/

#define QSOrder_exec(o, qo, reset)\
  if (o->Reset || reset)\
    o->Status = false;\
  if (qo->Status && !o->StatusOld)\
    o->Status = true;\
  o->StatusOld = qo->Status;\
  o->Reset = false;

/*_*
  Reset_QSo
  @aref reset_qso Reset_QSO
*/

#define Reset_QSO_exec(o, in)\
  if (in)\
    o->Reset = true;

/*_*
  DataQSubWind

  @aref dataqsubwind DataQSubWind
*/
#define DataQFoSubWind_exec(o, subwindow)\
  if (o->PlcConnectP &&\
      !(((pwr_sClass_DataQ*)o->PlcConnectP)->Intern.InitTime && \
	!((pwr_sClass_DataQ*)o->PlcConnectP)->Intern.ReloadDone)) {\
    o->DataCurrentIdx = 0;\
    memset(&o->DataCurrent, 0, sizeof(pwr_sClass_DataQBus));\
    subwindow;\
    for (o->DataCurrentIdx = 1;\
	 o->DataCurrentIdx <= ((pwr_sClass_DataQ1*)o->PlcConnectP)->DataSize;\
	 o->DataCurrentIdx++) {\
      o->DataCurrent = ((pwr_sClass_DataQ1*)o->PlcConnectP)->Data[o->DataCurrentIdx-1];\
      subwindow;\
    }\
  }


#endif

