/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2025 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*************************************************************************
 *
 * 	PROGRAM		rs_dataq_appl
 *
 *       Modifierad
 *		971002	Claes Sjöfors	Skapad
 *
 *	Funktion:	Applikationsgränssnitt mot Dataq.
 **************************************************************************/

/*_Include filer_________________________________________________________*/

#include "pwr_baseclasses.h"
#include "pwr_dataqclasses.h"

#include "co_cdh.h"
#include "co_string.h"

#include "rt_gdh.h"
#include "rt_lck.h"
#include "rt_gdh_msg.h"
#include "rt_hash_msg.h"
#include "rs_dataq_msg.h"

#include "dataq_appl.h"

/* Global functions________________________________________________________*/

typedef struct qappl_s_data_list {
  pwr_tOid objid;
  pwr_tString80 name;
  unsigned int possession;
  pwr_tAddress object_ptr;
  pwr_tDlid subid;
  int remove;
  int pending_remove;
  struct qappl_s_data_list* prev_ptr;
  struct qappl_s_data_list* next_ptr;
} qappl_tDataList;

typedef struct qappl_s_basectx {
  qappl_tQueueList* queuelist;
  int queuelist_count;
  qappl_tCtx applctx_list;
  int applctx_count;
  qappl_tDataList* datalist;
} * qappl_tBaseCtx;

/*_Global variables______________________________________________________*/

static qappl_tBaseCtx qappl_basectx = 0;

/*_Local functions________________________________________________________*/

static pwr_tStatus qappl_data_db_create(qappl_tDataList** data_list,
    pwr_tOid objid, int options, qappl_tDataList** datalist_ptr);
static pwr_tStatus qappl_data_db_delete(
    qappl_tDataList** data_list, qappl_tDataList* data_ptr);

/****************************************************************************
* Name:		qappl_data_db_create()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Create an entry in the datalist for an objid.
*
**************************************************************************/
static pwr_tStatus qappl_data_db_create(qappl_tDataList** data_list,
    pwr_tOid objid, int options, qappl_tDataList** datalist_ptr)
{
  qappl_tDataList* next_ptr;
  pwr_tStatus sts;
  pwr_tOName name;
  pwr_sAttrRef attrref;
  pwr_tAddress object_ptr;
  pwr_tDlid subid;

  /* Get a direct link to the original object */
  attrref = cdh_ObjidToAref(objid);
  sts = gdh_DLRefObjectInfoAttrref(&attrref, &object_ptr, &subid);
  if (EVEN(sts))
    return sts;

  if (options & qappl_mOption_NamePath)
    sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mName_path);
  else
    sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mName_object);
  if (EVEN(sts))
    return sts;

  *datalist_ptr = calloc(1, sizeof(qappl_tDataList));
  if (*datalist_ptr == 0)
    return DATAQ__NOMEMORY;

  (*datalist_ptr)->object_ptr = object_ptr;
  (*datalist_ptr)->subid = subid;
  (*datalist_ptr)->objid = objid;
  strcpy((*datalist_ptr)->name, name);

  /* Insert first in list */
  next_ptr = *data_list;
  if (next_ptr != NULL)
    next_ptr->prev_ptr = *datalist_ptr;
  (*datalist_ptr)->next_ptr = next_ptr;

  *data_list = *datalist_ptr;

  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qappl_data_db_delete()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Delete an entry in the datalist.
*
**************************************************************************/
static pwr_tStatus qappl_data_db_delete(
    qappl_tDataList** data_list, qappl_tDataList* data_ptr)
{
  int sts;

  sts = gdh_DLUnrefObjectInfo(data_ptr->subid);

  if (data_ptr == *data_list) {
    /* Change the root */
    *data_list = data_ptr->next_ptr;
    if (*data_list)
      (*data_list)->prev_ptr = 0;
  }

  if (data_ptr->prev_ptr)
    data_ptr->prev_ptr->next_ptr = data_ptr->next_ptr;
  if (data_ptr->next_ptr)
    data_ptr->next_ptr->prev_ptr = data_ptr->prev_ptr;

  free(data_ptr);

  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qappl_queue_init()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*
**************************************************************************/
static pwr_tStatus qappl_queue_init(char* queue_name, pwr_tOid* orig_objid,
    void** orig_queue, pwr_tSubid* orig_subid, pwr_tCid* orig_class)
{
  pwr_sAttrRef attrref;
  pwr_tStatus sts;
  pwr_tOid queue_objid;

  sts = gdh_NameToObjid(queue_name, &queue_objid);
  if (EVEN(sts))
    return DATAQ__APPLQUEUE;

  /* It might already have been stored */
  memset(&attrref, 0, sizeof(attrref));
  attrref = cdh_ObjidToAref(queue_objid);

  sts = gdh_GetObjectClass(attrref.Objid, orig_class);
  if (EVEN(sts))
    return sts;

  /* Link to object */
  sts = gdh_DLRefObjectInfoAttrref(
      &attrref, (pwr_tAddress*)orig_queue, orig_subid);
  if (EVEN(sts))
    return DATAQ__APPLQUEUE;

  return DATAQ__SUCCESS;
}

/**
 *@brief Initialize mirroring.
 *
 * qappl_MirrorInit initiates a mirroring by specifying the queues that should
 * be mirrored.
 *
 * Use qappl_Mirror to fetch the mirrored data structure.
 *
 * The option argument is a bitmask where the bits specifies different functions
 * in qappl_mirror:
 * - qappl_mOption_Remove Dataobject that is removed since the last call of
 *   qappl_Mirror is added to the dataobject list with the remove flags set.
 * - qappl_mOption_NamePath The name field for a dataobject in the
 *datastructure
 *   returned by qappl_Mirror contains the path.
 *
 * @see qappl_Mirror
 * @return pwr_tStatus
 */
pwr_tStatus qappl_MirrorInit(
    pwr_tOName* queue_array, /**< A string array with the
                     names of the queues that
                     should be mirrored. The
                     element after the last
                     queuename should be a NULL
                     string. */
    unsigned long options, /**< Bitmask specifying options for the mirroring.*/
    qappl_tCtx* ctx /**< Context pointer. */
)
{
  pwr_tOName* queuename;
  qappl_tBaseCtx basectx;
  qappl_tCtx applctx;
  qappl_tQueueList* queuelist_ptr;
  qappl_tQueueList* c_ptr;
  int found;
  int sts;
  int maxsize;
  int i;

  if (qappl_basectx == 0) {
    /* Base context is not yet created */
    qappl_basectx = calloc(1, sizeof(*qappl_basectx));
    if (qappl_basectx == 0)
      return 0;
  }
  basectx = qappl_basectx;

  if (basectx->applctx_count >= QAPPL_APPLSESS_MAX)
    return DATAQ__APPLSESSMAX;

  /* Create a context for this applikation call */
  applctx = calloc(1, sizeof(*applctx));
  if (applctx == 0)
    return 0;

  /* Insert applctx in basectx */
  applctx->next = basectx->applctx_list;
  basectx->applctx_list = applctx;
  applctx->index = basectx->applctx_count;
  applctx->index_mask = 1 << basectx->applctx_count;
  basectx->applctx_count++;

  *ctx = applctx;

  /* Add queues to queuelist */
  queuename = queue_array;
  while (!streq((char*)queuename, "")) {
    str_ToUpper((char*)queuename, (char*)queuename);

    /* Check if queue already is inserted */
    queuelist_ptr = basectx->queuelist;
    found = 0;
    while (queuelist_ptr) {
      if (streq((char*)queuename, queuelist_ptr->name)) {
        found = 1;
        break;
      }
      queuelist_ptr = queuelist_ptr->next;
    }
    if (!found) {
      /* Insert queue last position in queuelist */

      queuelist_ptr = calloc(1, sizeof(qappl_tQueueList));
      strcpy((char*)queuelist_ptr->name, (char*)queuename);
      sts = qappl_queue_init(queuelist_ptr->name, &queuelist_ptr->objid,
          &queuelist_ptr->object_ptr, &queuelist_ptr->subid, &queuelist_ptr->classid);
      if (EVEN(sts))
        return sts;

      c_ptr = basectx->queuelist;
      if (!c_ptr)
        basectx->queuelist = queuelist_ptr;
      else {
        while (c_ptr->next)
          c_ptr++;
        c_ptr->next = queuelist_ptr;
      }
      basectx->queuelist_count++;
    }
    if (applctx->queuelist_count < QAPPL_QUEUELIST_MAX) {
      applctx->queuelist[applctx->queuelist_count] = queuelist_ptr;
      queuelist_ptr->index_mask[applctx->index] = 1 << applctx->queuelist_count;
      applctx->queuelist_count++;
    } else
      return DATAQ__APPLQUEUELIST; /* Queuelist to large */

    queuename++;
  }

  /* Calculate the total size of the queue's in the list */
  applctx->total_queuesize = 0;
  for (i = 0; i < applctx->queuelist_count; i++) {
    queuelist_ptr = applctx->queuelist[i];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120:
      maxsize = ((pwr_sClass_DataQ*)queuelist_ptr->object_ptr)->Config.MaxSize;
      applctx->total_queuesize += maxsize;
      queuelist_ptr->tmp_size = sizeof(pwr_sClass_DataQ) + sizeof(pwr_tUInt32) +
          sizeof(pwr_sClass_DataQBus) * maxsize;
      break;
#if 0
    case pwr_cClass_DataQMirrorQueue:
      maxsize = ((pwr_sClass_DataQMirrorQueue*)queuelist_ptr->object_ptr)->MaxSize;
      applctx->total_queuesize += maxsize;
      queuelist_ptr->tmp_size = sizeof(pwr_sClass_DataQMirrorQueue)
          - sizeof(plc_t_DataInfoMirQueue) * (DATAQ_QUEUEMIR_SIZE - maxsize)
          - sizeof(dataq_t_mirqueue_copyarea);
      break;
#endif
    }
    queuelist_ptr->tmp_queue = (void*)calloc(1, queuelist_ptr->tmp_size);
  }

  /* Allocate memory for the data objects array in applctx */
  if (options & qappl_mOption_Remove)
    /* Remove requires the double size */
    applctx->datainfo = (qappl_tDataInfo*)calloc(
        applctx->total_queuesize * 2, sizeof(qappl_tDataInfo));
  else
    applctx->datainfo = (qappl_tDataInfo*)calloc(
        applctx->total_queuesize, sizeof(qappl_tDataInfo));

  lck_Create(&sts, lck_eLock_NMps);
  if (EVEN(sts))
    return sts;

  applctx->options = options;

  return DATAQ__SUCCESS;
}

/**
 *@brief Update mirroring.
 *
 * qappl_Mirror mirrors the content of one or several queues into an
 * application program.
 *
 * The function handles direct link of queues and dataobjects, and returns a list
 * of data objects to the application together with information about front, back,
 * select properties, and which data objects are new or has disappeard. The 
 * application also receives a pointer to each data object.
 *
 * The mirroring is initiated by calling qappl_MirrorInit. The queues are
 * mirrored are specified in this call. Then qappl_Mirror is called cyclic
 * to recieve the current content of the queues. All the dataobjects found in the
 * queues are placed in an array, and the order the queues was specified in
 * qappl_MirrorInit determines the order in the dataobject array.
 *
 * Several mirroring can be handled in the same application (max 32), and each
 * mirroring can handle maximum 32 queues.
 *
 * Example
 * @code
 * #include "pwr_inc:pwr.h"
 * #include "ssab_inc:rs_dataq_appl.h"
 * #include "pwrp_inc:pwr_cvolvkvendclasses.h"
 *
 * main()
 * {
 *   qappl_tCtx      ctx;
 *   int                 i;
 *   int                 plate_count;
 *   qappl_tDataInfo *plate_info;
 *   pwr_tStatus         sts;
 *   pwr_sClass_Plate    *plate_ptr;
 *   pwr_tString80       queuenames[] = {
 *                         "VKV-END-PF-Plc-W-Svb15",
 *                         "VKV-END-PF-Plc-W-R30A",
 *                         ""};
 *
 *   // Init Proview runtime
 *   sts = gdh_Init( "rs_dataq);
 *   if (EVEN(sts)) LogAndExit( sts);
 *
 *  // Init the mirroring
 *  sts = qappl_MirrorInit( queuenames, qappl_mOption_Remove, &ctx);
 *  if (EVEN(sts)) exit(sts);
 *
 *  for (;;) {
 *    sts = qappl_Mirror( ctx, &plate_count, &plate_info);
 *
 *    for ( i = 0; i < plate_count; i++) {
 *      plate_ptr = plate_info[i].object_ptr;
 *      printf( "%20s %1d %1d %1d %1d %1d %4d %5.1f\n",
 *                         plate_info[i].name,
 *                         plate_info[i].front,
 *                         plate_info[i].back,
 *                         plate_info[i].select,
 *                         plate_info[i].new,
 *                         plate_info[i].removed,
 *                         plate_info[i].queue_mask,
 *                         plate_ptr->Tjocklek);
 *     }
 *     sleep( 1);
 *   }
 * }
 *@endcode
 *@return pwr_tStatus
 */
pwr_tStatus qappl_Mirror(
    qappl_tCtx applctx, /**< Context for dataqappl mirror. */
    int* data_count, /**< Number or data object in the array. */
    qappl_tDataInfo**
        datainfo /**< Data strucure with dataobjects found in the queues. */
    )
{
  int i, j, k;
  int found;
  qappl_tQueueList* queuelist_ptr;
  qappl_tDataList* data_ptr;
  qappl_tDataList* data_next_ptr;
  int sts;

  /* Copy queue-objects into the temporary buffer, and hope that
     we will not be interuppted by the plc-program */
  for (i = 0; i < applctx->queuelist_count; i++) {
    queuelist_ptr = applctx->queuelist[i];
    lck_LockNMps;
    memcpy(
        queuelist_ptr->tmp_queue, queuelist_ptr->object_ptr, queuelist_ptr->tmp_size);
    lck_UnlockNMps;
  }

  applctx->data_count = 0;
  for (k = 0; k < applctx->queuelist_count; k++) {
    queuelist_ptr = applctx->queuelist[k];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120: {
      pwr_sClass_DataQ1* object_ptr;
      pwr_sClass_DataQBus* data_block_ptr;

      object_ptr = (pwr_sClass_DataQ1*)queuelist_ptr->tmp_queue;
      if (!(object_ptr->Super.Intern.ReloadDone & pwr_mDataQBackupMask_BackupInitialized))
        continue;

      data_block_ptr = (pwr_sClass_DataQBus*)&object_ptr->Data[0];
      if (applctx->options & qappl_mOption_ReverseOrder)
        data_block_ptr += object_ptr->DataSize - 1;
      for (i = 0; i < object_ptr->DataSize; i++) {
        /* Check that objid is not already inserted */
        found = 0;
        for (j = 0; j < applctx->data_count; j++) {
          if (cdh_ObjidIsEqual(applctx->datainfo[j].objid,
                  data_block_ptr->Data.Aref.Objid)) {
            found = 1;
            break;
          }
        }
        if (!found) {
          applctx->datainfo[applctx->data_count].objid
              = data_block_ptr->Data.Aref.Objid;
          applctx->datainfo[applctx->data_count].front
              = data_block_ptr->Front;
          applctx->datainfo[applctx->data_count].back
              = data_block_ptr->Back;
          applctx->datainfo[applctx->data_count].select
              = data_block_ptr->Select;
          applctx->datainfo[applctx->data_count].queue_mask
              = queuelist_ptr->index_mask[applctx->index];
          applctx->datainfo[applctx->data_count].removed = 0;
          applctx->data_count++;
        } else {
          applctx->datainfo[applctx->data_count].front
              |= data_block_ptr->Front;
          applctx->datainfo[applctx->data_count].back
              |= data_block_ptr->Back;
          if (data_block_ptr->Select)
            applctx->datainfo[applctx->data_count].select = 1;
          applctx->datainfo[applctx->data_count].queue_mask
              |= queuelist_ptr->index_mask[applctx->index];
        }
        if (applctx->options & qappl_mOption_ReverseOrder)
          data_block_ptr--;
        else
          data_block_ptr++;
      }
      break;
    }
#if 0
    case pwr_cClass_DataQMirrorQueue: {
      pwr_sClass_DataQMirrorQueue* object_ptr;
      plc_t_DataInfoMirQueue* data_block_ptr;

      object_ptr = (pwr_sClass_DataQMirrorQueue*)queuelist_ptr->tmp_queue;

      data_block_ptr = (plc_t_DataInfoMirQueue*)&object_ptr->Data1P;
      for (i = 0; i < object_ptr->LastIndex; i++) {
        /* Check that objid is not already inserted */
        found = 0;
        for (j = 0; j < i; j++) {
          if (cdh_ObjidIsEqual(applctx->datainfo[j].objid,
                  data_block_ptr->DataP.Aref.Objid)) {
            found = 1;
            break;
          }
        }
        if (!found) {
          applctx->datainfo[applctx->data_count].objid
              = data_block_ptr->DataP.Aref.Objid;
          applctx->datainfo[applctx->data_count].select = 0;
          applctx->datainfo[applctx->data_count].front = 0;
          applctx->datainfo[applctx->data_count].back = 0;
          applctx->datainfo[applctx->data_count].queue_mask
              = queuelist_ptr->index_mask[applctx->index];
          applctx->datainfo[applctx->data_count].removed = 0;
          applctx->data_count++;
        } else {
          applctx->datainfo[applctx->data_count].queue_mask
              |= queuelist_ptr->index_mask[applctx->index];
        }
        data_block_ptr++;
      }
      break;
    }
#endif
    }
  }

  /* Insert new data-object in the data db, or find the old ones */

  /* Set the remove flag for all the dataobjects of this applctx */
  data_ptr = qappl_basectx->datalist;
  while (data_ptr) {
    if (data_ptr->possession & applctx->index_mask)
      data_ptr->remove = 1;
    data_ptr = data_ptr->next_ptr;
  }

  for (i = 0; i < applctx->data_count; i++) {
    /* Try to find the data-object */
    found = 0;
    data_ptr = qappl_basectx->datalist;
    while (data_ptr) {
      if (cdh_ObjidIsEqual(applctx->datainfo[i].objid, data_ptr->objid)) {
        if (data_ptr->possession & applctx->index_mask) {
          /* It already belongs to this application session */
          if (data_ptr->pending_remove)
            /* The object has reappleard */
            data_ptr->pending_remove = 0;

          applctx->datainfo[i].object_ptr = data_ptr->object_ptr;
          data_ptr->remove = 0;
          applctx->datainfo[i].newdata = 0;
        } else {
          /* A new object for this session, mark possession */
          if (data_ptr->pending_remove) {
            /* The object has reappleard from another session */
            data_ptr->pending_remove = 0;
            data_ptr->possession = 0;
          }
          data_ptr->possession |= applctx->index_mask;
          applctx->datainfo[i].object_ptr = data_ptr->object_ptr;
          applctx->datainfo[i].newdata = 1;
          data_ptr->remove = 0;

          /* Insert in new data list */
        }
        strcpy(applctx->datainfo[i].name, data_ptr->name);
        found = 1;
        break;
      }
      data_ptr = data_ptr->next_ptr;
    }
    if (!found) {
      /* A new object, insert it into the data database */
      sts = qappl_data_db_create(&qappl_basectx->datalist,
          applctx->datainfo[i].objid, applctx->options, &data_ptr);
      if (EVEN(sts))
        return sts;

      data_ptr->possession |= applctx->index_mask;
      applctx->datainfo[i].object_ptr = data_ptr->object_ptr;
      applctx->datainfo[i].newdata = 1;
      strcpy(applctx->datainfo[i].name, data_ptr->name);

      /* Insert in new data list */
    }
  }

  /* Mark objects for remove that was previously possessed by this
          session only */
  data_ptr = qappl_basectx->datalist;
  while (data_ptr) {
    if (data_ptr->remove && data_ptr->possession & applctx->index_mask) {
      if (data_ptr->possession == applctx->index_mask
          && data_ptr->pending_remove) {
        /* Remove the object from the database */
        data_next_ptr = data_ptr->next_ptr;
        sts = qappl_data_db_delete(&qappl_basectx->datalist, data_ptr);
        if (EVEN(sts))
          return sts;
        data_ptr = data_next_ptr;
        continue;
      } else {
        /* Remove next scan */
        if (data_ptr->possession == applctx->index_mask)
          data_ptr->pending_remove = 1;
        else
          data_ptr->possession &= ~applctx->index_mask;
        if (applctx->options & qappl_mOption_Remove) {
          /* Add the removed to the list */
          applctx->datainfo[applctx->data_count].objid = data_ptr->objid;
          applctx->datainfo[applctx->data_count].select = 0;
          applctx->datainfo[applctx->data_count].front = 0;
          applctx->datainfo[applctx->data_count].back = 0;
          applctx->datainfo[applctx->data_count].queue_mask = 0;
          applctx->datainfo[applctx->data_count].removed = 1;
          applctx->datainfo[i].object_ptr = data_ptr->object_ptr;
          applctx->datainfo[i].newdata = 0;
          strcpy(applctx->datainfo[i].name, data_ptr->name);
          applctx->data_count++;
        }
      }
    }
    data_ptr = data_ptr->next_ptr;
  }

  *datainfo = applctx->datainfo;
  *data_count = applctx->data_count;
  return DATAQ__SUCCESS;
}

/**
 *@brief Removes a dataobject from one of the queues that are mirrored.
 *
 *@see qappl_RemoveAndDeleteData
 *@return pwr_tStatus
 */
pwr_tStatus qappl_RemoveData(
    qappl_tCtx applctx, /**< Context for dataqappl mirror. */
    pwr_tOid objid /**< Objid for dataobject that is to be removed. */
    )
{
  int k;
  qappl_tQueueList* queuelist_ptr;

  for (k = 0; k < applctx->queuelist_count; k++) {
    queuelist_ptr = applctx->queuelist[k];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120: {
      pwr_sClass_DataQ* object_ptr;

      object_ptr = (pwr_sClass_DataQ*)queuelist_ptr->object_ptr;
      object_ptr->Control.Operation = pwr_eDataQCtlEnum_Delete;
      object_ptr->Control.Objid = objid;
      object_ptr->Control.Commit = 1;
      break;
    }
    default:
      break;
    }
  }
  return DATAQ__SUCCESS;
}

/**
 *@brief Removes and deletes a dataobject from one of the queues that are
 *mirrored.
 *
 *@see qappl_RemoveData
 *@return pwr_tStatus
 */
pwr_tStatus qappl_RemoveAndDeleteData(
    qappl_tCtx applctx, /**< dataqappl mirror context. */
    pwr_tOid objid /**< Objid for the data object that is to be removed. */
    )
{
  int sts, k;
  qappl_tQueueList* queuelist_ptr;

  for (k = 0; k < applctx->queuelist_count; k++) {
    queuelist_ptr = applctx->queuelist[k];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120: {
      pwr_sClass_DataQ* object_ptr;

      object_ptr = (pwr_sClass_DataQ*)queuelist_ptr->object_ptr;
      object_ptr->Control.Operation = pwr_eDataQCtlEnum_DeleteObjid;
      object_ptr->Control.Objid = objid;
      object_ptr->Control.Commit = 1;
      break;
    }
    default:
      break;
    }
  }
  sts = gdh_DeleteObject(objid);
  if (EVEN(sts))
    return sts;

  return DATAQ__SUCCESS;
}

pwr_tStatus qappl_SelectData(qappl_tCtx applctx, pwr_tOid objid)
{
  int k;
  qappl_tQueueList* queuelist_ptr;

  for (k = 0; k < applctx->queuelist_count; k++) {
    queuelist_ptr = applctx->queuelist[k];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120: {
      pwr_sClass_DataQ* object_ptr;

      object_ptr = (pwr_sClass_DataQ*)queuelist_ptr->object_ptr;
      object_ptr->Control.Operation = pwr_eDataQCtlEnum_SelectObjid;
      object_ptr->Control.Objid = objid;
      object_ptr->Control.Commit = 1;
      break;
    }
    default:
      break;
    }
  }

  return DATAQ__SUCCESS;
}

pwr_tStatus qappl_TransportData(qappl_tCtx applctx, pwr_tOid objid,
    unsigned int from_queue_mask, unsigned int to_queue_mask)
{
  int k;
  unsigned int mask;
  qappl_tQueueList* queuelist_ptr;

  /* Check that to queue is not busy or full */
  mask = 1;
  for (k = 0; k < applctx->queuelist_count; k++, mask = mask << 1) {
    if (!(mask & to_queue_mask))
      continue;

    queuelist_ptr = applctx->queuelist[k];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120: {
      pwr_sClass_DataQ* object_ptr;

      object_ptr = (pwr_sClass_DataQ*)queuelist_ptr->object_ptr;
      if (object_ptr->Control.Commit)
        return DATAQ__QUEUEEXTERNBUSY;
      if (object_ptr->Intern.QueueFull)
        return DATAQ__QUEUEFULL;
      break;
    }
    default:
      break;
    }
    break;
  }

  /* Remove data first */
  mask = 1;
  for (k = 0; k < applctx->queuelist_count; k++, mask = mask << 1) {
    if (!(mask & from_queue_mask))
      continue;

    queuelist_ptr = applctx->queuelist[k];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120: {
      pwr_sClass_DataQ* object_ptr;

      object_ptr = (pwr_sClass_DataQ*)queuelist_ptr->object_ptr;
      if (object_ptr->Control.Commit)
        return DATAQ__QUEUEEXTERNBUSY;

      object_ptr->Control.Operation = pwr_eDataQCtlEnum_RemoveObjid;
      object_ptr->Control.Objid = objid;
      object_ptr->Control.Commit = 1;
      break;
    }
    default:
      break;
    }
  }

  /* Insert data */
  mask = 1;
  for (k = 0; k < applctx->queuelist_count; k++, mask = mask << 1) {
    if (!(mask & to_queue_mask))
      continue;

    queuelist_ptr = applctx->queuelist[k];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120: {
      pwr_sClass_DataQ* object_ptr;

      object_ptr = (pwr_sClass_DataQ*)queuelist_ptr->object_ptr;
      if (object_ptr->Control.Commit)
        return DATAQ__QUEUEEXTERNBUSY;
      if (object_ptr->Intern.QueueFull)
        return DATAQ__QUEUEFULL;

      object_ptr->Control.Operation = pwr_eDataQCtlEnum_Insert;
      object_ptr->Control.Objid = objid;
      object_ptr->Control.Commit = 1;
      break;
    }
    default:
      break;
    }
    break;
  }

  return DATAQ__SUCCESS;
}

pwr_tStatus qappl_InsertData(
    qappl_tCtx applctx, pwr_tOid objid, unsigned int queue_mask)
{
  int k;
  unsigned int mask;
  qappl_tQueueList* queuelist_ptr;

  /* Insert data */
  mask = 1;
  for (k = 0; k < applctx->queuelist_count; k++, mask = mask << 1) {
    if (!(mask & queue_mask))
      continue;

    queuelist_ptr = applctx->queuelist[k];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120: {
      pwr_sClass_DataQ* object_ptr;

      object_ptr = (pwr_sClass_DataQ*)queuelist_ptr->object_ptr;
      if (object_ptr->Control.Commit)
        return DATAQ__QUEUEEXTERNBUSY;

      object_ptr->Control.Operation = pwr_eDataQCtlEnum_Insert;
      object_ptr->Control.Objid = objid;
      object_ptr->Control.Commit = 1;
      break;
    }
    default:
      break;
    }
    break;
  }

  return DATAQ__SUCCESS;
}

pwr_tStatus qappl_RemoveAndKeepData(
    qappl_tCtx applctx, pwr_tOid objid, unsigned int queue_mask)
{
  int k;
  unsigned int mask;
  qappl_tQueueList* queuelist_ptr;

  /* Remove data first */
  mask = 1;
  for (k = 0; k < applctx->queuelist_count; k++, mask = mask << 1) {
    if (!(mask & queue_mask))
      continue;

    queuelist_ptr = applctx->queuelist[k];
    switch (queuelist_ptr->classid) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ5:
    case pwr_cClass_DataQ30:
    case pwr_cClass_DataQ120: {
      pwr_sClass_DataQ* object_ptr;

      object_ptr = (pwr_sClass_DataQ*)queuelist_ptr->object_ptr;
      if (object_ptr->Control.Commit)
        return DATAQ__QUEUEEXTERNBUSY;

      object_ptr->Control.Operation = pwr_eDataQCtlEnum_RemoveObjid;
      object_ptr->Control.Objid = objid;
      object_ptr->Control.Commit = 1;
      break;
    }
    default:
      break;
    }
  }

  return DATAQ__SUCCESS;
}
