/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2023 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* DataQ plc functions */

#include "pwr.h"

typedef struct {
  pwr_tDataRef                        Data pwr_dAlignLW;
  pwr_tBoolean                        Front pwr_dAlignW;
  pwr_tBoolean                        Back pwr_dAlignW;
  pwr_tRefId                          Dlid pwr_dAlignW;
  pwr_tBoolean                        Select pwr_dAlignW;
  pwr_tBoolean                        SelectOld pwr_dAlignW;
} pwr_tDataQBus;

#include "co_cdh.h"
#include "rt_lck.h"
#include "rt_plc.h"
#include "rt_gdh.h"
#include "pwr_dataqclasses.h"
#include "dataq.h"
#include "rs_dataq_msg.h"

#if 0
#define lck_Lock(l) ;
#define lck_Unlock(l) ;
#endif

#define NMPS_CELL_MAXSIZE 120

static void DataQStoreFo_exec(plc_sThread* tp, pwr_sClass_DataQFo* o);

/*      DataQ
*/
void DataQFo_init_time(pwr_sClass_DataQFo* o)
{
  pwr_sAttrRef attrref;
  pwr_sClass_DataQBus* data_index;
  int i, sts;
  pwr_sClass_DataQ1* co = (pwr_sClass_DataQ1*)o->PlcConnectP;

  /* Get new object pointers at restart av plc program */
  data_index = (pwr_sClass_DataQBus*)&co->Data[0];
  for (i = 1; i <= co->DataSize; i++) {
    attrref = data_index->Data.Aref;
    sts = gdh_DLRefObjectInfoAttrref(
        &attrref, (pwr_tAddress*)&data_index->Data.Ptr, &data_index->Dlid);
    data_index++;
  }
  if (co->DataSize) {
    data_index = (pwr_sClass_DataQBus*)&co->Data[0];
    data_index += co->DataSize - 1;
    memcpy(&co->Super.Trp.DataL, data_index, sizeof(*data_index));
    o->Data1 = co->Data[0];
    memcpy(&o->DataLast, data_index, sizeof(*data_index));
  }
  co->Super.Intern.InitTime = 0;
  co->Super.Intern.ReloadDone |= pwr_mDataQBackupMask_BackupInitialized;
}

void DataQFo_init(pwr_sClass_DataQFo* o)
{
  pwr_sClass_DataQBus* data_index;
  int i;
  pwr_tStatus sts;
  pwr_tDlid dlid;
  pwr_sClass_DataQ1* co;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts)) {
    o->PlcConnectP = 0;
    return;
  }
  co = (pwr_sClass_DataQ1*)o->PlcConnectP;

  lck_Create(&sts, lck_eLock_NMps);

  if (!(co->Super.Config.Function & pwr_mDataQOptionsMask_Backup))
    DataQFo_init_time(o);
  else {
    /* Backup, reset all nonvalid pointers */
    data_index = (pwr_sClass_DataQBus*)&co->Data[0];
    for (i = 1; i <= co->DataSize; i++) {
      data_index->Data.Ptr = NULL;
      data_index++;
    }
    if (co->DataSize) {
      co->Super.Trp.DataL.Data.Ptr = NULL;
      o->DataLast.Data.Ptr = NULL;
    }
    co->Super.Intern.InitTime = 1;
  }
  if (co->Super.Config.MaxSize > co->Super.Intern.DataElements)
    co->Super.Config.MaxSize = co->Super.Intern.DataElements;
}


/*_*
  DataQFo

  @aref dataqfo DataQFo
*/

void DataQFo_exec(plc_sThread* tp, pwr_sClass_DataQFo* o)
{
  int i, sts;
  pwr_sClass_DataQBus* data_max;
  pwr_sClass_DataQBus* data_last;
  pwr_sClass_DataQBus* data_index;
  pwr_sClass_DataQBus data_tmp;
  int size;
  pwr_sAttrRef extern_attrref;
  gdh_tDlid data_dlid;
  unsigned long* data_pointer = NULL;
#if defined OS_LINUX
  char* tmp_buf;
#endif

  pwr_sClass_DataQ1* co = (pwr_sClass_DataQ1*)o->PlcConnectP;

  if (co->Super.Config.Function == pwr_eDataQFunctionEnum_StoreQueue) {
    DataQStoreFo_exec(tp, o);
    return;
  }

  if (co->Super.Intern.InitTime) {
    if (!(co->Super.Intern.ReloadDone & pwr_mDataQBackupMask_BackupLoaded))
      return;
    else {
      lck_LockNMps;
      DataQFo_init_time(o);
      co->Super.Intern.ReloadDone &= ~pwr_mDataQBackupMask_BackupLoaded;
    }
  } else
    lck_LockNMps;

  if (o->FrontNew)
    o->FrontNew = 0;
  if (o->RearNew)
    o->RearNew = 0;
  if (co->Super.Config.MaxSize > NMPS_CELL_MAXSIZE)
    co->Super.Config.MaxSize = NMPS_CELL_MAXSIZE;

  if (o->ResetObjectP || co->Super.Intern.QReset) {
    if ((o->ResetObjectP && *o->ResetObjectP) || co->Super.Intern.QReset) {
      data_index = (pwr_sClass_DataQBus*)&co->Data[0];
      for (i = 1; i <= co->DataSize; i++) {
        sts = gdh_DLUnrefObjectInfo(data_index->Dlid);
        if (co->Super.Config.Options & pwr_mDataQOptionsMask_DeleteWhenReset)
          sts = gdh_DeleteObject(data_index->Data.Aref.Objid);
        data_index++;
      }
      memset(&co->Data[0], 0, co->DataSize * 
	  sizeof(pwr_sClass_DataQBus));
      memset(&co->Super.Trp.DataL, 0, sizeof(pwr_sClass_DataQBus));
      memset(&o->DataLast, 0, sizeof(pwr_sClass_DataQBus));
      memset(&o->Data1, 0, sizeof(pwr_sClass_DataQBus));
      o->QueueFull = 0;
      co->Super.Intern.QueueFull = o->QueueFull;
      co->DataSize = 0;
      if (!o->OldReset)
	co->Super.Intern.RQReset = 1;
      if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
        co->Super.Intern.BackupNow = 1;
    }
    if (o->ResetObjectP)
      o->OldReset = *o->ResetObjectP;
    co->Super.Intern.QReset = 0;
  }
  if ( co->Super.Config.Options & pwr_mDataQOptionsMask_CheckObjects) {
    data_index = &co->Data[0];
    for ( i = 0; i < co->DataSize; i++) {
      sts = gdh_CheckLocalObject(data_index->Data.Aref.Objid);
      if ( EVEN(sts)) {
	/* Remove object */
	sts = gdh_DLUnrefObjectInfo(data_index->Dlid);
	if (i < co->DataSize) {
	  size = (co->DataSize - i) * sizeof(*data_max);
#if defined OS_LINUX
	  tmp_buf = malloc(size);
	  memcpy(tmp_buf, (char*)data_index + sizeof(*data_max), size);
	  memcpy(data_index, tmp_buf, size);
	  free(tmp_buf);
#else
	  memcpy(data_index, (char*)data_index + sizeof(*data_max), size);
#endif
	}
	data_last = &co->Data[0];
	data_last += co->DataSize - 1;
	memset(data_last, 0, sizeof(*data_last));
	o->QueueFull = 0;
	co->Super.Intern.QueueFull = o->QueueFull;
	co->DataSize--;
	if (co->DataSize > 0) {
	  data_last--;
	  memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
	  memcpy(&o->DataLast, data_last, sizeof(*data_last));
	} else {
	  memset(&co->Super.Trp.DataL, 0, sizeof(*data_last));
	  memset(&o->DataLast, 0, sizeof(*data_last));
	}
	i--;
      }
      else
	data_index++;
    }
  }

  if (co->Super.Control.Commit) {
    /* Insert new object in Front position */

    switch (co->Super.Control.Operation) {
    case pwr_eDataQCtlEnum_Insert:
      co->Super.Control.Index = 1;
    case pwr_eDataQCtlEnum_InsertIndex:
      /* Direct link to extern objid */
      if (co->Super.Control.Index <= 0 || co->Super.Control.Index > co->Super.Config.MaxSize)
        co->Super.Control.Status = DATAQ__EXTERNIDX;
      else if (o->QueueFull)
        co->Super.Control.Status = DATAQ__QUEUEFULL;
      else if (co->Super.Control.Index > co->DataSize + 1)
        co->Super.Control.Status = DATAQ__EXTERNIDX;
      else {
	data_index = (pwr_sClass_DataQBus*)&co->Data[0];
	for ( i = 0; i < co->DataSize; i++) {
	  if ( cdh_ObjidIsEqual(data_index->Data.Aref.Objid, co->Super.Control.Objid)) {
	    co->Super.Control.Status = DATAQ__DATAALREXIST;
	    co->Super.Control.Commit = 0;
	    data_index = 0;
	    break;
	  }
	  data_index++;
	}
	if ( !data_index)
	  break;

        extern_attrref = cdh_ObjidToAref(co->Super.Control.Objid);
        co->Super.Control.Status = gdh_DLRefObjectInfoAttrref(
            &extern_attrref, (pwr_tAddress*)&data_pointer, &data_dlid);
      }
      if (ODD(co->Super.Control.Status)) {
        co->Super.Control.Commit = 0;
        data_index = &co->Data[0];
        data_index += co->Super.Control.Index - 1;

        if (co->DataSize >= co->Super.Control.Index) {
#if defined OS_LINUX
          tmp_buf = malloc((co->DataSize - co->Super.Control.Index + 1)
              * sizeof(*data_max));
          memcpy(
              tmp_buf, data_index, (co->DataSize - co->Super.Control.Index + 1)
                  * sizeof(*data_max));
          memcpy((char*)data_index + sizeof(*data_max), tmp_buf,
              (co->DataSize - co->Super.Control.Index + 1)
                  * sizeof(*data_max));
          free(tmp_buf);
#else
          memcpy((char*)data_index + sizeof(*data_max), data_index,
              (co->DataSize - co->Super.Control.Index + 1)
                  * sizeof(*data_max));
#endif
        }
        data_index->Data.Ptr = (pwr_tVoid*)data_pointer;
        data_index->Data.Aref = cdh_ObjidToAref(co->Super.Control.Objid);
        data_index->Front = 1;
        data_index->Back = 1;
        data_index->Dlid = data_dlid;

        co->DataSize++;
        if (co->DataSize == co->Super.Config.MaxSize) {
          o->QueueFull = 1;
	  co->Super.Intern.QueueFull = o->QueueFull;
	}
        data_last = &co->Data[0];
        data_last += co->DataSize - 1;
        memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
        memcpy(&o->DataLast, data_last, sizeof(*data_last));
        if (co->Super.Control.Operation == pwr_eDataQCtlEnum_Insert)
          o->FrontNew = 1;
	co->Super.Control.Status = DATAQ__SUCCESS;
      } else
        co->Super.Control.Commit = 0;
      o->Data1 = co->Data[0];
      break;
    case pwr_eDataQCtlEnum_DeleteObjid:
    case pwr_eDataQCtlEnum_RemoveObjid:
      data_index = (pwr_sClass_DataQBus*)&co->Data[0];
      for (co->Super.Control.Index = 1; co->Super.Control.Index <= co->DataSize;
           co->Super.Control.Index++) {
        if (!memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
                sizeof(pwr_tObjid)))
          break;
        data_index++;
      }
      if (memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
              sizeof(pwr_tObjid))) {
        co->Super.Control.Status = DATAQ__DATANOTFOUND;
        co->Super.Control.Commit = 0;
        break;
      }
    case pwr_eDataQCtlEnum_Delete:
      if (co->Super.Control.Operation == pwr_eDataQCtlEnum_Delete)
        co->Super.Control.Index = 1;
    case pwr_eDataQCtlEnum_DeleteIndex:
      if (co->Super.Control.Index > co->DataSize || co->Super.Control.Index <= 0) {
        co->Super.Control.Status = DATAQ__EXTERNIDX;
        co->Super.Control.Commit = 0;
        break;
      }
      co->Super.Control.Commit = 0;
      data_index = &co->Data[0];
      data_index += co->Super.Control.Index - 1;
      sts = gdh_DLUnrefObjectInfo(data_index->Dlid);
      if (co->Super.Config.Options & pwr_mDataQOptionsMask_DeleteWhenRemove
          && co->Super.Control.Operation != pwr_eDataQCtlEnum_RemoveObjid)
        sts = gdh_DeleteObject(data_index->Data.Aref.Objid);

      if (co->Super.Control.Index < co->DataSize) {
        size = (co->DataSize - co->Super.Control.Index) * sizeof(*data_max);
#if defined OS_LINUX
        tmp_buf = malloc(size);
        memcpy(tmp_buf, (char*)data_index + sizeof(*data_max), size);
        memcpy(data_index, tmp_buf, size);
        free(tmp_buf);
#else
        memcpy(data_index, (char*)data_index + sizeof(*data_max), size);
#endif
      }
      data_last = &co->Data[0];
      data_last += co->DataSize - 1;
      memset(data_last, 0, sizeof(*data_last));
      o->QueueFull = 0;
      co->Super.Intern.QueueFull = o->QueueFull;
      co->DataSize--;
      co->Super.Control.Commit = 0;
      if (co->DataSize > 0) {
        data_last--;
        memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
        memcpy(&o->DataLast, data_last, sizeof(*data_last));
      } else {
        memset(&co->Super.Trp.DataL, 0, sizeof(*data_last));
        memset(&o->DataLast, 0, sizeof(*data_last));
      }
      o->Data1 = co->Data[0];
      co->Super.Control.Status = DATAQ__SUCCESS;
      break;
    case pwr_eDataQCtlEnum_MoveForward:
      data_index = &co->Data[0];
      for (co->Super.Control.Index = 1; co->Super.Control.Index <= co->DataSize;
           co->Super.Control.Index++) {
        if (!memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
                sizeof(pwr_tObjid)))
          break;
        data_index++;
      }
      if (memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
              sizeof(pwr_tObjid))) {
        co->Super.Control.Status = DATAQ__DATANOTFOUND;
        co->Super.Control.Commit = 0;
        break;
      }
      if (co->Super.Control.Index >= co->DataSize) {
        co->Super.Control.Status = DATAQ__EXTERNIDX;
        co->Super.Control.Commit = 0;
        break;
      }
      data_index = &co->Data[0];
      data_index += co->Super.Control.Index - 1;
      if (!(data_index->Front && data_index->Back)) {
        co->Super.Control.Status = DATAQ__DATASPLIT;
        co->Super.Control.Commit = 0;
        break;
      }
      memcpy(&data_tmp, data_index + 1, sizeof(*data_index));
      memcpy(data_index + 1, data_index, sizeof(*data_index));
      memcpy(data_index, &data_tmp, sizeof(*data_index));
      co->Super.Control.Commit = 0;

      if (co->Super.Control.Index == co->DataSize - 1) {
        data_last = &co->Data[0];
        data_last += co->DataSize - 1;
        memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
        memcpy(&o->DataLast, data_last, sizeof(*data_last));
      }
      o->Data1 = co->Data[0];
      co->Super.Control.Status = DATAQ__SUCCESS;
      break;
    case pwr_eDataQCtlEnum_MoveBackward:
      data_index = (pwr_sClass_DataQBus*)&co->Data[0];
      for (co->Super.Control.Index = 1; co->Super.Control.Index <= co->DataSize;
           co->Super.Control.Index++) {
        if (!memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
                sizeof(pwr_tObjid)))
          break;
        data_index++;
      }
      if (memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
              sizeof(pwr_tObjid))) {
        co->Super.Control.Status = DATAQ__DATANOTFOUND;
        co->Super.Control.Commit = 0;
        break;
      }
      if (co->Super.Control.Index <= 1) {
        co->Super.Control.Status = DATAQ__EXTERNIDX;
        co->Super.Control.Commit = 0;
        break;
      }
      data_index = &co->Data[0];
      data_index += co->Super.Control.Index - 1;
      if (!(data_index->Front && data_index->Back)) {
        co->Super.Control.Status = DATAQ__DATASPLIT;
        co->Super.Control.Commit = 0;
        break;
      }
      memcpy(&data_tmp, data_index - 1, sizeof(*data_index));
      memcpy(data_index - 1, data_index, sizeof(*data_index));
      memcpy(data_index, &data_tmp, sizeof(*data_index));
      co->Super.Control.Commit = 0;

      if (co->Super.Control.Index == co->DataSize) {
        data_last = &co->Data[0];
        data_last += co->DataSize - 1;
        memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
        memcpy(&o->DataLast, data_last, sizeof(*data_last));
      }
      o->Data1 = co->Data[0];
      co->Super.Control.Status = DATAQ__SUCCESS;
      break;
    }
    if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
      co->Super.Intern.BackupNow = 1;
  }
  if (co->Super.Trp.InFlag) {
    if (co->Super.Config.Function == pwr_eDataQFunctionEnum_EndQueue) {
      switch (co->Super.Trp.InOpType) {
      case pwr_eQTrpOpEnum_ForwardUnit:
	/* Wait for dataq_server to send feedback */
	if (co->Super.Intern.RQStatus & pwr_mRemoteDataQStatusMask_NewFeedback &&
	    co->Data[0].Data.Ptr)
	  break;
	if (co->Super.Intern.RQStatus & pwr_mRemoteDataQStatusMask_IsFeedbackTarget &&
	    !co->Data[0].Data.Ptr) {
	  co->Data[0].Data.Ptr = co->Super.Trp.InPtr;
	  co->Data[0].Data.Aref = cdh_ObjidToAref(co->Super.Trp.InObjid);
	  co->Data[0].Front = 1;
	  co->Data[0].Back = 1;
	  co->Data[0].Dlid = co->Super.Trp.InDlid;
	  co->Super.Intern.RQStatus |= pwr_mRemoteDataQStatusMask_NewFeedback;
	  break;
	}
	if (!(co->Super.Intern.RQStatus & pwr_mRemoteDataQStatusMask_NewFeedback) &&
	    co->Data[0].Data.Ptr) {
	  memset(&co->Data[0], 0, sizeof(pwr_sClass_DataQBus));
	}

	/* Remove inserted object */
	sts = gdh_DLUnrefObjectInfo(co->Super.Trp.InDlid);
	if (co->Super.Config.Options & pwr_mDataQOptionsMask_DeleteWhenRemove)
	  sts = gdh_DeleteObject(co->Super.Trp.InObjid);
	co->Super.Trp.InFlag = 0;
	o->FrontNew = 1;
	break;
      }
      lck_UnlockNMps;
      return;
    }

    /* Insert new object in Front position */

    switch (co->Super.Trp.InOpType) {
    case pwr_eQTrpOpEnum_ForwardFront:
      /* Insert at front of object front of data */
      if (o->QueueFull)
	break;
      
      if (co->DataSize > 0) {
#if defined OS_LINUX
        tmp_buf = malloc(co->DataSize * sizeof(*data_max));
        memcpy(tmp_buf, &co->Data[0], co->DataSize * sizeof(*data_max));
        memcpy(&co->Data[1], tmp_buf, co->DataSize * sizeof(*data_max));
        free(tmp_buf);
#else
        memcpy(&co->Data[1], &co->Data[0],
            co->DataSize * sizeof(*data_max));
#endif
      }
      co->Data[0].Data.Ptr = co->Super.Trp.InPtr;
      co->Data[0].Data.Aref = cdh_ObjidToAref(co->Super.Trp.InObjid);
      co->Data[0].Front = 1;
      co->Data[0].Back = 0;
      co->Super.Trp.InFlag = 0;
      co->Data[0].Dlid = co->Super.Trp.InDlid;
      o->FrontNew = 1;
      co->DataSize++;
      if (co->DataSize == co->Super.Config.MaxSize) {
        o->QueueFull = 1;
	co->Super.Intern.QueueFull = o->QueueFull;
      }
      data_last = &co->Data[0];
      data_last += co->DataSize - 1;
      memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
      memcpy(&o->DataLast, data_last, sizeof(*data_last));
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_ForwardBack:
      if (memcmp(&co->Data[0].Data.Aref.Objid, &co->Super.Trp.InObjid,
              sizeof(pwr_tObjid))) {
        /* This it not the correct object */
        co->Super.Trp.InFlag = 0;
        lck_UnlockNMps;
        return;
      }
      co->Data[0].Back = 1;
      if (co->DataSize == 1) {
        co->Super.Trp.DataL.Back = 1;
        o->DataLast.Back = 1;
      }
      co->Super.Trp.InFlag = 0;
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_ForwardUnit:
      if (o->QueueFull)
	break;
      if (co->Super.Intern.RQStatus & pwr_mRemoteDataQStatusMask_NewData)
	break;
      if (co->Super.Intern.RQStatus & pwr_mRemoteDataQStatusMask_NewFeedback)
	break;

      if (co->DataSize > 0) {
#if defined OS_LINUX
        tmp_buf = malloc(co->DataSize * sizeof(*data_max));
        memcpy(tmp_buf, &co->Data[0], co->DataSize * sizeof(*data_max));
        memcpy(&co->Data[1], tmp_buf, co->DataSize * sizeof(*data_max));
        free(tmp_buf);
#else
        memcpy(&co->Data[1], &co->Data[0],
            co->DataSize * sizeof(*data_max));
#endif
      }
      co->Data[0].Data.Ptr = co->Super.Trp.InPtr;
      co->Data[0].Data.Aref = cdh_ObjidToAref(co->Super.Trp.InObjid);
      co->Data[0].Front = 1;
      co->Data[0].Back = 1;
      co->Data[0].Dlid = co->Super.Trp.InDlid;
      co->Super.Trp.InFlag = 0;
      o->FrontNew = 1;
      data_last = &co->Data[0];
      data_last += co->DataSize;
      memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
      memcpy(&o->DataLast, data_last, sizeof(*data_last));
      co->DataSize++;
      if (co->DataSize == co->Super.Config.MaxSize) {
        o->QueueFull = 1;
	co->Super.Intern.QueueFull = o->QueueFull;
      }
      o->Data1 = co->Data[0];
      if (co->Super.Intern.RQStatus & pwr_mRemoteDataQStatusMask_HasRemote)
	co->Super.Intern.RQStatus |= pwr_mRemoteDataQStatusMask_NewData;
      if (co->Super.Intern.RQStatus & pwr_mRemoteDataQStatusMask_IsFeedbackTarget) {
	co->Super.Intern.RQStatus |= pwr_mRemoteDataQStatusMask_NewFeedback;
      }
      break;
    case pwr_eQTrpOpEnum_ReverseBack:
      /* Insert at rear of object back of data */
      if (o->QueueFull)
	break;

      data_last = (pwr_sClass_DataQBus*)&co->Data[0];
      data_last += co->DataSize;
      data_last->Data.Ptr = co->Super.Trp.InPtr;
      data_last->Data.Aref = cdh_ObjidToAref(co->Super.Trp.InObjid);
      data_last->Front = 0;
      data_last->Back = 1;
      data_last->Dlid = co->Super.Trp.InDlid;
      co->Super.Trp.InFlag = 0;
      o->RearNew = 1;
      co->DataSize++;
      if (co->DataSize == co->Super.Config.MaxSize) {
        o->QueueFull = 1;
	co->Super.Intern.QueueFull = o->QueueFull;
      }
      memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
      memcpy(&o->DataLast, data_last, sizeof(*data_last));
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_ReverseUnit:
      /* Insert at rear of object all of data */
      if (o->QueueFull)
	break;

      data_last = &co->Data[0];
      data_last += co->DataSize;
      data_last->Data.Ptr = co->Super.Trp.InPtr;
      data_last->Data.Aref = cdh_ObjidToAref(co->Super.Trp.InObjid);
      data_last->Front = 1;
      data_last->Back = 1;
      data_last->Dlid = co->Super.Trp.InDlid;
      co->Super.Trp.InFlag = 0;
      co->DataSize++;
      o->RearNew = 1;
      if (co->DataSize == co->Super.Config.MaxSize) {
        o->QueueFull = 1;
	co->Super.Intern.QueueFull = o->QueueFull;
      }
      memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
      memcpy(&o->DataLast, data_last, sizeof(*data_last));
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_ReverseFront:
      data_last = &co->Data[0];
      data_last += co->DataSize - 1;
      if (memcmp(&data_last->Data.Aref.Objid, &co->Super.Trp.InObjid,
              sizeof(pwr_tObjid))) {
        /* This it not the correct object */
        co->Super.Trp.InFlag = 0;
        lck_UnlockNMps;
        return;
      }
      data_last->Front = 1;
      co->Super.Trp.DataL.Front = 1;
      o->DataLast.Front = 1;
      co->Super.Trp.InFlag = 0;
      o->Data1 = co->Data[0];
      break;
    }
    if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
      co->Super.Intern.BackupNow = 1;
  }
  if (co->Super.Trp.OutRearFlag) {
    /* Remove an object in Rear position */

    switch (co->Super.Trp.OutRearOpType) {
    case pwr_eQTrpOpEnum_Back:
    case pwr_eQTrpOpEnum_Unit:

      /* Get the last data */
      if (co->DataSize == 0) {
        co->Super.Trp.OutRearFlag = 0;
	break;
      }

      data_last = &co->Data[0];
      data_last += co->DataSize - 1;
      memset(data_last, 0, sizeof(*data_last));
      co->Super.Trp.OutRearFlag = 0;
      o->QueueFull = 0;
      co->Super.Intern.QueueFull = o->QueueFull;
      co->DataSize--;
      if (co->DataSize != 0) {
        data_last--;
        memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
        memcpy(&o->DataLast, data_last, sizeof(*data_last));
      } else {
        memset(&co->Super.Trp.DataL, 0, sizeof(*data_last));
        memset(&o->DataLast, 0, sizeof(*data_last));
      }
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_Front:
      data_last = (pwr_sClass_DataQBus*)&co->Data[0];
      data_last += co->DataSize - 1;
      data_last->Front = 0;
      co->Super.Trp.OutRearFlag = 0;
      co->Super.Trp.DataL.Front = 0; /* Korrigeras !!! */
      o->DataLast.Front = 0; /* Korrigeras !!! */
      o->Data1 = co->Data[0];
      break;
    }
    if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
      co->Super.Intern.BackupNow = 1;
  }
  if (co->Super.Trp.OutFrontFlag) {
    /* Remove an object in Front position */

    switch (co->Super.Trp.OutFrontOpType) {
    case pwr_eQTrpOpEnum_Front:
    case pwr_eQTrpOpEnum_Unit:

      /* Get the last data */
      if (co->DataSize == 0) {
        co->Super.Trp.OutFrontFlag = 0;
	break;
      }
#if defined OS_LINUX
      tmp_buf = malloc((co->DataSize - 1) * sizeof(*data_last));
      memcpy(tmp_buf, &co->Data[1],
          (co->DataSize - 1) * sizeof(*data_last));
      memcpy(&co->Data[0], tmp_buf,
          (co->DataSize - 1) * sizeof(*data_last));
      free(tmp_buf);
#else
      memcpy(&co->Data[0], &co->Data[1],
          (co->DataSize - 1) * sizeof(*data_last));
#endif
      data_last = &co->Data[0];
      data_last += co->DataSize - 1;
      memset(data_last, 0, sizeof(*data_last));
      o->QueueFull = 0;
      co->Super.Intern.QueueFull = o->QueueFull;
      co->DataSize--;
      co->Super.Trp.OutFrontFlag = 0;
      if (co->DataSize != 0) {
        data_last--;
        memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
        memcpy(&o->DataLast, data_last, sizeof(*data_last));
      } else {
        memset(&co->Super.Trp.DataL, 0, sizeof(*data_last));
        memset(&o->DataLast, 0, sizeof(*data_last));
      }
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_Back:
      co->Data[0].Back = 0;
      co->Super.Trp.OutFrontFlag = 0;
      if (co->DataSize == 1) {
        co->Super.Trp.DataL.Back = 0;
        o->DataLast.Back = 0;
      }
      break;
    }
    if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
      co->Super.Intern.BackupNow = 1;
  }
  co->Super.Intern.NumberOfData = co->DataSize;
  o->Status = co->DataSize ? 1 : 0;

  lck_UnlockNMps;
}

/*_*
  DataQStoreFo

  @aref dataqstore DataQStoreFo
*/
static void DataQStoreFo_exec(plc_sThread* tp, pwr_sClass_DataQFo* o)
{
  int i, sts;
  pwr_sClass_DataQBus* data_max;
  pwr_sClass_DataQBus* data_last;
  pwr_sClass_DataQBus* data_index;
  pwr_sClass_DataQBus data_tmp;
  int size;
  pwr_sAttrRef extern_attrref;
  gdh_tDlid data_dlid;
  unsigned long* data_pointer = NULL;
#if defined OS_LINUX
  char* tmp_buf;
#endif

  pwr_sClass_DataQ1* co = (pwr_sClass_DataQ1*)o->PlcConnectP;

  if (co->Super.Intern.InitTime) {
    if (!(co->Super.Intern.ReloadDone & pwr_mDataQBackupMask_BackupLoaded))
      return;
    else {
      lck_LockNMps;
      DataQFo_init_time((pwr_sClass_DataQFo*)o);
      co->Super.Intern.ReloadDone &= ~pwr_mDataQBackupMask_BackupLoaded;
    }
  } else
    lck_LockNMps;

  if (o->FrontNew)
    o->FrontNew = 0;
  if (o->RearNew)
    o->RearNew = 0;
  if (co->Super.Config.MaxSize > NMPS_CELL_MAXSIZE)
    co->Super.Config.MaxSize = NMPS_CELL_MAXSIZE;

  if (o->ResetObjectP || co->Super.Intern.QReset) {
    if ((o->ResetObjectP && *o->ResetObjectP) || co->Super.Intern.QReset) {
      data_index = (pwr_sClass_DataQBus*)&co->Data[0];
      for (i = 1; i <= co->DataSize; i++) {
        sts = gdh_DLUnrefObjectInfo(data_index->Dlid);
        if (co->Super.Config.Options & pwr_mDataQOptionsMask_DeleteWhenReset)
          sts = gdh_DeleteObject(data_index->Data.Aref.Objid);
        data_index++;
      }
      memset(&co->Data[0], 0, co->DataSize * 
	  sizeof(pwr_sClass_DataQBus));
      memset(&co->Super.Trp.DataL, 0, sizeof(pwr_sClass_DataQBus));
      memset(&o->DataLast, 0, sizeof(pwr_sClass_DataQBus));
      memset(&o->Data1, 0, sizeof(pwr_sClass_DataQBus));
      o->QueueFull = 0;
      co->Super.Intern.QueueFull = o->QueueFull;
      co->DataSize = 0;
      if (!o->OldReset)
	co->Super.Intern.RQReset = 1;
      if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
        co->Super.Intern.BackupNow = 1;
    }
    if (o->ResetObjectP)
      o->OldReset = *o->ResetObjectP;
    co->Super.Intern.QReset = 0;
  }

  if ( co->Super.Config.Options & pwr_mDataQOptionsMask_CheckObjects) {
    data_index = &co->Data[0];
    for ( i = 0; i < co->DataSize; i++) {
      sts = gdh_CheckLocalObject(data_index->Data.Aref.Objid);
      if ( EVEN(sts)) {
	/* Remove object */
	sts = gdh_DLUnrefObjectInfo(data_index->Dlid);
	if (i < co->DataSize) {
	  size = (co->DataSize - i) * sizeof(*data_max);
#if defined OS_LINUX
	  tmp_buf = malloc(size);
	  memcpy(tmp_buf, (char*)data_index + sizeof(*data_max), size);
	  memcpy(data_index, tmp_buf, size);
	  free(tmp_buf);
#else
	  memcpy(data_index, (char*)data_index + sizeof(*data_max), size);
#endif
	}
	data_last = &co->Data[0];
	data_last += co->DataSize - 1;
	memset(data_last, 0, sizeof(*data_last));
	o->QueueFull = 0;
	co->Super.Intern.QueueFull = o->QueueFull;
	co->DataSize--;
	if ((co->Super.Intern.SelectIndex != 0)
	    && (co->Super.Intern.SelectIndex > i))
	  co->Super.Intern.SelectIndex--;
	i--;
      }
      else
	data_index++;
    }
  }

  if (co->Super.Control.Commit) {
    /* Insert new object in Front position */

    switch (co->Super.Control.Operation) {
    case pwr_eDataQCtlEnum_Insert:
    case pwr_eDataQCtlEnum_InsertSelect:
      co->Super.Control.Index = 1;
    case pwr_eDataQCtlEnum_InsertIndex:
      /* Direct link to extern objid */
      if (co->Super.Control.Index <= 0 || co->Super.Control.Index > co->Super.Config.MaxSize)
        co->Super.Control.Status = DATAQ__EXTERNIDX;
      else if (o->QueueFull)
        co->Super.Control.Status = DATAQ__QUEUEFULL;
      else if (co->Super.Control.Index > co->DataSize + 1)
        co->Super.Control.Status = DATAQ__EXTERNIDX;
      else {
	data_index = &co->Data[0];
	for ( i = 0; i < co->DataSize; i++) {
	  if ( cdh_ObjidIsEqual(data_index->Data.Aref.Objid, co->Super.Control.Objid)) {
	    co->Super.Control.Status = DATAQ__DATAALREXIST;
	    co->Super.Control.Commit = 0;
	    data_index = 0;
	    break;
	  }
	  data_index++;
	}
	if ( !data_index)
	  break;

        extern_attrref = cdh_ObjidToAref(co->Super.Control.Objid);
        co->Super.Control.Status = gdh_DLRefObjectInfoAttrref(
            &extern_attrref, (pwr_tAddress*)&data_pointer, &data_dlid);
      }
      if (ODD(co->Super.Control.Status)) {
        co->Super.Control.Commit = 0;
        data_index = &co->Data[0];
        data_index += co->Super.Control.Index - 1;

        if (co->DataSize >= co->Super.Control.Index) {
#if defined OS_LINUX
          tmp_buf = malloc((co->DataSize - co->Super.Control.Index + 1)
              * sizeof(*data_max));
          memcpy(
              tmp_buf, data_index, (co->DataSize - co->Super.Control.Index + 1)
                  * sizeof(*data_max));
          memcpy((char*)data_index + sizeof(*data_max), tmp_buf,
              (co->DataSize - co->Super.Control.Index + 1)
                  * sizeof(*data_max));
          free(tmp_buf);
#else
          memcpy((char*)data_index + sizeof(*data_max), data_index,
              (co->DataSize - co->Super.Control.Index + 1)
                  * sizeof(*data_max));
#endif
        }
        data_index->Data.Ptr = (pwr_tVoid*)data_pointer;
        data_index->Data.Aref = cdh_ObjidToAref(co->Super.Control.Objid);
        data_index->Front = 1;
        data_index->Back = 1;
        data_index->Dlid = data_dlid;
        if (co->Super.Control.Operation == pwr_eDataQCtlEnum_InsertSelect) {
          data_index->Select = 1;
        }
        co->DataSize++;
        if (co->DataSize == co->Super.Config.MaxSize) {
          o->QueueFull = 1;
	  co->Super.Intern.QueueFull = o->QueueFull;
	}
        if ((co->Super.Control.Operation == pwr_eDataQCtlEnum_Insert)
            || (co->Super.Control.Operation == pwr_eDataQCtlEnum_InsertSelect))
          o->FrontNew = 1;
        if ((co->Super.Intern.SelectIndex != 0)
            && (co->Super.Intern.SelectIndex >= co->Super.Control.Index))
          co->Super.Intern.SelectIndex++;
      } else
        co->Super.Control.Commit = 0;
      o->Data1 = co->Data[0];
      break;
    case pwr_eDataQCtlEnum_SelectObjid:
      data_index = &co->Data[0];
      for (i = 1; i <= co->DataSize; i++) {
        if (!memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
                sizeof(pwr_tObjid))) {
          data_index->Select = 1;
          break;
        }
        data_index++;
      }
      if (memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
              sizeof(pwr_tObjid))) {
        co->Super.Control.Status = DATAQ__DATANOTFOUND;
      }
      co->Super.Control.Commit = 0;
      break;
    case pwr_eDataQCtlEnum_UnselectObjid:
      data_index = &co->Data[0];
      for (i = 1; i <= co->DataSize; i++) {
        if (!memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
                sizeof(pwr_tObjid))) {
          if (data_index->Select)
            co->Super.Intern.DataSelected--;
          data_index->Select = 0;
          if (i == co->Super.Intern.SelectIndex) {
            if (co->Super.Intern.DataSelected > 0) {
              data_last = &co->Data[0];
              data_last += co->DataSize - 1;
              for (i = co->DataSize; i > 0; i--) {
                if (data_last->Select) {
                  memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
                  memcpy(&o->DataLast, data_last, sizeof(*data_last));
                  co->Super.Intern.SelectIndex = i;
                  break;
                }
                data_last--;
              }
            } else {
              memset(&co->Super.Trp.DataL, 0, sizeof(*data_last));
              memset(&o->DataLast, 0, sizeof(*data_last));
              co->Super.Intern.SelectIndex = 0;
            }
          }
          break;
        }
        data_index++;
      }
      if (memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
              sizeof(pwr_tObjid))) {
        co->Super.Control.Status = DATAQ__DATANOTFOUND;
      }
      co->Super.Control.Commit = 0;
      break;
    case pwr_eDataQCtlEnum_DeleteObjid:
    case pwr_eDataQCtlEnum_RemoveObjid:
      data_index = &co->Data[0];
      for (co->Super.Control.Index = 1; co->Super.Control.Index <= co->DataSize;
           co->Super.Control.Index++) {
        if (!memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
                sizeof(pwr_tObjid)))
          break;
        data_index++;
      }
      if (memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
              sizeof(pwr_tObjid))) {
        co->Super.Control.Status = DATAQ__DATANOTFOUND;
        co->Super.Control.Commit = 0;
        break;
      }
    case pwr_eDataQCtlEnum_Delete:
      if (co->Super.Control.Operation == pwr_eDataQCtlEnum_Delete)
        co->Super.Control.Index = 1;
    case pwr_eDataQCtlEnum_DeleteIndex:
      if (co->Super.Control.Index > co->DataSize) {
        co->Super.Control.Status = DATAQ__EXTERNIDX;
        co->Super.Control.Commit = 0;
        break;
      }
      co->Super.Control.Commit = 0;
      data_index = &co->Data[0];
      data_index += co->Super.Control.Index - 1;
      sts = gdh_DLUnrefObjectInfo(data_index->Dlid);
      if (co->Super.Config.Options & pwr_mDataQOptionsMask_DeleteWhenRemove
          && co->Super.Control.Operation != pwr_eDataQCtlEnum_RemoveObjid)
        sts = gdh_DeleteObject(data_index->Data.Aref.Objid);

      /* Look for new last selected if data is selected */
      if (data_index->Select) {
        co->Super.Intern.DataSelected--;
        if (co->Super.Intern.SelectIndex == co->Super.Control.Index) {
          if (co->Super.Intern.DataSelected > 0) {
            data_index = &co->Data[0];
            data_index += co->DataSize - 1;
            for (i = co->DataSize; i > 0; i--) {
              if (data_index->Select && i != co->Super.Control.Index) {
                memcpy(&co->Super.Trp.DataL, data_index, sizeof(*data_index));
                memcpy(&o->DataLast, data_index, sizeof(*data_index));
                co->Super.Intern.SelectIndex = i;
                break;
              }
              data_index--;
            }
          } else {
            memset(&co->Super.Trp.DataL, 0, sizeof(*data_last));
            memset(&o->DataLast, 0, sizeof(*data_last));
            co->Super.Intern.SelectIndex = 0;
          }
        }
      }

      if (co->Super.Control.Index < co->DataSize) {
        size = (co->DataSize - co->Super.Control.Index) * sizeof(*data_max);
#if defined OS_LINUX
        tmp_buf = malloc(size);
        memcpy(tmp_buf, (char*)data_index + sizeof(*data_max), size);
        memcpy(data_index, tmp_buf, size);
        free(tmp_buf);
#else
        memcpy(data_index, (char*)data_index + sizeof(*data_max), size);
#endif
      }
      data_last = &co->Data[0];
      data_last += co->DataSize - 1;
      memset(data_last, 0, sizeof(*data_last));
      o->QueueFull = 0;
      co->Super.Intern.QueueFull = o->QueueFull;
      co->DataSize--;
      co->Super.Control.Commit = 0;
      data_last--;
      if ((co->Super.Intern.SelectIndex != 0)
          && (co->Super.Intern.SelectIndex > co->Super.Control.Index))
        co->Super.Intern.SelectIndex--;
      o->Data1 = co->Data[0];
      co->Super.Control.Status = DATAQ__SUCCESS;
      break;
    case pwr_eDataQCtlEnum_MoveForward:
      data_index = &co->Data[0];
      for (co->Super.Control.Index = 1; co->Super.Control.Index <= co->DataSize;
           co->Super.Control.Index++) {
        if (!memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
                sizeof(pwr_tObjid)))
          break;
        data_index++;
      }
      if (memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
              sizeof(pwr_tObjid))) {
        co->Super.Control.Status = DATAQ__DATANOTFOUND;
        co->Super.Control.Commit = 0;
        break;
      }
      if (co->Super.Control.Index >= co->DataSize) {
        co->Super.Control.Status = DATAQ__EXTERNIDX;
        co->Super.Control.Commit = 0;
        break;
      }
      data_index = &co->Data[0];
      data_index += co->Super.Control.Index - 1;
      if (!(data_index->Front && data_index->Back)) {
        co->Super.Control.Status = 2; /* Felkod !!! */
        co->Super.Control.Commit = 0;
        break;
      }
      memcpy(&data_tmp, data_index + 1, sizeof(*data_index));
      memcpy(data_index + 1, data_index, sizeof(*data_index));
      memcpy(data_index, &data_tmp, sizeof(*data_index));

      if (co->Super.Intern.SelectIndex == co->Super.Control.Index)
        co->Super.Intern.SelectIndex++;
      else if (co->Super.Intern.SelectIndex == co->Super.Control.Index + 1)
        co->Super.Intern.SelectIndex--;

      co->Super.Control.Commit = 0;

      if ((co->Super.Intern.DataSelected == 0)
          && (co->Super.Control.Index == co->DataSize - 1)) {
        data_last = &co->Data[0];
        data_last += co->DataSize - 1;
        memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
        memcpy(&o->DataLast, data_last, sizeof(*data_last));
      }
      o->Data1 = co->Data[0];
      co->Super.Control.Status = DATAQ__SUCCESS;
      break;
    case pwr_eDataQCtlEnum_MoveBackward:
      data_index = &co->Data[0];
      for (co->Super.Control.Index = 1; co->Super.Control.Index <= co->DataSize;
           co->Super.Control.Index++) {
        if (!memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
                sizeof(pwr_tObjid)))
          break;
        data_index++;
      }
      if (memcmp(&data_index->Data.Aref.Objid, &co->Super.Control.Objid,
              sizeof(pwr_tObjid))) {
        co->Super.Control.Status = DATAQ__DATANOTFOUND;
        co->Super.Control.Commit = 0;
        break;
      }
      if (co->Super.Control.Index <= 1) {
        co->Super.Control.Status = DATAQ__EXTERNIDX;
        co->Super.Control.Commit = 0;
        break;
      }
      data_index = &co->Data[0];
      data_index += co->Super.Control.Index - 1;
      if (!(data_index->Front && data_index->Back)) {
        co->Super.Control.Status = DATAQ__DATASPLIT;
        co->Super.Control.Commit = 0;
        break;
      }
      memcpy(&data_tmp, data_index - 1, sizeof(*data_index));
      memcpy(data_index - 1, data_index, sizeof(*data_index));
      memcpy(data_index, &data_tmp, sizeof(*data_index));

      if (co->Super.Intern.SelectIndex == co->Super.Control.Index)
        co->Super.Intern.SelectIndex--;
      else if (co->Super.Intern.SelectIndex == co->Super.Control.Index - 1)
        co->Super.Intern.SelectIndex++;

      co->Super.Control.Commit = 0;

      if ((co->Super.Intern.DataSelected == 0)
          && (co->Super.Control.Index == co->DataSize)) {
        data_last = &co->Data[0];
        data_last += co->DataSize - 1;
        memcpy(&co->Super.Trp.DataL, data_last, sizeof(*data_last));
        memcpy(&o->DataLast, data_last, sizeof(*data_last));
      }
      o->Data1 = co->Data[0];
      co->Super.Control.Status = 1; /* Felkod Success!!! */
      break;
    }
    if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
      co->Super.Intern.BackupNow = 1;
  }
  /* Count and find new selected objects */
  co->Super.Intern.DataSelected = 0;
  data_index = &co->Data[0];
  for (i = 1; i <= co->DataSize; i++) {
    if (data_index->Select && !data_index->SelectOld) {
      memcpy(&co->Super.Trp.DataL, data_index, sizeof(*data_index));
      memcpy(&o->DataLast, data_index, sizeof(*data_index));
      co->Super.Intern.SelectIndex = i;
      o->RearNew = 1;
      if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
        co->Super.Intern.BackupNow = 1;
    }
    if (data_index->Select)
      co->Super.Intern.DataSelected++;
    data_index->SelectOld = data_index->Select;
    data_index++;
  }
  if ((co->Super.Config.Options & pwr_mDataQOptionsMask_SingleSelect)
      || (co->Super.Config.Options & pwr_mDataQOptionsMask_OneSelect)) {
    /* Unselect everyone except last selected */
    if (co->Super.Intern.DataSelected > 1) {
      data_index = &co->Data[0];
      for (i = 1; i <= co->DataSize; i++) {
        if (i != co->Super.Intern.SelectIndex)
          data_index->Select = 0;
        data_index++;
      }
      co->Super.Intern.DataSelected = 1;
      if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
        co->Super.Intern.BackupNow = 1;
    }
  }
  if (co->Super.Config.Options & pwr_mDataQOptionsMask_OneSelect) {
    if ((co->Super.Intern.DataSelected == 0) && (co->DataSize != 0)) {
      data_index = &co->Data[0];
      data_index += co->DataSize - 1;
      data_index->Select = 1;
      data_index->SelectOld = 1;
      memcpy(&co->Super.Trp.DataL, data_index, sizeof(*data_last));
      memcpy(&o->DataLast, data_index, sizeof(*data_last));
      co->Super.Intern.SelectIndex = co->DataSize;
      co->Super.Intern.DataSelected = 1;
      if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
        co->Super.Intern.BackupNow = 1;
    }
  }
  if (co->Super.Intern.DataSelected == 0) {
    memset(&co->Super.Trp.DataL, 0, sizeof(*data_last));
    memset(&o->DataLast, 0, sizeof(*data_last));
    co->Super.Intern.SelectIndex = 0;
  }

  if (co->Super.Trp.InFlag) {
    /* Insert new object in Front position */

    switch (co->Super.Trp.InOpType) {
    case pwr_eQTrpOpEnum_ForwardFront:
      /* Insert at front of object front of data */
      if (o->QueueFull) {
        lck_UnlockNMps;
        return;
      }
      if (co->DataSize > 0) {
#if defined OS_LINUX
        tmp_buf = malloc(co->DataSize * sizeof(*data_max));
        memcpy(tmp_buf, &co->Data[0], co->DataSize * sizeof(*data_max));
        memcpy(&co->Data[1], tmp_buf, co->DataSize * sizeof(*data_max));
        free(tmp_buf);
#else
        memcpy(&co->Data[1], &co->Data[0],
            co->DataSize * sizeof(*data_max));
#endif
      }
      co->Data[0].Data.Ptr = co->Super.Trp.InPtr;
      co->Data[0].Data.Aref = cdh_ObjidToAref(co->Super.Trp.InObjid);
      co->Data[0].Front = 1;
      co->Data[0].Back = 0;
      co->Data[0].Select = 0;
      co->Super.Trp.InFlag = 0;
      co->Data[0].Dlid = co->Super.Trp.InDlid;
      o->FrontNew = 1;
      co->DataSize++;
      if (co->Super.Intern.DataSelected > 0)
        co->Super.Intern.SelectIndex++;
      if (co->DataSize == co->Super.Config.MaxSize) {
        o->QueueFull = 1;
	co->Super.Intern.QueueFull = o->QueueFull;
      }
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_ForwardBack:
      if (memcmp(&co->Data[0].Data.Aref.Objid, &co->Super.Trp.InObjid,
              sizeof(pwr_tObjid))) {
        /* This it not the correct object */
        co->Super.Trp.InFlag = 0;
        lck_UnlockNMps;
        return;
      }
      co->Data[0].Back = 1;
      if (co->Super.Intern.SelectIndex == 1) {
        co->Super.Trp.DataL.Back = 1;
        o->DataLast.Back = 1;
      }
      co->Super.Trp.InFlag = 0;
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_ForwardUnit:
      if (o->QueueFull) {
        lck_UnlockNMps;
        return;
      }
      if (co->DataSize > 0) {
#if defined OS_LINUX
        tmp_buf = malloc(co->DataSize * sizeof(*data_max));
        memcpy(tmp_buf, &co->Data[0], co->DataSize * sizeof(*data_max));
        memcpy(&co->Data[1], tmp_buf, co->DataSize * sizeof(*data_max));
        free(tmp_buf);
#else
        memcpy(&o->Data2P, &co->Data[0],
            co->DataSize * sizeof(*data_max));
#endif
      }
      co->Data[0].Data.Ptr = co->Super.Trp.InPtr;
      co->Data[0].Data.Aref = cdh_ObjidToAref(co->Super.Trp.InObjid);
      co->Data[0].Front = 1;
      co->Data[0].Back = 1;
      co->Data[0].Select = 0;
      co->Data[0].Dlid = co->Super.Trp.InDlid;
      co->Super.Trp.InFlag = 0;
      o->FrontNew = 1;
      if (co->Super.Intern.DataSelected > 0)
        co->Super.Intern.SelectIndex++;
      co->DataSize++;
      if (co->DataSize == co->Super.Config.MaxSize) {
        o->QueueFull = 1;
	co->Super.Intern.QueueFull = o->QueueFull;
      }
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_ReverseBack:
      /* Insert at rear of object back of data */
      if (o->QueueFull) {
        lck_UnlockNMps;
        return;
      }
      data_last = &co->Data[0];
      data_last += co->DataSize;
      data_last->Data.Ptr = co->Super.Trp.InPtr;
      data_last->Data.Aref = cdh_ObjidToAref(co->Super.Trp.InObjid);
      data_last->Front = 0;
      data_last->Back = 1;
      data_last->Dlid = co->Super.Trp.InDlid;
      co->Super.Trp.InFlag = 0;
      co->DataSize++;
      if (co->DataSize == co->Super.Config.MaxSize) {
        o->QueueFull = 1;
	co->Super.Intern.QueueFull = o->QueueFull;
      }
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_ReverseUnit:
      /* Insert at rear of object all of data */
      if (o->QueueFull) {
        lck_UnlockNMps;
        return;
      }
      data_last = &co->Data[0];
      data_last += co->DataSize;
      data_last->Data.Ptr = co->Super.Trp.InPtr;
      data_last->Data.Aref = cdh_ObjidToAref(co->Super.Trp.InObjid);
      data_last->Front = 1;
      data_last->Back = 1;
      data_last->Dlid = co->Super.Trp.InDlid;
      co->Super.Trp.InFlag = 0;
      co->DataSize++;
      if (co->DataSize == co->Super.Config.MaxSize) {
        o->QueueFull = 1;
	co->Super.Intern.QueueFull = o->QueueFull;
      }
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_ReverseFront:
      data_last = &co->Data[0];
      data_last += co->DataSize - 1;
      if (memcmp(&data_last->Data.Aref.Objid, &co->Super.Trp.InObjid,
              sizeof(pwr_tObjid))) {
        /* This it not the correct object */
        co->Super.Trp.InFlag = 0;
        lck_UnlockNMps;
        return;
      }
      data_last->Front = 1;
      co->Super.Trp.InFlag = 0;
      o->Data1 = co->Data[0];
      break;
    }
    if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
      co->Super.Intern.BackupNow = 1;
  }
  if (co->Super.Trp.OutRearFlag) {
    /* Remove an object in Rear position */

    switch (co->Super.Trp.OutRearOpType) {
    case pwr_eQTrpOpEnum_Unit:

      /* Get the last data */
      if (co->DataSize == 0) {
        co->Super.Trp.OutRearFlag = 0;
        lck_UnlockNMps;
        return;
      }

      data_index = &co->Data[0];
      data_index += co->Super.Intern.SelectIndex - 1;

      if (co->Super.Intern.SelectIndex < co->DataSize) {
        size = (co->DataSize - co->Super.Intern.SelectIndex) * sizeof(*data_max);
#if defined OS_LINUX
        tmp_buf = malloc(size);
        memcpy(tmp_buf, (char*)data_index + sizeof(*data_max), size);
        memcpy(data_index, tmp_buf, size);
        free(tmp_buf);
#else
        memcpy(data_index, (char*)data_index + sizeof(*data_max), size);
#endif
      }
      data_last = &co->Data[0];
      data_last += co->DataSize - 1;
      memset(data_last, 0, sizeof(*data_last));
      o->QueueFull = 0;
      co->Super.Intern.QueueFull = o->QueueFull;
      co->DataSize--;
      co->Super.Intern.DataSelected--;
      /* Find next selected, search backwards */
      if (co->Super.Intern.DataSelected > 0) {
        data_index = &co->Data[0];
        data_index += co->DataSize - 1;
        for (i = co->DataSize; i > 0; i--) {
          if (data_index->Select) {
            memcpy(&co->Super.Trp.DataL, data_index, sizeof(*data_index));
            memcpy(&o->DataLast, data_index, sizeof(*data_index));
            co->Super.Intern.SelectIndex = i;
            break;
          }
          data_index--;
        }
      } else {
        memset(&co->Super.Trp.DataL, 0, sizeof(*data_last));
        memset(&o->DataLast, 0, sizeof(*data_last));
        co->Super.Intern.SelectIndex = 0;
      }
      co->Super.Trp.OutRearFlag = 0;
      break;
    }
    if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
      co->Super.Intern.BackupNow = 1;
    o->Data1 = co->Data[0];
  }
  if (co->Super.Trp.OutFrontFlag) {
    /* Remove an object in Front position */

    switch (co->Super.Trp.OutFrontOpType) {
    case pwr_eQTrpOpEnum_Front:
    case pwr_eQTrpOpEnum_Unit:

      /* Get the last data */
      if (co->DataSize == 0) {
        co->Super.Trp.OutFrontFlag = 0;
        lck_UnlockNMps;
        return;
      }

      if (co->Data[0].Select) {
        co->Super.Intern.DataSelected--;
        if (co->Super.Intern.SelectIndex == 1) {
          if (co->Super.Intern.DataSelected > 0) {
            data_index = &co->Data[0];
            data_index += co->DataSize - 1;
            for (i = co->DataSize; i > 1; i--) {
              if (data_index->Select) {
                memcpy(&co->Super.Trp.DataL, data_index, sizeof(*data_index));
                memcpy(&o->DataLast, data_index, sizeof(*data_index));
                co->Super.Intern.SelectIndex = i;
                break;
              }
              data_index--;
            }
          } else {
            memset(&co->Super.Trp.DataL, 0, sizeof(*data_last));
            memset(&o->DataLast, 0, sizeof(*data_last));
            co->Super.Intern.SelectIndex = 0;
          }
        }
      }
      if (co->Super.Intern.SelectIndex > 0)
        co->Super.Intern.SelectIndex--;

#if defined OS_LINUX
      tmp_buf = malloc((co->DataSize - 1) * sizeof(*data_last));
      memcpy(tmp_buf, &co->Data[1],
          (co->DataSize - 1) * sizeof(*data_last));
      memcpy(&co->Data[0], tmp_buf,
          (co->DataSize - 1) * sizeof(*data_last));
      free(tmp_buf);
#else
      memcpy(&co->Data[0], &co->Data[1],
          (co->DataSize - 1) * sizeof(*data_last));
#endif
      data_last = &co->Data[0];
      data_last += co->DataSize - 1;
      memset(data_last, 0, sizeof(*data_last));
      o->QueueFull = 0;
      co->Super.Intern.QueueFull = o->QueueFull;
      co->DataSize--;
      co->Super.Trp.OutFrontFlag = 0;
      o->Data1 = co->Data[0];
      break;
    case pwr_eQTrpOpEnum_Back:
      co->Data[0].Back = 0;
      co->Super.Trp.OutFrontFlag = 0;
      if (co->DataSize == co->Super.Intern.SelectIndex) {
        co->Super.Trp.DataL.Back = 0;
        o->DataLast.Back = 0;
      }
      break;
    }
    if (co->Super.Config.Options & pwr_mDataQOptionsMask_Backup)
      co->Super.Intern.BackupNow = 1;
  }
  co->Super.Intern.NumberOfData = co->Super.Intern.DataSelected;
  o->Status = co->DataSize ? 1 : 0;

  lck_UnlockNMps;
}

/*_*
  QTrp

  @aref qtrp QTrp
*/
void QTrp_exec(plc_sThread* tp, pwr_sClass_QTrp* o)
{
  pwr_sClass_DataQFo *outp = (pwr_sClass_DataQFo*)o->OutP;
  pwr_sClass_DataQ1 *coutp = (pwr_sClass_DataQ1*)outp->PlcConnectP;
  pwr_sClass_DataQFo *inp = (pwr_sClass_DataQFo*)o->InP;
  pwr_sClass_DataQ1 *cinp = (pwr_sClass_DataQ1*)inp->PlcConnectP;

  if (!coutp || !cinp)
    return;

  if (o->Error)
    o->Error = 0;

  if ((((*(o->TriggForwFrontP) && !o->OldTriggForwFront) || 
      (*(o->TriggForwFrontP) && o->Options & pwr_mQTrpOptionsMask_LevelTrigg) || 
      o->FuncAllForward) &&
       !o->ManualMode) ||
      (o->ManualMode && o->ManTriggForwFront)) {
    if (o->Function == pwr_eQTrpFunctionEnum_MoveWholeObject) {
      /* Move all of data */
      /* Check destination */
      if (outp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__QUEUEFULL;
        goto trp_return;
      }
      if ((coutp->Super.Trp.InFlag &&
	   (coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardUnit ||
	    coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardBack ||
	    coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardFront)) ||
	  coutp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (cinp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trp_return;
      }
      if ((cinp->Super.Trp.InFlag && 
	   (cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseUnit ||
	    cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseBack ||
	    cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseFront)) ||
	  cinp->Super.Trp.OutRearFlag)
        return;

      /* Check that both Back and Front is in the in cell */
      if (!(cinp->Super.Trp.DataL.Back && cinp->Super.Trp.DataL.Front)) {
        o->Error = 1;
	o->Status = DATAQ__DATASPLIT;
        goto trp_return;
      }

      /* Transport data */
      coutp->Super.Trp.InPtr = cinp->Super.Trp.DataL.Data.Ptr;
      coutp->Super.Trp.InObjid = cinp->Super.Trp.DataL.Data.Aref.Objid;
      coutp->Super.Trp.InDlid = cinp->Super.Trp.DataL.Dlid;
      coutp->Super.Trp.InFlag = 1;
      cinp->Super.Trp.OutRearFlag = 1;
      coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardUnit;
      cinp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

    } else if ((o->Function == pwr_eQTrpFunctionEnum_MoveAllObjects)
        || (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty)) {
      /* Move all of data */
      /* Check destination */
      if (*(o->TriggForwFrontP) && !o->OldTriggForwFront) {
        /* This is the first object to move */
        if (o->FuncAllReverse || o->FuncAllForward) {
          /* We are already busy moving last trigg */
          return;
        }

        if (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty) {
          if (coutp->Super.Intern.NumberOfData != 0) {
            /* Destination cell is not empty */
            o->Error = 1;
	    o->Status = DATAQ__DESTNOTEMPTY;
            goto trp_return;
          }
        }
      }

      if (outp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__QUEUEFULL;
        o->FuncAllForward = 0;
        goto trp_return;
      }
      if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (cinp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trp_return;
      }
      if (cinp->Super.Trp.OutRearFlag)
        return;

      if (o->Options & pwr_mQTrpOptionsMask_Slow && o->FuncAllForward == 1) {
        /* Wait till next scan */
        o->FuncAllForward = 2;
        goto trp_return;
      }

      /* Transport data */
      coutp->Super.Trp.InPtr = cinp->Super.Trp.DataL.Data.Ptr;
      coutp->Super.Trp.InObjid = cinp->Super.Trp.DataL.Data.Aref.Objid;
      coutp->Super.Trp.InDlid = cinp->Super.Trp.DataL.Dlid;
      coutp->Super.Trp.InFlag = 1;
      cinp->Super.Trp.OutRearFlag = 1;
      coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardUnit;
      cinp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

      if (cinp->Super.Intern.NumberOfData == 1)
        o->FuncAllForward = 0;
      else
        o->FuncAllForward = 1;
    } else {
      /* Move front of data */
      /* Check destination */
      if (outp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__QUEUEFULL;
        goto trp_return;
      }
      if ((coutp->Super.Trp.InFlag && 
	   (coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardUnit ||
	    coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardBack ||
	    coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardFront)) ||
	  coutp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (cinp->DataSize == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trp_return;
      }
      if ((cinp->Super.Trp.InFlag && 
	   (cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseUnit ||
	    cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseBack ||
	    cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseFront)) ||
	  cinp->Super.Trp.OutRearFlag)
        return;

      if (cinp->Super.Trp.DataL.Data.Ptr == coutp->Data[0].Data.Ptr) {
	/* This should be a Back trigg */
	o->Error = 1;
	o->Status = DATAQ__DESTPRESENT;
	goto trp_return;
      }
      if (coutp->Data[0].Front && !coutp->Data[0].Back) {
	/* Destination data is split */
	o->Error = 1;
	o->Status = DATAQ__DATASPLIT;
	goto trp_return;
      }
      if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
	if (!cinp->Super.Trp.DataL.Back) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCBACK;
	  goto trp_return;
	}
	if (!cinp->Super.Trp.DataL.Front) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCFRONT;
	  goto trp_return;
	}
      }

      /* Transport data */
      coutp->Super.Trp.InPtr = cinp->Super.Trp.DataL.Data.Ptr;
      coutp->Super.Trp.InObjid = cinp->Super.Trp.DataL.Data.Aref.Objid;
      coutp->Super.Trp.InDlid = cinp->Super.Trp.DataL.Dlid;
      coutp->Super.Trp.InFlag = 1;
      cinp->Super.Trp.OutRearFlag = 1;
      coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardFront;
      cinp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Front;
      o->Status = DATAQ__SUCCESS;
    }
  }

  if ((*(o->TriggForwBackP) && !o->OldTriggForwBack && !o->ManualMode) ||
      (o->ManualMode && o->ManTriggForwBack)) {
    /* Check source */
    if (cinp->DataSize == 0) {
      /* Nothing to transport */
      o->Error = 1;
      o->Status = DATAQ__QUEUEEMPTY;
      goto trp_return;
    }

    if ((coutp->Super.Trp.InFlag && 
	 (coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardUnit ||
	  coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardBack ||
	  coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardFront)) ||
	 coutp->Super.Trp.OutFrontFlag)
      return;

    if ((cinp->Super.Trp.InFlag && 
	 (cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseUnit ||
	  cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseBack ||
	  cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseFront)) ||
	 cinp->Super.Trp.OutRearFlag)
      return;

    if (cinp->Super.Trp.DataL.Data.Ptr != coutp->Data[0].Data.Ptr) {
      /* This should be a Front trigg */
      o->Error = 1;
      o->Status = DATAQ__DESTNOTPRESENT;
      goto trp_return;
    } else {
      if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
	if (cinp->Super.Trp.DataL.Front) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCFRONT;
	  goto trp_return;
	} else if (!cinp->Super.Trp.DataL.Back) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCBACK;
	  goto trp_return;
	} else if (!coutp->Data[0].Front) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTFRONT;
	  goto trp_return;
	} else if (coutp->Data[0].Back) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTBACK;
	  goto trp_return;
	}
      }
    }

    /* Transport data */
    coutp->Super.Trp.InPtr = cinp->Super.Trp.DataL.Data.Ptr;
    coutp->Super.Trp.InObjid = cinp->Super.Trp.DataL.Data.Aref.Objid;
    coutp->Super.Trp.InDlid = cinp->Super.Trp.DataL.Dlid;
    coutp->Super.Trp.InFlag = 1;
    cinp->Super.Trp.OutRearFlag = 1;
    coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardBack;
    cinp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Back;
    o->Status = DATAQ__SUCCESS;
  }

  if ((*(o->TriggReverseBackP) && !o->OldTriggReverseBack && !o->ManualMode) ||
      (o->ManualMode && o->ManTriggReverseBack)) {
    /* Check destination */
    if (inp->QueueFull) {
      /* Destination cell is full */
      o->Error = 1;
      o->Status = DATAQ__QUEUEFULL;
      goto trp_return;
    }
    if ((cinp->Super.Trp.InFlag && 
	 (cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseUnit ||
	  cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseBack ||
	  cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseFront)) ||
	 cinp->Super.Trp.OutRearFlag)
      return;

    /* Check source */
    if (coutp->DataSize == 0) {
      /* Nothing to transport */
      o->Error = 1;
      o->Status = DATAQ__QUEUEEMPTY;
      goto trp_return;
    }
    if ((coutp->Super.Trp.InFlag && 
	 (coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardUnit ||
	  coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardBack ||
	  coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardFront)) ||
	 coutp->Super.Trp.OutFrontFlag)
      return;

    if (!coutp->Data[0].Back) {
      o->Error = 1;
      o->Status = DATAQ__SRCBACK;
      goto trp_return;
    }

    if (cinp->Super.Trp.DataL.Data.Ptr == coutp->Data[0].Data.Ptr) {
      /* This should be a Front trigg */
      o->Error = 1;
      o->Status = DATAQ__DESTPRESENT;
      goto trp_return;
    }
    if (cinp->Super.Trp.DataL.Back && !cinp->Super.Trp.DataL.Front) {
      /* Destination data is split */
      o->Error = 1;
      o->Status = DATAQ__DATASPLIT;
      goto trp_return;
    }
    if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
      if (!coutp->Data[0].Back) {
	o->Error = 1;
	o->Status = DATAQ__SRCBACK;
	  goto trp_return;
      } else if (!coutp->Data[0].Front) {
	o->Error = 1;
	o->Status = DATAQ__SRCFRONT;
	goto trp_return;
      }
    }

    /* Transport data */
    cinp->Super.Trp.InPtr = coutp->Data[0].Data.Ptr;
    cinp->Super.Trp.InObjid = coutp->Data[0].Data.Aref.Objid;
    cinp->Super.Trp.InDlid = coutp->Data[0].Dlid;
    cinp->Super.Trp.InFlag = 1;
    coutp->Super.Trp.OutFrontFlag = 1;
    cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseBack;
    coutp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Back;
    o->Status = DATAQ__SUCCESS;
  }

  if ((((*(o->TriggReverseFrontP) && !o->OldTriggReverseFront) || 
      (*(o->TriggReverseFrontP) && o->Options & pwr_mQTrpOptionsMask_LevelTrigg) || 
      o->FuncAllReverse) &&
       !o->ManualMode) || 
      (o->ManualMode && o->ManTriggReverseFront)) {
    if (o->Function == pwr_eQTrpFunctionEnum_MoveWholeObject) {
      /* Check destination */
      if (inp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__QUEUEFULL;
        goto trp_return;
      }
      if ((cinp->Super.Trp.InFlag && 
	   (cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseUnit ||
	    cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseBack ||
	    cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseFront)) ||
	   cinp->Super.Trp.OutRearFlag)
        return;

      /* Check source */
      if (coutp->DataSize == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trp_return;
      }
      if ((coutp->Super.Trp.InFlag && 
	   (coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardUnit ||
	    coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardBack ||
	    coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardFront)) ||
	   coutp->Super.Trp.OutFrontFlag)
        return;

      /* Check that both Front and Back is in the cell */
      if (!(coutp->Data[0].Back && coutp->Data[0].Front)) {
        o->Error = 1;
	o->Status = DATAQ__DATASPLIT;
        goto trp_return;
      }

      /* Transport data */
      cinp->Super.Trp.InPtr = coutp->Data[0].Data.Ptr;
      cinp->Super.Trp.InObjid = coutp->Data[0].Data.Aref.Objid;
      cinp->Super.Trp.InDlid = coutp->Data[0].Dlid;
      cinp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.OutFrontFlag = 1;
      cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseUnit;
      coutp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

    } else if ((o->Function == pwr_eQTrpFunctionEnum_MoveAllObjects)
        || (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty)) {
      if (*(o->TriggReverseFrontP) && !o->OldTriggReverseFront) {
        /* This is the first object to move */
        if (o->FuncAllReverse || o->FuncAllForward) {
          /* We are already busy moving last trigg */
          return;
        }

        /* Check destination */
        if (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty) {
          if (cinp->DataSize) {
            /* Destination cell is not empty */
            o->Error = 1;
	    o->Status = DATAQ__DESTNOTEMPTY;
            goto trp_return;
          }
        }
      }
      if (inp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        o->FuncAllReverse = 0;
        goto trp_return;
      }
      if (cinp->Super.Trp.InFlag || cinp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (coutp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trp_return;
      }
      if (coutp->Super.Trp.OutFrontFlag)
        return;

      if (cinp->Super.Trp.DataL.Data.Ptr == coutp->Data[0].Data.Ptr) {
        o->Error = 1;
	o->Status = DATAQ__DESTPRESENT;
        goto trp_return;
      }

      if (o->Options & pwr_mQTrpOptionsMask_Slow && o->FuncAllForward == 1) {
        /* Wait till next scan */
        o->FuncAllForward = 2;
        goto trp_return;
      }

      /* Transport data */
      cinp->Super.Trp.InPtr = coutp->Data[0].Data.Ptr;
      cinp->Super.Trp.InObjid = coutp->Data[0].Data.Aref.Objid;
      cinp->Super.Trp.InDlid = coutp->Data[0].Dlid;
      cinp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.OutFrontFlag = 1;
      cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseUnit;
      coutp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

      if (coutp->Super.Intern.NumberOfData == 1)
        o->FuncAllReverse = 0;
      else
        o->FuncAllReverse = 1;
    } else {

      if ((cinp->Super.Trp.InFlag && 
	   (cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseUnit ||
	    cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseBack ||
	    cinp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ReverseFront)) ||
	  cinp->Super.Trp.OutRearFlag)
        return;

      /* Check source */
      if (coutp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trp_return;
      }
      if ((coutp->Super.Trp.InFlag && 
	   (coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardUnit ||
	    coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardBack ||
	    coutp->Super.Trp.InOpType == pwr_eQTrpOpEnum_ForwardFront)) ||
	   coutp->Super.Trp.OutFrontFlag)
        return;

      if (cinp->Super.Trp.DataL.Data.Ptr != coutp->Data[0].Data.Ptr) {
        /* This should be a Back trigg */
	o->Status = DATAQ__DESTNOTPRESENT;
        o->Error = 1;
        goto trp_return;
      } else {
	if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
	  if (!cinp->Super.Trp.DataL.Back) {
	    o->Error = 1;
	    o->Status = DATAQ__DESTBACK;
	    goto trp_return;
	  } else if (cinp->Super.Trp.DataL.Front) {
	    o->Error = 1;
	    o->Status = DATAQ__DESTFRONT;
	    goto trp_return;
	  } else if (!coutp->Data[0].Front) {
	    o->Error = 1;
	    o->Status = DATAQ__SRCFRONT;
	    goto trp_return;
	  } else if (coutp->Data[0].Back) {
	    o->Error = 1;
	    o->Status = DATAQ__SRCBACK;
	    goto trp_return;
	  }
	}
      }

      /* Transport data */
      cinp->Super.Trp.InPtr = coutp->Data[0].Data.Ptr;
      cinp->Super.Trp.InObjid = coutp->Data[0].Data.Aref.Objid;
      cinp->Super.Trp.InDlid = coutp->Data[0].Dlid;
      cinp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.OutFrontFlag = 1;
      cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseFront;
      coutp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Front;
      o->Status = DATAQ__SUCCESS;
    }
  }

trp_return:
  o->OldTriggForwFront = *(o->TriggForwFrontP);
  o->OldTriggReverseFront = *(o->TriggReverseFrontP);
  o->OldTriggForwBack = *(o->TriggForwBackP);
  o->OldTriggReverseBack = *(o->TriggReverseBackP);

  o->ManTriggForwFront = 0;
  o->ManTriggForwBack = 0;
  o->ManTriggReverseFront = 0;
  o->ManTriggReverseBack = 0;

  if (o->Options & pwr_mQTrpOptionsMask_ResetTrigg) {
    /* Reset the trigg flags */
    o->TriggForwFront = 0;
    o->TriggReverseFront = 0;
    o->TriggForwBack = 0;
    o->TriggReverseBack = 0;
  }
}

/*_*
  QTrpRR

  @aref qtrprr QTrpRR
*/
void QTrpRR_exec(plc_sThread* tp, pwr_sClass_QTrpRR* o)
{
  pwr_sClass_DataQFo *outp = (pwr_sClass_DataQFo*)o->OutP;
  pwr_sClass_DataQ1 *coutp = (pwr_sClass_DataQ1*)outp->PlcConnectP;
  pwr_sClass_DataQFo *inp = (pwr_sClass_DataQFo*)o->InP;
  pwr_sClass_DataQ1 *cinp = (pwr_sClass_DataQ1*)inp->PlcConnectP;

  if (!coutp || !cinp)
    return;

  if (o->Error)
    o->Error = 0;

  if ((((*(o->TriggForwFrontP) && !o->OldTriggForwFront) || 
      (*(o->TriggForwFrontP) && o->Options & pwr_mQTrpOptionsMask_LevelTrigg) || 
      o->FuncAllForward) &&
       !o->ManualMode) ||
      (o->ManualMode && o->ManTriggForwFront)) {
    if (o->Function == pwr_eQTrpFunctionEnum_MoveWholeObject) {
      /* Move all of data */
      /* Check destination */
      if (outp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        goto trprr_return;
      }
      if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutRearFlag)
        return;

      /* Check source */
      if (cinp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trprr_return;
      }
      if (cinp->Super.Trp.OutRearFlag)
        return;

      /* Check that both Back and Front is in the in cell */
      if (!(cinp->Super.Trp.DataL.Back
              && cinp->Super.Trp.DataL.Front)) {
        o->Error = 1;
	o->Status = DATAQ__DATASPLIT;
        goto trprr_return;
      }

      /* Transport data */
      coutp->Super.Trp.InPtr = cinp->Super.Trp.DataL.Data.Ptr;
      coutp->Super.Trp.InObjid = cinp->Super.Trp.DataL.Data.Aref.Objid;
      coutp->Super.Trp.InDlid = cinp->Super.Trp.DataL.Dlid;
      coutp->Super.Trp.InFlag = 1;
      cinp->Super.Trp.OutRearFlag = 1;
      coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseUnit;
      cinp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

    } else if ((o->Function == pwr_eQTrpFunctionEnum_MoveAllObjects)
        || (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty)) {
      /* Move all of data */
      /* Check destination */
      if (*(o->TriggForwFrontP) && !o->OldTriggForwFront) {
        /* This is the first object to move */
        if (o->FuncAllReverse || o->FuncAllForward) {
          /* We are already busy moving last trigg */
          return;
        }

        if (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty) {
          if (coutp->Super.Intern.NumberOfData != 0) {
            /* Destination cell is not empty */
            o->Error = 1;
	    o->Status = DATAQ__DESTNOTEMPTY;
            goto trprr_return;
          }
        }
      }

      if (outp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        o->FuncAllForward = 0;
        goto trprr_return;
      }
      if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutRearFlag)
        return;

      /* Check source */
      if (cinp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trprr_return;
      }
      if (cinp->Super.Trp.OutRearFlag)
        return;

      if (o->Options & pwr_mQTrpOptionsMask_Slow && o->FuncAllForward == 1) {
        /* Wait till next scan */
        o->FuncAllForward = 2;
        goto trprr_return;
      }

      /* Transport data */
      coutp->Super.Trp.InPtr = cinp->Super.Trp.DataL.Data.Ptr;
      coutp->Super.Trp.InObjid = cinp->Super.Trp.DataL.Data.Aref.Objid;
      coutp->Super.Trp.InDlid = cinp->Super.Trp.DataL.Dlid;
      coutp->Super.Trp.InFlag = 1;
      cinp->Super.Trp.OutRearFlag = 1;
      coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseUnit;
      cinp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

      if (cinp->Super.Intern.NumberOfData == 1)
        o->FuncAllForward = 0;
      else
        o->FuncAllForward = 1;
    } else {
      /* Move front of data */
      /* Check destination */
      if (outp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        goto trprr_return;
      }
      if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutRearFlag)
        return;

      /* Check source */
      if (cinp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trprr_return;
      }
      if (cinp->Super.Trp.OutRearFlag)
        return;

      if (cinp->Super.Trp.DataL.Data.Ptr == coutp->Data[0].Data.Ptr) {
	/* This should be a Back trigg */
	o->Status = DATAQ__DESTPRESENT;
	o->Error = 1;
	goto trprr_return;
      } 
      if (!coutp->Super.Trp.DataL.Front && coutp->Super.Trp.DataL.Back) {
	o->Error = 1;
	o->Status = DATAQ__DATASPLIT;
	goto trprr_return;
      }
      if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
	if (!cinp->Super.Trp.DataL.Back) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCBACK;
	  goto trprr_return;
	} else if (!cinp->Super.Trp.DataL.Front) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCFRONT;
	  goto trprr_return;
	}
      }

      /* Transport data */
      coutp->Super.Trp.InPtr = cinp->Super.Trp.DataL.Data.Ptr;
      coutp->Super.Trp.InObjid = cinp->Super.Trp.DataL.Data.Aref.Objid;
      coutp->Super.Trp.InDlid = cinp->Super.Trp.DataL.Dlid;
      coutp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseBack;
      cinp->Super.Trp.OutRearFlag = 1;
      cinp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Front;
      o->Status = DATAQ__SUCCESS;
    }
  }

  if ((*(o->TriggForwBackP) && !o->OldTriggForwBack && !o->ManualMode) ||
      (o->ManualMode && o->ManTriggForwBack)) {
    if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutRearFlag)
      return;

    /* Check source */
    if (cinp->Super.Intern.NumberOfData == 0) {
      /* Nothing to transport */
      o->Error = 1;
      o->Status = DATAQ__QUEUEEMPTY;
      goto trprr_return;
    }
    if (cinp->Super.Trp.OutRearFlag)
      return;

    if (cinp->Super.Trp.DataL.Data.Ptr != coutp->Super.Trp.DataL.Data.Ptr) {
      /* This should be a Front trigg */
      o->Error = 1;
      o->Status = DATAQ__DESTNOTPRESENT;
      goto trprr_return;
    } else {
      if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
	if (!cinp->Super.Trp.DataL.Back) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCBACK;
	  goto trprr_return;
	} else if (cinp->Super.Trp.DataL.Front) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCFRONT;
	  goto trprr_return;
	} else if (!coutp->Super.Trp.DataL.Back) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTBACK;
	  goto trprr_return;
	} else if (coutp->Super.Trp.DataL.Front) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTFRONT;
	  goto trprr_return;
	}
      }
    }

    /* Transport data */
    coutp->Super.Trp.InPtr = cinp->Super.Trp.DataL.Data.Ptr;
    coutp->Super.Trp.InObjid = cinp->Super.Trp.DataL.Data.Aref.Objid;
    coutp->Super.Trp.InDlid = cinp->Super.Trp.DataL.Dlid;
    coutp->Super.Trp.InFlag = 1;
    cinp->Super.Trp.OutRearFlag = 1;
    coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseFront;
    cinp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Back;
    o->Status = DATAQ__SUCCESS;
  }

  if ((*(o->TriggReverseBackP) && !o->OldTriggReverseBack &&
       !o->ManualMode) ||
      (o->ManualMode && o->ManTriggReverseBack)) {
    /* Check destination */
    if (cinp->Super.Trp.InFlag || cinp->Super.Trp.OutRearFlag)
      return;

    /* Check source */
    if (coutp->Super.Intern.NumberOfData == 0) {
      /* Nothing to transport */
      o->Error = 1;
      o->Status = DATAQ__QUEUEEMPTY;
      goto trprr_return;
    }
    if (coutp->Super.Trp.OutRearFlag)
      return;

    if (!coutp->Super.Trp.DataL.Back) {
      o->Error = 1;
      o->Status = DATAQ__DESTBACK;
      goto trprr_return;
    }

    if (cinp->Super.Trp.DataL.Data.Ptr != coutp->Super.Trp.DataL.Data.Ptr) {
      o->Error = 1;
      o->Status = DATAQ__DESTNOTPRESENT;
      goto trprr_return;
    } else {
      if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
	if (!cinp->Super.Trp.DataL.Back) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCBACK;
	  goto trprr_return;
	} else if (cinp->Super.Trp.DataL.Front) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCFRONT;
	  goto trprr_return;
	} else if (!coutp->Super.Trp.DataL.Back) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTBACK;
	  goto trprr_return;
	} else if (coutp->Super.Trp.DataL.Front) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTFRONT;
	  goto trprr_return;
	}
      }
    }

    /* Transport data */
    cinp->Super.Trp.InPtr = coutp->Super.Trp.DataL.Data.Ptr;
    cinp->Super.Trp.InObjid = coutp->Super.Trp.DataL.Data.Aref.Objid;
    cinp->Super.Trp.InDlid = coutp->Super.Trp.DataL.Dlid;
    cinp->Super.Trp.InFlag = 1;
    cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseFront;
    coutp->Super.Trp.OutRearFlag = 1;
    coutp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Back;
  }

  if ((((*(o->TriggReverseFrontP) && !o->OldTriggReverseFront) || 
       (*(o->TriggReverseFrontP) && o->Options & pwr_mQTrpOptionsMask_LevelTrigg) || 
       o->FuncAllReverse) &&
      !o->ManualMode) ||
      (o->ManualMode && o->ManTriggReverseFront)) {
    if (o->Function == pwr_eQTrpFunctionEnum_MoveWholeObject) {
      /* Check destination */
      if (inp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        goto trprr_return;
      }
      if (cinp->Super.Trp.InFlag || cinp->Super.Trp.OutRearFlag)
        return;

      /* Check source */
      if (coutp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trprr_return;
      }
      if (coutp->Super.Trp.OutRearFlag)
        return;

      /* Check that both Front and Back is in the cell */
      if (!(coutp->Super.Trp.DataL.Back
              && coutp->Super.Trp.DataL.Front)) {
        o->Error = 1;
	o->Status = DATAQ__DATASPLIT;
        goto trprr_return;
      }

      /* Transport data */
      cinp->Super.Trp.InPtr = coutp->Super.Trp.DataL.Data.Ptr;
      cinp->Super.Trp.InObjid = coutp->Super.Trp.DataL.Data.Aref.Objid;
      cinp->Super.Trp.InDlid = coutp->Super.Trp.DataL.Dlid;
      cinp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.OutRearFlag = 1;
      cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseUnit;
      coutp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

    } else if ((o->Function == pwr_eQTrpFunctionEnum_MoveAllObjects)
        || (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty)) {
      if (*(o->TriggReverseFrontP) && !o->OldTriggReverseFront) {
        /* This is the first object to move */
        if (o->FuncAllReverse || o->FuncAllForward) {
          /* We are already busy moving last trigg */
          return;
        }

        /* Check destination */
        if (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty) {
          if (cinp->Super.Intern.NumberOfData) {
            /* Destination cell is not empty */
            o->Error = 1;
	    o->Status = DATAQ__DESTNOTEMPTY;
            goto trprr_return;
          }
        }
      }
      if (inp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        o->FuncAllReverse = 0;
        goto trprr_return;
      }
      if (cinp->Super.Trp.InFlag || cinp->Super.Trp.OutRearFlag)
        return;

      /* Check source */
      if (coutp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trprr_return;
      }
      if (coutp->Super.Trp.OutRearFlag)
        return;

      if (cinp->Super.Trp.DataL.Data.Ptr == coutp->Super.Trp.DataL.Data.Ptr) {
        o->Error = 1;
	o->Status = DATAQ__DESTPRESENT;
        goto trprr_return;
      }

      if (o->Options & pwr_mQTrpOptionsMask_Slow && o->FuncAllForward == 1) {
        /* Wait till next scan */
        o->FuncAllForward = 2;
        goto trprr_return;
      }

      /* Transport data */
      cinp->Super.Trp.InPtr = coutp->Super.Trp.DataL.Data.Ptr;
      cinp->Super.Trp.InObjid = coutp->Super.Trp.DataL.Data.Aref.Objid;
      cinp->Super.Trp.InDlid = coutp->Super.Trp.DataL.Dlid;
      cinp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.OutRearFlag = 1;
      cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseUnit;
      coutp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

      if (coutp->Super.Intern.NumberOfData == 1)
        o->FuncAllReverse = 0;
      else
        o->FuncAllReverse = 1;
    } else {
      if (cinp->Super.Trp.InFlag || cinp->Super.Trp.OutRearFlag)
        return;

      /* Check source */
      if (coutp->Super.Intern.NumberOfData == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trprr_return;
      }
      if (coutp->Super.Trp.OutRearFlag)
        return;

      if (cinp->Super.Trp.DataL.Data.Ptr == coutp->Super.Trp.DataL.Data.Ptr) {
        /* This should be a Back trigg */
        o->Error = 1;
	o->Status = DATAQ__DESTPRESENT;
        goto trprr_return;
      } 
      if (!cinp->Super.Trp.DataL.Front && cinp->Super.Trp.DataL.Back) {
	o->Error = 1;
	o->Status = DATAQ__DATASPLIT;
	goto trprr_return;	
      }
      if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
	if (!coutp->Super.Trp.DataL.Back) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCBACK;
	  goto trprr_return;
	} else if (!coutp->Super.Trp.DataL.Front) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCFRONT;
	  goto trprr_return;
	}
      }

      /* Transport data */
      cinp->Super.Trp.InPtr = coutp->Super.Trp.DataL.Data.Ptr;
      cinp->Super.Trp.InObjid = coutp->Super.Trp.DataL.Data.Aref.Objid;
      cinp->Super.Trp.InDlid = coutp->Super.Trp.DataL.Dlid;
      cinp->Super.Trp.InFlag = 1;
      cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ReverseBack;
      coutp->Super.Trp.OutRearFlag = 1;
      coutp->Super.Trp.OutRearOpType = pwr_eQTrpOpEnum_Front;
      o->Status = DATAQ__SUCCESS;
    }
  }

trprr_return:
  o->OldTriggForwFront = *(o->TriggForwFrontP);
  o->OldTriggReverseFront = *(o->TriggReverseFrontP);
  o->OldTriggForwBack = *(o->TriggForwBackP);
  o->OldTriggReverseBack = *(o->TriggReverseBackP);

  o->ManTriggForwFront = 0;
  o->ManTriggForwBack = 0;
  o->ManTriggReverseFront = 0;
  o->ManTriggReverseBack = 0;

  if (o->Options & pwr_mQTrpOptionsMask_ResetTrigg) {
    /* Reset the trigg flags */
    o->TriggForwFront = 0;
    o->TriggReverseFront = 0;
    o->TriggForwBack = 0;
    o->TriggReverseBack = 0;
  }
}

/*_*
  QTrpFF

  @aref atrpff QTrpFF
*/
void QTrpFF_exec(plc_sThread* tp, pwr_sClass_QTrpFF* o)
{
  pwr_sClass_DataQFo *outp = (pwr_sClass_DataQFo*)o->OutP;
  pwr_sClass_DataQ1 *coutp = (pwr_sClass_DataQ1*)outp->PlcConnectP;
  pwr_sClass_DataQFo *inp = (pwr_sClass_DataQFo*)o->InP;
  pwr_sClass_DataQ1 *cinp = (pwr_sClass_DataQ1*)inp->PlcConnectP;

  if (!coutp || !cinp)
    return;

  if (o->Error)
    o->Error = 0;

  if ((((*(o->TriggForwFrontP) && !o->OldTriggForwFront) ||
	(*(o->TriggForwFrontP) && o->Options & pwr_mQTrpOptionsMask_LevelTrigg) ||
	o->FuncAllForward) && 
       !o->ManualMode) || 
      (o->ManTriggForwFront && o->ManualMode)) {
    if (o->Function == pwr_eQTrpFunctionEnum_MoveWholeObject) {
      /* Move all of data */
      /* Check destination */
      if (outp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        goto trpff_return;
      }
      if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (cinp->DataSize == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trpff_return;
      }
      if (cinp->Super.Trp.OutFrontFlag)
        return;

      /* Check that both Back and Front is in the in cell */
      if (!(cinp->Data[0].Back && cinp->Data[0].Front)) {
        o->Error = 1;
	o->Status = DATAQ__DATASPLIT;
        goto trpff_return;
      }

      /* Transport data */
      coutp->Super.Trp.InPtr = cinp->Data[0].Data.Ptr;
      coutp->Super.Trp.InObjid = cinp->Data[0].Data.Aref.Objid;
      coutp->Super.Trp.InDlid = cinp->Data[0].Dlid;
      coutp->Super.Trp.InFlag = 1;
      cinp->Super.Trp.OutFrontFlag = 1;
      coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardUnit;
      cinp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;
    } else if ((o->Function == pwr_eQTrpFunctionEnum_MoveAllObjects)
        || (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty)) {
      /* Move all of data */
      /* Check destination */
      if (*(o->TriggForwFrontP) && !o->OldTriggForwFront) {
        /* This is the first object to move */
        if (o->FuncAllReverse || o->FuncAllForward) {
          /* We are already busy moving last trigg */
          return;
        }

        if (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty) {
          if (coutp->DataSize != 0) {
            /* Destination cell is not empty */
            o->Error = 1;
	    o->Status = DATAQ__DESTNOTEMPTY;
            goto trpff_return;
          }
        }
      }

      if (outp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        o->FuncAllForward = 0;
        goto trpff_return;
      }
      if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (cinp->DataSize == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trpff_return;
      }
      if (cinp->Super.Trp.OutFrontFlag)
        return;

      if (o->Options & pwr_mQTrpOptionsMask_Slow && o->FuncAllForward == 1) {
        /* Wait till next scan */
        o->FuncAllForward = 2;
        goto trpff_return;
      }

      /* Transport data */
      coutp->Super.Trp.InPtr = cinp->Data[0].Data.Ptr;
      coutp->Super.Trp.InObjid = cinp->Data[0].Data.Aref.Objid;
      coutp->Super.Trp.InDlid = cinp->Data[0].Dlid;
      coutp->Super.Trp.InFlag = 1;
      cinp->Super.Trp.OutFrontFlag = 1;
      coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardUnit;
      cinp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

      if (cinp->DataSize == 1)
        o->FuncAllForward = 0;
      else
        o->FuncAllForward = 1;
    } else {
      /* Move front of data */
      /* Check destination */
      if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (cinp->DataSize == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trpff_return;
      }
      if (cinp->Super.Trp.OutFrontFlag)
        return;

      if (cinp->Data[0].Data.Ptr != coutp->Data[0].Data.Ptr) {
        /* This should be a Back trigg */
        o->Error = 1;
	o->Status = DATAQ__DESTNOTPRESENT;
        goto trpff_return;
      } 
      if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
	if (cinp->Data[0].Back) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCBACK;
	  goto trpff_return;
	} else if (!cinp->Data[0].Front) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCFRONT;
	  goto trpff_return;
	} else if (coutp->Data[0].Back) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTBACK;
	  goto trpff_return;
	} else if (!coutp->Data[0].Front) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTFRONT;
	  goto trpff_return;
	}
      }

      /* Transport data */
      coutp->Super.Trp.InPtr = cinp->Data[0].Data.Ptr;
      coutp->Super.Trp.InObjid = cinp->Data[0].Data.Aref.Objid;
      coutp->Super.Trp.InDlid = cinp->Data[0].Dlid;
      coutp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardBack;
      cinp->Super.Trp.OutFrontFlag = 1;
      cinp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Front;
      o->Status = DATAQ__SUCCESS;

    }
  }

  if ((*(o->TriggForwBackP) && !o->OldTriggForwBack && !o->ManualMode) ||
      (o->ManTriggForwBack && o->ManualMode)) {
    if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutFrontFlag)
      return;

    /* Check source */
    if (outp->QueueFull) {
      /* Destination cell is full */
      o->Error = 1;
      o->Status = DATAQ__DESTFULL;
      goto trpff_return;
    }
    if (cinp->DataSize == 0) {
      /* Nothing to transport */
      o->Error = 1;
      o->Status = DATAQ__QUEUEEMPTY;
      goto trpff_return;
    }
    if (cinp->Super.Trp.OutRearFlag)
      return;

    if (cinp->Data[0].Data.Ptr == coutp->Data[0].Data.Ptr) {
      /* This should be a Front trigg */
      o->Error = 1;
      o->Status = DATAQ__DESTPRESENT;
      goto trpff_return;
    }
    if (coutp->Data[0].Front && !coutp->Data[0].Back) {
      o->Error = 1;
      o->Status = DATAQ__DATASPLIT;
      goto trpff_return;
    }
    if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
      if (!cinp->Data[0].Back) {
	o->Error = 1;
	o->Status = DATAQ__SRCBACK;
	goto trpff_return;
      } else if (!cinp->Data[0].Front) {
	o->Error = 1;
	o->Status = DATAQ__SRCFRONT;
	goto trpff_return;
      }
    }

    /* Transport data */
    coutp->Super.Trp.InPtr = cinp->Data[0].Data.Ptr;
    coutp->Super.Trp.InObjid = cinp->Data[0].Data.Aref.Objid;
    coutp->Super.Trp.InDlid = cinp->Data[0].Dlid;
    coutp->Super.Trp.InFlag = 1;
    cinp->Super.Trp.OutFrontFlag = 1;
    coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardFront;
    cinp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Back;
    o->Status = DATAQ__SUCCESS;
  }

  if ((*(o->TriggReverseBackP) && !o->OldTriggReverseBack && !o->ManualMode) ||
      (o->ManTriggReverseBack && o->ManualMode)) {
    /* Check destination */
    if (inp->QueueFull) {
      /* Destination cell is full */
      o->Error = 1;
      o->Status = DATAQ__DESTFULL;
      goto trpff_return;
    }
    if (cinp->Super.Trp.InFlag || cinp->Super.Trp.OutFrontFlag)
      return;

    /* Check source */
    if (coutp->DataSize == 0) {
      /* Nothing to transport */
      o->Error = 1;
      o->Status = DATAQ__QUEUEEMPTY;
      goto trpff_return;
    }

    if (coutp->Super.Trp.OutFrontFlag)
      return;

    if (cinp->Data[0].Data.Ptr == coutp->Data[0].Data.Ptr) {
      o->Error = 1;
      o->Status = DATAQ__DESTPRESENT;
      goto trpff_return;
    }
    if (cinp->Data[0].Front && !cinp->Data[0].Back) {
      o->Error = 1;
      o->Status = DATAQ__DATASPLIT;
      goto trpff_return;
    }
    if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
      if (!coutp->Data[0].Back) {
	o->Error = 1;
	o->Status = DATAQ__SRCBACK;
	goto trpff_return;
      } else if (!coutp->Data[0].Front) {
	o->Error = 1;
	o->Status = DATAQ__SRCFRONT;
	goto trpff_return;
      }
    }

    /* Transport data */
    cinp->Super.Trp.InPtr = coutp->Data[0].Data.Ptr;
    cinp->Super.Trp.InObjid = coutp->Data[0].Data.Aref.Objid;
    cinp->Super.Trp.InDlid = coutp->Data[0].Dlid;
    cinp->Super.Trp.InFlag = 1;
    coutp->Super.Trp.OutFrontFlag = 1;
    cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardFront;
    coutp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Back;
    o->Status = DATAQ__SUCCESS;
  }

  if ((((*(o->TriggReverseFrontP) && !o->OldTriggReverseFront) || 
	(*(o->TriggReverseFrontP) && o->Options & pwr_mQTrpOptionsMask_LevelTrigg) || 
	o->FuncAllReverse) &&
       !o->ManualMode) ||
      (o->ManualMode && o->ManTriggReverseFront)) {
    if (o->Function == pwr_eQTrpFunctionEnum_MoveWholeObject) {
      /* Check destination */
      if (inp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        goto trpff_return;
      }
      if (cinp->Super.Trp.InFlag || cinp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (coutp->DataSize == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trpff_return;
      }
      if (coutp->Super.Trp.OutFrontFlag)
        return;

      /* Check that Front is in the cell */
      if (!coutp->Data[0].Front) {
        o->Error = 1;
	o->Status = DATAQ__SRCFRONT;
        goto trpff_return;
      }

      /* Transport data */
      cinp->Super.Trp.InPtr = coutp->Data[0].Data.Ptr;
      cinp->Super.Trp.InObjid = coutp->Data[0].Data.Aref.Objid;
      cinp->Super.Trp.InDlid = coutp->Data[0].Dlid;
      cinp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.OutFrontFlag = 1;
      cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardUnit;
      coutp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

    } else if ((o->Function == pwr_eQTrpFunctionEnum_MoveAllObjects)
        || (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty)) {
      if (*(o->TriggReverseFrontP) && !o->OldTriggReverseFront) {
        /* This is the first object to move */
        if (o->FuncAllReverse || o->FuncAllForward) {
          /* We are already busy moving last trigg */
          return;
        }

        /* Check destination */
        if (o->Function == pwr_eQTrpFunctionEnum_MoveAllObjectsIfEmpty) {
          if (cinp->DataSize) {
            /* Destination cell is not empty */
            o->Error = 1;
	    o->Status = DATAQ__DESTNOTEMPTY;
            goto trpff_return;
          }
        }
      }
      if (inp->QueueFull) {
        /* Destination cell is full */
        o->Error = 1;
	o->Status = DATAQ__DESTFULL;
        o->FuncAllReverse = 0;
        goto trpff_return;
      }
      if (cinp->Super.Trp.InFlag || cinp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (coutp->DataSize == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trpff_return;
      }
      if (coutp->Super.Trp.OutFrontFlag)
        return;

      if (cinp->Data[0].Data.Ptr == coutp->Data[0].Data.Ptr) {
        o->Error = 1;
	o->Status = DATAQ__DESTPRESENT;
        goto trpff_return;
      }

      if (o->Options & pwr_mQTrpOptionsMask_Slow && o->FuncAllForward == 1) {
        /* Wait till next scan */
        o->FuncAllForward = 2;
        goto trpff_return;
      }

      /* Transport data */
      cinp->Super.Trp.InPtr = coutp->Data[0].Data.Ptr;
      cinp->Super.Trp.InObjid = coutp->Data[0].Data.Aref.Objid;
      cinp->Super.Trp.InDlid = coutp->Data[0].Dlid;
      cinp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.OutFrontFlag = 1;
      cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardUnit;
      coutp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Unit;
      o->Status = DATAQ__SUCCESS;

      if (coutp->DataSize == 1)
        o->FuncAllReverse = 0;
      else
        o->FuncAllReverse = 1;
    } else {
      if (cinp->Super.Trp.InFlag || cinp->Super.Trp.OutFrontFlag)
        return;

      /* Check source */
      if (coutp->DataSize == 0) {
        /* Nothing to transport */
        o->Error = 1;
	o->Status = DATAQ__QUEUEEMPTY;
        goto trpff_return;
      }
      if (coutp->Super.Trp.OutFrontFlag)
        return;

      if (!coutp->Data[0].Front) {
	o->Error = 1;
	o->Status = DATAQ__SRCFRONT;
	goto trpff_return;
      }

      if (cinp->Data[0].Data.Ptr != coutp->Data[0].Data.Ptr) {
        /* This should be a Back trigg */
        o->Error = 1;
	o->Status = DATAQ__DESTNOTPRESENT;
        goto trpff_return;
      } 
      if (o->Options & pwr_mQTrpOptionsMask_NoExtend) {
	if (cinp->Data[0].Back) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTBACK;
	  goto trpff_return;
	} else if (!cinp->Data[0].Front) {
	  o->Error = 1;
	  o->Status = DATAQ__DESTFRONT;
	  goto trpff_return;
	} else if (coutp->Data[0].Back) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCBACK;
	  goto trpff_return;
	} else if (!coutp->Data[0].Front) {
	  o->Error = 1;
	  o->Status = DATAQ__SRCFRONT;
	    goto trpff_return;
	}
      }

      /* Transport data */
      cinp->Super.Trp.InPtr = coutp->Data[0].Data.Ptr;
      cinp->Super.Trp.InObjid = coutp->Data[0].Data.Aref.Objid;
      cinp->Super.Trp.InDlid = coutp->Data[0].Dlid;
      cinp->Super.Trp.InFlag = 1;
      coutp->Super.Trp.OutFrontFlag = 1;
      cinp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardBack;
      coutp->Super.Trp.OutFrontOpType = pwr_eQTrpOpEnum_Front;
      o->Status = DATAQ__SUCCESS;
    }
  }

trpff_return:
  o->OldTriggForwFront = *(o->TriggForwFrontP);
  o->OldTriggReverseFront = *(o->TriggReverseFrontP);
  o->OldTriggForwBack = *(o->TriggForwBackP);
  o->OldTriggReverseBack = *(o->TriggReverseBackP);
      
  o->ManTriggForwFront = 0;
  o->ManTriggForwBack = 0;
  o->ManTriggReverseFront = 0;
  o->ManTriggReverseBack = 0;
     
  if (o->Options & pwr_mQTrpOptionsMask_ResetTrigg) {
    /* Reset the trigg flags */
    o->TriggForwFront = 0;
    o->TriggReverseFront = 0;
    o->TriggForwBack = 0;
    o->TriggReverseBack = 0;
  }
}

void QOrder_init(pwr_sClass_QOrder* o)
{
}

void QOrder_exec(plc_sThread* tp, pwr_sClass_QOrder* o)
{
  if (o->InP->Data.Ptr != o->PtrOld) {
    if (o->Status) {
      // Reset for one scan
      o->Status = 0;
      return;
    }
    o->Status = o->InP->Data.Ptr ? 1 : 0;
    if (o->InP->Data.Ptr)
      o->New = 1;
    else
      o->New = 0;
    o->PtrOld = o->InP->Data.Ptr;
  } else
    o->New = 0;

  o->Out.Front = o->InP->Front;
  o->Out.Back = o->InP->Back;
  if (o->New) {    
    o->Out.Data = o->InP->Data;
    o->Out.New = 1;
  }
  else
    o->Out.New = 0;
}
void QOrder_exec2(plc_sThread* tp, pwr_sClass_QOrder* o, pwr_tBoolean Status)
{
  o->Out.Status = Status;
  if (!Status && o->StatusOld) {
    o->Out.New = 0;
    o->Out.Data = pwr_cNDataRef;
    o->Out.Back = 0;
    o->Out.Front = 0;
  }
  o->StatusOld = o->Out.Status;
}

/*_*
  RemoteDataQFo

  @aref remotdataqfo RemoteDataQFo
*/
void RemoteDataQFo_init(pwr_sClass_RemoteDataQFo* o)
{
  pwr_tStatus sts;
  pwr_tDlid dlid;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts)) {
    o->PlcConnectP = 0;
    return;
  }
}

void RemoteDataQFo_exec(plc_sThread* tp, pwr_sClass_RemoteDataQFo* o)
{
  pwr_sClass_RemoteDataQ* co = (pwr_sClass_RemoteDataQ*)o->PlcConnectP;
  if (!co)
    return;

  if (o->Feedback)
    o->Feedback = 0;
  else if (co->Feedback) {
    o->Feedback = 1;
    co->Feedback = 0;
  }
}

/*_*
  QRemoteOrder

  @aref qremoteorder QRemoteOrder
*/
void QRemoteOrder_init(pwr_sClass_QRemoteOrder* o)
{
  QOrder_init((pwr_sClass_QOrder *)o);
}

void QRemoteOrder_exec(plc_sThread* tp, pwr_sClass_QRemoteOrder* o)
{
  QOrder_exec(tp, (pwr_sClass_QOrder *)o);
}

void QRemoteOrder_exec2(plc_sThread* tp, pwr_sClass_QRemoteOrder* o, pwr_tBoolean Status)
{
  QOrder_exec2(tp, (pwr_sClass_QOrder *)o, Status);
  if (Status && !o->QRStatusOld)
    o->QRStatus = 1;
  if (!Status && o->QRStatusOld)
    o->QRStatusReset = 1;
  if (o->Feedback)
    o->Feedback = 0;
  else if (o->QRFeedback) {
    o->Feedback = 1;
    o->QRFeedback = 0;
  }
  o->QRStatusOld = Status;
}

/*_*
  QTargetOrder

  @aref qtargetorder QTargetOrder
*/
void QTargetOrder_exec(plc_sThread* tp, pwr_sClass_QTargetOrder* o)
{
  if (o->Out.New)
    o->Out.New = 0;
  else {
    if (o->New) {
      if (cdh_ObjidIsNotNull(o->DataObject))
        gdh_DLUnrefObjectInfo(o->DataDlid);
      o->Out.Data.Aref = cdh_ObjidToAref(o->DataObject);
      pwr_tStatus sts = gdh_DLRefObjectInfoAttrref(&o->Out.Data.Aref, &o->Out.Data.Ptr, &o->DataDlid); 
      if (EVEN(sts)) {
	o->DataObject = pwr_cNOid;
	o->Out.Data.Ptr = 0;
	o->Out.Data.Aref.Objid = pwr_cNOid;
      } else {
	o->Out.New = 1;
	o->Out.Status = 1;
	o->Out.Front = 1;
	o->Out.Back = 1;
      }
      o->New = 0;
    }
  }
  if (o->QTStatusReset) {
    o->QTStatusReset = 0;
    o->QTFeedback = 1;
  }
  if (*o->FeedbackP && !o->FeedbackOld && !o->QTFeedback) {
    o->QTFeedback = 1;
  }
  if (!o->QTFeedback && o->QTFeedbackOld) {
    o->Out.Status = 0;
    gdh_DLUnrefObjectInfo(o->DataDlid);
    o->DataDlid = pwr_cNDlid;
    o->DataObject = pwr_cNOid;
    o->Out.Data.Ptr = 0;
    o->Out.Data.Aref.Objid = pwr_cNOid;
    o->Out.Front = 0;
    o->Out.Back = 0;
  }
  o->FeedbackOld = *o->FeedbackP;
  o->QTFeedbackOld = o->QTFeedback;
}


/*_*
  QCreateData

  @aref qcreatedata QCreateData
*/
void QCreateData_exec(plc_sThread* tp, pwr_sClass_QCreateData* o)
{
  pwr_sClass_DataQFo *outp = (pwr_sClass_DataQFo*)o->OutP;
  pwr_sClass_DataQ1 *coutp = (pwr_sClass_DataQ1*)outp->PlcConnectP;

  if (!coutp)
    return;

  if (o->Error)
    o->Error = 0;

  if (o->Transport) {
    if (outp->QueueFull) {
      /* Destination cell is full */
      o->Error = 1;
      o->Status = DATAQ__DESTFULL;
      return;
    }
    if (coutp->Super.Trp.InFlag || coutp->Super.Trp.OutFrontFlag)
      return;

    /* Transport data */
    coutp->Super.Trp.InPtr = o->Data.Data.Ptr;
    coutp->Super.Trp.InObjid = o->Data.Data.Aref.Objid;
    coutp->Super.Trp.InDlid = o->Data.Dlid;
    coutp->Super.Trp.InFlag = 1;
    coutp->Super.Trp.InOpType = pwr_eQTrpOpEnum_ForwardUnit;
    o->Data.Data.Ptr = 0;
    o->Data.Data.Aref.Objid = pwr_cNOid;
    o->Data.Dlid = pwr_cNRefId;
    o->Transport = 0;
  }

  if (*o->CreateP && !o->OldCreate) {
    pwr_tStatus sts;
    pwr_tOName name;
    pwr_tOid oid;
    pwr_tRefId dlid;
    void *data_p;

    if (outp->QueueFull) {
      /* Destination cell is full */
      o->Error = 1;
      o->Status = DATAQ__DESTFULL;
      return;
    }

    sts = gdh_ObjidToName(o->DataParent, name, sizeof(name), cdh_mName_volumeStrict);
    if (EVEN(sts)) {
      o->Error = 1;
      o->Status = DATAQ__PARENT;
      return;
    }
    if (name[strlen(name)-1] != ':')
      strcat(name, "-");
    if (strchr(o->DataName, '%')) {
      snprintf(&name[strlen(name)], sizeof(name), o->DataName, o->NameIdx);
      o->NameIdx++;
    } else {
      snprintf(&name[strlen(name)], sizeof(name), "%s%d", o->DataName, o->NameIdx); 
    }
    sts = gdh_CreateObject(name, o->DataClass, 0, &oid, pwr_cNOid, 0, 
	pwr_cNOid);
    if (EVEN(sts)) {
      o->Error = 1;
      o->Status = sts;
      return;
    }

    pwr_tAttrRef aref = cdh_ObjidToAref(oid);
    sts = gdh_DLRefObjectInfoAttrref(&aref, (pwr_tAddress*)&data_p, &dlid);
    if (EVEN(sts)) {
      o->Error = 1;
      o->Status = sts;
      return;
    }
    o->Status = DATAQ__SUCCESS;

    o->Data.Data.Ptr = data_p;
    o->Data.Data.Aref = aref;
    o->Data.Dlid = dlid;
    o->Transport = 1;
  }
  o->OldCreate = *o->CreateP;
}
