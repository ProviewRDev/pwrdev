/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*************************************************************************
*
* 	PROGRAM		dataq_backup
*
*       Modifierad
*		960205	Claes Sjöfors	Skapad
*		230105	Claes Sjöfors	Converted to DataQ
*
*	Funktion:	Backup av DataQ objekt och data objekt.
**************************************************************************/

/*_Include filer_________________________________________________________*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "pwr_dataqclasses.h"

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"
#include "rt_gdh.h"

#include "rt_gdh_msg.h"
#include "rt_hash_msg.h"
#include "rt_ini_event.h"
#include "rs_dataq_msg.h"
#include "rt_qcom_msg.h"
#include "dataq_backup.h"

/* Global functions________________________________________________________*/

#define LogAndExit(status)                                                     \
  {                                                                            \
    errh_CErrLog(DATAQ__BCKEXIT, errh_ErrArgMsg(status), NULL);                 \
    exit(status);                                                              \
  }

#define LogAndReturn(status1, status2)                                         \
  {                                                                            \
    errh_CErrLog(status1, errh_ErrArgMsg(status2), NULL);                      \
    return status2;                                                            \
  }

#define Log(status1, status2)                                                  \
  {                                                                            \
    errh_CErrLog(status1, errh_ErrArgMsg(status2), NULL);                      \
  }

typedef struct qbck_clist_tag {
  pwr_tOid objid;
  pwr_tCid class;
  char* buffer;
  int buffer_size;
  char* objectp;
  unsigned int object_size;
  struct qbck_clist_tag* next_ptr;
} qbck_tCList;

typedef struct qbck_data_tag {
  pwr_tOid objid;
  pwr_tOid old_objid;
  pwr_tCid class;
  int size;
  char data_name[120];
  char* data_ptr;
  gdh_tDlid data_subid;
  unsigned int found;
  unsigned int new;
  unsigned int created;
  struct qbck_data_tag* next_ptr;
  struct qbck_data_tag* prev_ptr;
} qbck_tDataList;

typedef struct qbck_queue_tag {
  pwr_tOid objid;
  pwr_tCid class;
  pwr_sClass_DataQ* queue;
  gdh_tDlid subid;
  int size;
  int backup_now;
  struct qbck_queue_tag* next_ptr;
} qbck_tDataQList;

typedef struct {
  int DataQObjectCount;
  int DataObjectCount;
  pwr_tUInt32 LoopCount;
  pwr_sClass_DataQBackupConfig* bckconfig;
  gdh_tDlid bckconfig_dlid;
  qbck_tDataQList* queuelist;
  int queue_count;
  qbck_tDataList* data_list;
  int init_done;
  char* buffer;
  int buffer_size;
  int queuelist_size;
  FILE* bckfile1;
  FILE* bckfile2;
  int file1_pos;
  int file2_pos;
  int file_num;
  int increment;
  int record_count;
} * qbck_tCtx;

static pwr_tCid qbck_qcidlist[] = {
  pwr_cClass_DataQ1,
  pwr_cClass_DataQ30
};

static pwr_tStatus qbck_data_handler(qbck_tCtx bckctx);
static pwr_tStatus qbck_set_queue_backup_done();
static pwr_tStatus qbck_data_db_delete(
    qbck_tDataList** data_list, qbck_tDataList* data_ptr);
static pwr_tStatus qbck_data_db_create(
    qbck_tCtx bckctx, pwr_tOid objid, qbck_tDataList** datalist_ptr);
static pwr_tStatus qbck_data_db_find(qbck_tDataList* data_list,
    pwr_tOid objid, qbck_tDataList** datalist_ptr);
static pwr_tStatus qbck_queuelist_add(qbck_tCtx bckctx, pwr_tOid objid,
    qbck_tDataQList** queuelist, int* queuelist_count);
static pwr_tStatus qbck_get_bckconfig(qbck_tCtx bckctx);
static pwr_tStatus qbck_queue_init(qbck_tCtx bckctx);
static pwr_tStatus qbck_get_queuebuffer(qbck_tCtx bckctx);
static pwr_tStatus qbck_fill_buffer(qbck_tCtx bckctx);
static pwr_tStatus qbck_write_queues(qbck_tCtx bckctx, FILE* bckfile);
static pwr_tStatus qbck_write_data(qbck_tCtx bckctx, FILE* bckfile);
static pwr_tStatus qbck_read(qbck_tCtx bckctx, char* backupfile);
static pwr_tStatus qbck_queue_handler(qbck_tCtx bckctx);
static pwr_tStatus qbck_free(qbck_tCtx bckctx);

/*************************************************************************
*
* Name:		qbck_fgetname()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Get filename for a filedescriptor.
*	This function is not implementet on all os, therefor a defaultname
*	should be supplied which is returned for this os.
*
**************************************************************************/
static char* qbck_fgetname(FILE* fp, char* name, char* def_name)
{
  strcpy(name, def_name);
  return name;
}

/*************************************************************************
*
* Name:		qbck_get_filename
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Backup of data objects.
*
**************************************************************************/
int qbck_get_filename(char* inname, char* outname, char* ext)
{
  char* s;
  char* s2;

  dcli_translate_filename(outname, inname);

  /* Look for extention in filename */
  if (ext != NULL) {
    s = strrchr(outname, ':');
    if (s == 0)
      s = outname;

    s2 = strrchr(s, '>');
    if (s2 == 0) {
      s2 = strrchr(s, ']');
      if (s2 == 0)
        s2 = s;
    }

    s = strrchr(s2, '.');
    if (s != 0)
      *s = 0;
    strcat(outname, ext);
  }
  dcli_translate_filename(outname, outname);
  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_data_handler
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Backup of data objects.
*
**************************************************************************/

static pwr_tStatus qbck_data_handler(qbck_tCtx bckctx)
{
  qbck_tDataList* data_ptr;
  qbck_tDataList* next_ptr;
  pwr_tStatus sts;
  int data_count;
  int offset;
  int i, k;
  qbck_tQueueHeader* queueheader;

  /* Reset the found and new flag in all data entries */
  data_ptr = bckctx->data_list;
  while (data_ptr != NULL) {
    data_ptr->found = 0;
    data_ptr = data_ptr->next_ptr;
  }

  /* Loop trough the queues to identify the new ones */
  offset = 0;
  for (i = 0; i < bckctx->queue_count; i++) {
    queueheader = (qbck_tQueueHeader*)(bckctx->buffer + offset);
    offset += sizeof(*queueheader);
    switch (queueheader->class) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ30: {
      pwr_sClass_DataQ1* queue_ptr;
      pwr_sClass_DataQBus* data_block_ptr;

      queue_ptr = (pwr_sClass_DataQ1*)(bckctx->buffer + offset);
      data_block_ptr = &queue_ptr->Data[0];
      for (k = 0; k < queue_ptr->DataSize; k++) {
        /* Check if the objid already is in the data_db */
        sts = qbck_data_db_find(
            bckctx->data_list, data_block_ptr->Data.Aref.Objid, &data_ptr);
        if (ODD(sts))
          data_ptr->found = 1;
        else {
          /* New data object, insert it */
          sts = qbck_data_db_create(
              bckctx, data_block_ptr->Data.Aref.Objid, &data_ptr);
          if (EVEN(sts))
            return sts;
          data_ptr->found = 1;
          data_ptr->new = 1;
        }
        data_block_ptr++;
      }
      break;
    }
#if 0
    case pwr_cClass_NMpsMirrorCell: {
      pwr_sClass_NMpsMirrorCell* cell_ptr;
      plc_t_DataInfoMirDataQ* data_block_ptr;

      cell_ptr = (pwr_sClass_NMpsMirrorCell*)(bckctx->buffer + offset);
      data_block_ptr = (plc_t_DataInfoMirDataQ*)&cell_ptr->Data1P;
      for (k = 0; k < cell_ptr->Intern.LastIndex; k++) {
        /* Check if the objid already is in the data_db */
        sts = qbck_data_db_find(
            bckctx->data_list, data_block_ptr->DataP.Aref.Objid, &data_ptr);
        if (ODD(sts))
          data_ptr->found = 1;
        else {
          /* New data object, insert it */
          sts = qbck_data_db_create(
              bckctx, data_block_ptr->DataP.Aref.Objid, &data_ptr);
          if (EVEN(sts)) {
            /* The object does not exist... */
            continue;
          }
          data_ptr->found = 1;
          data_ptr->new = 1;
        }
        data_block_ptr++;
      }
      break;
    }
#endif
    }
    offset += queueheader->size;
  }

  /* Remove data objects not found in a cell */
  data_count = 0;
  data_ptr = bckctx->data_list;
  while (data_ptr != NULL) {
    if (!data_ptr->found) {
      /* Remove subscriptions */
      sts = gdh_DLUnrefObjectInfo(data_ptr->data_subid);
      if (EVEN(sts))
        Log(DATAQ__MIRUNREF, sts);

      /* Delete the data entry */
      next_ptr = data_ptr->next_ptr;
      sts = qbck_data_db_delete(&bckctx->data_list, data_ptr);
      data_ptr = next_ptr;
      continue;
    } else
      data_count++;
    data_ptr = data_ptr->next_ptr;
  }
  bckctx->bckconfig->DataCount = data_count;
  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qbck_data_db_delete()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Delete an entry in the datalist.
*
**************************************************************************/
static pwr_tStatus qbck_data_db_delete(
    qbck_tDataList** data_list, qbck_tDataList* data_ptr)
{
  if (data_ptr == *data_list) {
    /* Change the root */
    *data_list = data_ptr->next_ptr;
    if (*data_list)
      (*data_list)->prev_ptr = 0;
  }

  if (data_ptr->prev_ptr)
    data_ptr->prev_ptr->next_ptr = data_ptr->next_ptr;
  if (data_ptr->next_ptr)
    data_ptr->next_ptr->prev_ptr = data_ptr->prev_ptr;

  free(data_ptr);

  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qbck_data_db_create()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Create an entry in the datalist for an objid.
*
**************************************************************************/
static pwr_tStatus qbck_data_db_create(
    qbck_tCtx bckctx, pwr_tOid objid, qbck_tDataList** datalist_ptr)
{
  qbck_tDataList* next_ptr;
  pwr_tStatus sts;
  pwr_sAttrRef attrref;
  pwr_tCid class;
  unsigned int size;
  pwr_tOName data_name;
  char* data_ptr;
  gdh_tDlid data_subid;

  sts = gdh_GetObjectClass(objid, &class);
  if (EVEN(sts))
    LogAndReturn(DATAQ__BCKDATA, sts);
  sts = gdh_GetObjectSize(objid, &size);
  if (EVEN(sts))
    LogAndReturn(DATAQ__BCKDATA, sts);
  sts = gdh_ObjidToName(
      objid, data_name, sizeof(data_name), cdh_mName_volumeStrict);
  if (EVEN(sts))
    LogAndReturn(DATAQ__BCKDATA, sts);

  /* Get a direct link to the object */
  attrref = cdh_ObjidToAref(objid);
  sts = gdh_DLRefObjectInfoAttrref(
      &attrref, (pwr_tAddress*)&data_ptr, &data_subid);
  if (EVEN(sts))
    LogAndReturn(DATAQ__BCKDATA, sts);

  *datalist_ptr = calloc(1, sizeof(qbck_tDataList));
  if (*datalist_ptr == 0)
    return DATAQ__NOMEMORY;

  /* Insert first in list */
  next_ptr = bckctx->data_list;
  if (next_ptr != NULL)
    next_ptr->prev_ptr = *datalist_ptr;
  (*datalist_ptr)->next_ptr = next_ptr;

  bckctx->data_list = *datalist_ptr;

  (*datalist_ptr)->objid = objid;
  (*datalist_ptr)->class = class;
  (*datalist_ptr)->size = size;
  strcpy((*datalist_ptr)->data_name, data_name);
  (*datalist_ptr)->data_ptr = data_ptr;
  (*datalist_ptr)->data_subid = data_subid;

  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qbck_data_db_find()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Find an entry in the datalist for an objid.
*
**************************************************************************/
static pwr_tStatus qbck_data_db_find(qbck_tDataList* data_list,
    pwr_tOid objid, qbck_tDataList** datalist_ptr)
{
  qbck_tDataList* data_ptr;
  int found;

  /* Insert first in list */
  found = 0;
  data_ptr = data_list;
  while (data_ptr != NULL) {
    if (cdh_ObjidIsEqual(data_ptr->objid, objid)) {
      *datalist_ptr = data_ptr;
      found = 1;
      break;
    }
    data_ptr = data_ptr->next_ptr;
  }

  if (!found)
    return DATAQ__DATANOTFOUND;

  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qbck_data_db_find_old()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Find an entry in the datalist for an old objid.
*
**************************************************************************/
static pwr_tStatus qbck_data_db_find_old(qbck_tDataList* data_list,
    pwr_tOid old_objid, qbck_tDataList** datalist_ptr)
{
  qbck_tDataList* data_ptr;
  int found;

  /* Insert first in list */
  found = 0;
  data_ptr = data_list;
  while (data_ptr != NULL) {
    if (cdh_ObjidIsEqual(data_ptr->old_objid, old_objid)) {
      *datalist_ptr = data_ptr;
      found = 1;
      break;
    }
    data_ptr = data_ptr->next_ptr;
  }

  if (!found)
    return DATAQ__DATANOTFOUND;

  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qbck_data_db_create()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Create an entry in the datalist for an objid.
*
**************************************************************************/
static pwr_tStatus qbck_clist_store(
    qbck_tCList** clist, pwr_tOid objid, qbck_tCList** clist_ptr)
{
  *clist_ptr = calloc(1, sizeof(qbck_tCList));
  if (clist_ptr == 0)
    return DATAQ__NOMEMORY;

  /* Insert first in list */
  (*clist_ptr)->next_ptr = *clist;

  *clist = *clist_ptr;
  (*clist_ptr)->objid = objid;
  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qbck_clist_find()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Find an entry in clist.
*
**************************************************************************/
static pwr_tStatus qbck_clist_find(
    qbck_tCList* clist, pwr_tOid objid, qbck_tCList** clist_ptr)
{
  while (clist != NULL) {
    if (cdh_ObjidIsEqual(clist->objid, objid)) {
      *clist_ptr = clist;
      return DATAQ__SUCCESS;
    }
    clist = clist->next_ptr;
  }
  return DATAQ__DATANOTFOUND;
}

/****************************************************************************
* Name:		qbck_clist_free()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Free the clist.
*
**************************************************************************/
static pwr_tStatus qbck_clist_free(qbck_tCList* clist)
{
  qbck_tCList* clist_ptr;

  while (clist != NULL) {
    clist_ptr = clist;
    clist = clist->next_ptr;
    if (clist_ptr->buffer)
      free(clist_ptr->buffer);
    free(clist_ptr);
  }
  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qbck_queuelist_add()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Add a queue to the queuelist
*
**************************************************************************/
static pwr_tStatus qbck_queuelist_add(qbck_tCtx bckctx, pwr_tOid objid,
    qbck_tDataQList** queuelist, int* queuelist_count)
{
  qbck_tDataQList* queuelist_ptr;
  pwr_sAttrRef attrref;
  pwr_tStatus sts;
  pwr_tCid class;
  char* objectp;

  sts = gdh_GetObjectClass(objid, &class);
  if (EVEN(sts))
    LogAndReturn(DATAQ__BCKQUEUE, sts);

  sts = gdh_ObjidToPointer(objid, (pwr_tAddress*)&objectp);
  if (EVEN(sts))
    LogAndReturn(DATAQ__BCKQUEUE, sts);

  /* Check if backup should be done on this queue */
  switch (class) {
  case pwr_cClass_DataQ1:
  case pwr_cClass_DataQ30:
    if (!(((pwr_sClass_DataQ*)objectp)->Config.Options & pwr_mDataQOptionsMask_Backup))
      return DATAQ__SUCCESS;
    break;
#if 0
  case pwr_cClass_NMpsMirrorCell:
    if (!(((pwr_sClass_NMpsMirrorCell*)objectp)->Config.Function
            & NMPS_CELLFUNC_BACKUP))
      return DATAQ__SUCCESS;
    break;
#endif
  default:
    return DATAQ__SUCCESS;
  }

  queuelist_ptr = calloc(1, sizeof(qbck_tDataQList));
  if (queuelist_ptr == 0)
    return DATAQ__NOMEMORY;

  /* Insert first in list */
  queuelist_ptr->next_ptr = *queuelist;
  *queuelist = queuelist_ptr;

  queuelist_ptr->objid = objid;
  queuelist_ptr->class = class;

  /* Direct link to the queue */
  attrref = cdh_ObjidToAref(objid);
  sts = gdh_DLRefObjectInfoAttrref(
      &attrref, (pwr_tAddress*)&queuelist_ptr->queue, &queuelist_ptr->subid);
  if (EVEN(sts))
    LogAndReturn(DATAQ__BCKQUEUE, sts);

  switch (queuelist_ptr->class) {
  case pwr_cClass_DataQ1:
  case pwr_cClass_DataQ30:
    queuelist_ptr->size
        = (char*)&(((pwr_sClass_DataQ1*)(queuelist_ptr->queue))->Data[0])
        - (char*)(queuelist_ptr->queue)
        + ((pwr_sClass_DataQ*)(queuelist_ptr->queue))->Config.MaxSize
            * sizeof(pwr_sClass_DataQBus);
    break;
#if 0
  case pwr_cClass_NMpsMirrorCell:
    cellist_ptr->size
        = (char*)&(((pwr_sClass_NMpsMirrorCell*)(cellist_ptr->cell))->Data1P)
        - (char*)(cellist_ptr->cell)
        + ((pwr_sClass_NMpsMirrorCell*)(cellist_ptr->cell))->MaxSize
            * sizeof(plc_t_DataInfoMirDataQ);
    break;
#endif
  }

  (*queuelist_count)++;
  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_get_bckconfig
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Hämta pekare till backup konfig objektet.
*
**************************************************************************/

static pwr_tStatus qbck_get_bckconfig(qbck_tCtx bckctx)
{
  pwr_tStatus sts;
  pwr_tOid objid;
  pwr_sAttrRef attrref;

  /* Get pointer to the bckconfig object */
  sts = gdh_GetClassList(pwr_cClass_DataQBackupConfig, &objid);
  if (EVEN(sts))
    return DATAQ__BCKCONFIG;

  /* Direct link to the queue */
  attrref = cdh_ObjidToAref(objid);
  sts = gdh_DLRefObjectInfoAttrref(
      &attrref, (pwr_tAddress*)&bckctx->bckconfig, &bckctx->bckconfig_dlid);
  if (EVEN(sts))
    return sts;
  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_queue_init
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Initiering av queue funktionen.
*
**************************************************************************/

static pwr_tStatus qbck_queue_init(qbck_tCtx bckctx)
{
  pwr_tStatus sts;
  pwr_tOid objid;
  int i;

  bckctx->init_done = 1;

  /* Get the queue objects on this node */
  for (i = 0; i < sizeof(qbck_qcidlist)/sizeof(qbck_qcidlist[0]); i++) {
    sts = gdh_GetClassList(qbck_qcidlist[i], &objid);
    while (ODD(sts)) {
      /* Store and direct link the queues */
      sts = qbck_queuelist_add(
          bckctx, objid, &bckctx->queuelist, &bckctx->queue_count);
      if (EVEN(sts))
	return sts;

      sts = gdh_GetNextObject(objid, &objid);
    }
  }

  /* Get the mirror queue objects on this node */
#if 0
  sts = gdh_GetClassList(pwr_cClass_NMpsMirrorCell, &objid);
  while (ODD(sts)) {
    /* Store and direct link the cells */
    sts = qbck_cellist_add(
        bckctx, objid, &bckctx->cellist, &bckctx->cell_count);
    if (EVEN(sts))
      return sts;

    sts = gdh_GetNextObject(objid, &objid);
  }
#endif

  bckctx->bckconfig->QueueCount = bckctx->queue_count;

  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_queue_handler
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Mirroring.
*
**************************************************************************/

static pwr_tStatus qbck_get_queuebuffer(qbck_tCtx bckctx)
{
  char* old_buffer;
  char old_buffer_size;
  int size;
  qbck_tDataQList* queue_ptr;

  old_buffer = bckctx->buffer;
  old_buffer_size = bckctx->buffer_size;

  /* Allocate the local queue buffer */
  size = 0;
  queue_ptr = bckctx->queuelist;
  while (queue_ptr) {
    size += sizeof(qbck_tQueueHeader);
    size += queue_ptr->size;
    queue_ptr = queue_ptr->next_ptr;
  }
  bckctx->buffer = calloc(1, size);
  if (bckctx->buffer == 0)
    return DATAQ__NOMEMORY;
  bckctx->buffer_size = size;

  /* Copy and free old buffer if there is one */
  if (old_buffer != 0 && old_buffer_size != 0) {
    memcpy(bckctx->buffer, old_buffer, old_buffer_size);
    free(old_buffer);
  }
  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_fill_buffer
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Fill the local buffer of queue objects.
*
**************************************************************************/

static pwr_tStatus qbck_fill_buffer(qbck_tCtx bckctx)
{
  pwr_tStatus sts;
  qbck_tDataQList* queue_ptr;
  qbck_tQueueHeader queueheader;
  int offset;

  /* Copy queues into local area */
  offset = 0;
  queue_ptr = bckctx->queuelist;
  while (queue_ptr) {
    strcpy(queueheader.type, HEADERTYPE_QUEUE);
    queueheader.objid = queue_ptr->objid;
    queueheader.class = queue_ptr->class;
    queueheader.size = queue_ptr->size;

    /* Check that there is size enough */
    if (offset + (int)sizeof(queueheader) + queueheader.size
        > bckctx->buffer_size) {
      sts = qbck_get_queuebuffer(bckctx);
      if (EVEN(sts))
        return sts;
    }

    memcpy(bckctx->buffer + offset, &queueheader, sizeof(queueheader));
    offset += sizeof(queueheader);
    memcpy(bckctx->buffer + offset, queue_ptr->queue, queueheader.size);
    offset += queueheader.size;

    queue_ptr = queue_ptr->next_ptr;
  }
  bckctx->queuelist_size = offset;

  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_write_queues
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Write the queue objects in the local buffer on file.
*
**************************************************************************/

static pwr_tStatus qbck_write_queues(qbck_tCtx bckctx, FILE* bckfile)
{
  qbck_tQueueHeader queueheader;
  qbck_tQueueHeader* queueheader_ptr;
  pwr_tUInt32 csts;
  int offset;
  qbck_tDataQList* queue_ptr;

  if (bckctx->increment) {
    /* Write only queues with backup_now flag */
    offset = 0;
    queue_ptr = bckctx->queuelist;
    while (queue_ptr) {
      queueheader_ptr = (qbck_tQueueHeader*)(bckctx->buffer + offset);
      if (queue_ptr->backup_now) {
        csts = fwrite(queueheader_ptr,
            sizeof(*queueheader_ptr) + queueheader_ptr->size, 1, bckfile);
        if (csts == 0)
          return csts;
        queue_ptr->backup_now = 0;
      }
      offset += sizeof(*queueheader_ptr) + queueheader_ptr->size;
      queue_ptr = queue_ptr->next_ptr;
    }
  } else {
    /* Write the whole buffer */
    if (bckctx->queuelist_size > 0) {
      csts = fwrite(bckctx->buffer, bckctx->queuelist_size, 1, bckfile);
      if (csts == 0)
        return csts;
    }

    /* Reset backup_now flag */
    queue_ptr = bckctx->queuelist;
    while (queue_ptr) {
      queue_ptr->backup_now = 0;
      queue_ptr = queue_ptr->next_ptr;
    }
  }
  strcpy(queueheader.type, HEADERTYPE_QUEUEEND);
  csts = fwrite(&queueheader, sizeof(queueheader), 1, bckfile);
  if (csts == 0)
    return csts;

  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_write_data
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Write the data objects in the local buffer on file.
*
**************************************************************************/

static pwr_tStatus qbck_write_data(qbck_tCtx bckctx, FILE* bckfile)
{
  qbck_tDataHeader dataheader;
  pwr_tUInt32 csts;
  qbck_tDataList* data_ptr;

  data_ptr = bckctx->data_list;
  while (data_ptr != NULL) {
    if (!bckctx->increment || data_ptr->new) {
      strcpy(dataheader.type, HEADERTYPE_DATA);
      dataheader.objid = data_ptr->objid;
      strcpy(dataheader.data_name, data_ptr->data_name);
      dataheader.class = data_ptr->class;
      dataheader.size = data_ptr->size;

      csts = fwrite(&dataheader, sizeof(dataheader), 1, bckfile);
      if (csts == 0)
        return csts;
      csts = fwrite(data_ptr->data_ptr, data_ptr->size, 1, bckfile);
      if (csts == 0)
        return csts;

      data_ptr->found = 0;
      data_ptr->new = 0;
    }
    data_ptr = data_ptr->next_ptr;
  }

  strcpy(dataheader.type, HEADERTYPE_DATAEND);
  csts = fwrite(&dataheader, sizeof(dataheader), 1, bckfile);
  if (csts == 0)
    return csts;

  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_open_file
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Open current backup file and write a file header.
*
**************************************************************************/

static pwr_tStatus qbck_open_file(qbck_tCtx bckctx)
{
  qbck_tFileHeader fileheader;
  pwr_tUInt32 csts;
  pwr_tFileName filename;
  float reopen_time = 10;
  int first_time;
  int wait_some_time;

  if (bckctx->file_num == 1) {
    if (bckctx->bckfile1 != 0) {
      /* Write error has occured */
      first_time = 0;
      bckctx->bckconfig->File1WriteErrorCount++;
      qbck_fgetname(bckctx->bckfile1, filename, "");
      errh_CErrLog(DATAQ__BCKWRITE, errh_ErrArgAF(filename), NULL);
      fclose(bckctx->bckfile1);
      wait_some_time = 1;
    } else {
      first_time = 1;
      wait_some_time = 0;
    }

    for (;;) {
      if (wait_some_time)
        time_Sleep(reopen_time);
      else
        wait_some_time = 1;

      /* Work with file 1 */
      /* Open file */
      qbck_get_filename(
          bckctx->bckconfig->BackupFile, filename, QBCK_FILE_EXT1);

      bckctx->bckfile1 = fopen(filename, "w+");
      if (bckctx->bckfile1 != NULL) {
        /* Write a file header */
        time_GetTime(&fileheader.creationtime);
        fileheader.version = QBCK_FILEVERSION;
        csts = fwrite(&fileheader, sizeof(fileheader), 1, bckctx->bckfile1);
        if (csts != 0) {
          /* File 1 is open */
          bckctx->bckconfig->File1OpenCount++;
          qbck_fgetname(bckctx->bckfile1, filename, "");
          errh_CErrLog(DATAQ__BCKFILEOPEN, errh_ErrArgAF(filename), NULL);
          if (first_time)
            return DATAQ__SUCCESS;
          else
            return DATAQ__FILEREOPEN;
        }
        fclose(bckctx->bckfile1);
      }
    }
  } else {
    if (bckctx->bckfile2 != 0) {
      /* Write error has occured */
      first_time = 0;
      bckctx->bckconfig->File2WriteErrorCount++;
      qbck_fgetname(bckctx->bckfile2, filename, "");
      errh_CErrLog(DATAQ__BCKWRITE, errh_ErrArgAF(filename), NULL);
      fclose(bckctx->bckfile2);
      wait_some_time = 1;
    } else {
      first_time = 1;
      wait_some_time = 0;
    }

    for (;;) {
      if (wait_some_time)
        time_Sleep(reopen_time);
      else
        wait_some_time = 1;

      /* Work with file 2 */
      /* Open file */
      qbck_get_filename(
          bckctx->bckconfig->BackupFile, filename, QBCK_FILE_EXT2);

      bckctx->bckfile2 = fopen(filename, "w+");
      if (bckctx->bckfile2 != NULL) {
        /* Write a file header */
        time_GetTime(&fileheader.creationtime);
        fileheader.version = QBCK_FILEVERSION;
        csts = fwrite(&fileheader, sizeof(fileheader), 1, bckctx->bckfile2);
        if (csts != 0) {
          /* File 2 is open */
          bckctx->bckconfig->File2OpenCount++;
          qbck_fgetname(bckctx->bckfile2, filename, "");
          errh_CErrLog(DATAQ__BCKFILEOPEN, errh_ErrArgAF(filename), NULL);
          if (first_time)
            return DATAQ__SUCCESS;
          else
            return DATAQ__FILEREOPEN;
        }
        fclose(bckctx->bckfile2);
      }
    }
  }
}

/*************************************************************************
*
* Name:		qbck_write
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Write the nmps objects in the backup file.
*
**************************************************************************/

static pwr_tStatus qbck_write(qbck_tCtx bckctx)
{
  pwr_tStatus sts;
  qbck_tRecordHeader recordheader;
  pwr_tUInt32 csts;
  long int actpos;
  FILE* bckfile;

  if (!bckctx->bckconfig->BackupOn)
    return DATAQ__SUCCESS;

  if ((bckctx->file_num == 1 && bckctx->bckfile1 == 0)
      || (bckctx->file_num == 2 && bckctx->bckfile2 == 0))
    /* This is the first time, open the file */
    sts = qbck_open_file(bckctx);

  if (bckctx->file_num == 1)
    bckfile = bckctx->bckfile1;
  else
    bckfile = bckctx->bckfile2;

  time_GetTime(&recordheader.time);
  strcpy(recordheader.type, HEADERTYPE_RECORDSTART);

  if (!bckctx->increment) {
    /* Start at the beginning of the file */
    actpos = ftell(bckfile);
    csts = fseek(bckfile, -actpos + sizeof(qbck_tFileHeader), 1);
    if (csts != 0)
      goto bck_write_error;
    bckctx->record_count = 0;
  } else {
    /* Go to the position of the last written record. */
    /* This is necessary in ELN (bugg or feature ?) */
    actpos = ftell(bckfile);
    if (bckctx->file_num == 1)
      csts = fseek(bckfile, -actpos + bckctx->file1_pos, 1);
    else
      csts = fseek(bckfile, -actpos + bckctx->file2_pos, 1);
    if (csts != 0)
      goto bck_write_error;
    bckctx->record_count++;
  }

  csts = fwrite(&recordheader, sizeof(recordheader), 1, bckfile);
  if (csts == 0)
    goto bck_write_error;

  /* Write the queue objects */
  csts = qbck_write_queues(bckctx, bckfile);
  if (csts == 0)
    goto bck_write_error;

  /* Write the data objects */
  csts = qbck_write_data(bckctx, bckfile);
  if (csts == 0)
    goto bck_write_error;

  /* Write record end header */
  time_GetTime(&recordheader.time);
  strcpy(recordheader.type, HEADERTYPE_RECORDEND);
  csts = fwrite(&recordheader, sizeof(recordheader), 1, bckfile);
  if (csts == 0)
    goto bck_write_error;

  /* Store current position */
  /* This is necessary in ELN (bugg or feature?) */
  if (bckctx->file_num == 1)
    bckctx->file1_pos = ftell(bckfile);
  else
    bckctx->file2_pos = ftell(bckfile);

  csts = fflush(bckfile);
  if (csts != 0)
    goto bck_write_error;

  if (bckctx->increment) {
    bckctx->bckconfig->IncrementLoopCount++;
    time_GetTime(&bckctx->bckconfig->LastIncrementBackup);
  } else {
    bckctx->bckconfig->FullLoopCount++;
    time_GetTime(&bckctx->bckconfig->LastFullBackup);
  }

  return DATAQ__SUCCESS;

bck_write_error:

  /* Some error has occured */
  sts = qbck_open_file(bckctx);
  return sts;
}

/*************************************************************************
*
* Name:		qbck_queues
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Read the queue objects from backup file.
*
**************************************************************************/

static int qbck_timecmp(pwr_tTime* time_old, pwr_tTime* time_new)
{
  int sts;

  sts = time_Acomp(time_new, time_old);
  if (sts >= 0)
    return 1;
  else
    return 0;
}

/*************************************************************************
*
* Name:		qbck_check_file
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Check the consistency of a backup file.
*
**************************************************************************/

static pwr_tStatus qbck_check_file(qbck_tCtx bckctx, FILE* bckfile,
    int* record_count, unsigned int* record_start, unsigned int* queuearea_start,
    unsigned int* dataarea_start, pwr_tTime* first_record_time,
    pwr_tTime* last_record_time, int time_only)
{
  qbck_tFileHeader fileheader;
  qbck_tRecordHeader recordheader;
  qbck_tRecordHeader recordheaderend;
  qbck_tQueueHeader queueheader;
  qbck_tDataHeader dataheader;
  pwr_tUInt32 csts;
  long int actpos;
  int queue_read_success;
  int data_read_success;

  actpos = ftell(bckfile);
  csts = fseek(bckfile, -actpos, 1);
  if (csts != 0)
    return DATAQ__FILEREAD;

  /* Read file header */
  csts = fread(&fileheader, sizeof(fileheader), 1, bckfile);
  if (csts == 0)
    return DATAQ__FILEREAD;

  /* Check version */
  if (fileheader.version != QBCK_FILEVERSION)
    return DATAQ__BCKVERSION;

  *record_count = 0;
  queue_read_success = 0;
  data_read_success = 0;
  for (;;) {
    /* Read record header */
    /* Store the start of the record */
    *record_start = ftell(bckfile);
    csts = fread(&recordheader, sizeof(recordheader), 1, bckfile);
    if (csts == 0)
      break;

    if (strcmp(recordheader.type, HEADERTYPE_RECORDSTART))
      break;
    if (!qbck_timecmp(&fileheader.creationtime, &recordheader.time))
      break;

    if (*record_count == 0) {
      memcpy(first_record_time, &recordheader.time, sizeof(recordheader.time));
      if (time_only)
        return DATAQ__SUCCESS;
    } else {
      if (!qbck_timecmp(first_record_time, &recordheader.time))
        break;
    }

    /* Read queue area */
    queue_read_success = 0;
    /* Store the start of the queue area */
    *queuearea_start = ftell(bckfile);
    for (;;) {
      csts = fread(&queueheader, sizeof(queueheader), 1, bckfile);
      if (csts == 0)
        break;

      if (!strcmp(queueheader.type, HEADERTYPE_QUEUEEND)) {
        /* End of queue area */
        queue_read_success = 1;
        break;
      } else if (strcmp(queueheader.type, HEADERTYPE_QUEUE))
        break;

      csts = fseek(bckfile, queueheader.size, 1);
      if (csts != 0)
        break;
    }

    if (!queue_read_success)
      break;

    /* Read data area */
    data_read_success = 0;
    /* Store the start of the data area */
    *dataarea_start = ftell(bckfile);
    for (;;) {
      csts = fread(&dataheader, sizeof(dataheader), 1, bckfile);
      if (csts == 0)
        break;

      if (!strcmp(dataheader.type, HEADERTYPE_DATAEND)) {
        /* End of data area */
        data_read_success = 1;
        break;
      } else if (strcmp(dataheader.type, HEADERTYPE_DATA))
        break;

      csts = fseek(bckfile, dataheader.size, 1);
      if (csts != 0)
        break;
    }

    if (!data_read_success)
      break;

    /* Read record header */
    csts = fread(&recordheaderend, sizeof(recordheaderend), 1, bckfile);
    if (csts == 0)
      break;

    if (strcmp(recordheaderend.type, HEADERTYPE_RECORDEND))
      break;

    if (!qbck_timecmp(&recordheader.time, &recordheaderend.time))
      break;

    (*record_count)++;
    record_start++;
    queuearea_start++;
    dataarea_start++;
  }

  if (*record_count == 0) {
    /* No valid record found */
    return DATAQ__BCKFILECORRUPT;
  }

  memcpy(last_record_time, &recordheader.time, sizeof(recordheader.time));

  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_read
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Read the queue objects from backup file.
*
**************************************************************************/

static pwr_tStatus qbck_read(qbck_tCtx bckctx, char* backupfile)
{
  pwr_tStatus sts;
  qbck_tQueueHeader queueheader;
  qbck_tDataHeader dataheader;
  FILE* bckfile;
  FILE* bckfile1;
  FILE* bckfile2;
  pwr_tUInt32 csts;
  long int actpos;
  int k;
  char* databuff = 0;
  int databuff_size = 0;
  qbck_tDataList* data_ptr;
  qbck_tDataList* next_ptr;
  char* objectp;
  pwr_tFileName filename;
  int file_num = 1;
  int record_count;
  pwr_tUInt32 queuearea_start[QBCK_MAX_RECORDS];
  pwr_tUInt32 dataarea_start[QBCK_MAX_RECORDS];
  pwr_tUInt32 record_start[QBCK_MAX_RECORDS];
  qbck_tCList* clist = 0;
  qbck_tCList* clist_ptr;
  int queue_read_success = 0;
  int data_read_success = 0;
  int i;
  pwr_tOid objid;
  int data_count;
  int created;
  pwr_tTime first_record_time;
  pwr_tTime last_record_time;
  pwr_tTime bckfile1_time;
  pwr_tTime bckfile2_time;
  pwr_tStatus bckfile1_sts;
  pwr_tStatus bckfile2_sts;
  int return_sts;

  /* Open file 1 */
  file_num = 1;
  bckfile1_sts = DATAQ__SUCCESS;
  qbck_get_filename(backupfile, filename, QBCK_FILE_EXT1);

  bckfile1 = fopen(filename, "r+");
  if (bckfile1 == NULL)
    bckfile1_sts = DATAQ__BCKOPEN;
  else {
    /* Get time of first record */
    bckfile1_sts = qbck_check_file(bckctx, bckfile1, &record_count,
        record_start, queuearea_start, dataarea_start, &bckfile1_time,
        &last_record_time, 1);
    if (EVEN(bckfile1_sts)) {
      Log(DATAQ__RELOAD_FILE1, bckfile1_sts);
      fclose(bckfile1);
    }
  }

  /* Open file 2 */
  file_num = 2;
  bckfile2_sts = DATAQ__SUCCESS;

  qbck_get_filename(backupfile, filename, QBCK_FILE_EXT2);

  bckfile2 = fopen(filename, "r+");
  if (bckfile2 == NULL)
    bckfile2_sts = DATAQ__BCKOPEN;
  else {
    /* Get time of first record */
    bckfile2_sts = qbck_check_file(bckctx, bckfile2, &record_count,
        record_start, queuearea_start, dataarea_start, &bckfile2_time,
        &last_record_time, 1);
    if (EVEN(bckfile2_sts)) {
      Log(DATAQ__RELOAD_FILE2, bckfile2_sts);
      fclose(bckfile2);
    }
  }

  if (ODD(bckfile1_sts) && ODD(bckfile2_sts)) {
    /* Both is ok so far */
    /* Compare time and choose the latest file */
    if (qbck_timecmp(&bckfile1_time, &bckfile2_time)) {
      /* Number 2 is the lastest, check consistency of file 2 */
      bckfile2_sts = qbck_check_file(bckctx, bckfile2, &record_count,
          record_start, queuearea_start, dataarea_start, &first_record_time,
          &last_record_time, 0);
      if (EVEN(bckfile2_sts)) {
        /* File number 2 is currupt, try file number 1 */
        Log(DATAQ__RELOAD_FILE2, bckfile2_sts);
        fclose(bckfile2);
        bckfile1_sts = qbck_check_file(bckctx, bckfile1, &record_count,
            record_start, queuearea_start, dataarea_start, &first_record_time,
            &last_record_time, 0);
        if (EVEN(bckfile1_sts)) {
          /* Both files are corrupt, log and return */
          Log(DATAQ__RELOAD_FILE1, bckfile1_sts);
          fclose(bckfile1);
          bckfile = 0;
          sts = DATAQ__RELOAD;
          goto qbck_read_abort;
        }
        /* File 1 is OK, read file 1 */
        bckfile = bckfile1;
      } else {
        /* File 2 is OK, read file 2 */
        bckfile = bckfile2;
        fclose(bckfile1);
      }
    } else {
      /* Number 1 is the lastest, check consistency of file 1 */
      bckfile1_sts = qbck_check_file(bckctx, bckfile1, &record_count,
          record_start, queuearea_start, dataarea_start, &first_record_time,
          &last_record_time, 0);
      if (EVEN(bckfile1_sts)) {
        /* File number 1 is currupt, try file number 2 */
        Log(DATAQ__RELOAD_FILE1, bckfile1_sts);
        fclose(bckfile1);
        bckfile2_sts = qbck_check_file(bckctx, bckfile2, &record_count,
            record_start, queuearea_start, dataarea_start, &first_record_time,
            &last_record_time, 0);
        if (EVEN(bckfile2_sts)) {
          /* Both files are corrupt, log and return */
          Log(DATAQ__RELOAD_FILE2, bckfile1_sts);
          fclose(bckfile2);
          bckfile = 0;
          sts = DATAQ__RELOAD;
          goto qbck_read_abort;
        }
        /* File 2 is OK, read file 2 */
        bckfile = bckfile2;
      } else {
        /* File 1 is OK, read file 1 */
        bckfile = bckfile1;
        fclose(bckfile2);
      }
    }
  } else if (ODD(bckfile1_sts)) {
    /* File 2 is currupt, go for file 1 */
    bckfile1_sts = qbck_check_file(bckctx, bckfile1, &record_count,
        record_start, queuearea_start, dataarea_start, &first_record_time,
        &last_record_time, 0);
    if (EVEN(bckfile1_sts)) {
      /* Both files are corrupt, log and return */
      Log(DATAQ__RELOAD_FILE1, bckfile1_sts);
      fclose(bckfile1);
      bckfile = 0;
      sts = DATAQ__RELOAD;
      goto qbck_read_abort;
    }
    /* File 1 is OK, read file 1 */
    bckfile = bckfile1;
  } else if (ODD(bckfile2_sts)) {
    /* File 1 is currupt, go for file2 */
    bckfile2_sts = qbck_check_file(bckctx, bckfile2, &record_count,
        record_start, queuearea_start, dataarea_start, &first_record_time,
        &last_record_time, 0);
    if (EVEN(bckfile2_sts)) {
      /* Both files are corrupt, log and return */
      Log(DATAQ__RELOAD_FILE2, bckfile2_sts);
      fclose(bckfile2);
      bckfile = 0;
      sts = DATAQ__RELOAD;
      goto qbck_read_abort;
    }
    /* File 2 is OK, read file 2 */
    bckfile = bckfile2;
  } else {
    /* Both files are corrupt, abort */
    if (bckfile2_sts != DATAQ__BCKOPEN)
      sts = bckfile2_sts;
    else
      sts = bckfile1_sts;
    bckfile = 0;
    goto qbck_read_abort;
  }

  qbck_fgetname(bckfile, filename, "");
  errh_CErrLog(DATAQ__RESTORING, errh_ErrArgAF(filename), NULL);

  /* Read dataareas records backwards */
  for (i = 0; i < record_count; i++) {
    /* Position on queue area on record */
    actpos = ftell(bckfile);
    csts = fseek(bckfile, dataarea_start[record_count - i - 1] - actpos, 1);
    if (csts != 0) {
      sts = DATAQ__FILEREAD;
      goto qbck_read_abort;
    }

    data_read_success = 0;
    for (;;) {
      csts = fread(&dataheader, sizeof(dataheader), 1, bckfile);
      if (csts == 0)
        break;

      if (!strcmp(dataheader.type, HEADERTYPE_DATAEND)) {
        /* End of data area */
        data_read_success = 1;
        break;
      }

      /* Allocate or increment the read buffer size */
      if (databuff == 0 || dataheader.size > databuff_size) {
        if (databuff)
          free(databuff);
        databuff = calloc(1, dataheader.size);
        if (databuff == 0) {
          sts = DATAQ__NOMEMORY;
          goto qbck_read_abort;
        }
        databuff_size = dataheader.size;
      }
      csts = fread(databuff, dataheader.size, 1, bckfile);
      if (csts == 0)
        break;

      /* Check if the objid already is in the data_db */
      sts = qbck_data_db_find_old(
          bckctx->data_list, dataheader.objid, &data_ptr);
      if (ODD(sts))
        continue;

      created = 1;
      sts = gdh_CreateObject(dataheader.data_name, dataheader.class, 0, &objid,
          pwr_cNObjid, 0, pwr_cNObjid);
      if (sts == GDH__DUPLNAME) {
        /* The object already exist, this might be a static object */
        sts = gdh_NameToObjid(dataheader.data_name, &objid);
        if (EVEN(sts)) {
          Log(DATAQ__RELOADCREA, sts);
          sts = DATAQ__RELOADCREA;
          goto qbck_read_abort;
        }
        created = 0;
      } else if (EVEN(sts)) {
        Log(DATAQ__RELOADCREA, sts);
        sts = DATAQ__RELOADCREA;
        goto qbck_read_abort;
      }

      /* Insert the object in the data list */
      sts = qbck_data_db_create(bckctx, objid, &data_ptr);
      if (EVEN(sts))
        goto qbck_read_abort;
      data_ptr->old_objid = dataheader.objid;
      data_ptr->new = 1;
      data_ptr->created = created;

      memcpy(
          data_ptr->data_ptr, databuff, MIN(dataheader.size, data_ptr->size));
    }
    if (!data_read_success)
      break;
  }

  if (databuff) {
    free(databuff);
    databuff = 0;
  }

  if (!data_read_success) {
    sts = DATAQ__FILEREAD;
    goto qbck_read_abort;
  }

  /* Read the queues backwards */
  for (i = 0; i < record_count; i++) {
    /* Position on queue area on record */
    actpos = ftell(bckfile);
    csts = fseek(bckfile, queuearea_start[record_count - i - 1] - actpos, 1);
    if (csts != 0) {
      sts = DATAQ__FILEREAD;
      goto qbck_read_abort;
    }

    queue_read_success = 0;
    for (;;) {
      csts = fread(&queueheader, sizeof(queueheader), 1, bckfile);
      if (csts == 0)
        break;

      if (!strcmp(queueheader.type, HEADERTYPE_QUEUEEND)) {
        /* End of data area */
        queue_read_success = 1;
        break;
      }

      sts = qbck_clist_find(clist, queueheader.objid, &clist_ptr);
      if (ODD(sts)) {
        /* This queue is already found */
        csts = fseek(bckfile, queueheader.size, 1);
        if (csts != 0)
          break;
        continue;
      }

      sts = qbck_clist_store(&clist, queueheader.objid, &clist_ptr);
      if (EVEN(sts))
        goto qbck_read_abort;

      clist_ptr->buffer = calloc(1, queueheader.size);
      if (clist_ptr->buffer == 0) {
        sts = DATAQ__NOMEMORY;
        goto qbck_read_abort;
      }
      clist_ptr->buffer_size = queueheader.size;
      clist_ptr->class = queueheader.class;

      sts = gdh_ObjidToPointer(
          clist_ptr->objid, (pwr_tAddress*)&clist_ptr->objectp);
      if (EVEN(sts)) {
        sts = DATAQ__RELOADINCONS;
        goto qbck_read_abort;
      }

      sts = gdh_GetObjectSize(clist_ptr->objid, &clist_ptr->object_size);
      if (EVEN(sts)) {
        sts = DATAQ__RELOADINCONS;
        goto qbck_read_abort;
      }

      csts = fread(clist_ptr->buffer, clist_ptr->buffer_size, 1, bckfile);
      if (csts == 0)
        break;

      switch (queueheader.class) {
      case pwr_cClass_DataQ1:
      case pwr_cClass_DataQ30: {
        pwr_sClass_DataQ1* queue_ptr;
        pwr_sClass_DataQ* object_ptr;
        pwr_sClass_DataQBus* data_block_ptr;

        queue_ptr = (pwr_sClass_DataQ1*)clist_ptr->buffer;
        object_ptr = (pwr_sClass_DataQ*)clist_ptr->objectp;
        data_block_ptr = &queue_ptr->Data[0];
        for (k = 0; k < queue_ptr->DataSize; k++) {
          /* Check if the objid already is in the data_db */
          sts = qbck_data_db_find_old(
              bckctx->data_list, data_block_ptr->Data.Aref.Objid, &data_ptr);
          if (EVEN(sts)) {
            sts = DATAQ__RELOADINCONS;
            goto qbck_read_abort;
          }
          /* Replace the objid */
          data_ptr->found = 1;
          data_block_ptr->Data.Aref.Objid = data_ptr->objid;
          /* Put NULL in pointer */
          data_block_ptr->Data.Ptr = NULL;
          data_block_ptr->Dlid = pwr_cNDlid;
          data_block_ptr++;
        }
        /* Replace DataLast and DataL */
        if (queue_ptr->DataSize > 0
            && cdh_ObjidIsNotNull(queue_ptr->Super.Trp.DataL.Data.Aref.Objid)) {
          sts = qbck_data_db_find_old(
              bckctx->data_list, queue_ptr->Super.Trp.DataL.Data.Aref.Objid, &data_ptr);
          if (EVEN(sts)) {
            sts = DATAQ__RELOADINCONS;
            goto qbck_read_abort;
          }
          /* Replace the objid */
          queue_ptr->Super.Trp.DataL.Data.Aref.Objid = data_ptr->objid;
          /* Put NULL in pointer */
          queue_ptr->Super.Trp.DataL.Data.Ptr = NULL;

#if 0
          sts = qbck_data_db_find_old(
              bckctx->data_list, queue_ptr->DataLastP.Aref.Objid, &data_ptr);
          if (EVEN(sts)) {
            sts = DATAQ__RELOADINCONS;
            goto qbck_read_abort;
          }
          /* Replace the objid */
          queue_ptr->DataLastP.Aref.Objid = data_ptr->objid;
          /* Put NULL in pointer */
          queue_ptr->DataLastP.Ptr = NULL;
#endif
        }

        /* Reset flags */
        queue_ptr->Super.Trp.InFlag = 0;
        queue_ptr->Super.Trp.OutFrontFlag = 0;
        queue_ptr->Super.Trp.OutRearFlag = 0;
        queue_ptr->Super.Control.Commit = 0;
        //queue_ptr->FrontNew = 0;
        //queue_ptr->RearNew = 0;
        queue_ptr->Super.Config.ResetObject = object_ptr->Config.ResetObject;
        //queue_ptr->Intern.ResetObjectP = object_ptr->Intern.ResetObjectP;
        break;
      }
#if 0
      case pwr_cClass_NMpsMirrorCell: {
        pwr_sClass_NMpsMirrorCell* cell_ptr;
        pwr_sClass_NMpsMirrorCell* object_ptr;
        plc_t_DataInfoMirDataQ* data_block_ptr;

        cell_ptr = (pwr_sClass_NMpsMirrorCell*)clist_ptr->buffer;
        object_ptr = (pwr_sClass_NMpsMirrorCell*)clist_ptr->objectp;
        data_block_ptr = (plc_t_DataInfoMirDataQ*)&cell_ptr->Data1P;
        for (k = 0; k < cell_ptr->LastIndex; k++) {
          /* Check if the objid already is in the data_db */
          sts = qbck_data_db_find_old(
              bckctx->data_list, data_block_ptr->DataP.Aref.Objid, &data_ptr);
          if (EVEN(sts)) {
            sts = DATAQ__RELOADINCONS;
            goto qbck_read_abort;
          }
          data_ptr->found = 1;
          data_block_ptr->DataP.Aref.Objid = data_ptr->objid;
          /* Put NULL in pointer */
          data_block_ptr->DataP.Ptr = NULL;
          data_block_ptr->Data_Dlid = pwr_cNDlid;
          data_block_ptr++;
        }
        /* Replace DataLast */
        if (cell_ptr->LastIndex > 0
            && cdh_ObjidIsNotNull(cell_ptr->DataLastP.Aref.Objid)) {
          sts = qbck_data_db_find_old(
              bckctx->data_list, cell_ptr->DataLastP.Aref.Objid, &data_ptr);
          if (EVEN(sts)) {
            sts = DATAQ__RELOADINCONS;
            goto qbck_read_abort;
          }
          /* Replace the objid */
          cell_ptr->DataLastP.Aref.Objid = data_ptr->objid;
          /* Put NULL in pointer */
          cell_ptr->DataLastP.Ptr = NULL;
        }
        /* Reset flags */
        object_ptr->TempLastIndex = cell_ptr->LastIndex;
        break;
      }
#endif
      }
    }
    if (!queue_read_success)
      break;
  }

  if (!queue_read_success) {
    sts = DATAQ__FILEREAD;
    goto qbck_read_abort;
  }

  /* Remove data objects that were not found in a queue */
  data_count = 0;
  data_ptr = bckctx->data_list;
  while (data_ptr != NULL) {
    if (!data_ptr->found) {
      /* Remove subscriptions */
      sts = gdh_DLUnrefObjectInfo(data_ptr->data_subid);
      if (EVEN(sts))
        Log(DATAQ__BCKUNREF, sts);

      /* Delete the data entry */
      next_ptr = data_ptr->next_ptr;
      objid = data_ptr->objid;
      created = data_ptr->created;
      sts = qbck_data_db_delete(&bckctx->data_list, data_ptr);
      if (created)
        sts = gdh_DeleteObject(objid);
      data_ptr = next_ptr;
      continue;
    } else
      data_count++;
    data_ptr = data_ptr->next_ptr;
  }
  bckctx->bckconfig->DataCount = data_count;

  /* Copy queue buffer into the queue object */
  clist_ptr = clist;
  while (clist_ptr != NULL) {
    /* Copy current function in queue object and reset reload bit */
    switch (clist_ptr->class) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ30:
      ((pwr_sClass_DataQ*)clist_ptr->buffer)->Intern.ReloadDone = 0;
      ((pwr_sClass_DataQ*)clist_ptr->buffer)->Intern.MirrorRestart = 1;
      ((pwr_sClass_DataQ*)clist_ptr->buffer)->Config.Function
          = ((pwr_sClass_DataQ*)clist_ptr->objectp)->Config.Function;
      ((pwr_sClass_DataQ*)clist_ptr->buffer)->Config.Options
          = ((pwr_sClass_DataQ*)clist_ptr->objectp)->Config.Options;
      memcpy(clist_ptr->objectp, clist_ptr->buffer,
          MIN((int)clist_ptr->object_size, clist_ptr->buffer_size));
      break;
#if 0
    case pwr_cClass_NMpsMirrorCell:
      /* Copy to temporary area for the mirror job to read */
      ptr = (char*)&((pwr_sClass_NMpsMirrorCell*)clist_ptr->buffer)->Data1P;
      memcpy(((pwr_sClass_NMpsMirrorCell*)(clist_ptr->objectp))->TempArea, ptr,
          ptr - clist_ptr->buffer);
      ((pwr_sClass_NMpsMirrorCell*)(clist_ptr->objectp))->Intern.ReloadDone
          = NMPS_CELL_RELOADDONE;
      ((pwr_sClass_NMpsMirrorCell*)(clist_ptr->objectp))->Intern.MirrorRestart = 1;
      break;
#endif
    }

    clist_ptr = clist_ptr->next_ptr;
  }

  /* Release new queues with backup function, by setting the
     backup done flag */
  for (i = 0; i < sizeof(qbck_qcidlist)/sizeof(qbck_qcidlist[0]); i++) {
    sts = gdh_GetClassList(qbck_qcidlist[i], &objid);
    while (ODD(sts)) {
      sts = qbck_clist_find(clist, queueheader.objid, &clist_ptr);
      if (EVEN(sts)) {
	sts = gdh_ObjidToPointer(objid, (pwr_tAddress*)&objectp);
	if (EVEN(sts)) {
	  qbck_set_queue_backup_done();
	  LogAndReturn(DATAQ__RESTOREERROR, sts);
	}

	if (((pwr_sClass_DataQ*)objectp)->Config.Options & pwr_mDataQOptionsMask_Backup) {
	  ((pwr_sClass_DataQ*)objectp)->Intern.ReloadDone = pwr_mDataQBackupMask_BackupLoaded;
	  ((pwr_sClass_DataQ*)objectp)->Intern.InitTime = 1;
	}
      }
      sts = gdh_GetNextObject(objid, &objid);
    }
  }
#if 0
  sts = gdh_GetClassList(pwr_cClass_NMpsMirrorCell, &objid);
  while (ODD(sts)) {
    sts = qbck_clist_find(clist, cellheader.objid, &clist_ptr);
    if (EVEN(sts)) {
      sts = gdh_ObjidToPointer(objid, (pwr_tAddress*)&objectp);
      if (EVEN(sts)) {
        qbck_set_cell_backup_done();
        LogAndReturn(DATAQ__RESTOREERROR, sts);
      }

      if (((pwr_sClass_NMpsMirrorCell*)objectp)->Config.Function
          & NMPS_CELLFUNC_BACKUP)
        ((pwr_sClass_NMpsMirrorCell*)objectp)->Intern.ReloadDone
            = pwr_mDataQBackupMask_BackupLoaded;
    }
    sts = gdh_GetNextObject(objid, &objid);
  }
#endif

  qbck_clist_free(clist);

  errh_CErrLog(DATAQ__RESTORED, NULL);
  fclose(bckfile);
  bckctx->bckconfig->ReloadFailure = 0;
  return DATAQ__SUCCESS;

qbck_read_abort:
  /* Abort reload and cleanup */
  return_sts = sts;
  Log(DATAQ__RESTOREABORT, return_sts);

  /* Remove data objects that were created */
  data_count = 0;
  data_ptr = bckctx->data_list;
  while (data_ptr != NULL) {
    /* Remove subscriptions */
    sts = gdh_DLUnrefObjectInfo(data_ptr->data_subid);
    if (data_ptr->created)
      sts = gdh_DeleteObject(data_ptr->objid);
    data_ptr = data_ptr->next_ptr;
  }

  data_ptr = bckctx->data_list;
  while (data_ptr != NULL) {
    next_ptr = data_ptr->next_ptr;
    sts = qbck_data_db_delete(&bckctx->data_list, data_ptr);
    data_ptr = next_ptr;
  }

  if (databuff)
    free(databuff);

  /* Release the queue objects by setting backup done flag */
  sts = qbck_set_queue_backup_done();
  if (EVEN(sts))
    return sts;

  qbck_clist_free(clist);
  if (bckfile != NULL)
    fclose(bckfile);
  bckctx->bckconfig->ReloadFailure = 1;

  return return_sts;
}

/*************************************************************************
*
* Name:		qbck_set_queue_backup_done
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Set backup done flag in all queue objects with backup function.
*
**************************************************************************/

static pwr_tStatus qbck_set_queue_backup_done()
{
  pwr_tStatus sts;
  pwr_tOid objid;
  char* objectp;
  int i;

  /* Release all queues with backup function, by setting the
     backup done flag */
  for (i = 0; i < sizeof(qbck_qcidlist)/sizeof(qbck_qcidlist[0]); i++) {
    sts = gdh_GetClassList(qbck_qcidlist[i], &objid);
    while (ODD(sts)) {
      sts = gdh_ObjidToPointer(objid, (pwr_tAddress*)&objectp);
      if (EVEN(sts))
	LogAndReturn(DATAQ__RESTOREERROR, sts);

      if (((pwr_sClass_DataQ*)objectp)->Config.Options & pwr_mDataQOptionsMask_Backup) {
	((pwr_sClass_DataQ*)objectp)->Intern.ReloadDone = pwr_mDataQBackupMask_BackupLoaded;
	((pwr_sClass_DataQ*)objectp)->Intern.InitTime = 1;
      }
      sts = gdh_GetNextObject(objid, &objid);
    }
  }
#if 0
  sts = gdh_GetClassList(pwr_cClass_NMpsMirrorCell, &objid);
  while (ODD(sts)) {
    sts = gdh_ObjidToPointer(objid, (pwr_tAddress*)&objectp);
    if (EVEN(sts))
      LogAndReturn(DATAQ__RESTOREERROR, sts);

    if (((pwr_sClass_NMpsMirrorCell*)objectp)->Config.Function & NMPS_CELLFUNC_BACKUP)
      ((pwr_sClass_NMpsMirrorCell*)objectp)->Intern.ReloadDone = pwr_mDataQBackupMask_BackupLoaded;
    sts = gdh_GetNextObject(objid, &objid);
  }
#endif
  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_queue_handler
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Mirroring.
*
**************************************************************************/

static pwr_tStatus qbck_queue_handler(qbck_tCtx bckctx)
{
  pwr_tStatus sts;
  qbck_tDataQList* queue_ptr;
  int backup_now;

  /* Loop through the queue objects */
  backup_now = 0;
  queue_ptr = bckctx->queuelist;
  while (queue_ptr) {
    switch (queue_ptr->class) {
    case pwr_cClass_DataQ1:
    case pwr_cClass_DataQ30:
      if (((pwr_sClass_DataQ*)(queue_ptr->queue))->Intern.BackupNow) {
        backup_now = 1;
        queue_ptr->backup_now = 1;
        ((pwr_sClass_DataQ*)(queue_ptr->queue))->Intern.BackupNow = 0;
      }
      break;
#if 0
    case pwr_cClass_NMpsMirrorCell:
      if (((pwr_sClass_NMpsMirrorCell*)(cell_ptr->cell))->Intern.BackupNow) {
        backup_now = 1;
        cell_ptr->backup_now = 1;
        ((pwr_sClass_NMpsMirrorCell*)(cell_ptr->cell))->Intern.BackupNow = 0;
      }
      break;
#endif
    }
    queue_ptr = queue_ptr->next_ptr;
  }
  if (backup_now || !bckctx->increment) {
    sts = qbck_fill_buffer(bckctx);
    if (EVEN(sts))
      return sts;

    /* Update the data list */
    sts = qbck_data_handler(bckctx);
    if (EVEN(sts))
      return sts;

    sts = qbck_write(bckctx);
    if (EVEN(sts))
      return sts;
  }
  return DATAQ__SUCCESS;
}

/****************************************************************************
* Name:		qbck_free()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Free the bck context.
*
**************************************************************************/
static pwr_tStatus qbck_free(qbck_tCtx bckctx)
{
  qbck_tDataList* data_ptr;
  qbck_tDataList* next_ptr;

  /* Free the object database */
  data_ptr = bckctx->data_list;
  gdh_DLUnrefObjectInfoAll();
  while (data_ptr != NULL) {
    next_ptr = data_ptr->next_ptr;
    free(data_ptr);
    data_ptr = next_ptr;
  }

  if (bckctx->buffer)
    free(bckctx->buffer);

  /* Free the context */
  free(bckctx);
  return DATAQ__SUCCESS;
}

int main(int argc, char* argv[])
{
  qbck_tCtx bckctx;
  pwr_tStatus sts;
  float scantime;
  int full_scan;
  int count;
  int first_scan = 1;
  int file_reopen = 0;
  qcom_sQid qid = qcom_cNQid;
  qcom_sQattr qAttr;
  qcom_sQid qini;
  int tmo;
  int swap = 0;
  char mp[2000];
  qcom_sGet get;

  if (argc > 2 && streq(argv[1], "-l")) {
    errh_Init("dataq_backup_load", 0);

    sts = gdh_Init("dataq_backup_load");
    if (EVEN(sts))
      LogAndExit(sts);

    bckctx = calloc(1, sizeof(*bckctx));
    if (bckctx == 0)
      return DATAQ__NOMEMORY;

    bckctx->file_num = 1;

    sts = qbck_get_bckconfig(bckctx);
    if (EVEN(sts))
      LogAndExit(sts);

    if (!bckctx->bckconfig->NoRead) {
      /* Restore the specified backup file */
      sts = qbck_read(bckctx, argv[2]);
    }
    exit(0);
  }

  errh_Init("dataq_backup", 0);

  if (!qcom_Init(&sts, 0, "dataq_backup")) {
    errh_Fatal("qcom_Init, %m", sts);
    exit(sts);
  }

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, &qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    exit(sts);
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, &qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    exit(-1);
  }

  sts = gdh_Init("dataq_backup");
  if (EVEN(sts))
    LogAndExit(sts);

  for (;;) {
    bckctx = calloc(1, sizeof(*bckctx));
    if (bckctx == 0)
      return DATAQ__NOMEMORY;

    bckctx->file_num = 1;

    sts = qbck_get_bckconfig(bckctx);
    if (EVEN(sts))
      LogAndExit(sts);

    if (!bckctx->bckconfig->NoRead) {
      /* Restore the old backup file */
      sts = qbck_read(bckctx, bckctx->bckconfig->BackupFile);
    } else {
      /* Release the queues by setting backup done flag */
      sts = qbck_set_queue_backup_done();
      if (EVEN(sts))
        LogAndExit(sts);
    }

    sts = qbck_queue_init(bckctx);
    if (EVEN(sts))
      LogAndExit(sts);

    sts = qbck_get_queuebuffer(bckctx);
    if (EVEN(sts))
      LogAndExit(sts);

    scantime = bckctx->bckconfig->IncrementCycleTime;
    full_scan = bckctx->bckconfig->FullCycleTime / scantime + FLT_EPSILON;
    tmo = (int)scantime * 1000;

    count = 0;
    for (;;) {
      get.maxSize = sizeof(mp);
      get.data = mp;
      qcom_Get(&sts, &qid, &get, tmo);
      if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
        if (swap)
          continue;

        if (bckctx->bckconfig->Initialize) {
          bckctx->bckconfig->Initialize = 0;
          qbck_free(bckctx);
          break;
        }

        count++;
        if (count > full_scan || first_scan || file_reopen
            || bckctx->record_count >= QBCK_MAX_RECORDS - 1
            || bckctx->bckconfig->ForceFullBackup) {
          /* Time for full backup */
          if (bckctx->bckconfig->ForceFullBackup)
            bckctx->bckconfig->ForceFullBackup = 0;
          bckctx->increment = 0;
          count = 0;

          /* Toggle file */
          if (!file_reopen) {
            if (bckctx->file_num == 1)
              bckctx->file_num = 2;
            else
              bckctx->file_num = 1;
          }
          file_reopen = 0;
        } else
          /* Incremental backup */
          bckctx->increment = 1;

        sts = qbck_queue_handler(bckctx);
        if (sts == DATAQ__FILEREOPEN) {
          /* New file is opened, write a full backup */
          file_reopen = 1;
          continue;
        }
        if (ODD(sts))
          bckctx->bckconfig->LoopCount++;

        first_scan = 0;
      } else {
        ini_mEvent new_event;
        qcom_sEvent* ep = (qcom_sEvent*)get.data;

        new_event.m = ep->mask;
        if (new_event.b.oldPlcStop && !swap) {
          swap = 1;
          qbck_free(bckctx);
          break;
        } else if (new_event.b.swapDone && swap) {
          swap = 0;
        } else if (new_event.b.simLoadStart && !swap) {
          swap = 1;
        } else if (new_event.b.simLoadDone && swap) {
          swap = 0;
        } else if (new_event.b.terminate) {
          exit(0);
        }
      }
    }
  }
}
