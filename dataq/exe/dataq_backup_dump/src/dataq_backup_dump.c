/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2025 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*************************************************************************
*
* 	PROGRAM		dataq_backup_dump
*	SYSTEM		SSAB
*
*       Modifierad
*		960205	Claes Sjöfors	Skapad
*		230105	Claes Sjöfors	Converted to DataQ
*
*
*
*	Funktion:	Backup av DataQ objekt och data objekt.
*
*
*
**************************************************************************
**************************************************************************/

#include <stdio.h>

#include "pwr.h"
#include "pwr_dataqclasses.h"

#include "co_cdh.h"
#include "co_string.h"
#include "co_time.h"
#include "rt_gdh.h"
#include "dataq_backup.h"

#include "rt_gdh_msg.h"
#include "rt_hash_msg.h"
#include "rs_dataq_msg.h"


typedef struct {
  pwr_sClass_DataQBackupConfig* bckconfig;
  gdh_tDlid bckconfig_dlid;
} * qbck_tCtx;

static pwr_tUInt32 qbck_fulltimestring(pwr_tTime* time, char* timestr)
{
  return time_AtoAscii(time, time_eFormat_DateAndTime, timestr, 80);
}

static pwr_tUInt32 qbck_print_recordheader(
    qbck_tRecordHeader* recordheader)
{
  char timestr[80];

  printf("Record header\n");
  printf("	type:  %s\n", recordheader->type);
  qbck_fulltimestring(&recordheader->time, timestr);
  printf("	time:  %s\n", timestr);
  return DATAQ__SUCCESS;
}

static pwr_tUInt32 qbck_print_fileheader(qbck_tFileHeader* fileheader)
{
  char timestr[80];

  printf("File header\n");
  printf("	version:  %d\n", fileheader->version);
  qbck_fulltimestring(&fileheader->creationtime, timestr);
  printf("	time:  %s\n", timestr);
  return DATAQ__SUCCESS;
}

static pwr_tUInt32 qbck_print_queueheader(qbck_tQueueHeader* queueheader)
{
  printf("Queue header\n");
  printf("	type:  %s\n", queueheader->type);
  printf("	objid: %s\n", cdh_ObjidToString(queueheader->objid, 0));
  if (!streq(queueheader->type, HEADERTYPE_QUEUEEND)) {
    printf("	class: %x\n", queueheader->class);
    printf("	size:  %d\n", queueheader->size);
  }
  return DATAQ__SUCCESS;
}

static pwr_tUInt32 qbck_print_dataheader(qbck_tDataHeader* dataheader)
{
  printf("Data header\n");
  printf("	type:  %s\n", dataheader->type);
  printf("	objid: %s\n", cdh_ObjidToString(dataheader->objid, 0));
  if (!streq(dataheader->type, HEADERTYPE_DATAEND)) {
    printf("	class: %x\n", dataheader->class);
    printf("	name:  %s\n", dataheader->data_name);
    printf("	size:  %d\n", dataheader->size);
  }
  return DATAQ__SUCCESS;
}
static int qbck_timecmp(pwr_tTime* time_old, pwr_tTime* time_new)
{
  int sts;

  sts = time_Acomp(time_new, time_old);
  if (sts == -1)
    return 0;
  return 1;
}

int qbck_get_filename(char* inname, char* outname, char* ext)
{
  char* s;
  char* s2;

  strcpy(outname, inname);

  /* Look for extention in filename */
  if (ext != NULL) {
    s = strrchr(inname, ':');
    if (s == 0)
      s = inname;

    s2 = strrchr(s, '>');
    if (s2 == 0) {
      s2 = strrchr(s, ']');
      if (s2 == 0)
        s2 = s;
    }

    s = strrchr(s2, '.');
    if (s != 0)
      *s = 0;
    strcat(outname, ext);
  }
  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_check_file
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Check the consistency of a backup file.
*
**************************************************************************/

static pwr_tStatus qbck_check_file(qbck_tCtx bckctx, FILE* bckfile,
    int* record_count, unsigned int* record_start, unsigned int* queuearea_start,
    unsigned int* dataarea_start, pwr_tTime* first_record_time,
    pwr_tTime* last_record_time, int time_only)
{
  qbck_tFileHeader fileheader;
  qbck_tRecordHeader recordheader;
  qbck_tRecordHeader recordheaderend;
  qbck_tQueueHeader queueheader;
  qbck_tDataHeader dataheader;
  pwr_tUInt32 csts;
  pwr_tUInt32 actpos;
  int queue_read_success;
  int data_read_success;
  char filename[80];
  int k;
  char buffer[30000];
  int size;

  // fgetname( bckfile, filename);
  strcpy(filename, bckctx->bckconfig->BackupFile);
  printf("******************************************************\n");
  printf("Examining file %s\n\n", filename);

  actpos = ftell(bckfile);
  csts = fseek(bckfile, -actpos, 1);
  if (csts != 0)
    return DATAQ__FILEREAD;

  /* Read file header */
  csts = fread(&fileheader, sizeof(fileheader), 1, bckfile);
  if (csts == 0)
    return DATAQ__FILEREAD;

  qbck_print_fileheader(&fileheader);

  /* Check version */
  if (fileheader.version != QBCK_FILEVERSION)
    return DATAQ__BCKVERSION;

  *record_count = 0;
  queue_read_success = 0;
  data_read_success = 0;
  for (;;) {
    /* Read record header */
    /* Store the start of the record */
    *queuearea_start = ftell(bckfile);
    csts = fread(&recordheader, sizeof(recordheader), 1, bckfile);
    if (csts == 0)
      break;

    qbck_print_recordheader(&recordheader);

    if (strcmp(recordheader.type, HEADERTYPE_RECORDSTART))
      break;
    if (!qbck_timecmp(&fileheader.creationtime, &recordheader.time))
      break;

    if (*record_count == 0) {
      memcpy(first_record_time, &recordheader.time, sizeof(recordheader.time));
      if (time_only)
        return DATAQ__SUCCESS;
    } else {
      if (!qbck_timecmp(first_record_time, &recordheader.time))
        break;
    }

    /* Read queue area */
    queue_read_success = 0;
    /* Store the start of the queue area */
    *queuearea_start = ftell(bckfile);
    for (;;) {
      csts = fread(&queueheader, sizeof(queueheader), 1, bckfile);
      if (csts == 0)
        break;

      qbck_print_queueheader(&queueheader);

      if (!strcmp(queueheader.type, HEADERTYPE_QUEUEEND)) {
        /* End of queue area */
        queue_read_success = 1;
        break;
      } else if (strcmp(queueheader.type, HEADERTYPE_QUEUE))
        break;

      size = queueheader.size;
      if (size > sizeof(buffer)) {
        size = sizeof(buffer);
        printf("** Max buffer size exceeded, queue body truncated\n");
      }
      csts = fread(buffer, queueheader.size, 1, bckfile);
      if (csts == 0)
        break;

      switch (queueheader.class) {
      case pwr_cClass_DataQ1:
      case pwr_cClass_DataQ5:
      case pwr_cClass_DataQ30:
      case pwr_cClass_DataQ120: {
        pwr_sClass_DataQ1* queue_ptr;
        pwr_sClass_DataQBus* data_block_ptr;

        queue_ptr = (pwr_sClass_DataQ1*)buffer;
        data_block_ptr = &queue_ptr->Data[0];
        for (k = 0; k < queue_ptr->DataSize; k++) {
          /* Check if the objid already is in the data_db */
          printf("         Data%d: %s  %c %c %c\n", k,
              cdh_ObjidToString(data_block_ptr->Data.Aref.Objid, 0),
              data_block_ptr->Front ? 'F' : ' ',
              data_block_ptr->Back ? 'B' : ' ',
              data_block_ptr->Select ? 'S' : ' ');
          data_block_ptr++;
        }
        data_block_ptr = &queue_ptr->Super.Trp.DataL;
        printf("         DataL:  %s  %c %c %c\n",
            cdh_ObjidToString(data_block_ptr->Data.Aref.Objid, 0),
            data_block_ptr->Front ? 'F' : ' ',
            data_block_ptr->Back ? 'B' : ' ',
            data_block_ptr->Select ? 'S' : ' ');
        break;
      }
#if 0
      case pwr_cClass_NMpsMirrorQueue: {
        pwr_sClass_NMpsMirrorQueue* queue_ptr;
        pwr_sClass_DataQBusMirQueue* data_block_ptr;

        queue_ptr = (pwr_sClass_NMpsMirrorQueue*)buffer;
        data_block_ptr = (pwr_sClass_DataQBusMirQueue*)&queue_ptr->Data1P.Ptr;
        for (k = 0; k < queue_ptr->LastIndex; k++) {
          printf("         Data%d: %s\n", k,
              cdh_ObjidToString(data_block_ptr->DataP.Aref.Objid, 0));
          data_block_ptr++;
        }
        break;
      }
#endif
      }
    }

    if (!queue_read_success)
      break;

    /* Read data area */
    data_read_success = 0;
    /* Store the start of the data area */
    *dataarea_start = ftell(bckfile);
    for (;;) {
      csts = fread(&dataheader, sizeof(dataheader), 1, bckfile);
      if (csts == 0)
        break;

      qbck_print_dataheader(&dataheader);

      if (!strcmp(dataheader.type, HEADERTYPE_DATAEND)) {
        /* End of data area */
        data_read_success = 1;
        break;
      } else if (strcmp(dataheader.type, HEADERTYPE_DATA))
        break;

      csts = fseek(bckfile, dataheader.size, 1);
      if (csts != 0)
        break;
    }

    if (!data_read_success)
      break;

    /* Read record header */
    csts = fread(&recordheaderend, sizeof(recordheaderend), 1, bckfile);
    if (csts == 0)
      break;

    qbck_print_recordheader(&recordheaderend);

    if (strcmp(recordheaderend.type, HEADERTYPE_RECORDEND))
      break;

    if (!qbck_timecmp(&recordheader.time, &recordheaderend.time))
      break;

    (*record_count)++;
    record_start++;
    queuearea_start++;
    dataarea_start++;
  }

  if (*record_count == 0) {
    /* No valid record found */
    return DATAQ__BCKFILECORRUPT;
  }

  memcpy(last_record_time, &recordheader.time, sizeof(recordheader.time));

  return DATAQ__SUCCESS;
}

/*************************************************************************
*
* Name:		qbck_read
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Read the queue objects from backup file.
*
**************************************************************************/

static pwr_tStatus qbck_read(qbck_tCtx bckctx)
{
  FILE* bckfile1;
  pwr_tUInt32 queuearea_start[QBCK_MAX_RECORDS];
  pwr_tUInt32 dataarea_start[QBCK_MAX_RECORDS];
  pwr_tUInt32 record_start[QBCK_MAX_RECORDS];
  int record_count;
  pwr_tTime last_record_time;
  pwr_tTime bckfile1_time;
  pwr_tStatus bckfile1_sts;

  /* Open file 1 */
  bckfile1 = fopen(bckctx->bckconfig->BackupFile, "r+");
  if (bckfile1 == NULL)
    bckfile1_sts = DATAQ__FILEREAD;
  bckfile1_sts
      = qbck_check_file(bckctx, bckfile1, &record_count, record_start,
          queuearea_start, dataarea_start, &bckfile1_time, &last_record_time, 0);
  fclose(bckfile1);
  return bckfile1_sts;
}

int main(int argc, char* argv[])
{
  qbck_tCtx bckctx;
  int sts;
  pwr_sClass_DataQBackupConfig bckconfig;

  if (argc < 2) {
    printf("Enter filename\n");
    exit(DATAQ__SUCCESS);
  }

  bckctx = calloc(1, sizeof(*bckctx));
  if (bckctx == 0)
    return DATAQ__NOMEMORY;

  bckctx->bckconfig = &bckconfig;
  memset(&bckconfig, 0, sizeof(bckconfig));
  strcpy(bckconfig.BackupFile, argv[1]);

  sts = qbck_read(bckctx);
  exit(sts);
}
