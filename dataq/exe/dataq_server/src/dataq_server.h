/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef dataq_server_h
#define dataq_server_h

#include <vector>
#include "pwr_baseclasses.h"
#include "pwr_dataqclasses.h"
#include "dataq_net.h"

class qsrv_node {
 public:
  pwr_tNodeId nid;
  char name[80];
  int connection;
};

class qsrv_convert_table {
 public:
  unsigned int target_offset;
  unsigned int source_offset;
  unsigned int size;
  pwr_tTid tid;
  unsigned int feedback;
};

class qsrv_data_converter {
 public:
  unsigned int version;
  std::vector<qsrv_convert_table> conv;

  pwr_tStatus create_table(pwr_tCid target_cid, pwr_tCid source_cid);
  unsigned int size() { return conv.size();}
  unsigned int feedback_size();
  unsigned int table_and_data_msg_size();
  unsigned int data_msg_size();
  unsigned int feedback_data_msg_size();
  void table_and_data_to_msg(char *mp, char *sourcep, unsigned int *msize);
  void table_to_msg(char *mp, unsigned int *msize);
  void msg_to_table(char *mp, unsigned int attr_num, unsigned int *msize);
  void msg_to_target_data(char *mp, char *op, unsigned int *msize);
  void msg_to_feedback_data(char *mp, char *op, unsigned int *msize);
  void source_data_to_msg(char *mp, char *op, unsigned int *msize);
  void feedback_data_to_msg(char *mp, char *op, unsigned int *msize);
  pwr_tStatus from_message(char *mp, char *target);
};

class qsrv_rdataq_remoteq {
 public:
  qsrv_rdataq_remoteq() : aref(pwr_cNAttrRef), options(0), start(0), end(0) {}
  pwr_tAttrRef aref;
  pwr_tMask options;
  unsigned int start;
  unsigned int end;
};

class qsrv_rdataq {
 public:
  pwr_tAttrRef aref;
  pwr_sClass_RemoteDataQ* op;
  pwr_sClass_DataQ1* src_op;
  pwr_tDlid dlid;
  pwr_tDlid src_dlid;
  int node_idx;
  unsigned int msg_size;
  std::vector<qsrv_rdataq_remoteq> remoteq;
  qsrv_data_converter dc;
};

class qsrv_tdataq_targetq {
 public:
  qsrv_tdataq_targetq() : aref(pwr_cNAttrRef), options(0),
    start(0), end(0), source(pwr_cNOid), op(0) {}
  pwr_tAttrRef aref;
  pwr_tMask options;
  unsigned int start;
  unsigned int end;
  pwr_tOid source;
  pwr_sClass_DataQ1* op;
  pwr_tDlid dlid;
};

class qsrv_tdataq {
 public:
  int node_idx;
  int reply_nid;
  pwr_tAttrRef rdataq;
  pwr_tOName source_dataname;
  unsigned int msg_size;
  std::vector<qsrv_tdataq_targetq> targetq;
  qsrv_data_converter dc;
};

class qsrv_rorder_copy {
 public:
  unsigned int target_offset;
  unsigned int source_offset;
  unsigned int size;
  pwr_tTid tid;
  unsigned int feedback;
};

class qsrv_rorder {
 public:
  pwr_tObjid oid;
  pwr_sClass_QRemoteOrder* op;
  pwr_tDlid dlid;
  int node_idx;
  unsigned int msg_size;
  qsrv_data_converter dc;
};

class qsrv_torder_copy {
 public:
  unsigned int source_offset;
  unsigned int target_offset;
  unsigned int size;
  pwr_tTid tid;
};

class qsrv_torder {
 public:
  pwr_tObjid oid;
  pwr_sClass_QTargetOrder* op;
  pwr_tDlid dlid;
  pwr_tOid rorder;
  pwr_tMask options;
  pwr_tCid data_class;
  int reply_nid;
  pwr_tOid reply_source;
  unsigned int msg_size;
  int initialized;
  qsrv_data_converter dc;
};

class dataq_server {
 public:
  dataq_server(): m_sts(DATAQ__SUCCESS), m_config(0), m_config_dlid(pwr_cNDlid), 
    m_msg_id(0) {
  }
  ~dataq_server();
  
  pwr_tStatus m_sts;
  pwr_sClass_DataQServer *m_config;
  pwr_tDlid m_config_dlid;
  std::vector<qsrv_node> m_nodes;
  std::vector<qsrv_rdataq> m_rdataq;
  std::vector<qsrv_tdataq> m_tdataq;
  std::vector<qsrv_rorder> m_rorder;
  std::vector<qsrv_torder> m_torder;
  unsigned int m_msg_id;

  pwr_tStatus node_up(pwr_tNid nid);
  pwr_tStatus node_up_reply(pwr_tNid nid);
  pwr_tStatus send_rdataq_init(pwr_tNid nid);
  pwr_tStatus rdataq_init_msg(dataq_sMsgRDataQInit* mp, int size, pwr_tNid reply_nid);
  pwr_tStatus rdataq_feedback(dataq_sMsgRDataQFeedback* mp, int size, pwr_tNid reply_nid);
  pwr_tStatus rdataq(dataq_sMsgRDataQ* mp, int size, pwr_tNid reply_nid);
  pwr_tStatus rdataq_reset(dataq_sMsgRDataQReset* mp, int size, pwr_tNid reply_nid);
  pwr_tStatus send_rorder_init(pwr_tNid nid);
  pwr_tStatus rorder_init_msg(dataq_sMsgROrderInit* mp, int size, pwr_tNid reply_nid);
  pwr_tStatus rorder(dataq_sMsgROrder* mp, int size, pwr_tNid reply_nid);
  pwr_tStatus rorder_feedback(dataq_sMsgROrderFeedback* mp, int size, pwr_tNid reply_nid);
  pwr_tStatus get_config();
  pwr_tStatus trans_handler();
  pwr_tStatus rdataq_init();
  pwr_tStatus rorder_init();
  pwr_tStatus torder_init();
  void rdataq_close();
  void rorder_close();
  void torder_close();
  pwr_tStatus init();
  pwr_tStatus connect();
  pwr_tStatus mainloop();
  pwr_tStatus remote_name(char* source_name, char* format, char *remote_name, unsigned int size);
};

#endif
