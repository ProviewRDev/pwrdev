/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rs_remote_mqTT.c Remote transport process with MQTT */

/*_Include files_________________________________________________________*/

#if defined PWRE_CONF_MQTT

#include <mosquitto.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>

#include "pwr_baseclasses.h"
#include "pwr_class.h"
#include "pwr_remoteclasses.h"
#include "pwr_systemclasses.h"

#include "co_string.h"
#include "co_time.h"
#include "co_cdh.h"

#include "rt_aproc.h"
#include "rt_errh.h"
#include "rt_gdh.h"
#include "rt_pwr_msg.h"
#include "rs_remote_msg.h"

#include "remote.h"
#include "remote_remtrans_utils.h"

#define TIME_INCR 0.02
#define debug 0
#define remote_cMsgClass 204

typedef enum {
  eCon_NotConnected = 0,
  eCon_Connected = 1,
  eCon_WaitConnect = 2
} eCon;

typedef struct {
  struct mosquitto *mosq;
  pwr_sClass_RemnodeMQTT* op;
  int is_subscriber;
  int is_publisher;
  eCon connected;
} mqtt_sCtx, *mqtt_tCtx;

typedef struct {
  unsigned int msg_size;
  unsigned short int msg_id[2];
} mqtt_header;

static mqtt_tCtx ctx = 0;
static remnode_item rn;
static pwr_sClass_RemnodeMQTT* rn_mqtt;

/*************************************************************************
**************************************************************************
*
* RemoteSleep
*
**************************************************************************
**************************************************************************/

void RemoteSleep(float time)
{
  struct timespec rqtp, rmtp;

  rqtp.tv_sec = (int)time;
  rqtp.tv_nsec = (long int)((time - rqtp.tv_sec) * 1000000000);
  nanosleep(&rqtp, &rmtp);
  return;
}

pwr_tStatus mqtt_error_to_sts(int err)
{
  pwr_tStatus sts = 0;

  switch (err) {
  case MOSQ_ERR_CONN_PENDING:
    sts = REM__TT_CONN_PENDING;
    break;
  case MOSQ_ERR_SUCCESS:
    sts = REM__SUCCESS;
    break;
  case MOSQ_ERR_NOMEM:
    sts = REM__TT_NOMEM;
    break;
  case MOSQ_ERR_PROTOCOL:
    sts = REM__TT_PROTOCOL;
    break;
  case MOSQ_ERR_INVAL:
    sts = REM__TT_INVAL;
    break;
  case MOSQ_ERR_NO_CONN:
    sts = REM__TT_NO_CONN;
    break;
  case MOSQ_ERR_CONN_REFUSED:
    sts = REM__TT_CONN_REFUSED;
    break;
  case MOSQ_ERR_NOT_FOUND:
    sts = REM__TT_NOT_FOUND;
    break;
  case MOSQ_ERR_CONN_LOST:
    sts = REM__TT_CONN_LOST;
    break;
  case MOSQ_ERR_TLS:
    sts = REM__TT_TLS;
    break;
  case MOSQ_ERR_PAYLOAD_SIZE:
    sts = REM__TT_PAYLOAD_SIZE;
    break;
  case MOSQ_ERR_NOT_SUPPORTED:
    sts = REM__TT_NOT_SUPPORTED;
    break;
  case MOSQ_ERR_AUTH:
    sts = REM__TT_AUTH;
    break;
  case MOSQ_ERR_ACL_DENIED:
    sts = REM__TT_ACL_DENIED;
    break;
  case MOSQ_ERR_UNKNOWN:
    sts = REM__TT_UNKNOWN;
    break;
  case MOSQ_ERR_ERRNO:
    sts = REM__TT_ERRNO;
    break;
  case MOSQ_ERR_EAI:
    sts = REM__TT_EAI;
    break;
  case MOSQ_ERR_PROXY:
    sts = REM__TT_PROXY;
    break;
  case MOSQ_ERR_PLUGIN_DEFER:
    sts = REM__TT_PLUGIN_DEFER;
    break;
  case MOSQ_ERR_MALFORMED_UTF8:
    sts = REM__TT_MALFORMED_UTF8;
    break;
  case MOSQ_ERR_KEEPALIVE:
    sts = REM__TT_KEEPALIVE;
    break;
  case MOSQ_ERR_LOOKUP:
    sts = REM__TT_LOOKUP;
    break;
  }
  return sts;
}

void mqtt_close()
{
  mosquitto_disconnect(ctx->mosq);
}

/* Callback from mosquitto when connection is done */

void connect_cb(struct mosquitto *mosq, void *obj, int result)
{
  if(result){
    ctx->op->Status = mqtt_error_to_sts(result);
    if (debug)
      printf("%s\n", mosquitto_connack_string(result));
    ctx->connected = eCon_NotConnected;
    if (result == MOSQ_ERR_CONN_REFUSED) {
      errh_Fatal("Remote mqtt terminated, %s", mosquitto_connack_string(result));
      exit(0);
    }
  }
  else {
    if (ctx->is_subscriber) {
      mosquitto_subscribe(ctx->mosq, NULL, ctx->op->SubscribeTopic, 0);
    }
    ctx->op->Status = REM__TT_CONNECTED;
    ctx->connected = eCon_Connected;
  }
}

/* Callback from mosquitto when message is received */

void message_cb(struct mosquitto *mosq, void *obj, 
    const struct mosquitto_message *msg)
{
  bool match = 0;
  pwr_tStatus sts;
  int search_remtrans = 0;
  remtrans_item* remtrans;
  mqtt_header header;
  int msg_received = 0;
  
  if (msg->payloadlen > 0 && rn_mqtt->DisableHeader) {
    /* Header disabled, take the first receive remtrans object */

    remtrans = rn.remtrans;
    search_remtrans = 1;

    while (remtrans && search_remtrans) {
      /* Match? */
      if (remtrans->objp->Direction == REMTRANS_IN) {
	if (ctx->is_subscriber == 1 && strcmp(remtrans->objp->TransName, "") == 0)
	  match = 1;
	else
	  mosquitto_topic_matches_sub(remtrans->objp->TransName, msg->topic, &match);
      
	if (match) {
	  search_remtrans = false;
	  sts = RemTrans_Receive(remtrans, (char*)msg->payload,
              msg->payloadlen);
	  msg_received = 1;
	  break;
	}
      }
      remtrans = (remtrans_item*)remtrans->next;
    }
    if (search_remtrans) {
      rn_mqtt->ErrCount++;
      errh_Info("MQTT Receive no remtrans %s", rn_mqtt->SubscribeTopic);
    }
  } else if (msg->payloadlen >= sizeof(mqtt_header)) {
    memcpy(&header, msg->payload, sizeof(mqtt_header));

    /* Convert the header to host byte order */
    header.msg_size = ntohs(header.msg_size);
    header.msg_id[0] = ntohs(header.msg_id[0]);
    header.msg_id[1] = ntohs(header.msg_id[1]);

    search_remtrans = 1;
    remtrans = rn.remtrans;
    while (remtrans && search_remtrans) {
      if (remtrans->objp->Address[0] == header.msg_id[0]
          && remtrans->objp->Address[1] == header.msg_id[1]
          && remtrans->objp->Direction == REMTRANS_IN) {
        search_remtrans = false;
        sts = RemTrans_Receive(remtrans,
            (char*)msg->payload + sizeof(mqtt_header),
            msg->payloadlen);
        if (sts != STATUS_OK && sts != STATUS_BUFF)
          errh_Error("Error from RemTrans_Receive, topic %s, status %d",
              rn_mqtt->SubscribeTopic, sts, 0);
        msg_received = 1;
        break;
      }
      remtrans = (remtrans_item*)remtrans->next;
    }
    if (search_remtrans) {
      rn_mqtt->ErrCount++;
      msg_received = 1;
      errh_Info("No remtrans for received message, topic %s, class %d, type %d",
          rn_mqtt->SubscribeTopic, header.msg_id[0], header.msg_id[1]);
    }
  }
}

/*************************************************************************
**************************************************************************
*
* Namn : mqtt_connect
*
* Typ  : int
*
* Typ		Parameter	       IOGF	Beskrivning
*
* Beskrivning : Connect to MQTT broker.
*
**************************************************************************
**************************************************************************/
int mqtt_connect()
{
  int rc;
  char id[20];

  if (!ctx->mosq) {
    sprintf(id, "%u", rn.objid.oix);
    ctx->mosq = mosquitto_new(id, true, NULL);
  
    mosquitto_connect_callback_set(ctx->mosq, connect_cb);
    if (ctx->is_subscriber)
      mosquitto_message_callback_set(ctx->mosq, message_cb);

    if (strcmp(ctx->op->User, "") != 0)
      mosquitto_username_pw_set(ctx->mosq, ctx->op->User, ctx->op->Password);
    // mosquitto_tls_set(ctx->mosq, "ca-cert.pem", NULL, NULL, NULL, NULL);

    rc = mosquitto_connect(ctx->mosq, ctx->op->Server, ctx->op->Port, 60);
    if (rc) {
      ctx->op->Status = mqtt_error_to_sts(rc);
      return ctx->op->Status;
    }
    ctx->connected = eCon_WaitConnect;
  }
  else {
    rc = mosquitto_reconnect(ctx->mosq);
    if (rc) {
      ctx->op->Status = mqtt_error_to_sts(rc);
      return ctx->op->Status;
    }
  }
  return 1;
}

void reconnect()
{
  int rc;

  if (ctx->connected == eCon_Connected)
    return;

  RemoteSleep(2);
  
  rc = mosquitto_connect(ctx->mosq, ctx->op->Server, ctx->op->Port, 60);
  if (debug)
    printf("reconnect: %s\n", mosquitto_connack_string(rc));
  if (!rc) {
    ctx->op->Status = mqtt_error_to_sts(rc);
    ctx->connected = eCon_Connected;
    return;
  }
  rc = mosquitto_loop(ctx->mosq, TIME_INCR * 1000, 1);
}

/*************************************************************************
**************************************************************************
*
* Namn : mqtt_send
*
* Typ  : unsigned int
*
* Typ		Parameter	       IOGF	Beskrivning
*
* Beskrivning : Sends a MQTT message to remote node
*
**************************************************************************
**************************************************************************/

unsigned int mqtt_send(remnode_item* remnode, pwr_sClass_RemTrans* remtrans,
    char* buf, int buf_size)
{
  char* tmpbuf;
  unsigned int tmpbuf_size;
  int retain;
  int rc;

  if (rn_mqtt->DisableHeader) {
    tmpbuf = buf;
    tmpbuf_size = buf_size;
  } else {
    tmpbuf_size = sizeof(mqtt_header) + buf_size;
    tmpbuf = malloc(tmpbuf_size);
    memcpy(tmpbuf + sizeof(mqtt_header), buf, buf_size);

    ((mqtt_header*)tmpbuf)->msg_size = htons(tmpbuf_size);
    ((mqtt_header*)tmpbuf)->msg_id[0] = htons(remtrans->Address[0]);
    ((mqtt_header*)tmpbuf)->msg_id[1] = htons(remtrans->Address[1]);
  }

  retain = remtrans->Address[3] == 1 ? 1 : 0;

  if (rn_mqtt->DisableHeader)
    rc = mosquitto_publish(ctx->mosq, NULL, remtrans->TransName, tmpbuf_size, 
	tmpbuf, 1, retain);
  else
    rc = mosquitto_publish(ctx->mosq, NULL, rn_mqtt->PublishTopic, tmpbuf_size, 
	tmpbuf, 1, retain);
  if (rc) {
    ctx->op->Status = mqtt_error_to_sts(rc);
  }
  if (!rn_mqtt->DisableHeader)
    free(tmpbuf);

  return STATUS_OK;
}

/*************************************************************************
**************************************************************************
*
* Main
*
**************************************************************************
**************************************************************************/

int main(int argc, char* argv[])
{
  remtrans_item* remtrans;
  unsigned char id[32];
  unsigned char pname[80];
  pwr_tStatus sts;
  int i;
  float time_since_scan = 0.0;
  int rc;

  /* Read arg number 2, should be id for this instance and id is our queue
   * number */

  if (argc >= 2)
    strncpy((char*)id, argv[1], sizeof(id));
  else
    strcpy((char*)id, "0");

  /* Build process name with id */

  sprintf((char*)pname, "rs_remmqtt_%s", id);

  /* Init of errh */

  errh_Init((char*)pname, errh_eAnix_remote);
  errh_SetStatus(PWR__SRVSTARTUP);

  /* Init of gdh */
  sts = gdh_Init((char*)pname);
  if (EVEN(sts)) {
    errh_Fatal("gdh_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  /* Arg number 3 should be my remnodes objid in string representation,
     read it, convert to real objid and store in remnode_item */

  sts = 0;
  if (argc >= 3)
    sts = cdh_StringToObjid(argv[2], &rn.objid);
  if (EVEN(sts)) {
    errh_Fatal("cdh_StringToObjid, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  /* Get pointer to RemnodeMQTT object and store locally */
  sts = gdh_ObjidToPointer(rn.objid, (pwr_tAddress*)&rn_mqtt);
  if (EVEN(sts)) {
    errh_Fatal("cdh_ObjidToPointer, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  if (streq(rn_mqtt->Server, "")) {
    errh_Fatal("Process terminated, server not configured, %s", id);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  /* Create context */
  ctx = calloc(1, sizeof(*ctx));
  ctx->op = rn_mqtt;

  /* Initialize some internal data and make standard remtrans init */

  rn.next = NULL;
  rn.local = NULL; // We dont use local structure since we only have one remnode
  rn_mqtt->ErrCount = 0;

  sts = RemTrans_Init(&rn);

  if (EVEN(sts)) {
    errh_Fatal("RemTrans_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  /* Store remtrans objects objid in remnode_qcom object */
  remtrans = rn.remtrans;
  i = 0;
  while (remtrans) {
    if (remtrans->objp->Direction == REMTRANS_OUT)
      ctx->is_publisher++;
    else if (remtrans->objp->Direction == REMTRANS_IN)
      ctx->is_subscriber++;

    rn_mqtt->RemTransObjects[i++] = remtrans->objid;
    if (i >= (int)(sizeof(rn_mqtt->RemTransObjects)
                 / sizeof(rn_mqtt->RemTransObjects[0])))
      break;
    remtrans = (remtrans_item*)remtrans->next;
  }

  /* Connect to mqtt server */
  sts = mqtt_connect();
  while(1) {
    if (debug)
      printf("Wait for connection\n");
    if (ctx->connected != eCon_WaitConnect)
      break;
    
    rc = mosquitto_loop(ctx->mosq, TIME_INCR * 1000, 1);
  }

  /* Set running status */

  errh_SetStatus(PWR__SRUN);

  /* Set (re)start time in remnode object */

  time_GetTime(&rn_mqtt->RestartTime);

  /* Loop forever */

  while (!doomsday) {
    if (rn_mqtt->Disable == 1) {
      errh_Fatal("Disabled, exiting");
      errh_SetStatus(PWR__SRVTERM);
      exit(0);
    }
    aproc_TimeStamp(TIME_INCR, 5);

    if (ctx->connected == eCon_NotConnected) {
      reconnect();
      continue;
    }

    if (ctx->is_publisher) {
      rc = mosquitto_loop(ctx->mosq, TIME_INCR * 1000, 1);
      if (rc)
	ctx->op->Status = mqtt_error_to_sts(rc);
      RemoteSleep(TIME_INCR);
    }
    else {
      rc = mosquitto_loop(ctx->mosq, -1, 1);
      if (rc) {
	ctx->op->Status = mqtt_error_to_sts(rc);
	if (rc == MOSQ_ERR_NO_CONN || MOSQ_ERR_CONN_LOST) {
	  ctx->connected = eCon_NotConnected;
	  continue;
	}
      }
    }

    time_since_scan += TIME_INCR;
    if (time_since_scan >= rn_mqtt->ScanTime) {
      if (ctx->is_publisher)
        sts = RemTrans_Cyclic(&rn, &mqtt_send);
      time_since_scan = 0.0;
    }
  }
}

#else
#include <stdio.h>
int main()
{
  printf("Remote MQTT not built for this release\n");
  return 0;
}
#endif
