/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2023 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#if defined PWRE_CONF_RDKAFKA

#include "export_rtdb_avro.h"

void AvroEncoder::encodeInt64(int64_t input) {
  unsigned long long val = ((input << 1) ^ (input >> 63));
  const int mask = 0x7F;
  unsigned long long v = val & mask;
  while (val >>= 7) {
    out.push_back(v | 0x80);
    v = val & mask;
  }
  out.push_back(v);
}

void AvroEncoder::encodeInt32(int32_t input) {
  unsigned int val = ((input << 1) ^ (input >> 31));
  const int mask = 0x7F;
  unsigned int v = val & mask;
  while (val >>= 7) {
    out.push_back(v | 0x80);
    v = val & mask;
  }
  out.push_back(v);
}

void AvroEncoder::writeBytes(const uint8_t* p, int size) {
  for (int i = 0; i < size; i++) {
    out.push_back(p[i]);
  }
}

void AvroEncoder::clear() {
  out.clear();
}

void AvroEncoder::arrayStart() {}
void AvroEncoder::startItem() {}
void AvroEncoder::arrayEnd() {
  this->encodeLong(0);
}

void AvroEncoder::setItemCount(size_t count) {
  this->encodeLong(count);
}

void AvroEncoder::encodeBool(bool b) {
  out.push_back(b ? 1 : 0);
}

void AvroEncoder::encodeInt(int32_t i) {
  encodeInt32(i);
}

void AvroEncoder::encodeLong(int64_t i) {
  encodeInt64(i);
}

void AvroEncoder::encodeFloat(float f) {
  const auto *p = reinterpret_cast<const uint8_t*>(&f);
  writeBytes(p, sizeof(float));
}

void AvroEncoder::encodeDouble(double d) {
  const auto *p = reinterpret_cast<const uint8_t*>(&d);
  writeBytes(p, sizeof(double));
}

void AvroEncoder::encodeString(const std::string &s) {
  encodeInt64(s.size());
  writeBytes(reinterpret_cast<const uint8_t*>(s.c_str()), s.size());
}

void AvroEncoder::encodeBytes(const uint8_t *bytes, size_t len) {
  encodeInt64(len);
  writeBytes(bytes, len);
}

void AvroEncoder::encodeFixed(const uint8_t *bytes, size_t len) {
  writeBytes(bytes, len);
}

void AvroEncoder::encodeUnionIndex(size_t e) {
  encodeInt64(e);
}

#endif
