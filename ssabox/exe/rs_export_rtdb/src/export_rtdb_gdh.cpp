/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2023 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#if defined PWRE_CONF_RDKAFKA

#include "pwr.h"
#include "pwr_baseclasses.h"
#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "co_cdh.h"
#include "export_rtdb_avro.h"
#include "export_rtdb_gdh.h"

const bool MAKE_VALUES_OPTIONAL = true;

template<typename T>
T attr_to_val(bool is_ptr, pwr_sAttrRef* aref, void* val) {
  T a;
  if (is_ptr)
    gdh_GetObjectInfoAttrref(aref, &a, sizeof(a));
  else
    a = *(T*)val;
  return a;
}

int encode_val(AvroEncoder &enc, pwr_eType type_id, bool is_ptr, pwr_sAttrRef* aref, void* val) {
  if (MAKE_VALUES_OPTIONAL && type_id < pwr_eType_Void) {
    enc.encodeUnionIndex(1);
  }
  if (type_id == pwr_eType_Boolean) {
    pwr_tBoolean a = attr_to_val<pwr_tBoolean>(is_ptr, aref, val);
    enc.encodeBool(a ? true : false);
  } else if (type_id == pwr_eType_Float32) {
    enc.encodeFloat(attr_to_val<pwr_tFloat32>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_Float64) {
    enc.encodeDouble(attr_to_val<pwr_tFloat64>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_Char) {
    enc.encodeInt(attr_to_val<pwr_tChar>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_Int8) {
    enc.encodeInt(attr_to_val<pwr_tInt8>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_Int16) {
    enc.encodeInt(attr_to_val<pwr_tInt16>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_Int32) {
    enc.encodeInt(attr_to_val<pwr_tInt32>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_Int64) {
    enc.encodeLong(attr_to_val<pwr_tInt64>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_UInt8) {
    enc.encodeInt(attr_to_val<pwr_tUInt8>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_UInt16) {
    enc.encodeInt(attr_to_val<pwr_tUInt16>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_UInt32 || type_id == pwr_eType_Mask || type_id == pwr_eType_DisableAttr || type_id == pwr_eType_Enum || type_id == pwr_eType_NetStatus || type_id == pwr_eType_Status) {
    enc.encodeInt(attr_to_val<pwr_tUInt32>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_UInt64) {
    enc.encodeLong(attr_to_val<pwr_tUInt64>(is_ptr, aref, val));
  } else if (type_id == pwr_eType_String) {
    pwr_tString80 a;
    if (is_ptr)
      gdh_GetObjectInfoAttrref(aref, &a, sizeof(a));
    else
      strcpy(a, *(pwr_tString80*)val);
    enc.encodeString(std::string(a));
  } else if (type_id == pwr_eType_Text) {
    pwr_tString80 a;
    if (is_ptr)
      gdh_GetObjectInfoAttrref(aref, &a, sizeof(a));
    else
      strcpy(a, *(pwr_tText*)val);
    pwr_tString80 str;
    char* s;
    char* t;
    for (s = (char*)a, t = str; *s != 10 && *s != 0; s++, t++) {
      *t = *s;
    }
    *t = 0;
    enc.encodeString(std::string(str));
  } else if (type_id == pwr_eType_Objid) {
    pwr_tObjid a = attr_to_val<pwr_tObjid>(is_ptr, aref, val);
    enc.encodeBytes((uint8_t*)&a, sizeof(a));
  } else if (type_id == pwr_eType_AttrRef) {
    pwr_sAttrRef attrref;
    if (is_ptr)
      gdh_GetObjectInfoAttrref(aref, &attrref, sizeof(attrref));
    else
      attrref = *(pwr_sAttrRef*)val;
    enc.encodeBytes((uint8_t*)&attrref, sizeof(attrref));
  } else if (type_id == pwr_eType_DataRef) {
    pwr_tDataRef dataref;
    if (is_ptr)
      gdh_GetObjectInfoAttrref(aref, &dataref, sizeof(dataref));
    else
      dataref = *(pwr_tDataRef*)val;
    enc.encodeBytes((uint8_t*)&dataref, sizeof(dataref));
  } else if (type_id == pwr_eType_Time) {
    pwr_tTime a = attr_to_val<pwr_tTime>(is_ptr, aref, val);
    uint8_t tmp[sizeof(a.tv_sec)+sizeof(a.tv_nsec)];
    for (int i = 0; i < sizeof(a.tv_sec); i++) {
      tmp[i] = ((a.tv_sec >> (8*i)) & 0xFF);
    }
    for (int i = 0; i < sizeof(a.tv_nsec); i++) {
      tmp[i+sizeof(a.tv_sec)] = ((a.tv_nsec >> (8*i)) & 0xFF);
    }
    enc.encodeBytes(tmp, sizeof(a.tv_sec)+sizeof(a.tv_nsec));
  } else if (type_id == pwr_eType_DeltaTime) {
    pwr_tDeltaTime a = attr_to_val<pwr_tDeltaTime>(is_ptr, aref, val);
    uint8_t tmp[sizeof(a.tv_sec)+sizeof(a.tv_nsec)];
    for (int i = 0; i < sizeof(a.tv_sec); i++) {
      tmp[i] = ((a.tv_sec >> (8*i)) & 0xFF);
    }
    for (int i = 0; i < sizeof(a.tv_nsec); i++) {
      tmp[i+sizeof(a.tv_sec)] = ((a.tv_nsec >> (8*i)) & 0xFF);
    }
    enc.encodeBytes(tmp, sizeof(a.tv_sec)+sizeof(a.tv_nsec));
  } else if (type_id == pwr_eType_ObjectIx) {
    pwr_tObjectIx a = attr_to_val<pwr_tObjectIx>(is_ptr, aref, val);
    enc.encodeBytes((uint8_t*)&a, sizeof(a));
  } else if (type_id == pwr_eType_ClassId) {
    pwr_tClassId a = attr_to_val<pwr_tClassId>(is_ptr, aref, val);
    enc.encodeBytes((uint8_t*)&a, sizeof(a));
  } else if (type_id == pwr_eType_TypeId || type_id == pwr_eType_CastId) {
    pwr_tTypeId a = attr_to_val<pwr_tTypeId>(is_ptr, aref, val);
    enc.encodeBytes((uint8_t*)&a, sizeof(a));
  } else if (type_id == pwr_eType_VolumeId) {
    pwr_tVolumeId a = attr_to_val<pwr_tVolumeId>(is_ptr, aref, val);
    enc.encodeBytes((uint8_t*)&a, sizeof(a));
  } else if (type_id == pwr_eType_RefId) {
    pwr_tSubid a = attr_to_val<pwr_tSubid>(is_ptr, aref, val);
    enc.encodeBytes((uint8_t*)&a, sizeof(a));
  } else {
    fprintf(stderr, "Not handling type %d\n", type_id);
    return GDH__CONVERT;
  }
  return GDH__SUCCESS;
}

std::string pwr_eType_to_str(pwr_eType tid) {
  std::string str = "";
  if (tid == pwr_eType_Boolean) {
    str = "boolean";
  } else if (tid == pwr_eType_Float32) {
    str =  "float";
  } else if (tid == pwr_eType_Float64) {
    str = "double";
  } else if (tid == pwr_eType_Char) {
    str = "bytes";
  } else if (tid == pwr_eType_Int8 || tid == pwr_eType_Int16 || tid == pwr_eType_Int32 || tid == pwr_eType_UInt8 || tid == pwr_eType_UInt16 || tid == pwr_eType_UInt32 || tid == pwr_eType_Mask || tid == pwr_eType_DisableAttr || tid == pwr_eType_Enum || tid == pwr_eType_NetStatus || tid == pwr_eType_Status) {
    str = "int";
  } else if (tid == pwr_eType_Int64 || tid == pwr_eType_UInt64) {
    str = "long";
  } else if (tid == pwr_eType_String || tid == pwr_eType_Text) {
    str = "string";
  } else if (tid == pwr_eType_Objid || tid == pwr_eType_AttrRef || tid == pwr_eType_DataRef || tid == pwr_eType_ObjectIx || tid == pwr_eType_ClassId || tid == pwr_eType_TypeId || tid == pwr_eType_CastId || tid == pwr_eType_VolumeId || tid == pwr_eType_RefId) {
    str = "bytes";
  } else if (tid == pwr_eType_Time || tid == pwr_eType_DeltaTime) {
    str = "bytes";
  }
  if (MAKE_VALUES_OPTIONAL && str.size() > 0) {
    return "[\\\"null\\\",\\\"" + str + "\\\"]";
  }
  return str;
}

#endif
