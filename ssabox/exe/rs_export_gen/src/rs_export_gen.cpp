/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2024 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rs_export_gen Generate export table in JSON format */

/*_Include files_________________________________________________________*/

#if defined PWRE_CONF_RDKAFKA

#include <cstdint>
#include <algorithm>
#include <unistd.h>
#include <sstream>
#include <vector>

#include <glib.h>

#include "pwr.h"
#include "pwr_systemclasses.h"
#include "pwr_baseclasses.h"
#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "rt_errh.h"
#include "co_cdh.h"
#include "co_dcli.h"
#include "co_error.h"
#include "co_string.h"

typedef enum {
  gen_eFilter_All,
  gen_eFilter_Signals,
  gen_eFilter_Redu,
  gen_eFilter_SevHist
} gen_eFilter;

static char json_filename[] = "$pwrp_load/select.json";
static gen_eFilter filter = gen_eFilter_Signals;

std::vector<std::string> tmp_array;

std::string aref_to_str(pwr_tAttrRef &aref) {
  return "{\"Objid\":{\"oix\":" + std::to_string(aref.Objid.oix) + ",\"vid\":" + std::to_string(aref.Objid.vid) + "},\"Body\":" + std::to_string(aref.Body) + ",\"Offset\":" + std::to_string(aref.Offset) + ",\"Size\":" + std::to_string(aref.Size) + ",\"Flags\":" + std::to_string(aref.Flags.m) + "}";
}

void printObjectR(char* ap, char* aname, pwr_tAttrRef* arp, pwr_tCid cid) {
  gdh_sAttrDef* bd;
  int rows;
  pwr_tStatus sts = gdh_GetObjectBodyDef(cid, &bd, &rows, arp->Objid);
  if (EVEN(sts)) throw co_error(sts);

  for (int i = 0; i < rows; i++) {
    pwr_sParInfo pari = bd[i].attr->Param.Info;

    if (filter == gen_eFilter_Signals && !(pari.Flags & PWR_MASK_CLASS) && strcmp(bd[i].attrName, "ActualValue") != 0)
      continue;

    if (filter == gen_eFilter_Redu && !(pari.Flags & PWR_MASK_REDUTRANSFER))
      continue;

    if (pari.Flags & PWR_MASK_RTVIRTUAL || (pari.Flags & PWR_MASK_PRIVATE && pari.Flags & PWR_MASK_POINTER) || pari.Type == pwr_eType_Void)
      continue;

    pwr_tOName name, attrName;
    strcpy(name, aname);
    strcat(name, ".");
    strcat(name, bd[i].attrName);
    strcpy(attrName, bd[i].attrName);

    int elements = 1;
    if (pari.Flags & PWR_MASK_ARRAY)
      elements = pari.Elements;

    for (int j = 0; j < elements; j++) {
      if (pari.Flags & PWR_MASK_ARRAY) {
        char idx[20];
        sprintf(idx, "[%d]", j);
        strcpy(name, aname);
        strcat(name, ".");
        strcat(name, bd[i].attrName);
        strcat(name, idx);
        strcpy(attrName, bd[i].attrName);
        strcat(attrName, idx);
      }
      pwr_tAttrRef aref;
      sts = gdh_ArefANameToAref(arp, attrName, &aref);
      if (EVEN(sts)) throw co_error(sts);

      if (bd[i].attr->Param.Info.Flags & PWR_MASK_CLASS) {
        printObjectR(ap + pari.Offset + j * pari.Size / elements, name, &aref, pari.Type);
      } else {
        std::string tmp = "{\"name\":\"" + std::string(name) + "\",\"aref\":" + aref_to_str(aref) + ",\"type\":" + std::to_string(pari.Type) + ",\"flags\":" + std::to_string(pari.Flags) + ",\"enable\":1}";
        tmp_array.push_back(tmp);
      }
    }
  }
}

void printObject(pwr_tAttrRef* arp, char* aname) {
  pwr_tTid tid;
  pwr_tStatus sts = gdh_GetAttrRefTid(arp, &tid);
  if (EVEN(sts)) throw co_error(sts);

  if (arp->Flags.b.Object && arp->Size == 0) {
    sts = gdh_GetObjectSize(arp->Objid, &arp->Size);
    if (EVEN(sts)) throw co_error(sts);
  } else if (arp->Size == 0) {
    throw co_error(GDH__BADARG);
  }

  char* ap = (char*)calloc(1, arp->Size);
  memset(ap, 0, arp->Size);

  sts = gdh_GetObjectInfoAttrref(arp, ap, arp->Size);
  if (EVEN(sts)) {
    fprintf(stderr, "Couldn't get object info attr ref for object %s\n", aname);
    throw co_error(sts);
  }

  printObjectR(ap, aname, arp, tid);

  free(ap);
}

void dfs_helper(pwr_tOid oid) {
  pwr_tOName name;
  pwr_tCid cid;
  pwr_tStatus sts;
  pwr_tBoolean local;

  // Dismiss the security object, dynamic volumes and mounted remote objects
  sts = gdh_GetObjectLocation(oid, &local);
  if (EVEN(sts)) throw co_error(sts);

  if (!local)
    return;

  sts = gdh_GetObjectClass(oid, &cid);
  if (EVEN(sts)) throw co_error(sts);

  if (cid == pwr_cClass_Security || cid == pwr_cClass_DynamicVolume)
    return;

  sts = gdh_ObjidToName(oid, name, sizeof(name), cdh_mName_volumeStrict);
  if (EVEN(sts)) throw co_error(sts);

  pwr_tAttrRef aref = cdh_ObjidToAref(oid);

  printObject(&aref, name);

  pwr_tOid coid;
  pwr_tStatus sts2 = gdh_GetChild(oid, &coid);
  while (ODD(sts2)) {
    dfs_helper(coid);
    sts2 = gdh_GetNextSibling(coid, &coid);
  }
}

void usage() {
  printf("rs_export_gen [-f 'filter']\n\n"
	 "-f Filter, 'all', 'signals' or 'redu'. Default 'signals'\n\n");
}

int main(int argc, char**argv) {

  if (argc > 1 && streq(argv[1], "-h")) {
    usage();
    exit(0);      
  }


  if (argc > 2 && streq(argv[1], "-f")) {
    if (streq(argv[2], "all"))
      filter = gen_eFilter_All;
    else if (streq(argv[2], "signals"))
      filter = gen_eFilter_Signals;
    else if (streq(argv[2], "redu"))
      filter = gen_eFilter_Redu;
    else if (streq(argv[2], "sevhist"))
      filter = gen_eFilter_SevHist;
    else {
      usage();
      exit(0);
    }
  }
    
  pwr_tFileName fname;
  dcli_translate_filename(fname, json_filename);
  errh_Interactive();

  pwr_tStatus sts = gdh_Init("java_native");
  if (EVEN(sts)) {
    fprintf(stderr, "gdh_Init failed\n");
    return sts;
  }
  pwr_tOid oid;

  std::ostringstream json_string;
  json_string << "{\n";
  json_string << "  \"frequency\": 1,\n";
  json_string << "  \"batches\": 1,\n";
  json_string << "  \"signals\": [\n";

  sts = gdh_GetRootList(&oid);
  while (ODD(sts)) {
    if (oid.oix != 0x80000001)
      dfs_helper(oid);
    sts = gdh_GetNextSibling(oid, &oid);
  }
  std::sort(std::begin(tmp_array), std::end(tmp_array));
  for (int i = 0; i < tmp_array.size(); i++) {
    json_string << "    " << tmp_array[i];
    if (i < tmp_array.size() - 1) {
      json_string << ",";
    }
    json_string << "\n";
  }
  json_string << "  ]\n";
  json_string << "}";

  FILE* fp = fopen(fname, "w");
  if (!fp) return 1;
  fputs(json_string.str().c_str(), fp);
  fclose(fp);

  printf("%s generated with %d columns\n", fname, (int)tmp_array.size());

  return 0;
}

#else
#include <stdio.h>
int main()
{
  printf("rs_export_gen not built for this release\n");
  return 0;
}
#endif
