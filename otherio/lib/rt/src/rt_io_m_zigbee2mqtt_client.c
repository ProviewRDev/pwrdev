/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2025 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_io_m_zigbee2mqtt_client.c -- I/O methods for class Zigbee2MQTT_Client. */

#include <unistd.h>
#include <pthread.h>
#include <math.h>
#include <errno.h>

#include "co_cdh.h"
#include "co_string.h"
#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"
#include "rt_lck.h"
#include "rt_io_base.h"
#include "rt_io_rack_init.h"
#include "rt_io_rack_close.h"
#include "rt_io_msg.h"

#if defined PWRE_CONF_MQTT

#define debug 1

#include <mosquitto.h>
#include "rt_io_zigbee2mqtt_client.h"
#include "rs_remote_msg.h"

typedef enum {
  json_mOpt_remove_quotes = 1
} json_mOpt;

/* Callback from mosquitto when message is received */

static void rgb_to_xy(unsigned int rgb, float* x, float* y)
{
  float blue = rgb & 0xff / 0xff;
  float green = (rgb >> 8) & 0xff / 0xff;
  float red = (rgb << 16) & 0xff / 0xff;

  red = (red > 0.04045) ? pow((red + 0.055) / (1.0 + 0.055), 2.4) : (red / 12.92);
  green = (green > 0.04045) ? pow((green + 0.055) / (1.0 + 0.055), 2.4) : (green / 12.92);
  blue = (blue > 0.04045) ? pow((blue + 0.055) / (1.0 + 0.055), 2.4) : (blue / 12.92);
  float X = red * 0.664511 + green * 0.154324 + blue * 0.162028;
  float Y = red * 0.283881 + green * 0.668433 + blue * 0.047685;
  float Z = red * 0.000088 + green * 0.072310 + blue * 0.986039;
  *x = X / (X + Y + Z);
  *y = Y / (X + Y + Z);
}

static pwr_tStatus mqtt_error_to_sts(int err)
{
  pwr_tStatus sts = 0;

  switch (err) {
  case MOSQ_ERR_CONN_PENDING:
    sts = REM__TT_CONN_PENDING;
    break;
  case MOSQ_ERR_SUCCESS:
    sts = REM__SUCCESS;
    break;
  case MOSQ_ERR_NOMEM:
    sts = REM__TT_NOMEM;
    break;
  case MOSQ_ERR_PROTOCOL:
    sts = REM__TT_PROTOCOL;
    break;
  case MOSQ_ERR_INVAL:
    sts = REM__TT_INVAL;
    break;
  case MOSQ_ERR_NO_CONN:
    sts = REM__TT_NO_CONN;
    break;
  case MOSQ_ERR_CONN_REFUSED:
    sts = REM__TT_CONN_REFUSED;
    break;
  case MOSQ_ERR_NOT_FOUND:
    sts = REM__TT_NOT_FOUND;
    break;
  case MOSQ_ERR_CONN_LOST:
    sts = REM__TT_CONN_LOST;
    break;
  case MOSQ_ERR_TLS:
    sts = REM__TT_TLS;
    break;
  case MOSQ_ERR_PAYLOAD_SIZE:
    sts = REM__TT_PAYLOAD_SIZE;
    break;
  case MOSQ_ERR_NOT_SUPPORTED:
    sts = REM__TT_NOT_SUPPORTED;
    break;
  case MOSQ_ERR_AUTH:
    sts = REM__TT_AUTH;
    break;
  case MOSQ_ERR_ACL_DENIED:
    sts = REM__TT_ACL_DENIED;
    break;
  case MOSQ_ERR_UNKNOWN:
    sts = REM__TT_UNKNOWN;
    break;
  case MOSQ_ERR_ERRNO:
    sts = REM__TT_ERRNO;
    break;
  case MOSQ_ERR_EAI:
    sts = REM__TT_EAI;
    break;
  case MOSQ_ERR_PROXY:
    sts = REM__TT_PROXY;
    break;
  case MOSQ_ERR_PLUGIN_DEFER:
    sts = REM__TT_PLUGIN_DEFER;
    break;
  case MOSQ_ERR_MALFORMED_UTF8:
    sts = REM__TT_MALFORMED_UTF8;
    break;
  case MOSQ_ERR_KEEPALIVE:
    sts = REM__TT_KEEPALIVE;
    break;
  case MOSQ_ERR_LOOKUP:
    sts = REM__TT_LOOKUP;
    break;
  }
  return sts;
}

static int json_match(pwr_tCid chan_cid, const char *id, const pwr_eDataRepEnum rep, const char *msg, void *ovalue, int osize, unsigned int opt)
{
  char iname[80];
  char ivalue[80];
  strcpy(iname, id);
  char *s1 = strchr(iname, ':');
  if (!s1)
    return 0;
  *s1 = 0;
  str_trim(iname, iname);

  switch (chan_cid) {
  case pwr_cClass_ChanDi: {
    strcpy(ivalue, s1+1);
    str_trim(ivalue, ivalue);
  
    char *s2 = strstr(msg, iname);
    if (!s2)
      return 0;

    s2 += strlen(iname);
    while (*s2) {
      if (*s2 == ':')
	break;
      s2++;
    }
    if (*s2 == 0)
      return 0;
    s2++;

    while (*s2) {
      if (!(*s2 == ' ' || *s2 == '	'))
	break;
      s2++;
    }
    if (*s2 == 0)
      return 0;

    if (strncmp(ivalue, s2, strlen(ivalue)) == 0) {
      s2 += strlen(ivalue);
      if (*s2 == 0 || *s2 == ',' || *s2 == '}' || *s2 == ' ' || *s2 == '	') {
	*(pwr_tBoolean *)ovalue = 1;
	return 1;
      }
    }
    return 0;
  }
  case pwr_cClass_ChanDo: {
    char mvalue[80];

    strcpy(ivalue, s1+1);
    str_trim(ivalue, ivalue);
  
    char *s2 = strstr(msg, iname);
    if (!s2)
      return 0;

    s2 += strlen(iname);
    while (*s2) {
      if (*s2 == ':')
	break;
      s2++;
    }
    if (*s2 == 0)
      return 0;
    s2++;

    while (*s2) {
      if (!(*s2 == ' ' || *s2 == '	'))
	break;
      s2++;
    }
    if (*s2 == 0)
      return 0;

    strncpy(mvalue, s2, sizeof(mvalue));
    mvalue[sizeof(mvalue)-1] = 0;
    s1 = mvalue;
    while (*s1) {
      if (*s1 == 0 || *s1 == ',' || *s1 == '}' || *s1 == ' ' || *s1 == '	') {
	*s1 = 0;
	break;
      }
      s1++;
    }
	
    if (strncmp(mvalue, ivalue, strlen(mvalue)) == 0) {
      s2 = ivalue;
      s2 += strlen(mvalue);
      if (*s2 == 0 || *s2 == ',' || *s2 == '}' || *s2 == ' ' || *s2 == '	') {
	*(pwr_tBoolean *)ovalue = 1;
	return 1;
      }
    }
    else {
      s2 = strchr(ivalue, ',');
      if (!s2)
	return 0;
    
      s2++;
      while (*s2) {
	if (!(*s2 == ' ' || *s2 == '	'))
	  break;
	s2++;
      }
      if (*s2 == 0)
	return 0;
    
      if (strncmp(mvalue, s2, strlen(mvalue)) == 0) {
	s2 += strlen(mvalue);
	if (*s2 == 0 || *s2 == ',' || *s2 == '}' || *s2 == ' ' || *s2 == '	') {
	  *(pwr_tBoolean *)ovalue = 0;
	  return 1;
	}
      }
    }
  }
  case pwr_cClass_ChanIi:
  case pwr_cClass_ChanAi: {
    int n;
    char *s2 = strstr(msg, iname);
    if (!s2)
      return 0;

    s2 += strlen(iname);
    while (*s2) {
      if (*s2 == ':')
	break;
      s2++;
    }
    if (*s2 == 0)
      return 0;
    s2++;

    if (rep == pwr_eDataRepEnum_Float32)
      n = sscanf(s2, "%f", (pwr_tFloat32 *)ovalue);
    else
      n = sscanf(s2, "%d", (pwr_tInt32 *)ovalue);
    if (n > 0)
      return 1;
    return 0;
  }
  case pwr_cClass_ChanEi:
  case pwr_cClass_ChanSi: {
    int len;
    char *s2 = strstr(msg, iname);
    if (!s2)
      return 0;

    s2 += strlen(iname);
    while (*s2) {
      if (*s2 == ':')
	break;
      s2++;
    }
    s2++;
    while (*s2) {
      if (*s2 != ' ' && *s2 != '	')
	break;
      s2++;
    }
    if (*s2 == 0)
      return 0;

    char *s3 = strchr(s2+1, '\"');
    if (s3)
      len = s3 - s2 + 1;
    else
      len = strlen(s2);

    if (len > osize - 1) 
      return 0;

    if ((opt & json_mOpt_remove_quotes) && *s2 == '\"') {
      strncpy((char *)ovalue, s2+1, osize);
      ((char *)ovalue)[len - 1] = 0;
    } else {
      strncpy((char *)ovalue, s2, osize);
      ((char *)ovalue)[len] = 0;
    }

    s3 = ovalue + strlen(ovalue) - 1;
    while (s3 != ovalue) {
      if (*s3 != ' ' && *s3 != '	')
	break;
      s3--;
    }
    *(s3+1) = 0;
    if ((opt & json_mOpt_remove_quotes) && *s3 == '\"')
      *s3 = 0;

    return 1;
  }
  default:
    return 0;
  }
}

static int json_msg(char *id, pwr_tBoolean sigval, char *msg)
{
  char iname[80];
  char ivalue[80];
  strcpy(iname, id);
  char *s1 = strchr(iname, ':');
  if (!s1)
    return 0;
  *s1 = 0;
  if (sigval) {
    s1++;
    strcpy(ivalue, s1);
    s1 = strchr(ivalue, ',');
    if (!s1)
      return 0;
    *s1 = 0;
  } else {
    s1++;
    s1 = strchr(s1, ',');
    if (!s1)
      return 0;
    strcpy(ivalue, s1+1);
  }
  str_trim(ivalue, ivalue);
  str_trim(iname, iname);

  strcpy(msg, "{");
  strcat(msg, iname);
  strcat(msg, ":");
  strcat(msg, ivalue);
  strcat(msg, "}");
  return 1;
}

static int json_amsg(char *id, pwr_tInt32 sigval, char *msg)
{
  char iname[80];

  strcpy(iname, id);
  str_trim(iname, iname);

  sprintf(msg, "{%s%d}", iname, sigval);
  return 1;
}

static int json_fmsg(char *id, pwr_tFloat32 sigval, char *msg, int dec)
{
  char iname[80];

  strcpy(iname, id);
  str_trim(iname, iname);

  sprintf(msg, "{%s%.*f}", iname, dec, sigval);
  return 1;
}

static int json_smsg(char *id, char *sigval, char *msg)
{
  char iname[80];

  strcpy(iname, id);
  str_trim(iname, iname);

  sprintf(msg, "{%s\"%s\"}", iname, sigval);
  return 1;
}

static void message_cb(struct mosquitto *mosq, void *obj, 
    const struct mosquitto_message *msg)
{
  io_sRack* rp = (io_sRack *)obj;
  io_sCard *cp;
  bool match = 0;
  pwr_sClass_Zigbee2MQTT_Device *cop;
  io_sCardLocal* clocal;
  int i;
  int sts;
  
  if (msg->payloadlen > 0) {
    for (cp = rp->cardlist; cp; cp = cp->next) {
      cop = (pwr_sClass_Zigbee2MQTT_Device *)cp->op;
      clocal = cp->Local;
      mosquitto_topic_matches_sub(clocal->subscribe_topic, msg->topic, &match);
      
      if (match) {
	cop->SubscribeCount++;
	for (i = 0; i < cp->ChanListSize; i++) {
	  io_sChannel *chanp = &cp->chanlist[i];
	  if (!chanp->sop)
	    continue;
	  switch (chanp->ChanClass) {
	  case pwr_cClass_ChanDi: {
	    pwr_tBoolean value;
	    char *s1, *s2, *id;

	    id = ((pwr_sClass_ChanDi *)chanp->cop)->Identity;
	    if ((s1 = strstr(id, ",")) != 0 &&
		(s2 = strstr(id, ":")) != 0) {    
	      char ident1[40];
	      char ident2[40];
	      int idx1 = s1 - id;
	      int idx2 = s2 - id;
    
	      chanp->udata = 2;
	      strncpy(ident1, id, idx1);
	      ident1[idx1] = 0;
	      strncpy(ident2, id, idx2 + 1);
	      strcpy(&ident2[idx2+1], &id[idx1+1]);
	      sts = json_match(chanp->ChanClass, ident1, 0, (char*)msg->payload, &value, 0, 0);
	      if (ODD(sts)) 
		*(pwr_tBoolean *)chanp->vbp = 1;
	      else {
		sts = json_match(chanp->ChanClass, ident2, 0, (char*)msg->payload, &value, 0, 0);
		if (ODD(sts)) 
		  *(pwr_tBoolean *)chanp->vbp = 0;
	      }
	    } else {
	      sts = json_match(chanp->ChanClass, ((pwr_sClass_ChanDi *)chanp->cop)->Identity, 0, (char*)msg->payload, &value, 0, 0);
	      if (ODD(sts) && value) {
		*(pwr_tBoolean *)chanp->vbp = 1;
	      }
	    }
	    break;
	  }
	  case pwr_cClass_ChanDo: {
	    pwr_tBoolean value;

	    sts = json_match(chanp->ChanClass, ((pwr_sClass_ChanDo *)chanp->cop)->Identity, 0, (char*)msg->payload, &value, 0, 0);
	    if (ODD(sts)) {
	      if (*(pwr_tBoolean *)chanp->vbp != value) {
		*(pwr_tBoolean *)chanp->vbp = value;
	      }
	    }
	    break;
	  }
	  case pwr_cClass_ChanIi: {
	    pwr_tInt32 value;
	    sts = json_match(chanp->ChanClass, ((pwr_sClass_ChanIi *)chanp->cop)->Identity, 0, (char*)msg->payload, &value, 0, 0);
	    if (ODD(sts)) {
	      *(pwr_tInt32 *)chanp->vbp = value;
	    }
	    break;
	  }
	  case pwr_cClass_ChanEi: {
	    pwr_tTid tid = ((pwr_sClass_Ei *)chanp->sop)->CastActualValue;
	    gdh_sValueDef* valuedef;
	    int rows;
	    char enumstr[80];

	    sts = json_match(chanp->ChanClass, ((pwr_sClass_ChanEi *)chanp->cop)->Identity, 0, 
			     (char*)msg->payload, enumstr, sizeof(enumstr), json_mOpt_remove_quotes);

	    sts = gdh_GetEnumValueDef(tid, &valuedef, &rows);
	    if (EVEN(sts))
	      break;

	    for (int i = 0; i < rows; i++) {
	      if (strcmp(valuedef[i].Value->Text, enumstr) == 0) {
		*(pwr_tInt32 *)chanp->vbp = valuedef[i].Value->Value;
		break;
	      }
	    }
	    free((char*)valuedef);
	    break;
	  }
	  case pwr_cClass_ChanSi: {
	    char sdata[81];

	    sts = json_match(chanp->ChanClass, ((pwr_sClass_ChanSi *)chanp->cop)->Identity, 0, 
			     (char*)msg->payload, sdata, sizeof(sdata), json_mOpt_remove_quotes);

	    lck_LockStr;
	    strncpy((char*)chanp->vbp, sdata, sizeof(pwr_tString80));
	    lck_UnlockStr;

	    break;
	  }
	  case pwr_cClass_ChanAi: {
	    pwr_tInt32 ivalue;
	    pwr_tFloat32 fvalue;

	    if (((pwr_sClass_ChanAi *)chanp->cop)->Representation == pwr_eDataRepEnum_Float32) {
	      sts = json_match(chanp->ChanClass, ((pwr_sClass_ChanAi *)chanp->cop)->Identity, 
		  ((pwr_sClass_ChanAi *)chanp->cop)->Representation, (char*)msg->payload, &fvalue, 0, 0);
	      if (ODD(sts)) {
		fvalue = ((pwr_sClass_ChanAi *)chanp->cop)->SensorPolyCoef0 + 
                    ((pwr_sClass_ChanAi *)chanp->cop)->SensorPolyCoef1 * fvalue;
		*(pwr_tFloat32 *)chanp->vbp = fvalue;
	      }
	    } else {
	      sts = json_match(chanp->ChanClass, ((pwr_sClass_ChanAi *)chanp->cop)->Identity, ((pwr_sClass_ChanAi *)chanp->cop)->Representation, (char*)msg->payload, &ivalue, 0, 0);

	      if (ODD(sts)) {
		((pwr_sClass_Ai *)chanp->sop)->RawValue = ivalue;
		io_ConvertAi32((pwr_sClass_ChanAi *)chanp->cop, ivalue, &fvalue);
		*(pwr_tFloat32 *)chanp->vbp = fvalue;
	      }
	    }
	    break;
	  }
	  default: ;
	  }
	}
      }
    }
  }
}

static void connect_cb(struct mosquitto *mosq, void *obj, int result)
{
  io_sRack* rp = (io_sRack *)obj;
  io_sRackLocal* local = (io_sRackLocal *)rp->Local;
  pwr_sClass_Zigbee2MQTT_Client *op = (pwr_sClass_Zigbee2MQTT_Client*)rp->op;

  if(result){
    op->Status = mqtt_error_to_sts(result);
    local->connected = z2m_eCon_NotConnected;
    if (result == MOSQ_ERR_CONN_REFUSED) {
      errh_Fatal("Remote mqtt terminated, %s", mosquitto_connack_string(result));
      exit(0);
    }
  }
  else {
    if (local->is_subscriber) {
      mosquitto_subscribe(local->mosq, NULL, local->subscribe_topic, 0);
    }
    op->Status = REM__TT_CONNECTED;
    local->connected = z2m_eCon_Connected;
  }
}

static int mqtt_connect(io_sRack* rp)
{
  io_sRackLocal* local = (io_sRackLocal *)rp->Local;
  pwr_sClass_Zigbee2MQTT_Client *op = (pwr_sClass_Zigbee2MQTT_Client*)rp->op;

  int rc;
  char id[20];

  if (!local->mosq) {
    sprintf(id, "%u", rp->Objid.oix);
    local->mosq = mosquitto_new(id, true, rp);
    if (local->mosq == NULL) {
      if (errno == ENXIO) {
	op->Status = IO__NOMQTT;
	return op->Status;
      }
    }
  
    mosquitto_connect_callback_set(local->mosq, connect_cb);
    if (local->is_subscriber)
      mosquitto_message_callback_set(local->mosq, message_cb);

    if (strcmp(op->User, "") != 0)
      mosquitto_username_pw_set(local->mosq, op->User, op->Password);
    // mosquitto_tls_set(local->mosq, "ca-cert.pem", NULL, NULL, NULL, NULL);

    rc = mosquitto_connect(local->mosq, op->Server, op->Port, 60);
    if (rc) {
      op->Status = mqtt_error_to_sts(rc);
      return op->Status;
    }
    local->connected = z2m_eCon_WaitConnect;
  }
  else {
    rc = mosquitto_reconnect(local->mosq);
    if (rc) {
      op->Status = mqtt_error_to_sts(rc);
      return op->Status;
    }
  }
  return 1;
}

static void* mqtt_loop(void* arg)
{
  io_sRack *rp = (io_sRack *)arg;
  pwr_sClass_Zigbee2MQTT_Client* op = (pwr_sClass_Zigbee2MQTT_Client *)rp->op;
  io_sRackLocal* local = (io_sRackLocal *)rp->Local;
  int rc;

  while(1) {
    rc = mosquitto_loop(local->mosq, -1, 1);
    if (rc) {
      op->Status = mqtt_error_to_sts(rc);
      sleep(10);
      mosquitto_reconnect(local->mosq);
    }
  }

  return NULL;
}

static pwr_tStatus IoRackInit(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  io_sRackLocal* local;
  io_sCardLocal* clocal;
  pwr_sClass_Zigbee2MQTT_Client* op = (pwr_sClass_Zigbee2MQTT_Client *)rp->op;
  pwr_tStatus sts;
  pwr_tOName name;
  pwr_sClass_Zigbee2MQTT_Device *cop;
  io_sCard *cp;
  int i;
  
  sts = gdh_ObjidToName(rp->Objid, name, sizeof(name), cdh_mNName);
  errh_Info("Init of Zigbee2MQTT IO Client %s", name);

  rp->Local = calloc(1, sizeof(io_sRackLocal));
  local = rp->Local;
  strcpy(local->subscribe_topic, op->BaseTopic);
  strcat(local->subscribe_topic, "/#");

  if (streq(op->Server, ""))
    strcpy(op->Server, "localhost");

  for (cp = rp->cardlist; cp; cp = cp->next) {
    cp->Local = calloc(1, sizeof(io_sCardLocal));
    clocal = cp->Local;
    cop = (pwr_sClass_Zigbee2MQTT_Device *)cp->op;
    strcpy(clocal->subscribe_topic, op->BaseTopic);
    strcat(clocal->subscribe_topic, "/");
    strcat(clocal->subscribe_topic, cop->DeviceID);
    strcat(clocal->subscribe_topic, "/#");
    strcpy(clocal->publish_topic, op->BaseTopic);
    strcat(clocal->publish_topic, "/");
    strcat(clocal->publish_topic, cop->DeviceID);
    strcat(clocal->publish_topic, "/set");
    local->is_subscriber = 1;
    local->is_publisher = 1;
  }

  for (cp = rp->cardlist; cp; cp = cp->next) {
    clocal = cp->Local;
    int str_cnt = 0;
    for (i = 0; i < cp->ChanListSize; i++) {
      io_sChannel *chanp = &cp->chanlist[i];
      if (!chanp->sop)
	continue;
      switch (chanp->ChanClass) {
      case pwr_cClass_ChanAi:
	io_AiRangeToCoef(&cp->chanlist[i]);
	break;
      case pwr_cClass_ChanAo:
	io_AoRangeToCoef(&cp->chanlist[i]);
	break;
      case pwr_cClass_ChanSo:
	cp->chanlist[i].udata = str_cnt;
	str_cnt++;
	break;
      default: ;
      }
    }
    if (str_cnt)
      clocal->str_old = (pwr_tString80*)calloc(str_cnt, sizeof(pwr_tString80));
  }

  // Look for connect attributes
  for (cp = rp->cardlist; cp; cp = cp->next) {
    clocal = cp->Local;
    for (i = 0; i < cp->ChanListSize; i++) {
      io_sChannel *chanp = &cp->chanlist[i];
      if (!chanp->sop)
	continue;

      switch (chanp->ChanClass) {
      case pwr_cClass_ChanIo: {
	// brightness and transition
	if (strncmp(((pwr_sClass_ChanIo*)chanp->cop)->Identity, "\"brightness\"", 12) == 0) {
	  pwr_tTid tid;
	  pwr_tAttrRef aref, taref;

	  sts = gdh_AttrArefToObjectAref(&chanp->SigAref, &aref);
	  if (EVEN(sts))
	    break;
	  
	  sts = gdh_ArefANameToAref(&aref, "transition", &taref);
	  if (EVEN(sts))
	    break;

	  sts = gdh_GetAttrRefTid(&taref, &tid);
	  if (EVEN(sts) || tid != pwr_eType_Float32)
	    break;

	  sts = gdh_AttrRefToPointer(&taref, (void**)&clocal->transition_p);
	  if (EVEN(sts))
	    clocal->transition_p = 0;	    
	}
	break;
      }
      default: ;
      }
    }
  }

  /* Connect to mqtt server */
  sts = mqtt_connect(rp);
  if (sts == IO__NOMQTT)
    return sts;

  /* Create mosquitto loop thread */
  sts = pthread_create(&local->loop_thread, NULL, mqtt_loop, rp);

  for (cp = rp->cardlist; cp; cp = cp->next) {
    cop = (pwr_sClass_Zigbee2MQTT_Device *)cp->op;
    cop->Status = IO__SUCCESS;
  }
  return IO__SUCCESS;
}

static pwr_tStatus IoRackRead(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  io_sCard *cp;
  pwr_sClass_Zigbee2MQTT_Device *cop;
  int i;

  for (cp = rp->cardlist; cp; cp = cp->next) {
    cop = (pwr_sClass_Zigbee2MQTT_Device *)cp->op;

    for (i = 0; i < cp->ChanListSize; i++) {
      io_sChannel *chanp = &cp->chanlist[i];
      if (!chanp->sop)
	continue;
      switch (chanp->ChanClass) {
      case pwr_cClass_ChanDi:
	if (chanp->udata == 2)
	  break;
	if (*(pwr_tBoolean *)chanp->vbp) {
	  if (chanp->udata) {
	    *(pwr_tBoolean *)chanp->vbp = 0;
	    chanp->udata = 0;
	  }
	  else
	    chanp->udata = 1;
	}
	break;
      case pwr_cClass_ChanAi:
	if (((pwr_sClass_ChanAi *)chanp->cop)->CalculateNewCoef)
	  // Request to calculate new coefficients
	  io_AiRangeToCoef(chanp);
	break;
      case pwr_cClass_ChanAo:
	if (((pwr_sClass_ChanAo *)chanp->cop)->CalculateNewCoef)
	  // Request to calculate new coefficients
	  io_AoRangeToCoef(chanp);
	break;
      default: ;
      }
    }
  }
  return IO__SUCCESS;
}

static pwr_tStatus IoRackWrite(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  io_sRackLocal* local = (io_sRackLocal *)rp->Local;
  //pwr_sClass_Zigbee2MQTT_Client *op = (pwr_sClass_Zigbee2MQTT_Client*)rp->op;
  io_sCard *cp;
  io_sCardLocal* clocal;
  pwr_sClass_Zigbee2MQTT_Device *cop;
  int i;
  int sts;
  int rc;

  for (cp = rp->cardlist; cp; cp = cp->next) {
    cop = (pwr_sClass_Zigbee2MQTT_Device *)cp->op;

    for (i = 0; i < cp->ChanListSize; i++) {
      io_sChannel *chanp = &cp->chanlist[i];
      clocal = cp->Local;

      if (!chanp->sop)
	continue;
      switch (chanp->ChanClass) {
      case pwr_cClass_ChanDo:
	if (*(pwr_tBoolean *)chanp->vbp && !chanp->udata) {
	  /* Publish set */
	  char msg[200];

	  chanp->udata = 1;
	  sts = json_msg(((pwr_sClass_ChanDo *)chanp->cop)->Identity, 
			 *(pwr_tBoolean *)chanp->vbp, msg);

	  if (strncmp(((pwr_sClass_ChanDo *)chanp->cop)->Identity, "\"state\"", 7) == 0 &&
	      clocal->transition_p &&
	      *clocal->transition_p >= 0) {
	    sprintf(&msg[strlen(msg)-1], ",\"transition\":%.1f}", *clocal->transition_p);
	  }

	  rc = mosquitto_publish(local->mosq, NULL, clocal->publish_topic, strlen(msg), 
				 msg, 1, 0);
	  if (rc != 0)
	    cop->Status = mqtt_error_to_sts(rc);
	  else {
	    cop->Status = IO__SUCCESS;
	    cop->PublishCount++;
	  }
	}
	else if (!(*(pwr_tBoolean *)chanp->vbp) && chanp->udata) {
	  /* Publish reset */
	  char msg[200];

	  chanp->udata = 0;
	  sts = json_msg(((pwr_sClass_ChanDo *)chanp->cop)->Identity, 
			 *(pwr_tBoolean *)chanp->vbp, msg);

	  if (strncmp(((pwr_sClass_ChanDo *)chanp->cop)->Identity, "\"state\"", 7) == 0 &&
	      clocal->transition_p &&
	      *clocal->transition_p >= 0) {
	    sprintf(&msg[strlen(msg)-1], ",\"transition\":%.1f}", *clocal->transition_p);
	  }
	  rc = mosquitto_publish(local->mosq, NULL, clocal->publish_topic, strlen(msg), 
				 msg, 1, 0);
	  if (rc != 0)
	    cop->Status = mqtt_error_to_sts(rc);
	  else {
	    cop->Status = IO__SUCCESS;
	    cop->PublishCount++;
	  }
	}
	break;
      case pwr_cClass_ChanIo:
	if (*(pwr_tInt32 *)chanp->vbp != chanp->udata) {
	  /* Publish set */
	  pwr_tInt32 value;
	  char msg[200];

	  if (strcmp(((pwr_sClass_ChanIo *)chanp->cop)->Identity, "\"color\":") == 0) {
	    float x, y;

	    value = *(pwr_tInt32 *)chanp->vbp;
	    rgb_to_xy(value, &x, &y);
	    //sprintf(msg, "{\"color\":{\"x\":%5.3f,\"y\":%5.3f}}", x, y);
	    sprintf(msg, "{\"color\":{\"hex\":\"#%06X\"}}", value);
	    chanp->udata = *(pwr_tInt32 *)chanp->vbp;
	    rc = mosquitto_publish(local->mosq, NULL, clocal->publish_topic, strlen(msg), 
		msg, 1, 0);
	    if (rc != 0)
	      cop->Status = mqtt_error_to_sts(rc);
	    else {
	      cop->Status = IO__SUCCESS;
	      cop->PublishCount++;
	    }
	    break;
	  }

	  switch(((pwr_sClass_ChanIo *)chanp->cop)->RawValueType) {
	  case pwr_eRawValueTypeEnum_DeltaValue:
	    value = *(pwr_tInt32 *)chanp->vbp - chanp->udata;
	    break;
	  default:
	    value = *(pwr_tInt32 *)chanp->vbp;
	  }
	  chanp->udata = *(pwr_tInt32 *)chanp->vbp;
	  sts = json_amsg(((pwr_sClass_ChanIo *)chanp->cop)->Identity, 
			  value, msg);

	  rc = mosquitto_publish(local->mosq, NULL, clocal->publish_topic, strlen(msg), 
				 msg, 1, 0);
	  if (rc != 0)
	    cop->Status = mqtt_error_to_sts(rc);
	  else {
	    cop->Status = IO__SUCCESS;
	    cop->PublishCount++;
	  }
	}
	break;
      case pwr_cClass_ChanEo:
	if (*(pwr_tInt32 *)chanp->vbp != chanp->udata) {
	  /* Publish set */
	  pwr_tTid tid = ((pwr_sClass_Eo *)chanp->sop)->CastActualValue;
	  pwr_tInt32 value;
	  char msg[200];
	  gdh_sValueDef* valuedef;
	  int rows;
	  bool converted;
	  char enumstr[80];

	  value = *(pwr_tInt32 *)chanp->vbp;
	  chanp->udata = *(pwr_tInt32 *)chanp->vbp;

	  sts = gdh_GetEnumValueDef(tid, &valuedef, &rows);
	  if (EVEN(sts))
	    break;

	  for (int i = 0; i < rows; i++) {
	    if (valuedef[i].Value->Value == value) {
	      strcpy(enumstr, valuedef[i].Value->Text);
	      converted = true;
	      break;
	    }
	  }
	  free((char*)valuedef);

	  if (!converted)
	    break;

	  sts = json_smsg(((pwr_sClass_ChanEo *)chanp->cop)->Identity, 
			  enumstr, msg);

	  rc = mosquitto_publish(local->mosq, NULL, clocal->publish_topic, strlen(msg), 
				 msg, 1, 0);
	  if (rc != 0)
	    cop->Status = mqtt_error_to_sts(rc);
	  else {
	    cop->Status = IO__SUCCESS;
	    cop->PublishCount++;
	  }
	  *(pwr_tInt32 *)chanp->vbp = 0;
	}
	break;
      case pwr_cClass_ChanSo: {
	char sdata[81];

	if (((pwr_sClass_ChanSo *)chanp->cop)->Size > 80)
	  break;

	lck_LockStr;
	memcpy(sdata, (char*)chanp->vbp, sizeof(sdata));
	lck_UnlockStr;
	sdata[((pwr_sClass_ChanSo *)chanp->cop)->Size] = 0;

	if (strcmp(clocal->str_old[chanp->udata], sdata) != 0) {
	  strncpy(clocal->str_old[chanp->udata], sdata, sizeof(pwr_tString80));
	
	  /* Publish set */
	  char msg[200];

	  sts = json_smsg(((pwr_sClass_ChanSo *)chanp->cop)->Identity, 
	      sdata, msg);

	  rc = mosquitto_publish(local->mosq, NULL, clocal->publish_topic, strlen(msg), 
				 msg, 1, 0);
	  if (rc != 0)
	    cop->Status = mqtt_error_to_sts(rc);
	  else {
	    cop->Status = IO__SUCCESS;
	    cop->PublishCount++;
	  }
	}
	break;
      }
      case pwr_cClass_ChanAo: {
	if (((pwr_sClass_ChanAo *)chanp->cop)->Representation == pwr_eDataRepEnum_Float32) {
	  pwr_tFloat32 rawvalue, value, udata;

	  memcpy(&udata, &chanp->udata, sizeof(udata));

	  rawvalue = *(pwr_tFloat32*)chanp->vbp * 
		      ((pwr_sClass_ChanAo *)chanp->cop)->OutPolyCoef1
		      + ((pwr_sClass_ChanAo *)chanp->cop)->OutPolyCoef0;

	  if (fabs(rawvalue - udata) > FLT_EPSILON) {
	    /* Publish set */
	    char msg[200];

	    switch(((pwr_sClass_ChanAo *)chanp->cop)->RawValueType) {
	    case pwr_eRawValueTypeEnum_DeltaValue:
	      value = rawvalue - udata;
	      break;
	    default:
	      value = rawvalue;
	    }
	    memcpy(&chanp->udata, &rawvalue, sizeof(chanp->udata));

	    int dec = ((pwr_sClass_Ao *)chanp->sop)->NoOfDecimals;
	    sts = json_fmsg(((pwr_sClass_ChanAo *)chanp->cop)->Identity, 
			    value, msg, dec);

	    rc = mosquitto_publish(local->mosq, NULL, clocal->publish_topic, strlen(msg), 
				   msg, 1, 0);
	    if (rc != 0)
	      cop->Status = mqtt_error_to_sts(rc);
	    else {
	      cop->Status = IO__SUCCESS;
	      cop->PublishCount++;
	    }
	    ((pwr_sClass_Ao *)chanp->sop)->RawValue = rawvalue;
	  }
	} else {
	  pwr_tInt32 rawvalue, value;

	  rawvalue = round(*(pwr_tFloat32*)chanp->vbp * 
		      ((pwr_sClass_ChanAo *)chanp->cop)->OutPolyCoef1
		      + ((pwr_sClass_ChanAo *)chanp->cop)->OutPolyCoef0);

	  if (rawvalue != chanp->udata) {
	    /* Publish set */
	    char msg[200];

	    switch(((pwr_sClass_ChanAo *)chanp->cop)->RawValueType) {
	    case pwr_eRawValueTypeEnum_DeltaValue:
	      value = rawvalue - chanp->udata;
	      break;
	    default:
	      value = rawvalue;
	    }
	    chanp->udata = rawvalue;
	    sts = json_amsg(((pwr_sClass_ChanAo *)chanp->cop)->Identity, 
			    value, msg);

	    rc = mosquitto_publish(local->mosq, NULL, clocal->publish_topic, strlen(msg), 
				   msg, 1, 0);
	    if (rc != 0)
	      cop->Status = mqtt_error_to_sts(rc);
	    else {
	      cop->Status = IO__SUCCESS;
	      cop->PublishCount++;
	    }
	    ((pwr_sClass_Ao *)chanp->sop)->RawValue = rawvalue;
	  }
	}
	break;
      }
      default: ;
      }
    }
  }

  return IO__SUCCESS;
}

static pwr_tStatus IoRackClose(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  io_sRackLocal* local = (io_sRackLocal *)rp->Local;

  mosquitto_disconnect(local->mosq);
  pthread_cancel(local->loop_thread);
  free(local);
  rp->Local = 0;
  return IO__SUCCESS;
}

#else
static pwr_tStatus IoRackInit(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  return IO__RELEASEBUILD;
}
static pwr_tStatus IoRackClose(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  return IO__RELEASEBUILD;
}
static pwr_tStatus IoRackRead(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  return IO__RELEASEBUILD;
}
static pwr_tStatus IoRackWrite(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  return IO__RELEASEBUILD;
}
#endif

/*  Every method should be registred here. */

pwr_dExport pwr_BindIoMethods(Zigbee2MQTT_Client) = { pwr_BindIoMethod(IoRackInit),
    pwr_BindIoMethod(IoRackClose), pwr_BindIoMethod(IoRackRead), 
    pwr_BindIoMethod(IoRackWrite), pwr_NullMethod};
