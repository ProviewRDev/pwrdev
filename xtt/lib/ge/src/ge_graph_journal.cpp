/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2025 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <iostream>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_log.h"
#include "co_string.h"
#include "co_time.h"
#include "co_error.h"

#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "rt_load.h"

#include "cow_wow.h"

#include "flow_browctx.h"

#include "glow_curveapi.h"
#include "glow_msg.h"

#include "ge_dyn.h"
#include "ge_msg.h"

#define journal_cTag_Undo 80000009
#define journal_cTag_Redo 80000010
#define journal_cTag_Object 80000011
#define journal_cTag_Size 80000012
#define journal_cTag_Layer 80000013
#define journal_cTag_Target 80000014
#define journal_cTag_End 80009999

static char* gname(const char* name)
{
  static char n[80];
  char* s;

  if ((s = (char*)strrchr(name, '/')))
    strncpy(n, s + 1, sizeof(n));
  else
    strncpy(n, name, sizeof(n));
  if ((s = strchr(n, '.')))
    *s = 0;

  return n;
}

GraphJournal::GraphJournal(Graph* g, int* sts)
    : graph(g), status(journal_eStatus_Empty), current_idx(0)
{
  strcpy(graphname, "");
  strcpy(filename, "");
  strcpy(rename_name, "");
  strcpy(active_layer, "");

  // Open default file
  *sts = open("nameless_$$");
}

GraphJournal::~GraphJournal()
{
  if (fp) {
    fp.close();

    // Remove file
    pwr_tCmd cmd;
    sprintf(cmd, "rm %s", filename);
    system(cmd);
  }
}

int GraphJournal::open(const char* name)
{
  pwr_tFileName fname;
  pwr_tFileName new_filename;
  char new_graphname[80];
  pwr_tTime time;
  int sts;
  bool restored = false;

  poslist.clear();
  current_idx = 0;
  status = journal_eStatus_Empty;

  if (fp && !streq(filename, "")) {
    fp.close();

    // Remove file
    pwr_tCmd cmd;
    sprintf(cmd, "rm %s", filename);
    system(cmd);
  }

  strcpy(new_graphname, gname(name));

  sprintf(fname, "$pwrp_tmp/%s.gjl", new_graphname);
  dcli_translate_filename(new_filename, fname);

  if (!streq(graphname, new_graphname)) {
    if (ODD(dcli_file_time(new_filename, &time))) {
      if (graph->create_modal_dialog_cb) {
        sts = (graph->create_modal_dialog_cb)(graph->parent_ctx, "Restore",
            "A journal file from previous session is found.\n\nDo you want to "
            "restore the previous session ?",
            "  Yes  ", "   No   ", "Cancel", 0);
        switch (sts) {
        case wow_eModalDialogReturn_Button1:
          restore(new_filename);
          restored = true;
          break;
        case wow_eModalDialogReturn_Button2:
        case wow_eModalDialogReturn_Button3:
        case wow_eModalDialogReturn_Deleted:
          break;
        }
      }
    }
  }

  strcpy(graphname, new_graphname);
  strcpy(filename, new_filename);
  if (!restored) {
    fp.open(filename, std::ios::in | std::ios::out | std::ios::trunc);
    if (!fp) {
      printf("Unable to open journal file %s\n", filename);
      return GE__FILEOPEN;
    }
  }
  return GE__SUCCESS;
}

int GraphJournal::clear(char* name)
{
  poslist.clear();
  current_idx = 0;
  status = journal_eStatus_Empty;

  fp.close();

  // Check if new name
  if (name) {
    char g[80];
    pwr_tFileName fname;

    strcpy(g, gname(name));
    if (!streq(g, graphname)) {
      // Remove old file
      pwr_tCmd cmd;
      sprintf(cmd, "rm %s", filename);
      system(cmd);

      strcpy(graphname, g);
      sprintf(fname, "$pwrp_tmp/%s.gjl", graphname);
      dcli_translate_filename(filename, fname);
    }
  }

  fp.open(filename, std::ios::in | std::ios::out | std::ios::trunc);
  if (!fp) {
    printf("Unable to open journal file %s\n", filename);
    return GE__FILEOPEN;
  }
  return GE__SUCCESS;
}

int GraphJournal::store(journal_eAction action, grow_tObject o)
{
  static grow_tObject lock_object = 0;
  int sts;

  switch (action) {
  case journal_eAction_AntePropertiesSelect:
  case journal_eAction_PostPropertiesSelect:
  case journal_eAction_DeleteSelect:
  case journal_eAction_UngroupSelect:
  case journal_eAction_PopSelect:
  case journal_eAction_PushSelect: {
    grow_tObject* sel_list;
    int sel_count;

    grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
    if (sel_count == 0) {
      return GE__SUCCESS;
    }
    break;
  }
  default:;
  }

  if (status == journal_eStatus_AnteProperties
      && !((action == journal_eAction_PostPropertiesObject
               || action == journal_eAction_PostPropertiesSelect)
             && o == lock_object)) {
    log_debug("Unfinished action, forced close\n");
    // Close prevoius action
    poslist[current_idx].redo_pos = fp.tellp();
    fp << journal_cTag_Redo << " " << journal_eAction_No << " " << status << " "
       << current_idx << '\n';

    current_idx++;
    status = journal_eStatus_Stored;
    lock_object = 0;

    log_debug("Store(F)x: %3d  list: %3zd undo: %10d redo: %10d\n",
          current_idx - 1, poslist.size() - 1,
          (int)poslist[poslist.size() - 1].undo_pos,
          (int)poslist[poslist.size() - 1].redo_pos);
  }
  if ((status != journal_eStatus_AnteProperties
          || (status == journal_eStatus_AnteProperties && lock_object != o))
      && (action == journal_eAction_PostPropertiesObject
             || action == journal_eAction_PostPropertiesSelect)) {
    log_debug("Interrupted action, reopening\n");
    // Open prevoius action
    JournalPos up;

    switch (status) {
    case journal_eStatus_Stored:
    case journal_eStatus_Redo:
    case journal_eStatus_Undo:
      fp.seekp(poslist[current_idx - 1].end_pos);
      break;
    default:;
    }

    while ((int)poslist.size() > current_idx) {
      log_debug("Remove %zd\n", poslist.size() - 1);
      poslist.pop_back();
    }

    up.undo_pos = fp.tellp();
    poslist.push_back(up);
    fp << journal_cTag_Undo << " " << journal_eAction_No << " " << status << " "
       << current_idx << '\n';

    status = journal_eStatus_AnteProperties;
  }

  if (action == journal_eAction_AntePropertiesSelect
      || action == journal_eAction_AntePropertiesObject
      || action == journal_eAction_AnteGroupSelect
      || action == journal_eAction_AntePaste
      || action == journal_eAction_AnteRename
      || action == journal_eAction_AnteActivateLayer
      || action == journal_eAction_AnteMoveToLayer
      || action == journal_eAction_AnteSelectObject
      || action == journal_eAction_AnteSelectReset
      || action == journal_eAction_AnteSelectRegion
      || action == journal_eAction_AnteSelectRegionAdd
      || action == journal_eAction_AnteOrderObject) {
    switch (status) {
    case journal_eStatus_Stored:
      break;
    case journal_eStatus_Redo:
      fp.seekp(poslist[current_idx - 1].end_pos);
      break;
    case journal_eStatus_Undo:
      if (poslist[current_idx].redo_pos < poslist[current_idx].undo_pos)
        fp.seekp(poslist[current_idx].redo_pos);
      else
        fp.seekp(poslist[current_idx].undo_pos);
      break;
    default:;
    }

    while ((int)poslist.size() > current_idx) {
      log_debug("Remove %zd\n", poslist.size() - 1);
      poslist.pop_back();
    }

    JournalPos up;

    try {
      switch (action) {
      case journal_eAction_AntePropertiesSelect:
	up.undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_properties_select();
	status = journal_eStatus_AnteProperties;
	lock_object = o;
	break;
      case journal_eAction_AntePropertiesObject:
	up.undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_properties_object(o);
	status = journal_eStatus_AnteProperties;
	lock_object = o;
	break;
      case journal_eAction_AnteGroupSelect:
	up.redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_group_select();
	status = journal_eStatus_AnteGroup;
	break;
      case journal_eAction_AntePaste:
	up.undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_undo_paste();
	status = journal_eStatus_AntePaste;
	break;
      case journal_eAction_AnteRename: {
	grow_GetObjectName(
	    o, rename_name, sizeof(rename_name), glow_eName_Object);
	break;
      }
      case journal_eAction_AnteActivateLayer: {
	grow_tObject layer;

	strcpy(active_layer, "");
	sts = grow_GetActiveLayer(graph->grow->ctx, &layer);
	if (ODD(sts))
	  grow_GetObjectName(layer, active_layer, sizeof(active_layer),
	      glow_eName_Object);
	break;
      }
      case journal_eAction_AnteMoveToLayer: {
	grow_tObject *list;
	int list_cnt;
	grow_tObject prev;

	movelist.clear();
	grow_GetSelectList(graph->grow->ctx, &list, &list_cnt);
	for (int i = 0; i < list_cnt; i++) {
	  MoveObject mo;

	  sts = grow_GetPreviousObject(graph->grow->ctx, list[i], &prev);
	  if (ODD(sts))
	    grow_GetObjectName(prev, mo.name_prev, sizeof(mo.name_prev), glow_eName_Path);
	  grow_GetObjectName(list[i], mo.name, sizeof(mo.name), glow_eName_Path);
	  movelist.push_back(mo);	  
	}
	break;
      }
      case journal_eAction_AnteSelectObject:
      case journal_eAction_AnteSelectReset:
      case journal_eAction_AnteSelectRegion:
      case journal_eAction_AnteSelectRegionAdd: {
	grow_tObject *list;
	int list_cnt;
      
	movelist.clear();
	grow_GetSelectList(graph->grow->ctx, &list, &list_cnt);
	for (int i = 0; i < list_cnt; i++) {
	  MoveObject mo;
	  grow_GetObjectName(list[i], mo.name, sizeof(mo.name),
	      glow_eName_Path);
	  movelist.push_back(mo);
	}
	break;
      }
      case journal_eAction_AnteOrderObject: {
	grow_tObject prev;
	MoveObject mo;

	movelist.clear();

	grow_GetObjectName(
	    o, mo.name, sizeof(mo.name), glow_eName_Object);

	sts = grow_GetPreviousObject(graph->grow->ctx, o, &prev);
	if (ODD(sts))
	  grow_GetObjectName(prev, mo.name_prev, sizeof(mo.name_prev), 
	      glow_eName_Path);
	movelist.push_back(mo);
	break;
      }
      default:;
      }
    } catch (co_error& e) {
      std::cerr << "** Write journal file: " << e.what();
      graph->message('E', e.what().c_str());
    }
    poslist.push_back(up);
    fp.flush();
    return GE__SUCCESS;
  }
  if (action == journal_eAction_PostPropertiesSelect
      || action == journal_eAction_PostPropertiesObject
      || action == journal_eAction_PostGroupSelect
      || action == journal_eAction_PostPaste
      || action == journal_eAction_PostRename
      || action == journal_eAction_PostActivateLayer
      || action == journal_eAction_PostMoveToLayer
      || action == journal_eAction_PostSelectObject
      || action == journal_eAction_PostSelectReset
      || action == journal_eAction_PostSelectRegion
      || action == journal_eAction_PostSelectRegionAdd
      || action == journal_eAction_PostOrderObject) {
    if (current_idx >= (int)poslist.size()) {
      std::cerr << "Journal file disorder\n";
      return GE__SUCCESS;
    }

    try {
      switch (action) {
      case journal_eAction_PostPropertiesSelect:
	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_properties_select();
	break;
      case journal_eAction_PostPropertiesObject:
	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_properties_object(o);
	break;
      case journal_eAction_PostGroupSelect:
	poslist[current_idx].undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_undo_group_select(o);
	break;
      case journal_eAction_PostPaste:
	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_paste();
	break;
      case journal_eAction_PostRename:
	poslist[current_idx].undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_undo_rename(o);

	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_rename(o);
	break;
      case journal_eAction_PostActivateLayer:
	poslist[current_idx].undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_undo_activate_layer(o);

	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_activate_layer(o);
	break;
      case journal_eAction_PostMoveToLayer:
	poslist[current_idx].undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_undo_move_to_layer(o);

	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_move_to_layer(o);
	break;
      case journal_eAction_PostSelectObject:
	poslist[current_idx].undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_undo_select_object(o);

	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_select_object(o);
	break;
      case journal_eAction_PostSelectReset:
	poslist[current_idx].undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_undo_select_reset();

	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_select_reset();
	break;
      case journal_eAction_PostSelectRegion:
	poslist[current_idx].undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_undo_select_region();

	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_select_region();
	break;
      case journal_eAction_PostSelectRegionAdd:
	poslist[current_idx].undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
         << current_idx << '\n';
	store_undo_select_region_add();

	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_select_region_add();
	break;
      case journal_eAction_PostOrderObject:
	poslist[current_idx].undo_pos = fp.tellp();
	fp << journal_cTag_Undo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_undo_order_object(o);

	poslist[current_idx].redo_pos = fp.tellp();
	fp << journal_cTag_Redo << " " << action << " " << status << " "
	   << current_idx << '\n';
	store_redo_order_object(o);
	break;

      default:;
      }
    } catch (co_error& e) {
      std::cerr << "** Read journal file: " << e.what();
      graph->message('E', e.what().c_str());
    }
    poslist[current_idx].end_pos = fp.tellp();

    status = journal_eStatus_Stored;

    current_idx++;

    log_debug("Store idx: %3d  list: %3zd undo: %10d redo: %10d\n",
          current_idx - 1, poslist.size() - 1,
          (int)poslist[poslist.size() - 1].undo_pos,
          (int)poslist[poslist.size() - 1].redo_pos);

    fp.flush();
    return GE__SUCCESS;
  }

  switch (status) {
  case journal_eStatus_Stored:
    break;
  case journal_eStatus_Redo:
    fp.seekp(poslist[current_idx - 1].end_pos);
    break;
  case journal_eStatus_Undo:
    if (poslist[current_idx].redo_pos < poslist[current_idx].undo_pos)
      fp.seekp(poslist[current_idx].redo_pos);
    else
      fp.seekp(poslist[current_idx].undo_pos);
    break;
  default:;
  }

  while ((int)poslist.size() > current_idx) {
    log_debug("Remov idx: %3d  list: %3zd undo: %10d redo: %10d\n", 0,
          poslist.size() - 1, (int)poslist[poslist.size() - 1].undo_pos,
          (int)poslist[poslist.size() - 1].redo_pos);
    poslist.pop_back();
  }

  JournalPos up;
  up.redo_pos = fp.tellp();
  fp << journal_cTag_Redo << " " << action << " " << status << " "
     << current_idx << '\n';

  status = journal_eStatus_Stored;

  switch (action) {
  case journal_eAction_DeleteSelect:
    store_redo_delete_select();
    break;
  case journal_eAction_DeleteObject:
    store_redo_delete_object(o);
    break;
  case journal_eAction_CreateObject:
    store_redo_create_object(o);
    break;
  case journal_eAction_UngroupSelect:
    store_redo_ungroup_select();
    break;
  case journal_eAction_PopSelect:
    store_redo_pop_select();
    break;
  case journal_eAction_PushSelect:
    store_redo_push_select();
    break;
  case journal_eAction_InactivateLayer:
    store_redo_inactivate_layer(o);
    break;
  case journal_eAction_SetLayerVisible:
    store_redo_set_layer_visible(o);
    break;
  case journal_eAction_SetLayerInvisible:
    store_redo_set_layer_invisible(o);
    break;
  case journal_eAction_SelectObjectAdd:
    store_redo_select_object_add(o);
    break;
  case journal_eAction_MergeAllLayers:
    store_redo_merge_all_layers();
    break;
  case journal_eAction_MergeVisibleLayersToBg:
    store_redo_merge_visible_layers_to_bg();
    break;
  case journal_eAction_MergeVisibleLayers:
    store_redo_merge_visible_layers();
    break;
  default:;
  }

  up.undo_pos = fp.tellp();
  fp << journal_cTag_Undo << " " << action << " " << status << " "
     << current_idx << '\n';

  switch (action) {
  case journal_eAction_DeleteSelect:
    store_undo_delete_select();
    break;
  case journal_eAction_DeleteObject:
    store_undo_delete_object(o);
    break;
  case journal_eAction_CreateObject:
    store_undo_create_object(o);
    break;
  case journal_eAction_UngroupSelect:
    store_undo_ungroup_select();
    break;
  case journal_eAction_PopSelect:
    store_undo_pop_select();
    break;
  case journal_eAction_PushSelect:
    store_undo_push_select();
    break;
  case journal_eAction_InactivateLayer:
    store_undo_inactivate_layer(o);
    break;
  case journal_eAction_SetLayerVisible:
    store_undo_set_layer_visible(o);
    break;
  case journal_eAction_SetLayerInvisible:
    store_undo_set_layer_invisible(o);
    break;
  case journal_eAction_SelectObjectAdd:
    store_undo_select_object_add(o);
    break;
  case journal_eAction_MergeAllLayers:
    store_undo_merge_all_layers();
    break;
  case journal_eAction_MergeVisibleLayersToBg:
    store_undo_merge_visible_layers_to_bg();
    break;
  case journal_eAction_MergeVisibleLayers:
    store_undo_merge_visible_layers();
    break;
  default:;
  }

  up.end_pos = fp.tellp();
  poslist.push_back(up);
  current_idx++;

  log_debug("Store idx: %3d  list: %3zd undo: %10d redo: %10d\n",
        current_idx - 1, poslist.size() - 1,
        (int)poslist[poslist.size() - 1].undo_pos,
        (int)poslist[poslist.size() - 1].redo_pos);

  fp.flush();
  return GE__SUCCESS;
}

int GraphJournal::undo()
{
  int tag;
  int action;
  char line[100];
  int idx;

  if (current_idx == 0)
    return 0;

  log_debug("Undo  idx: %3d  list: %3zd undo: %10d redo: %10d\n",
        current_idx - 1, poslist.size() - 1,
        (int)poslist[current_idx - 1].undo_pos,
        (int)poslist[current_idx - 1].redo_pos);

  fp.seekp(poslist[current_idx - 1].undo_pos);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d %d %d %d", &tag, &action, (int*)&status, &idx);

  status = journal_eStatus_Undo;

  if (tag != journal_cTag_Undo) {
    std::cerr << "Journal file disorder, unable to undo\n";
    return 0;
  }

  try {
    switch (action) {
    case journal_eAction_DeleteSelect:
      undo_delete_select();
      break;
    case journal_eAction_DeleteObject:
      undo_delete_object();
      break;
    case journal_eAction_CreateObject:
      undo_create_object();
      break;
    case journal_eAction_AntePropertiesSelect:
    case journal_eAction_PostPropertiesSelect:
      undo_properties_select();
      break;
    case journal_eAction_AntePropertiesObject:
    case journal_eAction_PostPropertiesObject:
      undo_properties_object();
      break;
    case journal_eAction_AnteGroupSelect:
    case journal_eAction_PostGroupSelect:
      undo_group_select();
      break;
    case journal_eAction_UngroupSelect:
      undo_ungroup_select();
      break;
    case journal_eAction_AntePaste:
    case journal_eAction_PostPaste:
      undo_paste();
      break;
    case journal_eAction_PopSelect:
      undo_pop_select();
      break;
    case journal_eAction_PushSelect:
      undo_push_select();
      break;
    case journal_eAction_AnteRename:
    case journal_eAction_PostRename:
      undo_rename();
      break;
    case journal_eAction_AnteActivateLayer:
    case journal_eAction_PostActivateLayer:
      undo_activate_layer();
      break;
    case journal_eAction_InactivateLayer:
      undo_inactivate_layer();
      break;
    case journal_eAction_SetLayerVisible:
      undo_set_layer_visible();
      break;
    case journal_eAction_SetLayerInvisible:
      undo_set_layer_invisible();
      break;
    case journal_eAction_AnteMoveToLayer:
    case journal_eAction_PostMoveToLayer:
      undo_move_to_layer();
      break;
    case journal_eAction_AnteSelectObject:
    case journal_eAction_PostSelectObject:
      undo_select_object();
      break;
    case journal_eAction_SelectObjectAdd:
      undo_select_object_add();
      break;
    case journal_eAction_AnteSelectReset:
    case journal_eAction_PostSelectReset:
      undo_select_reset();
      break;
    case journal_eAction_AnteSelectRegion:
    case journal_eAction_PostSelectRegion:
      undo_select_region();
      break;
    case journal_eAction_AnteSelectRegionAdd:
    case journal_eAction_PostSelectRegionAdd:
      undo_select_region_add();
      break;
    case journal_eAction_MergeAllLayers:
      undo_merge_all_layers();
      break;
    case journal_eAction_MergeVisibleLayersToBg:
      undo_merge_visible_layers_to_bg();
      break;
    case journal_eAction_MergeVisibleLayers:
      undo_merge_visible_layers();
      break;
    case journal_eAction_AnteOrderObject:
    case journal_eAction_PostOrderObject:
      undo_order_object();
      break;
    case journal_eAction_No:
      break;
    default:;
    }
  } catch (co_error& e) {
    std::cerr << "** Read journal file: " << e.what();
    graph->message('E', e.what().c_str());
  }

  current_idx--;
  return GE__SUCCESS;
}

int GraphJournal::redo()
{
  std::streampos pos;
  std::streampos ipos;
  int tag;
  int action;
  char line[100];
  int idx;

  if (current_idx >= (int)poslist.size())
    return 0;

  log_debug("Redo  idx: %3d  list: %3zd undo: %10d redo: %10d\n", current_idx,
        poslist.size() - 1, (int)poslist[current_idx].undo_pos,
        (int)poslist[current_idx].redo_pos);

  if (poslist[current_idx].redo_pos == (std::streampos)-1)
    return 0;

  fp.seekp(poslist[current_idx].redo_pos);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d %d %d %d", &tag, &action, (int*)&status, &idx);

  status = journal_eStatus_Redo;

  if (tag != journal_cTag_Redo) {
    std::cerr << "Journal file disorder, unable to undo\n";
    return 0;
  }

  try {
    switch (action) {
    case journal_eAction_DeleteSelect:
      redo_delete_select();
      break;
    case journal_eAction_DeleteObject:
      redo_delete_object();
      break;
    case journal_eAction_CreateObject:
      redo_create_object();
      break;
    case journal_eAction_AntePropertiesSelect:
    case journal_eAction_PostPropertiesSelect:
      undo_properties_select();
      break;
    case journal_eAction_AntePropertiesObject:
    case journal_eAction_PostPropertiesObject:
      undo_properties_object();
      break;
    case journal_eAction_AnteGroupSelect:
    case journal_eAction_PostGroupSelect:
      redo_group_select();
      break;
    case journal_eAction_UngroupSelect:
      redo_ungroup_select();
      break;
    case journal_eAction_AntePaste:
    case journal_eAction_PostPaste:
      redo_paste();
      break;
    case journal_eAction_PopSelect:
      redo_pop_select();
      break;
    case journal_eAction_PushSelect:
      redo_push_select();
      break;
    case journal_eAction_AnteRename:
    case journal_eAction_PostRename:
      redo_rename();
      break;
    case journal_eAction_AnteActivateLayer:
    case journal_eAction_PostActivateLayer:
      redo_activate_layer();
      break;
    case journal_eAction_InactivateLayer:
      redo_inactivate_layer();
      break;
    case journal_eAction_SetLayerVisible:
      redo_set_layer_visible();
      break;
    case journal_eAction_SetLayerInvisible:
      redo_set_layer_invisible();
      break;
    case journal_eAction_AnteMoveToLayer:
    case journal_eAction_PostMoveToLayer:
      redo_move_to_layer();
      break;
    case journal_eAction_AnteSelectObject:
    case journal_eAction_PostSelectObject:
      redo_select_object();
      break;
    case journal_eAction_SelectObjectAdd:
      redo_select_object_add();
      break;
    case journal_eAction_AnteSelectReset:
    case journal_eAction_PostSelectReset:
      redo_select_reset();
      break;
    case journal_eAction_AnteSelectRegion:
    case journal_eAction_PostSelectRegion:
      redo_select_region();
      break;
    case journal_eAction_AnteSelectRegionAdd:
    case journal_eAction_PostSelectRegionAdd:
      redo_select_region_add();
      break;
    case journal_eAction_MergeAllLayers:
      redo_merge_all_layers();
      break;
    case journal_eAction_MergeVisibleLayersToBg:
      redo_merge_visible_layers_to_bg();
      break;
    case journal_eAction_MergeVisibleLayers:
      redo_merge_visible_layers();
      break;
    case journal_eAction_AnteOrderObject:
    case journal_eAction_PostOrderObject:
      redo_order_object();
      break;
    case journal_eAction_No:
      break;
    default:;
    }
  } catch (co_error& e) {
    std::cerr << "** Read journal file: " << e.what();
    graph->message('E', e.what().c_str());
  }

  current_idx++;

  return GE__SUCCESS;
}

void GraphJournal::read_tag(int tag)
{
  char line[100];
  int val;

  fp.getline(line, sizeof(line));
  if (!fp)
    throw co_error(GE__JOURNAL_DISORDER);

  sscanf(line, "%d", &val);

  if (val != tag)
    throw co_error(GE__JOURNAL_DISORDER);
}

void GraphJournal::read_str(int tag, char *name, int size)
{
  char line[100];
  int val;

  fp.getline(line, sizeof(line));
  if (!fp)
    throw co_error(GE__JOURNAL_DISORDER);

  sscanf(line, "%d", &val);

  if (val != tag)
    throw co_error(GE__JOURNAL_DISORDER);

  fp.getline(name, size);
  if (!fp)
    throw co_error(GE__JOURNAL_DISORDER);
}

void GraphJournal::read_int(int tag, int* value)
{
  char line[100];
  int t;
  int num;

  fp.getline(line, sizeof(line));
  if (!fp)
    throw co_error(GE__JOURNAL_DISORDER);

  sscanf(line, "%d", &t);

  if (t != tag)
    throw co_error(GE__JOURNAL_DISORDER);

  fp.getline(line, sizeof(line));
  if (!fp)
    throw co_error(GE__JOURNAL_DISORDER);

  num = sscanf(line, "%d", value);
  if (num != 1)
    throw co_error(GE__JOURNAL_DISORDER);
}

int GraphJournal::undo_delete_select()
{
  grow_tObject o;
  char line[100];
  int tag;
  char name_prev[80];
  char name_layer[80];
  grow_tObject prev;
  grow_tObject layer;
  grow_tObject active_layer;
  int sts;

  log_debug("undo_delete_select\n");

  grow_SetNodraw(graph->grow->ctx);

  sts = grow_GetActiveLayer(graph->grow->ctx, &active_layer);
  if (EVEN(sts))
    active_layer = 0;

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while ( tag == journal_cTag_Object) {
    fp.getline(name_layer, sizeof(name_layer));
    fp.getline(name_prev, sizeof(name_prev));
    
    if (!streq(name_layer,"")) {
      sts = grow_FindLayerByName(graph->grow->ctx, name_layer, &layer);
      if (EVEN(sts)) {
	grow_ResetNodraw(graph->grow->ctx);
	grow_Redraw(graph->grow->ctx);
	throw co_error(sts);
      }
    }
    else
      layer = grow_GetBackgroundLayer(graph->grow->ctx);

    if (layer != active_layer)
      grow_LayerSetActive(layer, 1);
    
    grow_ObjectRead(graph->grow->ctx, (std::ifstream&)fp, &o);
    if (!o) {
      grow_ResetNodraw(graph->grow->ctx);
      grow_Redraw(graph->grow->ctx);
      return GE__SUCCESS;
    }
    if (streq(name_prev, "")) {
      grow_OrderObject(graph->grow->ctx, o, 0, glow_eDest_Before);
    } else {
      sts = grow_FindObjectByName(graph->grow->ctx, name_prev, &prev);
      if (ODD(sts)) {
        grow_OrderObject(graph->grow->ctx, o, prev, glow_eDest_After);
      }
    }

    if (active_layer == 0)
      grow_LayerSetActive(layer, 0);
    else if (layer != active_layer)
      grow_LayerSetActive(active_layer, 1);
 
    fp.get();
    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_delete_select()
{
  grow_tObject* sel_list;
  int sel_count;
  grow_tObject prev;
  int sts;
  char name[80];

  log_debug("store_undo_delete_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = sel_count - 1; i >= 0; i--) {

    sts = grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Layer);
    fp << journal_cTag_Object << '\n';
    if (ODD(sts))
      fp << name << '\n';
    else
      fp << '\n';    

    sts = grow_GetPreviousObject(graph->grow->ctx, sel_list[i], &prev);
    if (ODD(sts)) {
      grow_GetObjectName(prev, name, sizeof(name), glow_eName_Path);
      fp << name << '\n';
    } else
      fp << '\n';    
    grow_ObjectSave(sel_list[i], (std::ofstream&)fp, glow_eSaveMode_Edit);
  }
  fp << journal_cTag_End << '\n';
  return GE__SUCCESS;
}

int GraphJournal::store_redo_delete_select()
{
  char name[80];
  grow_tObject* sel_list;
  int sel_count;

  log_debug("store_redo_delete_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = 0; i < sel_count; i++) {
    grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Path);

    fp << journal_cTag_Object << '\n';
    fp << name << '\n';
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_delete_select()
{
  char name[80];
  grow_tObject o;
  int sts;
  char line[100];
  int tag;

  log_debug("redo_delete_select\n");

  grow_SetNodraw(graph->grow->ctx);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    fp.getline(name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (ODD(sts))
      grow_DeleteObject(graph->grow->ctx, o);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  return GE__SUCCESS;
}

int GraphJournal::undo_delete_object()
{
  grow_tObject o;
  grow_tObject prev;
  char name_prev[80];
  int sts;

  log_debug("undo_delete_object\n");

  read_str(journal_cTag_Object, name_prev, sizeof(name_prev));

  grow_ObjectRead(graph->grow->ctx, (std::ifstream&)fp, &o);
  grow_Redraw(graph->grow->ctx);

  if (streq(name_prev, "")) {
    grow_OrderObject(graph->grow->ctx, o, 0, glow_eDest_Before);
  } else {
    sts = grow_FindObjectByName(graph->grow->ctx, name_prev, &prev);
    if (ODD(sts)) {
      grow_OrderObject(graph->grow->ctx, o, prev, glow_eDest_After);
    }
  }

  if (grow_GetObjectType(o) == glow_eObjectType_GrowLayer) 
    grow_LayerSetActive(o, 1);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_delete_object(grow_tObject o)
{
  grow_tObject prev;
  char name[80];
  int sts;

  log_debug("store_undo_delete_object\n");

  fp << journal_cTag_Object << '\n';
  sts = grow_GetPreviousObject(graph->grow->ctx, o, &prev);
  if (ODD(sts)) {
    grow_GetObjectName(prev, name, sizeof(name), glow_eName_Path);
    fp << name << '\n';
  }
  else 
    fp << '\n';

  grow_ObjectSave(o, (std::ofstream&)fp, glow_eSaveMode_Edit);
  return GE__SUCCESS;
}

int GraphJournal::store_redo_delete_object(grow_tObject o)
{
  char name[80];

  log_debug("store_redo_delete_object\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << name << '\n';
  return GE__SUCCESS;
}

int GraphJournal::redo_delete_object()
{
  char name[80];
  grow_tObject o;
  int sts;

  log_debug("redo_delete_object\n");

  fp.getline(name, sizeof(name));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (ODD(sts))
    grow_DeleteObject(graph->grow->ctx, o);

  return GE__SUCCESS;
}

int GraphJournal::undo_create_object()
{
  char name[80];
  grow_tObject o;
  int sts;

  log_debug("undo_create_object\n");

  fp.getline(name, sizeof(name));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (ODD(sts))
    grow_DeleteObject(graph->grow->ctx, o);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_create_object(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_create_object\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << name << '\n';
  return GE__SUCCESS;
}

int GraphJournal::redo_create_object()
{
  grow_tObject o;

  log_debug("redo_create_object\n");

  grow_ObjectRead(graph->grow->ctx, (std::ifstream&)fp, &o);
  if (!o)
    return GE__SUCCESS;

  check_object_number(o);
  grow_Redraw(graph->grow->ctx);
  return GE__SUCCESS;
}

int GraphJournal::store_redo_create_object(grow_tObject o)
{
  log_debug("store_redo_create_object\n");

  grow_ObjectSave(o, (std::ofstream&)fp, glow_eSaveMode_Edit);
  return GE__SUCCESS;
}

int GraphJournal::undo_properties_select()
{
  grow_tObject o;
  char line[100];
  int tag;
  char name[80];
  int sts;

  log_debug("undo_properties_select\n");

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    fp.getline(name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (ODD(sts))
      grow_ObjectOpen(o, (std::ifstream&)fp);

    fp.get();
    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  grow_Redraw(graph->grow->ctx);

  return GE__SUCCESS;
}

int GraphJournal::store_properties_select()
{
  grow_tObject* sel_list;
  int sel_count;
  char name[80];

  log_debug("store_properties_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = 0; i < sel_count; i++) {
    grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);

    fp << journal_cTag_Object << '\n';
    fp << name << '\n';
    grow_ObjectSave(sel_list[i], (std::ofstream&)fp, glow_eSaveMode_Edit);
  }
  fp << journal_cTag_End << '\n';
  return GE__SUCCESS;
}

int GraphJournal::undo_properties_object()
{
  grow_tObject o;
  char line[100];
  int tag;
  char name[80];
  int sts;

  log_debug("undo_properties_object\n");

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  if (tag != journal_cTag_Object)
    return 0;

  fp.getline(name, sizeof(name));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (EVEN(sts))
    return GE__SUCCESS;

  grow_ObjectOpen(o, (std::ifstream&)fp);

  fp.get();
  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  grow_Redraw(graph->grow->ctx);

  return GE__SUCCESS;
}

int GraphJournal::store_properties_object(grow_tObject o)
{
  char name[80];

  log_debug("store_properties_object\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  grow_ObjectSave(o, (std::ofstream&)fp, glow_eSaveMode_Edit);
  fp << journal_cTag_End << '\n';
  return GE__SUCCESS;
}

int GraphJournal::undo_group_select()
{
  grow_tObject o;
  char line[100];
  char name[80];
  int tag;
  int sts;

  log_debug("undo_group_select\n");

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  if (tag != journal_cTag_Object)
    return 0;

  fp.getline(name, sizeof(name));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (ODD(sts))
    grow_UngroupGroup(graph->grow->ctx, o);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_group_select(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_group_select\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';
  return GE__SUCCESS;
}

int GraphJournal::store_redo_group_select()
{
  char name[80];
  grow_tObject* sel_list;
  int sel_count;

  log_debug("store_redo_group_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = 0; i < sel_count; i++) {
    grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);

    fp << journal_cTag_Object << '\n';
    fp << name << '\n';
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_group_select()
{
  char name[80];
  grow_tObject o;
  int sts;
  char line[100];
  int tag;
  char group_name[80];
  char last_group_name[80];
  grow_tObject group;
  GeDyn* data;

  log_debug("redo_group_select\n");

  grow_SelectClear(graph->grow->ctx);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    fp.getline(name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (ODD(sts))
      grow_SelectInsert(graph->grow->ctx, o);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  // Read group name
  fp.getline(line, sizeof(line));
  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  if (tag != journal_cTag_Object)
    throw co_error(GE__JOURNAL_DISORDER);

  fp.getline(line, sizeof(line));
  strcpy(group_name, line);

  sts = grow_GroupSelect(graph->grow->ctx, &group, last_group_name);
  grow_SelectClear(graph->grow->ctx);

  // Rename to previous name
  sts = grow_FindObjectByName(graph->grow->ctx, group_name, &o);
  if (EVEN(sts))
    grow_SetObjectName(group, group_name);

  if (!streq(last_group_name, "")) {
    // Try to recover dynamics
    sts = graph->recall.get(&data, last_group_name);
    if (ODD(sts)) {
      graph->set_recall_data(group, last_group_name);
      return GE__SUCCESS;
    }
  }
  GeDyn* dyn = new GeDyn(graph);
  grow_SetUserData(group, (void*)dyn);

  return GE__SUCCESS;
}

int GraphJournal::undo_ungroup_select()
{
  char name[80];
  grow_tObject o;
  int sts;
  char line[100];
  int tag;
  char group_name[80];
  char last_group_name[80];
  grow_tObject group;
  GeDyn* data;

  for (;;) {
    grow_SelectClear(graph->grow->ctx);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);

    if (tag != journal_cTag_Object)
      break;
    fp.getline(group_name, sizeof(group_name));

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);

    while (tag == journal_cTag_Object) {
      fp.getline(name, sizeof(name));

      sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
      if (ODD(sts))
        grow_SelectInsert(graph->grow->ctx, o);

      fp.getline(line, sizeof(line));
      sscanf(line, "%d", &tag);
    }
    if (tag != journal_cTag_End)
      throw co_error(GE__JOURNAL_DISORDER);

    sts = grow_GroupSelect(graph->grow->ctx, &group, last_group_name);
    grow_SelectClear(graph->grow->ctx);

    // Rename to previous name
    sts = grow_FindObjectByName(graph->grow->ctx, group_name, &o);
    if (EVEN(sts))
      grow_SetObjectName(group, group_name);

    if (!streq(last_group_name, "")) {
      // Try to recover dynamics
      sts = graph->recall.get(&data, last_group_name);
      if (ODD(sts)) {
        graph->set_recall_data(group, last_group_name);
        return GE__SUCCESS;
      }
    }
    GeDyn* dyn = new GeDyn(graph);
    grow_SetUserData(group, (void*)dyn);
  }

  return GE__SUCCESS;
}

int GraphJournal::store_undo_ungroup_select()
{
  char name[80];
  grow_tObject* sel_list;
  int sel_count;
  grow_tObject* member_list;
  int member_count;

  log_debug("store_undo_ungroup_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = 0; i < sel_count; i++) {
    if (grow_GetObjectType(sel_list[i]) == glow_eObjectType_GrowGroup) {
      grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);

      fp << journal_cTag_Object << '\n';
      fp << name << '\n';

      grow_GetGroupObjectList(sel_list[i], &member_list, &member_count);
      for (int j = 0; j < member_count; j++) {
        grow_GetObjectName(
            member_list[j], name, sizeof(name), glow_eName_Object);

        fp << journal_cTag_Object << '\n';
        fp << name << '\n';
      }
      fp << journal_cTag_End << '\n';
    }
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::store_redo_ungroup_select()
{
  char name[80];
  grow_tObject* sel_list;
  int sel_count;

  log_debug("store_redo_ungroup_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = 0; i < sel_count; i++) {
    if (grow_GetObjectType(sel_list[i]) == glow_eObjectType_GrowGroup) {
      grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);

      fp << journal_cTag_Object << '\n';
      fp << name << '\n';
    }
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_ungroup_select()
{
  grow_tObject o;
  char line[100];
  char name[80];
  int tag;
  int sts;

  log_debug("redo_ungroup_select\n");

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    fp.getline(name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (ODD(sts))
      grow_UngroupGroup(graph->grow->ctx, o);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  return GE__SUCCESS;
}

int GraphJournal::undo_paste()
{
  char name[80];
  grow_tObject o;
  int sts;
  char line[100];
  int tag;

  log_debug("undo_paste\n");

  grow_SetNodraw(graph->grow->ctx);
  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    fp.getline(name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (ODD(sts))
      grow_DeleteObject(graph->grow->ctx, o);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_paste()
{
  char name[80];
  grow_tObject* move_list;
  int move_count;

  log_debug("store_undo_paste\n");

  grow_GetMoveList(graph->grow->ctx, &move_list, &move_count);
  for (int i = 0; i < move_count; i++) {
    pastelist.push_back(move_list[i]);
    grow_GetObjectName(move_list[i], name, sizeof(name), glow_eName_Object);

    fp << journal_cTag_Object << '\n';
    fp << name << '\n';
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_paste()
{
  grow_tObject o;
  char line[100];
  int tag;

  log_debug("redo_paste\n");

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    grow_ObjectRead(graph->grow->ctx, (std::ifstream&)fp, &o);
    if (!o)
      return GE__SUCCESS;

    fp.get();
    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  grow_Redraw(graph->grow->ctx);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_paste()
{
  log_debug("store_redo_paste\n");

  grow_SetNodraw(graph->grow->ctx);
  for (int i = 0; i < (int)pastelist.size(); i++) {
    fp << journal_cTag_Object << '\n';
    grow_ObjectSave(pastelist[i], (std::ofstream&)fp, glow_eSaveMode_Edit);
  }
  fp << journal_cTag_End << '\n';
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  pastelist.clear();
  return GE__SUCCESS;
}

int GraphJournal::undo_pop_select()
{
  grow_tObject o;
  grow_tObject next;
  char line[100];
  char name[80];
  char name_next[80];
  int tag;
  int sts;

  log_debug("undo_pop_select\n");

  grow_SetNodraw(graph->grow->ctx);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    fp.getline(name, sizeof(name));
    fp.getline(name_next, sizeof(name_next));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (ODD(sts)) {
      if (streq(name_next, "")) {
        grow_OrderObject(graph->grow->ctx, o, 0, glow_eDest_After);
      } else {
        sts = grow_FindObjectByName(graph->grow->ctx, name_next, &next);
        if (ODD(sts)) {
          grow_OrderObject(graph->grow->ctx, o, next, glow_eDest_Before);
        }
      }
    }
    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_pop_select()
{
  grow_tObject* sel_list;
  int sel_count;
  char name[80];
  grow_tObject next;
  int sts;

  log_debug("store_undo_pop_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = sel_count - 1; i >= 0; i--) {
    fp << journal_cTag_Object << '\n';
    grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);

    fp << name << '\n';

    sts = grow_GetNextObject(graph->grow->ctx, sel_list[i], &next);
    if (ODD(sts)) {
      grow_GetObjectName(next, name, sizeof(name), glow_eName_Object);
      fp << name << '\n';
    } else
      fp << '\n';
  }
  fp << journal_cTag_End << '\n';
  return GE__SUCCESS;
}

int GraphJournal::store_redo_pop_select()
{
  char name[80];
  grow_tObject* sel_list;
  int sel_count;

  log_debug("store_redo_pop_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = 0; i < sel_count; i++) {
    grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);

    fp << journal_cTag_Object << '\n';
    fp << name << '\n';
  }
  fp << journal_cTag_End << '\n';
  return GE__SUCCESS;
}

int GraphJournal::redo_pop_select()
{
  char name[80];
  grow_tObject o;
  int sts;
  char line[100];
  int tag;

  log_debug("redo_pop_select\n");

  grow_SetNodraw(graph->grow->ctx);
  grow_SelectClear(graph->grow->ctx);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    fp.getline(name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (ODD(sts))
      grow_SelectInsert(graph->grow->ctx, o);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_PopSelectedObjects(graph->grow->ctx);
  grow_SelectClear(graph->grow->ctx);
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  return GE__SUCCESS;
}

int GraphJournal::undo_push_select()
{
  grow_tObject o;
  grow_tObject next;
  char line[100];
  char name[80];
  char name_next[80];
  int tag;
  int sts;

  log_debug("undo_push_select\n");

  grow_SetNodraw(graph->grow->ctx);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    fp.getline(name, sizeof(name));
    fp.getline(name_next, sizeof(name_next));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (ODD(sts)) {
      if (streq(name_next, "")) {
        grow_OrderObject(graph->grow->ctx, o, 0, glow_eDest_After);
      } else {
        sts = grow_FindObjectByName(graph->grow->ctx, name_next, &next);
        if (ODD(sts)) {
          grow_OrderObject(graph->grow->ctx, o, next, glow_eDest_Before);
        }
      }
    }
    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_push_select()
{
  grow_tObject* sel_list;
  int sel_count;
  char name[80];
  grow_tObject next;
  int sts;

  log_debug("store_undo_push_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = sel_count - 1; i >= 0; i--) {
    fp << journal_cTag_Object << '\n';
    grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);

    fp << name << '\n';

    sts = grow_GetNextObject(graph->grow->ctx, sel_list[i], &next);
    if (ODD(sts)) {
      grow_GetObjectName(next, name, sizeof(name), glow_eName_Object);
      fp << name << '\n';
    } else
      fp << '\n';
  }
  fp << journal_cTag_End << '\n';
  return GE__SUCCESS;
}

int GraphJournal::store_redo_push_select()
{
  char name[80];
  grow_tObject* sel_list;
  int sel_count;

  log_debug("store_redo_push_select\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
  for (int i = 0; i < sel_count; i++) {
    grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);

    fp << journal_cTag_Object << '\n';
    fp << name << '\n';
  }
  fp << journal_cTag_End << '\n';
  return GE__SUCCESS;
}

int GraphJournal::redo_push_select()
{
  char name[80];
  grow_tObject o;
  int sts;
  char line[100];
  int tag;

  log_debug("redo_push_select\n");

  grow_SetNodraw(graph->grow->ctx);
  grow_SelectClear(graph->grow->ctx);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Object) {
    fp.getline(name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (ODD(sts))
      grow_SelectInsert(graph->grow->ctx, o);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_PushSelectedObjects(graph->grow->ctx);
  grow_SelectClear(graph->grow->ctx);
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  return GE__SUCCESS;
}

int GraphJournal::undo_rename()
{
  grow_tObject o;
  char name_old[80];
  char name_new[80];
  int sts;

  log_debug("undo_rename\n");

  read_str(journal_cTag_Object, name_new, sizeof(name_new));
  read_str(journal_cTag_Object, name_old, sizeof(name_old));

  sts = grow_FindObjectByName(graph->grow->ctx, name_new, &o);
  if (ODD(sts))
    grow_SetObjectName(o, name_old);

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_rename(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_rename\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_Object << '\n';
  fp << rename_name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::store_redo_rename(grow_tObject o)
{
  char name[80];

  log_debug("store_redo_rename\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_Object << '\n';
  fp << rename_name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_rename()
{
  grow_tObject o;
  char name_old[80];
  char name_new[80];
  int sts;

  log_debug("redo_rename\n");

  read_str(journal_cTag_Object, name_new, sizeof(name_new));
  read_str(journal_cTag_Object, name_old, sizeof(name_old));

  sts = grow_FindObjectByName(graph->grow->ctx, name_old, &o);
  if (ODD(sts))
    grow_SetObjectName(o, name_new);

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::undo_activate_layer()
{
  grow_tObject o;
  int sts;
  char new_layer[80];
  char old_layer[80];

  log_debug("undo_activate_layer\n");
  
  read_str(journal_cTag_Object, new_layer, sizeof(new_layer));
  read_str(journal_cTag_Object, old_layer, sizeof(old_layer));

  if (strcmp(old_layer, "") != 0) {
    sts = grow_FindLayerByName(graph->grow->ctx, old_layer, &o);
    if (ODD(sts)) {
      grow_LayerSetActive(o, 1);
      graph->refresh_objects(attr_mRefresh_Objects);
    }
  } else {
    sts = grow_FindLayerByName(graph->grow->ctx, new_layer, &o);
    if (ODD(sts))
      grow_LayerSetActive(o, 0);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_activate_layer(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_activate_layer\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_Object << '\n';
  fp << active_layer << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_activate_layer()
{
  grow_tObject o;
  int sts;
  char new_layer[80];
  char old_layer[80];

  log_debug("redo_activate_layer\n");

  read_str(journal_cTag_Object, new_layer, sizeof(new_layer));
  read_str(journal_cTag_Object, old_layer, sizeof(old_layer));

  sts = grow_FindLayerByName(graph->grow->ctx, new_layer, &o);
  if (ODD(sts)) {
    grow_LayerSetActive(o, 1);
    graph->refresh_objects(attr_mRefresh_Objects);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_activate_layer(grow_tObject o)
{
  char name[80];
  log_debug("store_redo_activate_layer\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_Object << '\n';
  fp << active_layer << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_inactivate_layer()
{
  grow_tObject o;
  int sts;
  char layer[80];

  log_debug("undo_inactivate_layer\n");

  read_str(journal_cTag_Object, layer, sizeof(layer));

  sts = grow_FindLayerByName(graph->grow->ctx, layer, &o);
  if (ODD(sts)) {
    grow_LayerSetActive(o, 1);
    graph->refresh_objects(attr_mRefresh_Objects);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_inactivate_layer(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_inactivate_layer\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_inactivate_layer()
{
  grow_tObject o;
  int sts;
  char layer[80];

  log_debug("redo_inactivate_layer\n");

  read_str(journal_cTag_Object, layer, sizeof(layer));

  sts = grow_FindLayerByName(graph->grow->ctx, layer, &o);
  if (ODD(sts)) {
    grow_LayerSetActive(o, 0);
    graph->refresh_objects(attr_mRefresh_Objects);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_inactivate_layer(grow_tObject o)
{
  char name[80];
  log_debug("store_redo_inactivate_layer\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_set_layer_visible()
{
  grow_tObject o;
  int sts;
  char layer[80];

  log_debug("undo_set_layer_visible\n");

  read_str(journal_cTag_Object, layer, sizeof(layer));

  sts = grow_FindLayerByName(graph->grow->ctx, layer, &o);
  if (ODD(sts)) {
    grow_SetObjectVisibility(o, glow_eVis_Invisible);
    graph->refresh_objects(attr_mRefresh_Objects);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_set_layer_visible(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_set_layer_visible\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_set_layer_visible()
{
  grow_tObject o;
  int sts;
  char layer[80];

  log_debug("redo_set_layer_visible\n");

  read_str(journal_cTag_Object, layer, sizeof(layer));

  sts = grow_FindLayerByName(graph->grow->ctx, layer, &o);
  if (ODD(sts)) {
    grow_SetObjectVisibility(o, glow_eVis_Visible);
    graph->refresh_objects(attr_mRefresh_Objects);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_set_layer_visible(grow_tObject o)
{
  char name[80];
  log_debug("store_redo_set_layer_visible\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_set_layer_invisible()
{
  grow_tObject o;
  int sts;
  char layer[80];

  log_debug("undo_set_layer_invisible\n");

  read_str(journal_cTag_Object, layer, sizeof(layer));

  sts = grow_FindLayerByName(graph->grow->ctx, layer, &o);
  if (ODD(sts)) {
    grow_SetObjectVisibility(o, glow_eVis_Visible);
    graph->refresh_objects(attr_mRefresh_Objects);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_set_layer_invisible(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_set_layer_invisible\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_set_layer_invisible()
{
  grow_tObject o;
  int sts;
  char layer[80];

  log_debug("redo_set_layer_invisible\n");

  read_str(journal_cTag_Object, layer, sizeof(layer));

  sts = grow_FindLayerByName(graph->grow->ctx, layer, &o);
  if (ODD(sts)) {
    grow_SetObjectVisibility(o, glow_eVis_Invisible);
    graph->refresh_objects(attr_mRefresh_Objects);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_set_layer_invisible(grow_tObject o)
{
  char name[80];
  log_debug("store_redo_set_layer_invisible\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_move_to_layer()
{
  grow_tObject o;
  grow_tObject layer;
  grow_tObject prev;
  int sts;
  char layername[80];
  char name[80];
  char name_prev[80];
  char target[80];
  char oname[80];
  int object_cnt;
  int to_layer = 0;
  grow_tObject targetlayer = 0;
  char *s;

  log_debug("undo_move_to_layer\n");

  read_str(journal_cTag_Object, layername, sizeof(layername));

  sts = grow_FindLayerByName(graph->grow->ctx, layername, &layer);
  if (EVEN(sts))
    throw co_error(sts);

  read_int(journal_cTag_Size, &object_cnt);

  for (int i = 0; i < object_cnt; i++) {

    read_str(journal_cTag_Target, name_prev, sizeof(name_prev));
    read_str(journal_cTag_Object, name, sizeof(name));
    to_layer = 0;
    strcpy(target, name);
    s = strrchr(target, '-');
    if (s) {
      *s = 0;
      s++;
      to_layer = 1;
    }
    else
      s = target;

    strcpy(oname, layername);
    strcat(oname, "-");
    strcat(oname, s);

    if (to_layer) {
      sts = grow_FindLayerByName(graph->grow->ctx, target, &targetlayer);
      if (EVEN(sts))
	throw co_error(sts);
    }
    else
      targetlayer = grow_GetBackgroundLayer(graph->grow->ctx);

    sts = grow_FindObjectByName(graph->grow->ctx, oname, &o);
    if (EVEN(sts))
      throw co_error(sts);

    sts = grow_LayerRemove(layer, o);
    if (EVEN(sts)) 
      throw co_error(sts);
    sts = grow_LayerInsert(targetlayer, o);
    if (EVEN(sts))
      throw co_error(sts);

    if (streq(name_prev, "")) {
      grow_OrderObject(graph->grow->ctx, o, 0, glow_eDest_Before);
    } else {
      sts = grow_FindObjectByName(graph->grow->ctx, name_prev, &prev);
      if (ODD(sts)) {
	grow_OrderObject(graph->grow->ctx, o, prev, glow_eDest_After);
      }
    }
  }

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Objects);
  graph->refresh_objects(attr_mRefresh_Select);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_move_to_layer(grow_tObject o)
{
  char name[80] = "";
  grow_tObject layer;
  int sts;

  log_debug("store_undo_move_to_layer\n");

  sts = grow_GetActiveLayer(graph->grow->ctx, &layer);
  if (ODD(sts))
    grow_GetObjectName(layer, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_Size << '\n';
  fp << movelist.size() << '\n';
  for (int i = 0; i < movelist.size(); i++) {
    fp << journal_cTag_Target << '\n';
    fp << movelist[i].name_prev << '\n';
    fp << journal_cTag_Object << '\n';
    fp << movelist[i].name << '\n';
  }
  fp << journal_cTag_End << '\n';
  return GE__SUCCESS;
}

int GraphJournal::redo_move_to_layer()
{
  grow_tObject o;
  grow_tObject layer;
  int sts;
  char layername[80];
  char name[80];
  int object_cnt;
  grow_tObject targetlayer = 0;

  log_debug("redo_move_to_layer\n");

  read_str(journal_cTag_Object, layername, sizeof(layername));

  sts = grow_FindLayerByName(graph->grow->ctx, layername, &targetlayer);
  if (EVEN(sts))
    throw co_error(sts);

  read_int(journal_cTag_Size, &object_cnt);

  for (int i = 0; i < object_cnt; i++) {
    read_str(journal_cTag_Object, name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (EVEN(sts))
      throw co_error(sts);

    grow_GetObjectParent(o, &layer);
    sts = grow_LayerRemove(layer, o);
    if (EVEN(sts))
      throw co_error(sts);
    sts = grow_LayerInsert(targetlayer, o);
    if (EVEN(sts))
      throw co_error(sts);
  }

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Objects);



  return GE__SUCCESS;
}

int GraphJournal::store_redo_move_to_layer(grow_tObject o)
{
  char name[80];
  grow_tObject layer;
  int sts;
  log_debug("store_redo_move_to_layer\n");

  sts = grow_GetActiveLayer(graph->grow->ctx, &layer);
  if (ODD(sts))
    grow_GetObjectName(layer, name, sizeof(name),
	glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';

  fp << journal_cTag_Size << '\n';
  fp << movelist.size() << '\n';
  for (int i = 0; i < movelist.size(); i++) {
    fp << journal_cTag_Object << '\n';
    fp << movelist[i].name << '\n';
  }
  fp << journal_cTag_End << '\n';
  movelist.clear();

  return GE__SUCCESS;
}

int GraphJournal::undo_select_object()
{
  grow_tObject o;
  int sts;
  char name[80];
  int object_cnt;

  log_debug("undo_select_object\n");

  read_str(journal_cTag_Object, name, sizeof(name));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (ODD(sts)) {
    if (grow_FindSelectedObject(graph->grow->ctx, o)) {
      // Unselect and select old ones
      grow_SelectClear(graph->grow->ctx);

      read_int(journal_cTag_Size, &object_cnt);

      for (int i = 0; i < object_cnt; i++) {
	read_str(journal_cTag_Object, name, sizeof(name));
	
	sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
	if (EVEN(sts))
	  throw co_error(sts);

	grow_SetHighlight(o, 1);
	grow_SelectInsert(graph->grow->ctx, o);
      }
    } else {
      // Clear and select current
      grow_SelectClear(graph->grow->ctx);
      grow_SetHighlight(o, 1);
      grow_SelectInsert(graph->grow->ctx, o);

      read_int(journal_cTag_Size, &object_cnt);
      for (int i = 0; i < object_cnt; i++)
	read_str(journal_cTag_Object, name, sizeof(name));
    }
    graph->refresh_objects(attr_mRefresh_Select);
  } else {
    read_int(journal_cTag_Size, &object_cnt);
    for (int i = 0; i < object_cnt; i++)
      read_str(journal_cTag_Object, name, sizeof(name));
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_select_object(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_select_object\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Path);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_Size << '\n';
  fp << movelist.size() << '\n';
  for (int i = 0; i < movelist.size(); i++) {
    fp << journal_cTag_Object << '\n';
    fp << movelist[i].name << '\n';
  }
  fp << journal_cTag_End << '\n';
  movelist.clear();

  return GE__SUCCESS;
}

int GraphJournal::redo_select_object()
{
  grow_tObject o;
  int sts;
  char name[80];

  log_debug("redo_select_object\n");

  read_str(journal_cTag_Object, name, sizeof(name));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (ODD(sts)) {
    if ( o > (void*)0x5fffffffffff)
      printf("Error\n");
    if (grow_FindSelectedObject(graph->grow->ctx, o)) {
      grow_SelectClear(graph->grow->ctx);
    } else {
      grow_SelectClear(graph->grow->ctx);
      grow_SetHighlight(o, 1);
      grow_SelectInsert(graph->grow->ctx, o);
    }
  }

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Select);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_select_object(grow_tObject o)
{
  char name[80];
  log_debug("store_redo_select_object\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_select_object_add()
{
  grow_tObject o;
  int sts;
  char name[80];

  log_debug("undo_select_object_add\n");

  read_str(journal_cTag_Object, name, sizeof(name));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (ODD(sts)) {
    if (grow_FindSelectedObject(graph->grow->ctx, o)) {
      grow_SetHighlight(o, 0);
      grow_SelectRemove(graph->grow->ctx, o);
    } else {
      grow_SetHighlight(o, 1);
      grow_SelectInsert(graph->grow->ctx, o);
    }
    graph->refresh_objects(attr_mRefresh_Select);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_select_object_add(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_select_object_add\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Path);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_select_object_add()
{
  grow_tObject o;
  int sts;
  char name[80];

  log_debug("redo_select_object_add\n");

  read_str(journal_cTag_Object, name, sizeof(name));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (ODD(sts)) {
    if (grow_FindSelectedObject(graph->grow->ctx, o)) {
      grow_SetHighlight(o, 0);
      grow_SelectRemove(graph->grow->ctx, o);
    } else {
      grow_SetHighlight(o, 1);
      grow_SelectInsert(graph->grow->ctx, o);
    }
    graph->refresh_objects(attr_mRefresh_Select);
  }

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_select_object_add(grow_tObject o)
{
  char name[80];
  log_debug("store_redo_select_object_add\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_select_reset()
{
  grow_tObject o;
  int sts;
  char name[80];
  int object_cnt;

  log_debug("undo_select_reset\n");

  read_int(journal_cTag_Size, &object_cnt);

  for (int i = 0; i < object_cnt; i++) {
    read_str(journal_cTag_Object, name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (EVEN(sts))
      throw co_error(sts);

    grow_SetHighlight(o, 1);
    grow_SelectInsert(graph->grow->ctx, o);
  }

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Select);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_select_reset()
{
  log_debug("store_undo_select_reset\n");

  fp << journal_cTag_Size << '\n';
  fp << movelist.size() << '\n';
  for (int i = 0; i < movelist.size(); i++) {
    fp << journal_cTag_Object << '\n';
    fp << movelist[i].name << '\n';
  }
  fp << journal_cTag_End << '\n';
  movelist.clear();

  return GE__SUCCESS;
}

int GraphJournal::redo_select_reset()
{
  log_debug("redo_select_reset\n");

  grow_SelectClear(graph->grow->ctx);

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Select);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_select_reset()
{
  log_debug("store_redo_select_reset\n");

  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_select_region()
{
  grow_tObject o;
  int sts;
  char name[80];
  int object_cnt;

  log_debug("undo_select_region\n");

  grow_SelectClear(graph->grow->ctx);

  read_int(journal_cTag_Size, &object_cnt);

  for (int i = 0; i < object_cnt; i++) {
    read_str(journal_cTag_Object, name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (EVEN(sts))
      throw co_error(sts);

    grow_SetHighlight(o, 1);
    grow_SelectInsert(graph->grow->ctx, o);
  }

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Select);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_select_region()
{
  log_debug("store_undo_select_region\n");

  fp << journal_cTag_Size << '\n';
  fp << movelist.size() << '\n';
  for (int i = 0; i < movelist.size(); i++) {
    fp << journal_cTag_Object << '\n';
    fp << movelist[i].name << '\n';
  }
  fp << journal_cTag_End << '\n';
  movelist.clear();

  return GE__SUCCESS;
}

int GraphJournal::redo_select_region()
{
  char name[80];
  int object_cnt;
  int sts;
  grow_tObject o;

  log_debug("redo_select_region\n");

  grow_SelectClear(graph->grow->ctx);

  read_int(journal_cTag_Size, &object_cnt);

  for (int i = 0; i < object_cnt; i++) {
    read_str(journal_cTag_Object, name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (EVEN(sts))
      throw co_error(sts);

    grow_SetHighlight(o, 1);
    grow_SelectInsert(graph->grow->ctx, o);
  }

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Select);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_select_region()
{
  log_debug("store_redo_select_region\n");

  char name[80];
  grow_tObject* sel_list;
  int sel_count;

  log_debug("store_redo_redo_select_region\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);

  fp << journal_cTag_Size << '\n';
  fp << sel_count << '\n';
  for (int i = 0; i < sel_count; i++) {
    grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);
    fp << journal_cTag_Object << '\n';
    fp << name << '\n';
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_select_region_add()
{
  grow_tObject o;
  int sts;
  char name[80];
  int object_cnt;

  log_debug("undo_select_region_add\n");

  read_int(journal_cTag_Size, &object_cnt);

  for (int i = 0; i < object_cnt; i++) {
    read_str(journal_cTag_Object, name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (EVEN(sts))
      throw co_error(sts);

    grow_SetHighlight(o, 0);
    grow_SelectRemove(graph->grow->ctx, o);
  }

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Select);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_select_region_add()
{
  grow_tObject* sel_list;
  int sel_count;
  int found;
  int new_select;
  char name[80];
  int sts;
  grow_tObject o;

  log_debug("store_undo_select_region_add\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);

  new_select = sel_count - movelist.size();
  fp << journal_cTag_Size << '\n';
  if (new_select <= 0)
    fp << "0" << '\n';
  else {
    fp << sel_count - movelist.size() << '\n';

    for (int i = 0; i < sel_count; i++) {
      found = 0;
      for (int j = 0; j < movelist.size(); j++) {
	sts = grow_FindObjectByName(graph->grow->ctx, movelist[j].name, &o);
	if (EVEN(sts))
	  throw co_error(sts);

	if (o == sel_list[i]) {
	  found = 1;
	  break;
	}
      }
      if (!found) {
	grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);
	fp << journal_cTag_Object << '\n';
	fp << name << '\n';
      }
    }
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_select_region_add()
{
  char name[80];
  int object_cnt;
  int sts;
  grow_tObject o;

  log_debug("redo_select_region_add\n");

  read_int(journal_cTag_Size, &object_cnt);

  for (int i = 0; i < object_cnt; i++) {
    read_str(journal_cTag_Object, name, sizeof(name));

    sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
    if (EVEN(sts))
      throw co_error(sts);

    grow_SetHighlight(o, 1);
    grow_SelectInsert(graph->grow->ctx, o);
  }

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Select);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_select_region_add()
{
  grow_tObject* sel_list;
  int sel_count;
  int found;
  int new_select;
  char name[80];
  int sts;
  grow_tObject o;

  log_debug("store_redo_select_region_add\n");

  grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);

  new_select = sel_count - movelist.size();
  fp << journal_cTag_Size << '\n';
  if (new_select <= 0)
    fp << "0" << '\n';
  else {
    fp << sel_count - movelist.size() << '\n';

    for (int i = 0; i < sel_count; i++) {
      found = 0;
      for (int j = 0; j < movelist.size(); j++) {
	sts = grow_FindObjectByName(graph->grow->ctx, movelist[j].name, &o);
	if (EVEN(sts))
	  throw co_error(sts);

	if (o == sel_list[i]) {
	  found = 1;
	  break;
	}
      }
      if (!found) {
	grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);
	fp << journal_cTag_Object << '\n';
	fp << name << '\n';
      }
    }
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_merge_all_layers()
{
  char line[100];
  int tag;
  grow_tObject o;
  grow_tObject layer;
  grow_tObject prev;
  int sts;
  char name_prev[80];
  char name[80];
  int object_cnt;

  log_debug("undo_merge_all_layers\n");

  grow_SetNodraw(graph->grow->ctx);
  grow_SelectClear(graph->grow->ctx);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Target) {
    fp.getline(name_prev, sizeof(name_prev));
    if (!fp)
      throw co_error(GE__JOURNAL_DISORDER);

    read_tag(journal_cTag_Layer);
    grow_ObjectRead(graph->grow->ctx, (std::ifstream&)fp, &layer);
    if (!layer)
      return GE__SUCCESS;

    if (streq(name_prev, "")) {
      grow_OrderObject(graph->grow->ctx, layer, 0, glow_eDest_Before);
    } else {
      sts = grow_FindObjectByName(graph->grow->ctx, name_prev, &prev);
      if (ODD(sts)) {
	grow_OrderObject(graph->grow->ctx, layer, prev, glow_eDest_After);
      }
    }

    fp.get();
    read_int(journal_cTag_Size, &object_cnt);

    for (int i = 0; i < object_cnt; i++) {
      read_str(journal_cTag_Object, name, sizeof(name));

      sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
      if (EVEN(sts))
	throw co_error(sts);

      grow_SelectInsert(graph->grow->ctx, o);
    }

    grow_LayerSetActive(layer, 1);
    grow_MoveSelectToLayer(graph->grow->ctx);
    grow_LayerSetActive(layer, 0);
    grow_SelectClear(graph->grow->ctx);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  graph->refresh_objects(attr_mRefresh_Objects);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_merge_all_layers()
{
  grow_tObject* list;
  int list_count;
  grow_tObject* layer_list;
  int layer_list_count;
  grow_tObject prev = 0;
  char name[80];

  log_debug("store_undo_merge_all_layers\n");

  grow_GetObjectList(graph->grow->ctx, &list, &list_count);

  for (int i = 0; i < list_count; i++) {
    if (grow_GetObjectType(list[i]) == glow_eObjectType_GrowLayer) {
      fp << journal_cTag_Target << '\n';
      if (prev == 0)
	fp << '\n';
      else {
	grow_GetObjectName(prev, name, sizeof(name), glow_eName_Object);
	fp << name << '\n';
      }
      fp << journal_cTag_Layer << '\n';
      grow_LayerSave(list[i], 1, (std::ofstream&)fp, glow_eSaveMode_Edit);
    
      grow_GetLayerObjectList(list[i], &layer_list, &layer_list_count);
      fp << journal_cTag_Size << '\n';
      fp << layer_list_count << '\n';
      for (int j = 0; j < layer_list_count; j++) {
	fp << journal_cTag_Object << '\n';
	grow_GetObjectName(layer_list[j], name, sizeof(name), glow_eName_Object);
	fp << name << '\n';
      }
    }
    prev = list[i];
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_merge_all_layers()
{
  log_debug("redo_merge_all_layers\n");

  grow_MergeAllLayers(graph->grow->ctx);

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Objects);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_merge_all_layers()
{
  log_debug("store_redo_merge_all_layers\n");

  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_merge_visible_layers_to_bg()
{
  char line[100];
  int tag;
  grow_tObject o;
  grow_tObject layer;
  int sts;
  char name[80];
  int object_cnt;

  log_debug("undo_merge_visible_layers_to_bg\n");

  grow_SetNodraw(graph->grow->ctx);
  grow_SelectClear(graph->grow->ctx);

  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Layer) {
    grow_ObjectRead(graph->grow->ctx, (std::ifstream&)fp, &layer);
    if (!layer)
      return GE__SUCCESS;

    fp.get();
    read_int(journal_cTag_Size, &object_cnt);

    for (int i = 0; i < object_cnt; i++) {
      read_str(journal_cTag_Object, name, sizeof(name));

      sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
      if (EVEN(sts))
	throw co_error(sts);

      grow_SelectInsert(graph->grow->ctx, o);
    }

    grow_LayerSetActive(layer, 1);
    grow_MoveSelectToLayer(graph->grow->ctx);
    grow_LayerSetActive(layer, 0);
    grow_SelectClear(graph->grow->ctx);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  graph->refresh_objects(attr_mRefresh_Objects);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_merge_visible_layers_to_bg()
{
  grow_tObject* list;
  int list_count;
  grow_tObject* layer_list;
  int layer_list_count;
  char name[80];

  log_debug("store_undo_merge_visible_layers_to_bg\n");

  grow_GetObjectList(graph->grow->ctx, &list, &list_count);

  for (int i = 0; i < list_count; i++) {
    if (grow_GetObjectType(list[i]) == glow_eObjectType_GrowLayer &&
	grow_GetObjectVisibility(list[i]) == glow_eVis_Visible) {
      fp << journal_cTag_Layer << '\n';
      grow_LayerSave(list[i], 1, (std::ofstream&)fp, glow_eSaveMode_Edit);

      grow_GetLayerObjectList(list[i], &layer_list, &layer_list_count);
      fp << journal_cTag_Size << '\n';
      fp << layer_list_count << '\n';
      for (int j = 0; j < layer_list_count; j++) {
	fp << journal_cTag_Object << '\n';
	grow_GetObjectName(layer_list[j], name, sizeof(name), glow_eName_Object);
	fp << name << '\n';
      }
    }
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_merge_visible_layers_to_bg()
{
  log_debug("redo_merge_visible_layers_to_bg\n");

  grow_MergeVisibleLayersToBg(graph->grow->ctx);

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Objects);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_merge_visible_layers_to_bg()
{
  log_debug("store_redo_merge_visible_layers_to_bg\n");

  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_merge_visible_layers()
{
  char line[100];
  int tag;
  grow_tObject o;
  grow_tObject layer;
  grow_tObject source_layer;
  int sts;
  char name[80];
  char layer_name[100];
  char path_name[200];
  int object_cnt;
  int active_layer;

  log_debug("undo_merge_visible_layers\n");

  grow_SetNodraw(graph->grow->ctx);
  grow_SelectClear(graph->grow->ctx);

  read_str(journal_cTag_Object, name, sizeof(name));
  read_int(journal_cTag_Size, &active_layer);
  snprintf(layer_name, sizeof(layer_name), "Merged%s", name);

  sts = grow_FindObjectByName(graph->grow->ctx, layer_name, &source_layer);
  if (EVEN(sts))
    throw co_error(sts);

  grow_SetObjectName(source_layer, name);
  strcpy(layer_name, name);
    
  fp.getline(line, sizeof(line));
  sscanf(line, "%d", &tag);
  while (tag == journal_cTag_Layer) {
    grow_ObjectRead(graph->grow->ctx, (std::ifstream&)fp, &layer);
    if (!layer)
      return GE__SUCCESS;

    fp.get();
    read_int(journal_cTag_Size, &object_cnt);

    for (int i = 0; i < object_cnt; i++) {
      read_str(journal_cTag_Object, name, sizeof(name));
      snprintf(path_name, sizeof(path_name), "%s-%s", layer_name, name);
      sts = grow_FindObjectByName(graph->grow->ctx, path_name, &o);
      if (EVEN(sts))
	throw co_error(sts);

      grow_SelectInsert(graph->grow->ctx, o);
    }

    grow_LayerSetActive(layer, 1);
    grow_MoveSelectToLayer(graph->grow->ctx);
    grow_LayerSetActive(layer, 0);
    grow_SelectClear(graph->grow->ctx);

    fp.getline(line, sizeof(line));
    sscanf(line, "%d", &tag);
  }
  grow_ResetNodraw(graph->grow->ctx);
  grow_Redraw(graph->grow->ctx);

  if (tag != journal_cTag_End)
    throw co_error(GE__JOURNAL_DISORDER);

  if (active_layer)
    grow_LayerSetActive(source_layer, 1);

  graph->refresh_objects(attr_mRefresh_Objects);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_merge_visible_layers()
{
  grow_tObject* list;
  grow_tObject target;
  int list_count;
  grow_tObject* layer_list;
  int layer_list_count;
  char name[80];
  int active_layer = 0;
  int found = 0;

  log_debug("store_undo_merge_visible_layers\n");

  grow_GetObjectList(graph->grow->ctx, &list, &list_count);

  // Merge to active layer
  for (int i = 0; i < list_count; i++) {
    if (grow_GetObjectType(list[i]) == glow_eObjectType_GrowLayer &&
	grow_LayerIsActive(list[i]) &&
	grow_GetObjectVisibility(list[i]) == glow_eVis_Visible) {
      target = list[i];
      active_layer = 1;
      found = 1;
      break;
    }      
  }

  if (!found) {
    // Merge to first layer
    for (int i = 0; i < list_count; i++) {
      if (grow_GetObjectType(list[i]) == glow_eObjectType_GrowLayer &&
	  grow_GetObjectVisibility(list[i]) == glow_eVis_Visible) {
	target = list[i];
	found = 1;
	break;
      }
    }
  }
  if (!found)
    return 0;

  grow_GetObjectName(target, name, sizeof(name), glow_eName_Object);
  fp << journal_cTag_Object << '\n';
  fp << name << '\n';
  fp << journal_cTag_Size << '\n';
  fp << active_layer << '\n';

  for (int i = 0; i < list_count; i++) {
    if (grow_GetObjectType(list[i]) == glow_eObjectType_GrowLayer &&
	grow_GetObjectVisibility(list[i]) == glow_eVis_Visible) {
      if (list[i] == target) {
	continue;
      } else {
	fp << journal_cTag_Layer << '\n';
	grow_LayerSave(list[i], 1, (std::ofstream&)fp, glow_eSaveMode_Edit);

	grow_GetLayerObjectList(list[i], &layer_list, &layer_list_count);
	fp << journal_cTag_Size << '\n';
	fp << layer_list_count << '\n';
	for (int j = 0; j < layer_list_count; j++) {
	  fp << journal_cTag_Object << '\n';
	  grow_GetObjectName(layer_list[j], name, sizeof(name), glow_eName_Object);
	  fp << name << '\n';
	}
      }
    }
  }
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_merge_visible_layers()
{
  log_debug("redo_merge_visible_layers\n");

  grow_MergeVisibleLayers(graph->grow->ctx);

  read_tag(journal_cTag_End);

  graph->refresh_objects(attr_mRefresh_Objects);

  return GE__SUCCESS;
}

int GraphJournal::store_redo_merge_visible_layers()
{
  log_debug("store_redo_merge_visible_layers\n");

  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::undo_order_object()
{
  grow_tObject o;
  grow_tObject prev;
  char name[80];
  char name_prev[80];
  int sts;

  log_debug("undo_order_object\n");

  read_str(journal_cTag_Object, name, sizeof(name));
  read_str(journal_cTag_Object, name_prev, sizeof(name_prev));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (EVEN(sts))
    throw co_error(sts);
 
  if (streq(name_prev, ""))
    prev = 0;
  else {
    sts = grow_FindObjectByName(graph->grow->ctx, name_prev, &prev);
    if (EVEN(sts))
      throw co_error(sts);
  }
  if (prev == 0)
    grow_OrderObject(graph->grow->ctx, o, prev, glow_eDest_Before);
  else
    grow_OrderObject(graph->grow->ctx, o, prev, glow_eDest_After);
 
  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

int GraphJournal::store_undo_order_object(grow_tObject o)
{
  char name[80];

  log_debug("store_undo_order_object\n");

  if (movelist.size() != 1)
    throw co_error(GE__JOURNAL_DISORDER);

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << movelist[0].name << '\n';
  fp << journal_cTag_Object << '\n';
  fp << movelist[0].name_prev << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::store_redo_order_object(grow_tObject o)
{
  char name[80];
  grow_tObject prev;
  int sts;

  log_debug("store_redo_order_object\n");

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);

  fp << journal_cTag_Object << '\n';
  fp << name << '\n';

  fp << journal_cTag_Object << '\n';
  sts = grow_GetPreviousObject(graph->grow->ctx, o, &prev);
  if (ODD(sts)) {
    grow_GetObjectName(prev, name, sizeof(name), glow_eName_Path);
    fp << name << '\n';
  }
  else 
    fp << '\n';
  fp << journal_cTag_End << '\n';

  return GE__SUCCESS;
}

int GraphJournal::redo_order_object()
{
  grow_tObject o;
  grow_tObject prev;
  char name[80];
  char name_prev[80];
  int sts;

  log_debug("redo_order_object\n");

  read_str(journal_cTag_Object, name, sizeof(name));
  read_str(journal_cTag_Object, name_prev, sizeof(name_prev));

  sts = grow_FindObjectByName(graph->grow->ctx, name, &o);
  if (EVEN(sts))
    throw co_error(sts);
 
  if (streq(name_prev, ""))
    prev = 0;
  else {
    sts = grow_FindObjectByName(graph->grow->ctx, name_prev, &prev);
    if (EVEN(sts))
      throw co_error(sts);
  }
  if (prev == 0)
    grow_OrderObject(graph->grow->ctx, o, prev, glow_eDest_Before);
  else
    grow_OrderObject(graph->grow->ctx, o, prev, glow_eDest_After);

  read_tag(journal_cTag_End);

  return GE__SUCCESS;
}

void GraphJournal::check_object_number(grow_tObject o)
{
  char name[80];
  char c;
  int num;
  int nr;

  grow_GetObjectName(o, name, sizeof(name), glow_eName_Object);
  nr = sscanf(name, "%c%d", &c, &num);
  if (nr == 2 && (c == 'C' || c == 'O')) {
    if (num >= grow_GetNextObjectNameNumber(graph->grow->ctx))
      grow_SetNextObjectNameNumber(graph->grow->ctx, num + 1);
  }
}

int GraphJournal::restore(char* fname)
{
  char line[200];
  int nr = 0;
  int tag = 0;
  int action;
  int idx;
  int end_found = 0;
  std::streampos pos;
  JournalPos up;

  poslist.clear();
  current_idx = -1;
  status = journal_eStatus_Empty;

  fp.open(fname, std::ios::in | std::ios::out);
  if (!fp) {
    printf("Unable to open journal file %s\n", filename);
    return GE__FILEOPEN;
  }

  while (1) {
    while (!(nr == 1 && tag == journal_cTag_Redo)) {
      pos = fp.tellp();
      if (!fp.getline(line, sizeof(line))) {
        end_found = 1;
        break;
      }
      nr = sscanf(line, "%d", &tag);
      if (nr == 1 && tag == journal_cTag_Redo) {
        sscanf(line, "%d %d %d %d", &tag, &action, (int*)&status, &idx);
        if (current_idx < idx) {
          up.redo_pos = pos;
          up.undo_pos = 0;
          up.end_pos = 0;
          current_idx = idx;

          if (idx > 0)
            poslist[idx - 1].end_pos = pos;

          poslist.push_back(up);
        } else if (idx == current_idx)
          poslist[idx].redo_pos = pos;
      }
      if (nr == 1 && tag == journal_cTag_Undo) {
        sscanf(line, "%d %d %d %d", &tag, &action, (int*)&status, &idx);
        if (current_idx < idx) {
          up.redo_pos = 0;
          up.undo_pos = pos;
          up.end_pos = 0;
          current_idx = idx;

          if (idx > 0)
            poslist[idx - 1].end_pos = pos;

          poslist.push_back(up);
        } else if (idx == current_idx)
          poslist[idx].undo_pos = pos;
      }
    }

    if (end_found)
      break;

    sscanf(line, "%d %d %d %d", &tag, &action, (int*)&status, &idx);

    switch (action) {
    case journal_eAction_DeleteSelect:
      redo_delete_select();
      break;
    case journal_eAction_DeleteObject:
      redo_delete_object();
      break;
    case journal_eAction_CreateObject:
      redo_create_object();
      break;
    case journal_eAction_AntePropertiesSelect:
    case journal_eAction_PostPropertiesSelect:
      undo_properties_select();
      break;
    case journal_eAction_AntePropertiesObject:
    case journal_eAction_PostPropertiesObject:
      undo_properties_object();
      break;
    case journal_eAction_AnteGroupSelect:
    case journal_eAction_PostGroupSelect:
      redo_group_select();
      break;
    case journal_eAction_UngroupSelect:
      redo_ungroup_select();
      break;
    case journal_eAction_AntePaste:
    case journal_eAction_PostPaste:
      redo_paste();
      break;
    case journal_eAction_PopSelect:
      redo_pop_select();
      break;
    case journal_eAction_PushSelect:
      redo_push_select();
      break;
    case journal_eAction_AnteRename:
    case journal_eAction_PostRename:
      redo_rename();
      break;
    case journal_eAction_AnteOrderObject:
    case journal_eAction_PostOrderObject:
      redo_order_object();
      break;
    case journal_eAction_No:
      break;
    default:;
    }
    nr = 0;
  }
  fp.clear();
  if (current_idx >= 0)
    poslist[current_idx].end_pos = pos;
  current_idx++;
  status = journal_eStatus_Stored;

  return GE__SUCCESS;
}

void GraphJournal::print(char* fname)
{
  char line[200];
  int nr = 0;
  int tag;
  int action;
  int idx;
  std::ifstream fp;
  pwr_tFileName fn;
  int status;
  int row = 0;
  int row_fetched = 0;

  dcli_translate_filename(fn, fname);

  fp.open(fn, std::ios::in);
  if (!fp) {
    printf("Unable to open journal file %s\n", fn);
    return;
  }

  printf("%4s %4s %-20s %-22s\n", "Row", "Idx", "Tag", "Action");
  printf("%4s %4s %-20s %-22s\n", "---", "---", "---", "------");

  while (row_fetched || fp.getline(line, sizeof(line))) {
    row++;

    nr = sscanf(line, "%d", &tag);
    if (nr == 1 && (tag == journal_cTag_Redo || tag == journal_cTag_Undo)) {
      sscanf(line, "%d %d %d %d", &tag, &action, (int*)&status, &idx);

      printf("%4d %4d %-20s %-22s", row, idx, tag_to_str(tag),
          action_to_str(action));

      if (!fp.getline(line, sizeof(line)))
        break;

      nr = sscanf(line, "%d", &tag);
      if (nr == 1 && tag == journal_cTag_Object) {
        if (!fp.getline(line, sizeof(line)))
          break;
        row_fetched = 0;
        printf("%-10s\n", line);
      } else {
        row_fetched = 1;
        printf("\n");
      }
    } else
      row_fetched = 0;
  }
  fp.close();
}

char* GraphJournal::action_to_str(int action)
{
  static char str[40];

  switch (action) {
  case journal_eAction_DeleteObject:
    strcpy(str, "DeleteObject");
    break;
  case journal_eAction_DeleteSelect:
    strcpy(str, "DeleteSelect");
    break;
  case journal_eAction_MoveObject:
    strcpy(str, "MoveObject");
    break;
  case journal_eAction_MoveSelect:
    strcpy(str, "MoveSelect");
    break;
  case journal_eAction_CreateObject:
    strcpy(str, "CreateObject");
    break;
  case journal_eAction_AntePropertiesSelect:
    strcpy(str, "AntePropertiesSelect");
    break;
  case journal_eAction_PostPropertiesSelect:
    strcpy(str, "PostPropertiesSelect");
    break;
  case journal_eAction_AntePropertiesObject:
    strcpy(str, "AntePropertiesObject");
    break;
  case journal_eAction_PostPropertiesObject:
    strcpy(str, "PostPropertiesObject");
    break;
  case journal_eAction_AnteGroupSelect:
    strcpy(str, "AnteGroupSelect");
    break;
  case journal_eAction_PostGroupSelect:
    strcpy(str, "PostGroupSelect");
    break;
  case journal_eAction_UngroupSelect:
    strcpy(str, "UngroupSelect");
    break;
  case journal_eAction_PopSelect:
    strcpy(str, "PopSelect");
    break;
  case journal_eAction_PushSelect:
    strcpy(str, "PushSelect");
    break;
  case journal_eAction_AntePaste:
    strcpy(str, "AntePaste");
    break;
  case journal_eAction_PostPaste:
    strcpy(str, "PostPaste");
    break;
  case journal_eAction_AnteRename:
    strcpy(str, "AnteRename");
    break;
  case journal_eAction_PostRename:
    strcpy(str, "PostRename");
    break;
  case journal_eAction_AnteActivateLayer:
    strcpy(str, "AnteActivateLayer");
    break;
  case journal_eAction_PostActivateLayer:
    strcpy(str, "PostActivateLayer");
    break;
  case journal_eAction_InactivateLayer:
    strcpy(str, "InactivateLayer");
    break;
  case journal_eAction_SetLayerVisible:
    strcpy(str, "SetLayerVisible");
    break;
  case journal_eAction_SetLayerInvisible:
    strcpy(str, "SetLayerInvisible");
    break;
  case journal_eAction_AnteMoveToLayer:
    strcpy(str, "AnteMoveToLayer");
    break;
  case journal_eAction_PostMoveToLayer:
    strcpy(str, "PostMoveToLayer");
    break;
  case journal_eAction_AnteSelectObject:
    strcpy(str, "AnteSelectObject");
    break;
  case journal_eAction_PostSelectObject:
    strcpy(str, "PostSelectObject");
    break;
  case journal_eAction_SelectObjectAdd:
    strcpy(str, "SelectObjectAdd");
    break;
  case journal_eAction_AnteSelectReset:
    strcpy(str, "SelectAnteReset");
    break;
  case journal_eAction_PostSelectReset:
    strcpy(str, "SelectPostReset");
    break;
  case journal_eAction_AnteSelectRegionAdd:
    strcpy(str, "AnteSelectRegionAdd");
    break;
  case journal_eAction_PostSelectRegionAdd:
    strcpy(str, "PostSelectRegionAdd");
    break;
  case journal_eAction_MergeAllLayers:
    strcpy(str, "MergeAllLayers");
    break;
  case journal_eAction_MergeVisibleLayersToBg:
    strcpy(str, "MergeVisibleLayersToBg");
    break;
  case journal_eAction_MergeVisibleLayers:
    strcpy(str, "MergeVisibleLayers");
    break;
  default:
    strcpy(str, "Undefined");
  }
  return str;
}

char* GraphJournal::tag_to_str(int tag)
{
  static char str[20];

  switch (tag) {
  case journal_cTag_Undo:
    strcpy(str, "Undo");
    break;
  case journal_cTag_Redo:
    strcpy(str, "Redo");
    break;
  case journal_cTag_Object:
    strcpy(str, "Object");
    break;
  case journal_cTag_End:
    strcpy(str, "End");
    break;
  default:
    strcpy(str, "Undefined");
  }
  return str;
}
