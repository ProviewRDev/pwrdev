/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2024 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include "ge_graph.h"
#include "ge_graph_unitconv.h"

#define uc_acceleration_size 3
static double uc_acceleration_a1[uc_acceleration_size] = 
  // m/s2, ft/s2,       in/s2
  {1.0,    3.280839895, 39.37007874};

#define uc_angle_size 6
static double uc_angle_a1[uc_angle_size] = 
  // rad, degree,      min,       mrad,  percent,     sec
  {1.0,   180.0/M_PI,  3437.74677,1e3,   15.91549430, 4.84813681e-6};

#define uc_area_size 11
static double uc_area_a1[uc_area_size] =
  // m2, a,       ac,         cm2,   ha,     km2,    mm2,   sq_in,      sq_mi,     sq_ft       sq_yd
  {1.0,  1.0e-2,  2.471053e-4,1.0e4, 1.0e-4, 1.0e-6, 1.0e6, 1550.0031,  0.38610e-6, 10.763915,  1.19599};

#define uc_energy_size 3
static double uc_energy_a1[uc_energy_size] = 
  // J,  cal,          kJ
  {1.0,  0.2389029576, 1e-3};

#define uc_force_size 5
static double uc_force_a1[uc_force_size] = 
  // N,  kN,   kp,             MN,   p
  {1.0,  1e-3, 0.101971621297, 1e-6, 101.971621297};

#define uc_frequency_size 6
static double uc_frequency_a1[uc_frequency_size] = 
  // Hz, kHz,  MHz,  rad/min,   rad/s,     RPM
  {1.0,  1e-3, 1e-6, 376.99112, 6.2831853, 60.0};

#define uc_general_size 13
static double uc_general_a1[uc_general_size] =
  // 1:1,  Tera,   Giga, Mega,  Kilo,  Hecto,  Deca,   Deci,  Centi,  Milli,  Micro,  Nano,   Pico
  {1,      1e-12,  1e-9, 1e-6,  1e-3,  1e-2,   1e-1,   1e1,   1e2,    1e3,    1e6,    1e9,    1e12};

#define uc_length_size 12
static double uc_length_a1[uc_length_size] =
  // m,      cm,       dm,       ft,         in,           km,        mi,         mm,       nm,        NM,         um,       yd
  {1.0,      1.0e2,    1.0e1,    3.28083989, 39.3700787,   1.0e-3,    6.21371e-4, 1.0e3,    1.0e9,     5.39957e-4, 1.0e6,    1.0936133};

#define uc_mass_size 10
static double uc_mass_a1[uc_mass_size] =
  // kg,  g,    hg,   kt,    lb_av,        mg,   oz,          st,           t,        ug 
  {1.0,   1e3,  1e1,  1e-6,  2.20462262,   1e6,  35.27396194, 0.1574730444, 1e-3,     1e9};

#define uc_massflow_size 10
static double uc_massflow_a1[uc_massflow_size] =
  // kg/s, g/min, g/s,  kg/min, lb/min,       lb/s,       mg/min, mg/s,  oz/min,        oz/s 
  {1.0,    6e4,   1e3,  60,     132.27746521, 2.204244201,6e7,    1e6,   2116.43944337, 35.273990722};

#define uc_power_size 8
static double uc_power_a1[uc_power_size] =
  // W, GW,   hp,               kW,   mW,  MW,   uW,  TW,
  {1.0, 1e-9, 1.34410220895e-3, 1e-3, 1e3, 1e-6, 1e6, 1e-12};

#define uc_pressure_size 10
static double uc_pressure_a1[uc_pressure_size] =
  // Pa, atm,            b,    kPa,  lb/ft2,         lb/in2,           mb,   mmHg,          mPa, MPa
  {1.0,  9.869232667e-6, 1e-5, 1e-3, 2.088543427e-2, 1.45037738007e-4, 1e-2, 7.50061561e-3, 1e3, 1e-6};

#define uc_speed_size 12
static double uc_speed_a1[uc_speed_size] =
  // m/s,       ft/min,      ft/s,       in/min,      in/s,       km/h,        kn,         m/min,      mm/s,       mi/h,       yd/min,    yd/s
  {1.0,         1.96850393e2,3.28083989, 2362.2047244,39.37007874,3.6,         1.9438444,  60,         1e3,        2.23693629, 65.617979, 1.093613298};

#define uc_temperature_size 4
static double uc_temperature_a0[uc_temperature_size] =
  // K,        C,           F         R
  {0,          -273.15,     -459.67,  0};

static double uc_temperature_a1[uc_temperature_size] =
  // K,         C,      F      R
  {1.0,         1.0,    1.8,   1.8};

#define uc_time_size 9
static double uc_time_a1[uc_time_size] =
  // s,         d,           h,          min,         ms,        ns,         us,       wk,          y
  {1.0,         1.157407e-5, 2.77778e-4, 1.6666667e-2,1e3,       1e9,        1e6,      1.653439e-6, 3.1709792e-8};

#define uc_volume_size 6
static double uc_volume_a1[uc_volume_size] =
  // m3,        cm3,        dm3,         ft3,         in3,          mm3,
  {1.0,         1e6,        1e3,         3.5314645e1, 6.10237440e4, 1e9};

#define uc_volumeflow_size 11
static double uc_volumeflow_a1[uc_volumeflow_size] =
  // m3/s,      cl/s,       in3/min,       in3/s,         ft3/min,      ft3/s,      l/s, m3/min, mm3/s, yd3/min,      yd3/s
  {1.0,         1e5,        3.661424929e6, 6.102374321e4, 2.118879972e3,35.31466621,1e3, 60,     1e9,   78.477036028, 1.30795060046};


static int uc_attrtype[] = {
  ge_eAttrType_UcAcceleration,
  ge_eAttrType_UcAngle,
  ge_eAttrType_UcArea,
  ge_eAttrType_UcEnergy,
  ge_eAttrType_UcForce,
  ge_eAttrType_UcFrequency,
  ge_eAttrType_UcGeneral,
  ge_eAttrType_UcLength,
  ge_eAttrType_UcMass,
  ge_eAttrType_UcMassFlow,
  ge_eAttrType_UcPower,
  ge_eAttrType_UcPressure,
  ge_eAttrType_UcSpeed,
  ge_eAttrType_UcTemperature,
  ge_eAttrType_UcTime,
  ge_eAttrType_UcVolume,
  ge_eAttrType_UcVolumeFlow};

int uc_entity_to_attrtype(int entity)
{
  return uc_attrtype[entity];
}

double uc_convert(graph_eUcEntity entity, int from, int to, double value)
{
  switch (entity) {
  case graph_eUcEntity_Acceleration:
    if (from >= uc_acceleration_size || to >= uc_acceleration_size)
      return 0;
    return value * uc_acceleration_a1[to]/uc_acceleration_a1[from];
  case graph_eUcEntity_Angle:
    if (from >= uc_angle_size || to >= uc_angle_size)
      return 0;
    return value * uc_angle_a1[to]/uc_angle_a1[from];
  case graph_eUcEntity_Area:
    if (from >= uc_area_size || to >= uc_area_size)
      return 0;
    return value * uc_area_a1[to]/uc_area_a1[from];
  case graph_eUcEntity_Energy:
    if (from >= uc_energy_size || to >= uc_energy_size)
      return 0;
    return value * uc_energy_a1[to]/uc_energy_a1[from];
  case graph_eUcEntity_Force:
    if (from >= uc_force_size || to >= uc_force_size)
      return 0;
    return value * uc_force_a1[to]/uc_force_a1[from];
  case graph_eUcEntity_Frequency:
    if (from >= uc_frequency_size || to >= uc_frequency_size)
      return 0;
    return value * uc_frequency_a1[to]/uc_frequency_a1[from];
  case graph_eUcEntity_General:
    if (from >= uc_general_size || to >= uc_general_size)
      return 0;
    return value * uc_general_a1[to]/uc_general_a1[from];
  case graph_eUcEntity_Length:
    if (from >= uc_length_size || to >= uc_length_size)
      return 0;
    return value * uc_length_a1[to]/uc_length_a1[from];
  case graph_eUcEntity_Mass:
    if (from >= uc_mass_size || to >= uc_mass_size)
      return 0;
    return value * uc_mass_a1[to]/uc_mass_a1[from];
  case graph_eUcEntity_MassFlow:
    if (from >= uc_massflow_size || to >= uc_massflow_size)
      return 0;
    return value * uc_massflow_a1[to]/uc_massflow_a1[from];
  case graph_eUcEntity_Power:
    if (from >= uc_power_size || to >= uc_power_size)
      return 0;
    return value * uc_power_a1[to]/uc_power_a1[from];
  case graph_eUcEntity_Pressure:
    if (from >= uc_pressure_size || to >= uc_pressure_size)
      return 0;
    return value * uc_pressure_a1[to]/uc_pressure_a1[from];
  case graph_eUcEntity_Temperature:
    if (from >= uc_temperature_size || to >= uc_temperature_size)
      return 0;
    return uc_temperature_a0[to] + (value - uc_temperature_a0[from])* uc_temperature_a1[to]/uc_temperature_a1[from];
  case graph_eUcEntity_Speed:
    if (from >= uc_speed_size || to >= uc_speed_size)
      return 0;
    return value * uc_speed_a1[to]/uc_speed_a1[from];
  case graph_eUcEntity_Time:
    if (from >= uc_time_size || to >= uc_time_size)
      return 0;
    return value * uc_time_a1[to]/uc_time_a1[from];
  case graph_eUcEntity_Volume:
    if (from >= uc_volume_size || to >= uc_volume_size)
      return 0;
    return value * uc_volume_a1[to]/uc_volume_a1[from];
  case graph_eUcEntity_VolumeFlow:
    if (from >= uc_volumeflow_size || to >= uc_volumeflow_size)
      return 0;
    return value * uc_volumeflow_a1[to]/uc_volumeflow_a1[from];
  }
  return 0;
}
