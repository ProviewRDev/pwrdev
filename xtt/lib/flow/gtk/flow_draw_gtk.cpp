/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>

#include "co_dcli.h"
#include "co_string.h"
#include "cow_wow.h"

#include "flow_browwidget_gtk.h"
#include "flow_draw_gtk.h"
#include "flow_msg.h"
#include "flow_printdraw_gtk.h"
#include "flow_widget_gtk.h"

#include <gdk/gdkkeysyms.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gdk/gdkx.h>
typedef void* GdkImlibImage;

#define DRAW_PRESS_PIX 9
#define DRAW_TSCALE 0.93

typedef struct {
  GtkWidget* w;
  int x;
  int y;
  int width;
  int height;
  FlowArrayElem* node;
  int number;
  FlowCtx* ctx;
} draw_sAnnotData;

typedef struct {
  FlowCtx* ctx;
  void (*callback_func)(FlowCtx* ctx);
  guint timer_id;
} draw_sTimerCb;

typedef int GdkPixmap; // TODO

typedef struct {
  cairo_surface_t* pixmap[DRAW_PIXMAP_SIZE];
  unsigned char* data[DRAW_PIXMAP_SIZE];
} draw_sPixmap;

char FlowDrawGtk::font_name[40] = "Lucida Sans";

static GdkEvent last_event;

static void event_timer(FlowCtx* ctx, int time_ms);
static void cancel_event_timer(FlowCtx* ctx);
static gboolean event_timer_cb(void* ctx);

static int flow_create_cursor(FlowDrawGtk* draw_ctx)
{
  /* Create some cursors */

  /* Cross cursor */
  draw_ctx->cursors[draw_eCursor_CrossHair]
      = gdk_cursor_new_for_display(draw_ctx->display, GDK_CROSSHAIR);

  draw_ctx->cursors[draw_eCursor_DiamondCross]
      = gdk_cursor_new_for_display(draw_ctx->display, GDK_DIAMOND_CROSS);

  draw_ctx->cursors[draw_eCursor_Hand]
      = gdk_cursor_new_for_display(draw_ctx->display, GDK_HAND2);

  return 1;
}

static int draw_free_gc(FlowDrawGtk* draw_ctx)
{
  if (draw_ctx->gc_black)
    cairo_pattern_destroy(draw_ctx->gc_black);
  if (draw_ctx->gc_gray)
    cairo_pattern_destroy(draw_ctx->gc_gray);
  if (draw_ctx->gc_darkgray)
    cairo_pattern_destroy(draw_ctx->gc_darkgray);
  if (draw_ctx->gc_red)
    cairo_pattern_destroy(draw_ctx->gc_red);
  if (draw_ctx->gc_yellow)
    cairo_pattern_destroy(draw_ctx->gc_yellow);
  if (draw_ctx->gc_green)
    cairo_pattern_destroy(draw_ctx->gc_green);
  if (draw_ctx->gc_erase)
    cairo_pattern_destroy(draw_ctx->gc_erase);
  if (draw_ctx->gc_inverse)
    cairo_pattern_destroy(draw_ctx->gc_inverse);

  return 1;
}

typedef struct {
  double fg[3];
  double bg[3];
  double inverse[3];
  double gray[3];
  double darkgray[3];
  double red[3];
  double yellow[3];
  double green[3];
} draw_sTheme;

static draw_sTheme theme[] = {
  // Standard, not used
  {{0.0, 0.0, 0.0}, // Foreground
   {1.0, 1.0, 1.0}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // Sand
  {{0.288, 0.118, 0.009}, // Foreground
   {1.000, 0.949, 0.891}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // Maroon
  {{0.000, 0.000, 0.000}, // Foreground
   {0.906, 0.851, 0.851}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // Sienna
  {{1.000, 0.749, 0.459}, // Foreground
   {0.184, 0.067, 0.000}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // DarkBlue
  {{1.000, 1.000, 1.000}, // Foreground
   {0.122, 0.184, 0.247}, // Background
   {1.0, 1.0, 1.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2} // Green
  }, // Classic
  {{0.0, 0.0, 0.0}, // Foreground
   {1.0, 1.0, 1.0}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // Midnight
  {{1.000, 0.686, 0.424}, // Foreground
   {0.145, 0.153, 0.251}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // PlayRoom
  {{0.098, 0.388, 0.753}, // Foreground
   {1.000, 0.886, 0.988}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // NordicLight
  {{0.000, 0.000, 0.000}, // Foreground
   {0.906, 0.941, 1.000}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // Contrast
  {{0.0, 0.0, 0.0}, // Foreground
   {1.0, 1.0, 1.0}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // AzureContrast
  {{0.0, 0.0, 0.0}, // Foreground
   {0.639, 0.812, 0.980}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // OchreContrast
  {{0.0, 0.0, 0.0}, // Foreground
   {0.988, 0.812, 0.475}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // Chesterfield
  {{0.941, 0.823, 0.718}, // Foreground
   {0.223, 0.027, 0.012}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // TerraVerte
  {{0.0, 0.0, 0.0}, // Foreground
   {1.0, 1.0, 1.0}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // Polar
  {{0.000, 0.000, 0.000}, // Foreground
   {0.890, 0.937, 1.000}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // StandardLight
  {{0.0, 0.0, 0.0}, // Foreground
   {1.0, 1.0, 1.0}, // Background
   {0.0, 0.0, 0.0}, // Inverse
   {0.6, 0.6, 0.6}, // Gray
   {0.3, 0.3, 0.3}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2}  // Green
  }, // StandardDark
  {{1.000, 1.000, 1.000}, // Foreground
   {0.180, 0.180, 0.180}, // Background
   {0.6, 0.6, 0.6}, // Inverse
   {0.3, 0.3, 0.3}, // Gray
   {0.15, 0.15, 0.15}, // Darkgray
   {1.0, 0.2, 0.2}, // Red
   {1.0, 1.0, 0.0}, // Yellow
   {0.2, 1.0, 0.2} // Green
  }};

static int flow_create_gc(FlowDrawGtk* draw_ctx, int ct)
{
  // GdkRGBA c;
  //gtk_style_context_get_color(draw_ctx->style_context, GTK_STATE_FLAG_NORMAL, &c);
  //draw_ctx->gc_black = cairo_pattern_create_rgba(c.red, c.green, c.blue, c.alpha);

  int i = ct;
  if (i >= sizeof(theme)/sizeof(theme[0]))
    i = 0;

  draw_ctx->gc_black = cairo_pattern_create_rgb(theme[i].fg[0], theme[i].fg[1], theme[i].fg[2]);
  draw_ctx->gc_erase = cairo_pattern_create_rgb(theme[i].bg[0], theme[i].bg[1], theme[i].bg[2]);
  draw_ctx->gc_inverse = cairo_pattern_create_rgb(theme[i].inverse[0], theme[i].inverse[1], theme[i].inverse[2]);
  draw_ctx->gc_gray = cairo_pattern_create_rgb(theme[i].gray[0], theme[i].gray[1], theme[i].gray[2]);
  draw_ctx->gc_darkgray = cairo_pattern_create_rgb(theme[i].darkgray[0], theme[i].darkgray[1], theme[i].darkgray[2]);
  draw_ctx->gc_red = cairo_pattern_create_rgb(theme[i].red[0], theme[i].red[1], theme[i].red[2]);
  draw_ctx->gc_yellow = cairo_pattern_create_rgb(theme[i].yellow[0], theme[i].yellow[1], theme[i].yellow[2]);
  draw_ctx->gc_green = cairo_pattern_create_rgb(theme[i].green[0], theme[i].green[1], theme[i].green[2]);
  
  return 1;
}

void FlowDrawGtk::update_color_theme(int ct)
{
  draw_free_gc(this);
  flow_create_gc(this, ct);
}

FlowDrawGtk::~FlowDrawGtk()
{
  closing_down = 1;

  basectx->set_nodraw();
  delete basectx;
  draw_free_gc(this);
  if (font_face_bold)
    cairo_font_face_destroy(font_face_bold);
  if (font_face_normal)
    cairo_font_face_destroy(font_face_normal);

  if (timer_id)
    g_source_remove(timer_id);
}

int FlowDrawGtk::create_secondary_ctx(FlowCtx* flow_ctx,
    void** secondary_flow_ctx,
    int (*init_proc)(FlowCtx* ctx, void* client_data), void* client_data,
    flow_eCtxType type)
{
  FlowCtx* ctx;

  if (type == flow_eCtxType_Brow)
    ctx = (FlowCtx*)new BrowCtx("Claes context", 20);
  else
    ctx = new FlowCtx("Claes context", 20);

  ctx->fdraw = this;
  ctx->set_nodraw();
  ctx->trace_connect_func = flow_ctx->trace_connect_func;
  ctx->trace_disconnect_func = flow_ctx->trace_disconnect_func;
  ctx->trace_scan_func = flow_ctx->trace_scan_func;
  ctx->trace_started = flow_ctx->trace_started;
  ctx->zoom_factor = flow_ctx->zoom_factor;
  if (type == flow_eCtxType_Brow) {
    ((BrowCtx*)ctx)->scroll_callback = ((BrowCtx*)flow_ctx)->scroll_callback;
    ((BrowCtx*)ctx)->scroll_data = ((BrowCtx*)flow_ctx)->scroll_data;
  }

  init_proc(ctx, client_data);
  *secondary_flow_ctx = (void*)ctx;
  return 1;
}

int FlowDrawGtk::change_ctx(FlowCtx* from_ctx, FlowCtx* to_ctx)
{
  if (from_ctx->type() == flow_eCtxType_Brow)
    browwidgetgtk_modify_ctx(toplevel, to_ctx);
  else
    flowwidgetgtk_modify_ctx(toplevel, to_ctx);

  to_ctx->window_width = from_ctx->window_width;
  to_ctx->window_height = from_ctx->window_height;
  from_ctx->set_nodraw();
  to_ctx->reset_nodraw();
  if (from_ctx->type() == flow_eCtxType_Brow) {
    to_ctx->zoom_factor = from_ctx->zoom_factor;
    ((BrowCtx*)to_ctx)->configure(0);
  } else
    to_ctx->redraw();
  return 1;
}

void FlowDrawGtk::delete_secondary_ctx(FlowCtx* ctx)
{
  ctx->set_nodraw();
  delete ctx;
}

FlowDrawGtk::FlowDrawGtk(GtkWidget* x_toplevel, void** flow_ctx,
    int (*init_proc)(GtkWidget* w, FlowCtx* ctx, void* client_data),
    void* client_data, flow_eCtxType type)
    : toplevel(x_toplevel), nav_shell(0), nav_toplevel(0), display(0),
      window(0), nav_window(0), screen(0), gc_black(0), gc_gray(0), 
      gc_darkgray(0), gc_red(0), gc_yellow(0), gc_green(0), gc_erase(0),
      gc_inverse(0), timer_id(0),
      closing_down(0), cairo_cr(0), cairo_cr_refcnt(0), cairo_region(0),
      cairo_context(0), cairo_nav_cr(0), cairo_nav_cr_refcnt(0), cairo_nav_region(0),
      cairo_nav_context(0), antialias(CAIRO_ANTIALIAS_NONE), 
      nav_antialias(CAIRO_ANTIALIAS_NONE), style_context(0),
      font_face_bold(0), font_face_normal(0)
{
  memset(cursors, 0, sizeof(cursors));

  if (type == flow_eCtxType_Brow)
    basectx = (FlowCtx*)new BrowCtx("Claes context", 20);
  else
    basectx = new FlowCtx("Claes context", 20);
  *flow_ctx = (void*)basectx;

  basectx->fdraw = this;

  display = gtk_widget_get_display(toplevel);
  window = gtk_widget_get_window(toplevel);
  screen = gtk_widget_get_screen(toplevel);
  style_context = gtk_widget_get_style_context(toplevel);
  update_color_theme(CoWow::ColorTheme());
  //flow_create_gc(this, 0);
  //set_white_background(basectx);

  flow_create_cursor(this);

  init_proc(toplevel, basectx, client_data);
}

int FlowDrawGtk::init_nav(GtkWidget* nav_widget, void* flow_ctx)
{
  nav_toplevel = nav_widget;
  nav_window = gtk_widget_get_window(nav_toplevel);

  // flow_create_gc(this, nav_window);

  ((FlowCtx*)flow_ctx)->no_nav = 0;
  return 1;
}

void FlowDrawGtk::invalidate(int x, int y, int width, int height)
{
  GdkRectangle rect;

  rect.x = x;
  rect.y = y;
  rect.width = width;
  rect.height = height;
  gdk_window_invalidate_rect(window, &rect, FALSE);
}

void FlowDrawGtk::invalidate_nav(int x, int y, int width, int height)
{
  GdkRectangle rect;

  rect.x = x;
  rect.y = y;
  rect.width = width;
  rect.height = height;
  gdk_window_invalidate_rect(nav_window, &rect, FALSE);
}

int FlowDrawGtk::expose(FlowCtx* ctx, cairo_t* cr, int is_navigator)
{
  int sts;
  int x, y, width, height;
  GdkRectangle rect;

  if (!is_navigator) {
    pwr_Assert(cairo_cr_refcnt == 0);

    cairo_cr = cr;
    cairo_cr_refcnt++;
    get_window_size(ctx, &ctx->window_width, &ctx->window_height);
    if (gdk_cairo_get_clip_rectangle(cr, &rect)) {
      x = rect.x;
      y = rect.y;
      width = rect.width;
      height = rect.height;
    } else {
      x = 0;
      y = 0;
      width = ctx->window_width;
      height = ctx->window_height;
    }
    //gtk_render_background(style_context, cr, 0, 0, x + width, y + height);
    fill_rect(ctx, x, y, width, height, flow_eDrawType_LineErase);
    sts = ctx->event_handler(flow_eEvent_Exposure, x, y, width, height);
    cairo_cr = 0;
    cairo_cr_refcnt--;
    pwr_Assert(cairo_cr_refcnt == 0);
  } else {  
    pwr_Assert(cairo_nav_cr_refcnt == 0);

    cairo_nav_cr = cr;
    cairo_nav_cr_refcnt++;
    nav_fill_rect(ctx, 0, 0, ctx->nav_window_width, ctx->nav_window_height, flow_eDrawType_LineErase);
    sts = ctx->event_handler_nav(flow_eEvent_Exposure, 0, 0);
    cairo_nav_cr = 0;
    cairo_nav_cr_refcnt--;
    pwr_Assert(cairo_nav_cr_refcnt == 0);
  }
  return sts;
}

int FlowDrawGtk::event_handler(FlowCtx* ctx, GdkEvent event)
{
  static int button_pressed = 0;
  static int button_clicked = 0;
  static int button_clicked_and_pressed = 0;
  static int button1_pressed = 0;
  static int button2_pressed = 0;
  static int button3_pressed = 0;
  static int last_press_x = 0;
  static int last_press_y = 0;
  int sts = 1;

  if (closing_down)
    return 1;

  if (event.any.window == window || event.type == GDK_KEY_PRESS) {
    switch (event.type) {
    case GDK_KEY_PRESS: {
      guint keysym = event.key.keyval;

      switch (keysym) {
      case GDK_KEY_Return:
        sts = ctx->event_handler(flow_eEvent_Key_Return, 0, 0, 0, 0);
        //            printf( "-- Return key event\n");
        break;
      case GDK_KEY_Up:
        if (event.key.state & GDK_SHIFT_MASK)
          sts = ctx->event_handler(flow_eEvent_Key_ShiftUp, 0, 0, 0, 0);
        else
          sts = ctx->event_handler(flow_eEvent_Key_Up, 0, 0, 0, 0);
        break;
      case GDK_KEY_Down:
        if (event.key.state & GDK_SHIFT_MASK)
          sts = ctx->event_handler(flow_eEvent_Key_ShiftDown, 0, 0, 0, 0);
        else
          sts = ctx->event_handler(flow_eEvent_Key_Down, 0, 0, 0, 0);
        break;
      case GDK_KEY_Right:
        if (event.key.state & GDK_SHIFT_MASK)
          sts = ctx->event_handler(flow_eEvent_Key_ShiftRight, 0, 0, 0, 0);
        else
          sts = ctx->event_handler(flow_eEvent_Key_Right, 0, 0, 0, 0);
        break;
      case GDK_KEY_Left:
        if (event.key.state & GDK_SHIFT_MASK)
          sts = ctx->event_handler(flow_eEvent_Key_ShiftLeft, 0, 0, 0, 0);
        else
          sts = ctx->event_handler(flow_eEvent_Key_Left, 0, 0, 0, 0);
        break;
      case GDK_KEY_Page_Up:
      case 0xFF41:
        sts = ctx->event_handler(flow_eEvent_Key_PageUp, 0, 0, 0, 0);
        break;
      case GDK_KEY_Page_Down:
      case 0xFF42:
        sts = ctx->event_handler(flow_eEvent_Key_PageDown, 0, 0, 0, 0);
        break;
      case GDK_KEY_BackSpace:
        sts = ctx->event_handler(flow_eEvent_Key_BackSpace, 0, 0, 0, 0);
        break;
      case GDK_KEY_KP_F1:
        sts = ctx->event_handler(flow_eEvent_Key_PF1, 0, 0, 0, 0);
        break;
      case GDK_KEY_KP_F2:
        sts = ctx->event_handler(flow_eEvent_Key_PF2, 0, 0, 0, 0);
        break;
      case GDK_KEY_KP_F3:
        sts = ctx->event_handler(flow_eEvent_Key_PF3, 0, 0, 0, 0);
        break;
      case GDK_KEY_KP_F4:
        sts = ctx->event_handler(flow_eEvent_Key_PF4, 0, 0, 0, 0);
        break;
      case GDK_KEY_Tab:
        sts = ctx->event_handler(flow_eEvent_Key_Tab, 0, 0, 0, 0);
        break;
      default:;
      }
      break;
    }
    case GDK_BUTTON_PRESS:

      switch (event.button.button) {
      case 1:
        ctx->event_handler(flow_eEvent_MB1Down, (int)event.button.x,
            (int)event.button.y, 0, 0);
        if (click_sensitivity & flow_mSensitivity_MB1Click
            && !(click_sensitivity & flow_mSensitivity_MB1DoubleClick)
            && !(click_sensitivity & flow_mSensitivity_MB1Press)) {
          memcpy(&last_event, &event, sizeof(event));
          button_pressed = 0;
          button_clicked = 1;
          last_press_x = (int)event.button.x;
          last_press_y = (int)event.button.y;
          return 1;
        } else if (!(click_sensitivity & flow_mSensitivity_MB1Click)
            && !(click_sensitivity & flow_mSensitivity_MB1DoubleClick)
            && click_sensitivity & flow_mSensitivity_MB1Press) {
          memcpy(&last_event, &event, sizeof(event));
          button_pressed = 1;
          button_clicked = 0;
          last_press_x = (int)event.button.x;
          last_press_y = (int)event.button.y;
        }
        break;
      case 2:
        ctx->event_handler(flow_eEvent_MB2Down, (int)event.button.x,
            (int)event.button.y, 0, 0);
        if (click_sensitivity & flow_mSensitivity_MB2Click
            && !(click_sensitivity & flow_mSensitivity_MB2DoubleClick)
            && !(click_sensitivity & flow_mSensitivity_MB2Press)) {
          memcpy(&last_event, &event, sizeof(event));
          button_pressed = 0;
          button_clicked = 1;
          last_press_x = (int)event.button.x;
          last_press_y = (int)event.button.y;
          return 1;
        } else if (!(click_sensitivity & flow_mSensitivity_MB2Click)
            && !(click_sensitivity & flow_mSensitivity_MB2DoubleClick)
            && click_sensitivity & flow_mSensitivity_MB2Press) {
          memcpy(&last_event, &event, sizeof(event));
          button_pressed = 1;
          button_clicked = 0;
          last_press_x = (int)event.button.x;
          last_press_y = (int)event.button.y;
        }
        break;
      case 3: // Button 3
        ctx->event_handler(flow_eEvent_MB3Down, (int)event.button.x,
            (int)event.button.y, 0, 0);
        if (click_sensitivity & flow_mSensitivity_MB3Press
            && !(click_sensitivity & flow_mSensitivity_MB3DoubleClick)
            && !(click_sensitivity & flow_mSensitivity_MB3Click)) {
          ctx->event_handler(flow_eEvent_MB3Press, (int)event.button.x,
              (int)event.button.y, 0, 0);
          click_sensitivity = 0;
          return 1;
        }
        break;
      default:;
      }
      /* Detect press or click event */
      if (button_clicked) {
        /* Wait for release */
        button_clicked_and_pressed = 1;
        cancel_event_timer(ctx);
        button_clicked = 0;
        memcpy(&last_event, &event, sizeof(event));
        button_pressed = event.button.button;
        last_press_x = (int)event.button.x;
        last_press_y = (int)event.button.y;
        event_timer(ctx, 200);
        return 1;
      }
      if (!button_pressed) {
        memcpy(&last_event, &event, sizeof(event));
        button_pressed = event.button.button;
        last_press_x = (int)event.button.x;
        last_press_y = (int)event.button.y;
        event_timer(ctx, 200);
        return 1;
      } else {
        /* Press event, callback from timer */
        button_pressed = 0;
        button_clicked_and_pressed = 0;
        switch (event.button.button) {
        case 1: // Button1
          button1_pressed = 1;
          if ((event.button.state & GDK_SHIFT_MASK)
              && !(event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB1PressShift,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else if (!(event.button.state & GDK_SHIFT_MASK)
              && (event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB1PressCtrl,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else if ((event.button.state & GDK_SHIFT_MASK)
              && (event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB1PressShiftCtrl,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else
            ctx->event_handler(flow_eEvent_MB1Press, (int)event.button.x,
                (int)event.button.y, 0, 0);
          click_sensitivity = 0;
          break;
        case 2: // Button2
          button2_pressed = 1;
          if ((event.button.state & GDK_SHIFT_MASK)
              && !(event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB2PressShift,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else if (!(event.button.state & GDK_SHIFT_MASK)
              && (event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB2PressShift,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else if ((event.button.state & GDK_SHIFT_MASK)
              && (event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB2PressShiftCtrl,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else
            sts = ctx->event_handler(flow_eEvent_MB2Press, (int)event.button.x,
                (int)event.button.y, 0, 0);
          click_sensitivity = 0;
          break;
        case 3: // Button3
          button3_pressed = 1;
          sts = ctx->event_handler(flow_eEvent_MB3Press, (int)event.button.x,
              (int)event.button.y, 0, 0);
          click_sensitivity = 0;
          break;
        }
      }
      break;

    case GDK_BUTTON_RELEASE:
      button1_pressed = 0;
      button2_pressed = 0;
      button3_pressed = 0;

      if (!button_pressed) {
        if (button_clicked) {
          /* Button click, callback from timer */
          button_clicked = 0;
          switch (event.button.button) {
          case 1: // Button1
            if ((event.button.state & GDK_SHIFT_MASK)
                && !(event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB1ClickShift,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else if (!(event.button.state & GDK_SHIFT_MASK)
                && (event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB1ClickCtrl,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else if ((event.button.state & GDK_SHIFT_MASK)
                && (event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB1ClickShiftCtrl,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else
              sts = ctx->event_handler(flow_eEvent_MB1Click,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            click_sensitivity = 0;
            break;
          case 2: // Button2
            if ((event.button.state & GDK_SHIFT_MASK)
                && !(event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB2ClickShift,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else if (!(event.button.state & GDK_SHIFT_MASK)
                && (event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB2ClickCtrl,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else if ((event.button.state & GDK_SHIFT_MASK)
                && (event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB2ClickShiftCtrl,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else
              sts = ctx->event_handler(flow_eEvent_MB2Click,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            click_sensitivity = 0;
            break;
          case 3: // Button3
            sts = ctx->event_handler(flow_eEvent_MB3Click, (int)event.button.x,
                (int)event.button.y, 0, 0);
            click_sensitivity = 0;
            break;
          }
        } else {
          /* Button release */
          sts = ctx->event_handler(flow_eEvent_ButtonRelease,
              (int)event.button.x, (int)event.button.y, 0, 0);
        }
      } else {
        /* Button click */
        cancel_event_timer(ctx);
        if (!button_clicked_and_pressed) {
          /* wait for button double click */
          memcpy(&last_event, &event, sizeof(event));
          button_clicked = 1;
          event_timer(ctx, 200);
          button_pressed = 0;
          return 1;
        } else {
          /* Button double click */
          cancel_event_timer(ctx);
          button_clicked = 0;
          button_pressed = 0;
          button_clicked_and_pressed = 0;
          switch (event.button.button) {
          case 1: // Button1
            if ((event.button.state & GDK_SHIFT_MASK)
                && !(event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB1DoubleClickShift,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else if (!(event.button.state & GDK_SHIFT_MASK)
                && (event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB1DoubleClickCtrl,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else if ((event.button.state & GDK_SHIFT_MASK)
                && (event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB1DoubleClickShiftCtrl,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else
              sts = ctx->event_handler(flow_eEvent_MB1DoubleClick,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            if (sts == FLOW__TERMINATED)
              return sts;
            click_sensitivity = 0;

            break;
          case 2: // Button2
            if ((event.button.state & GDK_SHIFT_MASK)
                && !(event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB2DoubleClickShift,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else if (!(event.button.state & GDK_SHIFT_MASK)
                && (event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB2DoubleClickCtrl,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else if ((event.button.state & GDK_SHIFT_MASK)
                && (event.button.state & GDK_CONTROL_MASK))
              sts = ctx->event_handler(flow_eEvent_MB2DoubleClickShiftCtrl,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            else
              sts = ctx->event_handler(flow_eEvent_MB2DoubleClick,
                  (int)event.button.x, (int)event.button.y, 0, 0);
            click_sensitivity = 0;
            break;
          case 3: // Button3
            click_sensitivity = 0;
            break;
          }
        }
      }
      break;
    case GDK_EXPOSE:
      sts = ctx->event_handler(flow_eEvent_Exposure, event.expose.area.x,
          event.expose.area.y, event.expose.area.width,
          event.expose.area.height);
      break;
    case GDK_VISIBILITY_NOTIFY:
      switch (event.visibility.state) {
      case GDK_VISIBILITY_UNOBSCURED:
        sts = ctx->event_handler(flow_eEvent_VisibilityUnobscured, 0, 0, 0, 0);
        break;
      default:
        sts = ctx->event_handler(flow_eEvent_VisibilityObscured, 0, 0, 0, 0);
        break;
      }
      break;
    case GDK_MOTION_NOTIFY:
      if (event.motion.is_hint) {
        int x, y;

        gdk_window_get_device_position(event.any.window, 
	    gdk_seat_get_pointer(gdk_display_get_default_seat(gdk_display_get_default())),
	    &x, &y, NULL);
        event.button.x = x;
        event.button.y = y;
      }

      if (button3_pressed) {
        button3_pressed = 0;
        button_pressed = 0;
        button_clicked_and_pressed = 0;
      }

      if (button_pressed
          && (ABS((int)event.button.x - last_press_x) > DRAW_PRESS_PIX
                 || ABS((int)event.button.y - last_press_y) > DRAW_PRESS_PIX)) {
        event.button.x = last_press_x;
        event.button.y = last_press_y;

        /* Button press */
        cancel_event_timer(ctx);
        switch (button_pressed) {
        case 1: // Button1
          button1_pressed = 1;
          if ((event.button.state & GDK_SHIFT_MASK)
              && !(event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB1PressShift,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else if (!(event.button.state & GDK_SHIFT_MASK)
              && (event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB1PressCtrl,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else if ((event.button.state & GDK_SHIFT_MASK)
              && (event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB1PressShiftCtrl,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else
            ctx->event_handler(flow_eEvent_MB1Press, (int)event.button.x,
                (int)event.button.y, 0, 0);
          break;
        case 2: // Button2
          button2_pressed = 1;
          if ((event.button.state & GDK_SHIFT_MASK)
              && !(event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB2PressShift,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else if (!(event.button.state & GDK_SHIFT_MASK)
              && (event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB2PressShift,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else if ((event.button.state & GDK_SHIFT_MASK)
              && (event.button.state & GDK_CONTROL_MASK))
            sts = ctx->event_handler(flow_eEvent_MB2PressShiftCtrl,
                (int)event.button.x, (int)event.button.y, 0, 0);
          else
            sts = ctx->event_handler(flow_eEvent_MB2Press, (int)event.button.x,
                (int)event.button.y, 0, 0);
          break;
        case 3: // Button3
          button3_pressed = 1;
          sts = ctx->event_handler(flow_eEvent_MB3Press, (int)event.button.x,
              (int)event.button.y, 0, 0);
          break;
        }
        button_pressed = 0;
        button_clicked_and_pressed = 0;
      }
      if (button1_pressed || button2_pressed || button3_pressed)
        sts = ctx->event_handler(flow_eEvent_ButtonMotion, (int)event.button.x,
            (int)event.button.y, 0, 0);
      else
        sts = ctx->event_handler(flow_eEvent_CursorMotion, (int)event.button.x,
            (int)event.button.y, 0, 0);
      break;
    case GDK_ENTER_NOTIFY:
      sts = ctx->event_handler(flow_eEvent_Enter, (int)event.crossing.x,
          (int)event.crossing.y, 0, 0);
      break;
    case GDK_LEAVE_NOTIFY:
      sts = ctx->event_handler(flow_eEvent_Leave, (int)event.crossing.x,
          (int)event.crossing.y, 0, 0);
      break;
    case GDK_MAP:
      sts = ctx->event_handler(flow_eEvent_Map, 0, 0, 0, 0);
      break;
    case GDK_UNMAP:
      sts = ctx->event_handler(flow_eEvent_Unmap, 0, 0, 0, 0);
      break;
    case GDK_FOCUS_CHANGE:
      break;
    case GDK_SCROLL:
      if (event.scroll.direction == GDK_SCROLL_UP)
        sts = ctx->event_handler(flow_eEvent_ScrollUp, 0, 0, 0, 0);
      else if (event.scroll.direction == GDK_SCROLL_DOWN)
        sts = ctx->event_handler(flow_eEvent_ScrollDown, 0, 0, 0, 0);
      break;
    default:
      break;
    }
  } else if (event.any.window == nav_window) {
    switch (event.type) {
    case GDK_BUTTON_PRESS:
      switch (event.button.button) {
      case 1: // Button1
        button1_pressed = 1;
        sts = ctx->event_handler_nav(
            flow_eEvent_MB1Press, (int)event.button.x, (int)event.button.y);
        break;
      case 2: // Button2
        button2_pressed = 1;
        sts = ctx->event_handler_nav(
            flow_eEvent_MB2Press, (int)event.button.x, (int)event.button.y);
        break;
      case 3: // Button3
        button3_pressed = 1;
        break;
      }
      break;
    case GDK_BUTTON_RELEASE:
      switch (event.button.button) {
      case 1: // Button1
        button1_pressed = 0;
        break;
      case 2: // Button2
        button2_pressed = 0;
        break;
      case 3: // Button3
        button3_pressed = 0;
        break;
      }
      if (event.button.button == 1 && (event.button.state & GDK_SHIFT_MASK)
          && !(event.button.state & GDK_CONTROL_MASK))
        sts = ctx->event_handler_nav(flow_eEvent_MB1ClickShift,
            (int)event.button.x, (int)event.button.y);
      else
        sts = ctx->event_handler_nav(flow_eEvent_ButtonRelease,
            (int)event.button.x, (int)event.button.y);
      break;
    case GDK_EXPOSE:
      sts = ctx->event_handler_nav(flow_eEvent_Exposure, 0, 0);
      break;
    case GDK_MOTION_NOTIFY:
      if (event.motion.is_hint) {
        int x, y;

        gdk_window_get_device_position(event.any.window, 
	    gdk_seat_get_pointer(gdk_display_get_default_seat(gdk_display_get_default())),
            &x, &y, NULL);
        event.button.x = x;
        event.button.y = y;
      }

      if (button1_pressed || button2_pressed || button3_pressed)
        sts = ctx->event_handler_nav(
            flow_eEvent_ButtonMotion, (int)event.button.x, (int)event.button.y);
      else
        sts = ctx->event_handler_nav(
            flow_eEvent_CursorMotion, (int)event.button.x, (int)event.button.y);
      break;
    default:;
    }
  }
  if (sts == FLOW__DESTROYED)
    return 1;

  gdk_display_flush(display);
  return 1;
}

void FlowDrawGtk::enable_event(FlowCtx* ctx, flow_eEvent event,
    flow_eEventType event_type,
    int (*event_cb)(FlowCtx* ctx, flow_tEvent event))
{
  ctx->enable_event(event, event_type, event_cb);
}

cairo_t* FlowDrawGtk::get_cairo(int create)
{
  if (!cairo_cr_refcnt) {
    if (!create)
      printf("** Cairo context create error\n");

    cairo_region = cairo_region_create();
    cairo_context = gdk_window_begin_draw_frame(window, cairo_region);
    cairo_cr = gdk_drawing_context_get_cairo_context(cairo_context);
  }
  cairo_cr_refcnt++;
  return cairo_cr;
}

void FlowDrawGtk::end_cairo(cairo_t* cr)
{
  pwr_Assert(cairo_cr_refcnt != 0);
  cairo_cr_refcnt--;

  if (cairo_cr_refcnt == 0) {
    gdk_window_end_draw_frame(window, cairo_context);
    cairo_region_destroy(cairo_region);
  }
}

cairo_t* FlowDrawGtk::get_cairo_nav()
{
  if (!cairo_nav_cr_refcnt) {
    cairo_nav_region = cairo_region_create();
    cairo_nav_context = gdk_window_begin_draw_frame(nav_window, cairo_nav_region);
    cairo_nav_cr = gdk_drawing_context_get_cairo_context(cairo_nav_context);
  }
  cairo_nav_cr_refcnt++;
  return cairo_nav_cr;
}

void FlowDrawGtk::end_cairo_nav(cairo_t* cr)
{
  pwr_Assert(cairo_nav_cr_refcnt != 0);
  cairo_nav_cr_refcnt--;

  if (cairo_nav_cr_refcnt == 0) {
    gdk_window_end_draw_frame(nav_window, cairo_nav_context);
    cairo_region_destroy(cairo_nav_region);
  }
}

int FlowDrawGtk::rect(FlowCtx* ctx, int x, int y, int width, int height,
    flow_eDrawType gc_type, int idx, int highlight, int dimmed)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  if (highlight) {
    if (gc_type == flow_eDrawType_LineGray)
      cairo_set_source(cr, gc_black);
    else
      cairo_set_source(cr, gc_red);
  } else {
    if (dimmed || gc_type == flow_eDrawType_LineGray)
      cairo_set_source(cr, gc_gray);
    else if (gc_type == flow_eDrawType_LineErase)
      cairo_set_source(cr, gc_erase);
    else
      cairo_set_source(cr, gc_black);
  }
  cairo_set_line_width(cr, idx+1);

  cairo_rectangle(cr, x, y, width, height);
  cairo_stroke(cr);
  end_cairo(cr);

  return 1;
}

int FlowDrawGtk::rect_erase(
    FlowCtx* ctx, int x, int y, int width, int height, int idx)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  cairo_set_source(cr, gc_erase);
  cairo_set_line_width(cr, idx+1);

  cairo_rectangle(cr, x, y, width, height);
  cairo_stroke(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::nav_rect(FlowCtx* ctx, int x, int y, int width, int height,
    flow_eDrawType gc_type, int idx, int highlight)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  if (gc_type == flow_eDrawType_LineGray && highlight)
    cairo_set_source(cr, gc_black);
  else if (highlight)
    cairo_set_source(cr, gc_red);
  else
    cairo_set_source(cr, gc_black);
  cairo_set_line_width(cr, idx+1);

  cairo_rectangle(cr, x, y, width, height);
  cairo_stroke(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::nav_rect_erase(
    FlowCtx* ctx, int x, int y, int width, int height, int idx)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  cairo_set_source(cr, gc_erase);
  cairo_set_line_width(cr, idx+1);

  cairo_rectangle(cr, x, y, width, height);
  cairo_stroke(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::triangle(FlowCtx* ctx, int x, int y, int width, int height,
    flow_eDrawType gc_type, int idx, int highlight, int dimmed)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  if (dimmed || gc_type == flow_eDrawType_LineGray)
    cairo_set_source(cr, gc_gray);
  else if (gc_type == flow_eDrawType_LineGray && highlight)
    cairo_set_source(cr, gc_black);
  else if (highlight)
    cairo_set_source(cr, gc_red);
  else
    cairo_set_source(cr, gc_black);
  cairo_set_line_width(cr, idx+1);

  cairo_move_to(cr, x, y + height);
  cairo_line_to(cr, x + width / 2, y);
  cairo_line_to(cr, x + width, y + height);
  cairo_line_to(cr, x, y + height);
  cairo_stroke(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::triangle_erase(
    FlowCtx* ctx, int x, int y, int width, int height, int idx)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  cairo_set_source(cr, gc_erase);
  cairo_set_line_width(cr, idx+1);

  cairo_move_to(cr, x, y + height);
  cairo_line_to(cr, x + width / 2, y);
  cairo_line_to(cr, x + width, y + height);
  cairo_line_to(cr, x, y + height);
  cairo_stroke(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::nav_triangle(FlowCtx* ctx, int x, int y, int width, int height,
    flow_eDrawType gc_type, int idx, int highlight)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  if (highlight)
    cairo_set_source(cr, gc_red);
  else
    cairo_set_source(cr, gc_black);
  cairo_set_line_width(cr, idx+1);

  cairo_move_to(cr, x, y + height);
  cairo_line_to(cr, x + width / 2, y);
  cairo_line_to(cr, x + width, y + height);
  cairo_line_to(cr, x, y + height);
  cairo_stroke(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::nav_fill_triangle(
    FlowCtx* ctx, int x, int y, int width, int height, flow_eDrawType gc_type)
{
  if (ctx->no_nav || ctx->nodraw || gc_type != flow_eDrawType_LineRed)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  cairo_set_source(cr, gc_red);

  cairo_move_to(cr, x, y + height);
  cairo_line_to(cr, x + width / 2, y);
  cairo_line_to(cr, x + width, y + height);
  cairo_line_to(cr, x, y + height);
  cairo_fill(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::nav_triangle_erase(
    FlowCtx* ctx, int x, int y, int width, int height, int idx)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  cairo_set_source(cr, gc_erase);

  cairo_move_to(cr, x, y + height);
  cairo_line_to(cr, x + width / 2, y);
  cairo_line_to(cr, x + width, y + height);
  cairo_line_to(cr, x, y + height);
  cairo_fill(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::arrow(FlowCtx* ctx, int x1, int y1, int x2, int y2, int x3,
    int y3, flow_eDrawType gc_type, int idx, int highlight)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  if (highlight)
    cairo_set_source(cr, gc_red);
  else {
    if (gc_type == flow_eDrawType_LineGray)
      cairo_set_source(cr, gc_gray);
    else
      cairo_set_source(cr, gc_black);
  }
  cairo_move_to(cr, x1, y1);
  cairo_line_to(cr, x2, y2);
  cairo_line_to(cr, x3, y3);
  cairo_close_path(cr);
  cairo_fill(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::arrow_erase(
    FlowCtx* ctx, int x1, int y1, int x2, int y2, int x3, int y3, int idx)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  cairo_set_source(cr, gc_erase);

  cairo_move_to(cr, x1, y1);
  cairo_line_to(cr, x2, y2);
  cairo_line_to(cr, x3, y3);
  cairo_close_path(cr);
  cairo_fill(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::nav_arrow(FlowCtx* ctx, int x1, int y1, int x2, int y2, int x3,
    int y3, flow_eDrawType gc_type, int idx, int highlight)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  if (gc_type == flow_eDrawType_LineGray && highlight)
    cairo_set_source(cr, gc_black);
  else if (gc_type == flow_eDrawType_LineGray)
    cairo_set_source(cr, gc_gray);
  else if (highlight)
    cairo_set_source(cr, gc_red);
  else
    cairo_set_source(cr, gc_black);

  cairo_move_to(cr, x1, y1);
  cairo_line_to(cr, x2, y2);
  cairo_line_to(cr, x3, y3);
  cairo_line_to(cr, x1, y1);
  cairo_fill(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::nav_arrow_erase(
    FlowCtx* ctx, int x1, int y1, int x2, int y2, int x3, int y3, int idx)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  cairo_set_source(cr, gc_erase);

  cairo_move_to(cr, x1, y1);
  cairo_line_to(cr, x2, y2);
  cairo_line_to(cr, x3, y3);
  cairo_line_to(cr, x1, y1);
  cairo_fill(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::arc(FlowCtx* ctx, int x, int y, int width, int height,
    int angle1, int angle2, flow_eDrawType gc_type, int idx, int highlight,
    int dimmed)
{
  if (ctx->nodraw)
    return 1;

  if (width == 0 || height == 0)
    return 1;

  cairo_matrix_t matrix;
  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  if (dimmed)
    cairo_set_source(cr, gc_gray);
  else if (gc_type == flow_eDrawType_LineGray && highlight)
    cairo_set_source(cr, gc_black);
  else if (highlight)
    cairo_set_source(cr, gc_red);
  else
    cairo_set_source(cr, gc_black);
  cairo_set_line_width(cr, idx+1);

  if (width != height) {
    cairo_get_matrix(cr, &matrix);
    cairo_translate(cr, x + width/2, y + height/2);
    cairo_scale(cr, 1, (double)height/width);
    cairo_translate(cr, -(x + width/2), -(y + height/2));
  }
  cairo_arc(cr, x+width/2, y+height/2, 0.5 * width, -M_PI/180*(angle1 + angle2),- M_PI/180*angle1);

  if (width != height)
    cairo_set_matrix(cr, &matrix);

  cairo_stroke(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::arc_erase(FlowCtx* ctx, int x, int y, int width, int height,
    int angle1, int angle2, int idx)
{
  if (ctx->nodraw)
    return 1;

  cairo_matrix_t matrix;
  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  cairo_set_source(cr, gc_erase);
  cairo_set_line_width(cr, idx+1);

  if (width != height) {
    cairo_get_matrix(cr, &matrix);
    cairo_translate(cr, x + width/2, y + height/2);
    cairo_scale(cr, 1, (double)height/width);
    cairo_translate(cr, -(x + width/2), -(y + height/2));
  }

  cairo_arc(cr, x+width/2, y+height/2, 0.5 * width, -M_PI/180*(angle1+angle2), -M_PI/180*angle1);

  if (width != height)
    cairo_set_matrix(cr, &matrix);

  cairo_stroke(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::nav_arc(FlowCtx* ctx, int x, int y, int width, int height,
    int angle1, int angle2, flow_eDrawType gc_type, int idx, int highlight)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  if (width == 0 || height == 0)
    return 1;

  cairo_matrix_t matrix;
  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  if (gc_type == flow_eDrawType_LineGray && highlight)
    cairo_set_source(cr, gc_black);
  else if (highlight)
    cairo_set_source(cr, gc_red);
  else
    cairo_set_source(cr, gc_black);
  cairo_set_line_width(cr, idx+1);

  if (width != height) {
    cairo_get_matrix(cr, &matrix);
    cairo_translate(cr, x + width/2, y + height/2);
    cairo_scale(cr, 1, (double)height/width);
    cairo_translate(cr, -(x + width/2), -(y + height/2));
  }
  cairo_arc(cr, x+width/2, y+height/2, 0.5 * width, -M_PI/180*(angle1 + angle2),- M_PI/180*angle1);

  if (width != height)
    cairo_set_matrix(cr, &matrix);

  cairo_stroke(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::nav_arc_erase(FlowCtx* ctx, int x, int y, int width,
    int height, int angle1, int angle2, int idx)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  if (width == 0 || height == 0)
    return 1;

  cairo_matrix_t matrix;
  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  cairo_set_source(cr, gc_erase);
  cairo_set_line_width(cr, idx+1);

  if (width != height) {
    cairo_get_matrix(cr, &matrix);
    cairo_translate(cr, x + width/2, y + height/2);
    cairo_scale(cr, 1, (double)height/width);
    cairo_translate(cr, -(x + width/2), -(y + height/2));
  }
  cairo_arc(cr, x+width/2, y+height/2, 0.5 * width, -M_PI/180*(angle1 + angle2),- M_PI/180*angle1);

  if (width != height)
    cairo_set_matrix(cr, &matrix);

  cairo_stroke(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::line(FlowCtx* ctx, int x1, int y1, int x2, int y2,
    flow_eDrawType gc_type, int idx, int highlight, int dimmed)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  if (dimmed || gc_type == flow_eDrawType_LineGray)
    cairo_set_source(cr, gc_gray);
  else if (gc_type == flow_eDrawType_LineGray && highlight)
    cairo_set_source(cr, gc_black);
  else if (highlight)
    cairo_set_source(cr, gc_red);
  else
    cairo_set_source(cr, gc_black);
  if (gc_type == flow_eDrawType_LineDashed) {
    double d[] = {7.0};
    cairo_set_dash(cr, d, 1, 0);
  }
      
  cairo_set_line_width(cr, idx+1);

  if (y1 == y2)
    x1--;
  cairo_move_to(cr, x1, y1);
  cairo_line_to(cr, x2, y2);
  cairo_stroke(cr);
  
  if (gc_type == flow_eDrawType_LineDashed)
    cairo_set_dash(cr, 0, 0, 0);

  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::line_erase(
    FlowCtx* ctx, int x1, int y1, int x2, int y2, int idx)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();
  cairo_set_antialias(cr, antialias);
  cairo_set_source(cr, gc_erase);
  cairo_set_line_width(cr, idx+1);

  if (y1 == y2)
    x1--;
  cairo_move_to(cr, x1, y1);
  cairo_line_to(cr, x2, y2);
  cairo_stroke(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::nav_line(FlowCtx* ctx, int x1, int y1, int x2, int y2,
    flow_eDrawType gc_type, int idx, int highlight)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  if (gc_type == flow_eDrawType_LineGray && highlight)
    cairo_set_source(cr, gc_black);
  else if (highlight)
    cairo_set_source(cr, gc_red);
  else
    cairo_set_source(cr, gc_black);
  cairo_set_line_width(cr, idx+1);

  cairo_move_to(cr, x1, y1);
  cairo_line_to(cr, x2, y2);
  cairo_stroke(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::nav_line_erase(
    FlowCtx* ctx, int x1, int y1, int x2, int y2, int idx)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  cairo_set_source(cr, gc_erase);
  cairo_set_line_width(cr, idx+1);

  cairo_move_to(cr, x1, y1);
  cairo_line_to(cr, x2, y2);
  cairo_stroke(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::text(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType gc_type, int idx, int highlight, int dimmed, int line,
    double size)
{
  if (ctx->nodraw)
    return 1;

  size *= DRAW_TSCALE;

  char* textutf8 = 0;
  if (ctx->text_coding != flow_eTextCoding_UTF_8) {
    textutf8 = g_convert(text, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
    text = textutf8;
  }

  cairo_t *cr = get_cairo();
  if (gc_type == flow_eDrawType_TextHelveticaErase ||
      gc_type == flow_eDrawType_TextHelveticaEraseBold)
    cairo_set_source(cr, gc_erase);
  else
    cairo_set_source(cr, gc_black);

  cairo_set_font_face(cr, get_font_face(gc_type));
  cairo_set_font_size(cr, size);
  cairo_move_to(cr, x, y-1);
  cairo_show_text(cr, text);
  end_cairo(cr);

  if (textutf8)
    g_free(textutf8);

  return 1;
}

int FlowDrawGtk::text_inverse(FlowCtx* ctx, int x, int y, char* txt, int len,
    flow_eDrawType gc_type, int idx, int line, double size)
{
  if (ctx->nodraw)
    return 1;

  switch (gc_type) {
  case flow_eDrawType_TextHelveticaErase:
    gc_type =  flow_eDrawType_TextHelvetica;
    break;
  case flow_eDrawType_TextHelveticaEraseBold:
    gc_type =  flow_eDrawType_TextHelveticaBold;
    break;
  case flow_eDrawType_TextHelvetica:
    gc_type =  flow_eDrawType_TextHelveticaErase;
    break;
  case flow_eDrawType_TextHelveticaBold:
    gc_type =  flow_eDrawType_TextHelveticaEraseBold;
    break;
  default:
    ;
  }
  return text(ctx, x, y, txt, len, gc_type, idx, 0, 0, line, size);
}

int FlowDrawGtk::text_erase(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType gc_type, int idx, int line, double size)
{
  if (ctx->nodraw)
    return 1;

  size *= DRAW_TSCALE;

  char* textutf8 = 0;
  if (ctx->text_coding != flow_eTextCoding_UTF_8) {
    textutf8 = g_convert(text, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
    text = textutf8;
  }

  cairo_text_extents_t extents;
  cairo_t *cr = get_cairo();
  cairo_set_source(cr, gc_erase);

  cairo_set_font_face(cr, get_font_face(gc_type));
  cairo_set_font_size(cr, size);
  cairo_text_extents(cr, text, &extents);
  cairo_set_source(cr, gc_erase);
  cairo_rectangle(cr, (double)x + extents.x_bearing, (double)y + extents.y_bearing, extents.width, extents.height);
  cairo_fill(cr);

  end_cairo(cr);

  if (textutf8)
    g_free(textutf8);

  return 1;
}

int FlowDrawGtk::nav_text(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType gc_type, int idx, int highlight, int line, double size)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  size *= DRAW_TSCALE;

  cairo_t *cr = get_cairo_nav();
  if (gc_type == flow_eDrawType_TextHelveticaErase ||
      gc_type == flow_eDrawType_TextHelveticaEraseBold)
    cairo_set_source(cr, gc_erase);
  else
    cairo_set_source(cr, gc_black);

  cairo_set_font_face(cr, get_font_face(gc_type));
  cairo_set_font_size(cr, size);
  cairo_move_to(cr, x, y);
  cairo_show_text(cr, text);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::nav_text_erase(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType gc_type, int idx, int line, double size)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  size *= DRAW_TSCALE;

  char* textutf8 = 0;
  if (ctx->text_coding != flow_eTextCoding_UTF_8) {
    textutf8 = g_convert(text, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
    text = textutf8;
  }

  cairo_text_extents_t extents;
  cairo_t *cr = get_cairo_nav();
  cairo_set_source(cr, gc_erase);

  cairo_set_font_face(cr, get_font_face(gc_type));
  cairo_set_font_size(cr, size);
  cairo_text_extents(cr, text, &extents);
  cairo_set_source(cr, gc_erase);
  cairo_rectangle(cr, (double)x + extents.x_bearing, (double)y + extents.y_bearing, extents.width, extents.height);
  cairo_fill(cr);

  end_cairo_nav(cr);

  if (textutf8)
    g_free(textutf8);

  return 1;
}

int FlowDrawGtk::pixmaps_create(
    FlowCtx* ctx, flow_sPixmapData* pixmap_data, void** pixmaps)
{
  cairo_format_t format = CAIRO_FORMAT_A1;
  int stride;

  draw_sPixmap* pms;
  flow_sPixmapDataElem *prev_pdata = NULL,
      *pdata = (flow_sPixmapDataElem *)pixmap_data;
  int i;

  pms = (draw_sPixmap*)calloc(1, sizeof(*pms));
  for (i = 0; i < DRAW_PIXMAP_SIZE; i++) {
    if (i == 0 || (i > 0 && pdata->bits != prev_pdata->bits)) {
      stride = cairo_format_stride_for_width(format, pdata->width);

      pms->data[i] = (unsigned char *)calloc(1, stride * pdata->height);
      int pwidth = ((pdata->width - 1)/8 + 1);
      int pidx = 0;
      int sidx = 0;
      for (int j = 0; j < pdata->height; j++) {
	for (int k = 0; k < pwidth; k++) {
	  pms->data[i][sidx] = pdata->bits[pidx];
	  pidx++;	  
	  sidx++;
	}
	sidx = (j + 1) * stride;
      }

      pms->pixmap[i] = cairo_image_surface_create_for_data(pms->data[i], 
	  format, pdata->width, pdata->height, stride);

      //free(data);
    } else
      pms->pixmap[i] = pms->pixmap[i - 1];
    prev_pdata = pdata;
    pdata++;
  }
  *pixmaps = (void*)pms;
  return 1;
}

void FlowDrawGtk::pixmaps_delete(FlowCtx* ctx, void* pixmaps)
{
  draw_sPixmap* pms;
  int i;

  pms = (draw_sPixmap*)pixmaps;
  for (i = 0; i < DRAW_PIXMAP_SIZE; i++) {
    if (i == 0 || (i > 0 && pms->pixmap[i] != pms->pixmap[i - 1])) {
      cairo_surface_destroy(pms->pixmap[i]);
      free(pms->data[i]);
    }
  }
  free(pixmaps);

}

int FlowDrawGtk::pixmap(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType gc_type,
    int idx, int highlight, int line)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();
 
  draw_sPixmap* pms = (draw_sPixmap*)pixmaps;
#if 0
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;

  cairo_set_source(cr, gc_erase);
  cairo_rectangle(cr, x, y, pdata->width, pdata->height);
  cairo_fill(cr);
#endif

  if (gc_type == flow_eDrawType_LineRed)
    cairo_set_source(cr, gc_red);
  else
    cairo_set_source(cr, gc_black);
  cairo_mask_surface(cr, pms->pixmap[idx], x, y);
  cairo_fill(cr);

  end_cairo(cr);

  return 1;
}

int FlowDrawGtk::pixmap_inverse(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType gc_type,
    int idx, int line)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();
 
  draw_sPixmap* pms = (draw_sPixmap*)pixmaps;
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;

  cairo_set_source(cr, gc_black);
  cairo_rectangle(cr, x, y, pdata->width, pdata->height);
  cairo_fill(cr);

  cairo_set_source(cr, gc_erase);
  cairo_mask_surface(cr, pms->pixmap[idx], x, y);
  cairo_fill(cr);

  end_cairo(cr);

  return 1;
}

int FlowDrawGtk::pixmap_erase(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType gc_type,
    int idx, int line)
{
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;

  fill_rect(ctx, x, y, pdata->width, pdata->height, flow_eDrawType_LineErase);

  return 1;
}

int FlowDrawGtk::nav_pixmap(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType gc_type,
    int idx, int highlight, int line)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();
 
  draw_sPixmap* pms = (draw_sPixmap*)pixmaps;
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;

  cairo_set_source(cr, gc_erase);
  cairo_rectangle(cr, x, y, pdata->width, pdata->height);
  cairo_fill(cr);

  cairo_set_source(cr, gc_black);
  cairo_mask_surface(cr, pms->pixmap[idx], x, y);
  cairo_fill(cr);

  end_cairo_nav(cr);

  return 1;
}

int FlowDrawGtk::nav_pixmap_erase(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType gc_type,
    int idx, int line)
{
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;

  nav_fill_rect(ctx, x, y, pdata->width, pdata->height, flow_eDrawType_LineErase);
  return 1;
}

int FlowDrawGtk::fill_rect(
    FlowCtx* ctx, int x, int y, int w, int h, flow_eDrawType gc_type)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  switch (gc_type) {
  case flow_eDrawType_LineRed:
    cairo_set_source(cr, gc_red);
    break;
  case flow_eDrawType_Green:
    cairo_set_source(cr, gc_green);
    break;
  case flow_eDrawType_Yellow:
    cairo_set_source(cr, gc_yellow);
    break;
  case flow_eDrawType_DarkGray:
    cairo_set_source(cr, gc_darkgray);
    break;
  case flow_eDrawType_LineErase:
    cairo_set_source(cr, gc_erase);
    break;
  default:
    cairo_set_source(cr, gc_black);
  }
  cairo_rectangle(cr, x, y, w, h);
  cairo_fill(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::nav_fill_rect(
    FlowCtx* ctx, int x, int y, int w, int h, flow_eDrawType gc_type)
{
  if (ctx->no_nav || ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo_nav();

  cairo_set_antialias(cr, nav_antialias);
  switch (gc_type) {
  case flow_eDrawType_LineRed:
    cairo_set_source(cr, gc_red);
    break;
  case flow_eDrawType_Green:
    cairo_set_source(cr, gc_green);
    break;
  case flow_eDrawType_Yellow:
    cairo_set_source(cr, gc_yellow);
    break;
  case flow_eDrawType_DarkGray:
    cairo_set_source(cr, gc_darkgray);
    break;
  case flow_eDrawType_LineErase:
    cairo_set_source(cr, gc_erase);
    break;
  default:
    cairo_set_source(cr, gc_black);
  }
  cairo_rectangle(cr, x, y, w, h);
  cairo_fill(cr);
  end_cairo_nav(cr);
  return 1;
}

int FlowDrawGtk::fill_triangle(
    FlowCtx* ctx, int x, int y, int w, int h, flow_eDrawType gc_type)
{
  if (ctx->nodraw)
    return 1;

  cairo_t *cr = get_cairo();

  cairo_set_antialias(cr, antialias);
  switch (gc_type) {
  case flow_eDrawType_LineRed:
    cairo_set_source(cr, gc_red);
    break;
  case flow_eDrawType_Green:
    cairo_set_source(cr, gc_green);
    break;
  case flow_eDrawType_Yellow:
    cairo_set_source(cr, gc_yellow);
    break;
  case flow_eDrawType_DarkGray:
    cairo_set_source(cr, gc_darkgray);
    break;
  case flow_eDrawType_LineErase:
    cairo_set_source(cr, gc_erase);
    break;
  default:
    cairo_set_source(cr, gc_black);
  }
  cairo_move_to(cr, x, y + h);
  cairo_line_to(cr, x + w / 2, y);
  cairo_line_to(cr, x + w, y + h);
  cairo_line_to(cr, x, y + h);
  cairo_fill(cr);
  end_cairo(cr);
  return 1;
}

int FlowDrawGtk::image(FlowCtx* ctx, int x, int y, int width, int height,
    flow_tImImage image, flow_tPixmap pixmap, flow_tPixmap clip_mask)
{
  if (ctx->nodraw)
    return 1;

  if (width == 0 || height == 0)
    return 1;

  cairo_t *cr = get_cairo();

  if (clip_mask)
    set_image_clip_mask(ctx, clip_mask, x, y);

  gdk_cairo_set_source_pixbuf(cr, (GdkPixbuf *)image, x, y);
  cairo_paint(cr);

  if (clip_mask)
    reset_image_clip_mask(ctx);

  end_cairo(cr);

  return 1;
}

void FlowDrawGtk::clear(FlowCtx* ctx)
{
  if (ctx->nodraw)
    return;

  fill_rect(ctx, 0, 0, ctx->window_width, ctx->window_height, flow_eDrawType_LineErase);
  //gdk_window_clear(window);
}

void FlowDrawGtk::nav_clear(FlowCtx* ctx)
{
  nav_fill_rect(ctx, 0, 0, ctx->nav_window_width, ctx->nav_window_height, flow_eDrawType_LineErase);
}

void FlowDrawGtk::get_window_size(FlowCtx* ctx, int* width, int* height)
{
  *width = gdk_window_get_width(window);
  *height = gdk_window_get_height(window); 
}

void FlowDrawGtk::get_nav_window_size(FlowCtx* ctx, int* width, int* height)
{
  *width = gdk_window_get_width(nav_window);
  *height = gdk_window_get_height(nav_window);
}

void FlowDrawGtk::set_nav_window_size(FlowCtx* ctx, int width, int height)
{
  GdkGeometry hints;
  hints.min_width = width;
  hints.max_width = width;
  hints.min_height = height;
  hints.max_height = height;
  gtk_window_set_geometry_hints(GTK_WINDOW(nav_toplevel), GTK_WIDGET(nav_toplevel), 
     &hints, (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));
  gtk_window_set_default_size(GTK_WINDOW(nav_toplevel), width, height);
}

static gboolean draw_timer_cb(void* data)
{
  draw_sTimerCb* timer_cb = (draw_sTimerCb*)data;
  FlowDrawGtk* draw_ctx = (FlowDrawGtk*)timer_cb->ctx->fdraw;

  (timer_cb->callback_func)(timer_cb->ctx);
  gdk_display_flush(draw_ctx->display);
  free(timer_cb);
  return FALSE;
}

static gboolean event_timer_cb(void* ctx)
{
  ((FlowDrawGtk*)((FlowCtx*)ctx)->fdraw)->timer_id = 0;
  ((FlowDrawGtk*)((FlowCtx*)ctx)->fdraw)
      ->event_handler((FlowCtx*)ctx, last_event);
  return FALSE;
}

static void cancel_event_timer(FlowCtx* ctx)
{
  FlowDrawGtk* draw_ctx = (FlowDrawGtk*)ctx->fdraw;
  if (draw_ctx->timer_id) {
    g_source_remove(draw_ctx->timer_id);
    draw_ctx->timer_id = 0;
  }
}

static void event_timer(FlowCtx* ctx, int time_ms)
{
  FlowDrawGtk* draw_ctx = (FlowDrawGtk*)ctx->fdraw;
  draw_ctx->timer_id = g_timeout_add(time_ms, event_timer_cb, ctx);
}

void FlowDrawGtk::set_timer(
    FlowCtx* ctx, int time_ms, void (*callback_func)(FlowCtx* ctx), void** id)
{
  draw_sTimerCb* timer_cb;

  timer_cb = (draw_sTimerCb*)calloc(1, sizeof(draw_sTimerCb));
  timer_cb->ctx = ctx;
  timer_cb->callback_func = callback_func;

  timer_cb->timer_id = g_timeout_add(time_ms, draw_timer_cb, timer_cb);

  *id = (void*)timer_cb;
}

void FlowDrawGtk::cancel_timer(FlowCtx* ctx, void* id)
{
  g_source_remove(((draw_sTimerCb*)id)->timer_id);

  free((char*)id);
}

void FlowDrawGtk::set_cursor(FlowCtx* ctx, draw_eCursor cursor)
{
  if (cursor == draw_eCursor_Normal)
    gdk_window_set_cursor(window, NULL);
  else
    gdk_window_set_cursor(window, cursors[cursor]);
  gdk_display_flush(display);
}

void FlowDrawGtk::set_nav_cursor(FlowCtx* ctx, draw_eCursor cursor)
{
  if (ctx->no_nav)
    return;

  if (cursor == draw_eCursor_Normal)
    gdk_window_set_cursor(nav_window, NULL);
  else
    gdk_window_set_cursor(nav_window, cursors[cursor]);
  gdk_display_flush(display);
}

int FlowDrawGtk::get_text_extent(FlowCtx* ctx, const char* text, int len,
    flow_eDrawType gc_type, int idx, int* width, int* height, double size)
{
  cairo_text_extents_t extents;

  size *= DRAW_TSCALE;

  char* textutf8 = 0;
  if (ctx->text_coding != flow_eTextCoding_UTF_8) {
    textutf8 = g_convert(text, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
    text = textutf8;
  }

  cairo_t *cr = get_cairo(1);

  cairo_set_font_face(cr, get_font_face(gc_type));
  cairo_set_font_size(cr, size);

  cairo_text_extents(cr, text, &extents);
  *width = extents.width;
  *height = extents.height;

  end_cairo(cr);

  if (textutf8)
    g_free(textutf8);

  return 1;
}

cairo_font_face_t* FlowDrawGtk::get_font_face(flow_eDrawType gc_type)
{
  if (gc_type == flow_eDrawType_TextHelveticaBold ||
      gc_type == flow_eDrawType_TextHelveticaEraseBold) {
    if (!font_face_bold)
      font_face_bold = cairo_toy_font_face_create(font_name, CAIRO_FONT_SLANT_NORMAL,
          CAIRO_FONT_WEIGHT_BOLD);
    return font_face_bold;
  }
  else {
    if (!font_face_normal)
      font_face_normal = cairo_toy_font_face_create(font_name, CAIRO_FONT_SLANT_NORMAL,
        CAIRO_FONT_WEIGHT_NORMAL);
    return font_face_normal;
  }
}


void FlowDrawGtk::copy_area(FlowCtx* ctx, int x, int y)
{
  if (ctx->nodraw)
    return;

  ctx->draw(0, 0, ctx->window_width, ctx->window_height);
}

void FlowDrawGtk::clear_area(
    FlowCtx* ctx, int ll_x, int ur_x, int ll_y, int ur_y)
{
  fill_rect(ctx, ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, flow_eDrawType_LineErase);
}

void FlowDrawGtk::set_inputfocus(FlowCtx* ctx)
{
  gdk_window_focus(((FlowDrawGtk*)ctx->fdraw)->window, GDK_CURRENT_TIME);
  // gtk_widget_grab_focus( toplevel);
}

void FlowDrawGtk::set_click_sensitivity(FlowCtx* ctx, int value)
{
  click_sensitivity = value;
}

void FlowDrawGtk::set_image_clip_mask(
    FlowCtx* ctx, flow_tPixmap pixmap, int x, int y)
{
}

void FlowDrawGtk::reset_image_clip_mask(FlowCtx* ctx)
{
}

void FlowDrawGtk::set_white_background(FlowCtx* ctx)
{
  //fill_rect(ctx, 0, 0, ctx->window_width, ctx->window_height, flow_eDrawType_LineErase);

}

int FlowDrawGtk::get_font_idx(int gc_type)
{
  int font_idx;

  switch (gc_type) {
  case flow_eDrawType_TextHelvetica:
  case flow_eDrawType_TextHelveticaErase:
    font_idx = draw_eFont_Helvetica;
    break;
  case flow_eDrawType_TextHelveticaBold:
  case flow_eDrawType_TextHelveticaEraseBold:
    font_idx = draw_eFont_HelveticaBold;
    break;
  default:
    font_idx = draw_eFont_Helvetica;
  }

  return font_idx;
}

int FlowDrawGtk::image_get_width(flow_tImImage image)
{
  return gdk_pixbuf_get_width((GdkPixbuf*)image);
}

int FlowDrawGtk::image_get_height(flow_tImImage image)
{
  return gdk_pixbuf_get_height((GdkPixbuf*)image);
}

void FlowDrawGtk::image_scale(float scale, flow_tImImage orig_im,
    flow_tImImage* im, flow_tPixmap* im_pixmap, flow_tPixmap* im_mask)
{
  int current_width = int(scale * gdk_pixbuf_get_width((GdkPixbuf*)orig_im));
  int current_height = int(scale * gdk_pixbuf_get_height((GdkPixbuf*)orig_im));

  if (*im)
    g_object_unref((GdkPixbuf*)*im);
  *im = gdk_pixbuf_scale_simple(
      (GdkPixbuf*)orig_im, current_width, current_height, GDK_INTERP_NEAREST);
}

int FlowDrawGtk::image_load(const char* imagefile, float scale, float nav_scale,
    flow_tImImage* orig_im, flow_tImImage* im, flow_tPixmap* im_pixmap,
    flow_tPixmap* im_mask, flow_tPixmap* im_nav_pixmap,
    flow_tPixmap* im_nav_mask)
{
  pwr_tFileName filename;
  bool found = false;

  strcpy(filename, imagefile);

  // Look for file in $pwrp_exe, $pwr_doc/en_us/orm and $pwr_exe
  for (int i = 0; i < 3; i++) {
    switch (i) {
    case 0:
      strcpy(filename, "$pwrp_exe/");
      break;
    case 1:
      strcpy(filename, "$pwr_doc/en_us/orm/");
      break;
    case 2:
      strcpy(filename, "$pwr_exe/");
      break;
    }
    strcat(filename, imagefile);
    dcli_translate_filename(filename, filename);
    FILE* fp = fopen(filename, "r");
    if (!fp)
      continue;
    fclose(fp);
    found = true;
    break;
  }
  if (!found)
    return 0;

  if (*im)
    g_object_unref((GdkPixbuf*)*im);
  *orig_im = (flow_tImImage*)gdk_pixbuf_new_from_file(filename, 0);

  int width = int(scale * gdk_pixbuf_get_width((GdkPixbuf*)*orig_im));
  int height = int(scale * gdk_pixbuf_get_height((GdkPixbuf*)*orig_im));

  *im = (flow_tImImage*)gdk_pixbuf_scale_simple(
      (GdkPixbuf*)*orig_im, width, height, GDK_INTERP_NEAREST);
  return 1;
}

FlowPrintDraw* FlowDrawGtk::print_draw_new(void* context, const char* title,
    int page, void* flow_ctx, int page_border, int* sts)
{
  FlowPrintDrawGtk* pd
      = new FlowPrintDrawGtk(context, title, page, flow_ctx, page_border, sts);
  return (FlowPrintDraw*)pd;
}
