/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2020 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_cdh.h"
#include "co_string.h"

#include "rt_gdh_msg.h"

#include "ge_graph.h"

#include "xtt_ge.h"
#include "xtt_log.h"
#include "xtt_xnav.h"

void XttGe::eventlog_enable(int enable)
{
  Graph::eventlog_enable(enable);
}

void XttGe::graph_init_cb(void* client_data)
{
  XttGe* ge = (XttGe*)client_data;
  char fname[120];
  int default_width;
  int default_height;
  int sts;
  int path_cnt = 2;
  char path[10][80] = {"$pwrp_exe/", "$pwr_exe/",};

  ge->graph->set_subgraph_path(path_cnt, (char *)path);
  strncpy(fname, ge->filename, sizeof(fname));
  if (fname[0] == '@') {
    ge->graph->read_scriptfile(&fname[1]);
    ge->graph->set_modified(0);
  }
  else {
    if (!strrchr(fname, '.'))
      strcat(fname, ".pwg");
    ge->graph->open(fname);
  }
  if (ge->width == 0 || ge->height == 0) {
    sts = ge->graph->get_default_size(&default_width, &default_height);
    if (ODD(sts)) {
      ge->set_size(default_width, default_height);
    }
  }
  ge->graph->set_default_layout();

  ge->graph->init_trace();
}

int XttGe::graph_close_cb(void* client_data)
{
  XttGe* ge = (XttGe*)client_data;

  if (ge->options & ge_mOptions_Embedded)
    return 0;

  delete ge;
  return 1;
}

int XttGe::ge_command_cb(void* ge_ctx, char* cmd, char* script)
{
  XttGe* ge = (XttGe*)ge_ctx;
  int sts;

  if (ge->command_cb) {
    sts = (ge->command_cb)(ge->parent_ctx, cmd, script, ge_ctx);
    return sts;
  }
  return 0;
}

int XttGe::ge_sound_cb(void* ge_ctx, pwr_tAttrRef* aref)
{
  XttGe* ge = (XttGe*)ge_ctx;

  if (ge->sound_cb)
    return (ge->sound_cb)(ge->parent_ctx, aref);

  return 0;
}

void XttGe::ge_display_in_xnav_cb(void* ge_ctx, pwr_sAttrRef* arp)
{
  XttGe* ge = (XttGe*)ge_ctx;

  if (ge->display_in_xnav_cb)
    (ge->display_in_xnav_cb)(ge->parent_ctx, arp);
}

void XttGe::ge_popup_menu_cb(void* ge_ctx, pwr_sAttrRef attrref,
    unsigned long item_type, unsigned long utility, char* arg, int x, int y)
{
  XttGe* ge = (XttGe*)ge_ctx;

  if (ge->popup_menu_cb)
    (ge->popup_menu_cb)(ge->parent_ctx, attrref, item_type, utility, arg, x, y);
}

int XttGe::ge_call_method_cb(void* ge_ctx, char* method, char* filter,
    pwr_sAttrRef attrref, unsigned long item_type, unsigned long utility,
    char* arg)
{
  XttGe* ge = (XttGe*)ge_ctx;

  if (ge->call_method_cb)
    return (ge->call_method_cb)(
        ge->parent_ctx, method, filter, attrref, item_type, utility, arg);
  else
    return 0;
}

int XttGe::ge_is_authorized_cb(void* ge_ctx, unsigned int access)
{
  XttGe* ge = (XttGe*)ge_ctx;

  if (ge->is_authorized_cb)
    return (ge->is_authorized_cb)(ge->parent_ctx, access);
  return 0;
}

int XttGe::ge_get_current_objects_cb(
    void* ge_ctx, pwr_sAttrRef** alist, int** is_alist)
{
  XttGe* ge = (XttGe*)ge_ctx;

  if (ge->get_current_objects_cb)
    return (ge->get_current_objects_cb)(ge->parent_ctx, alist, is_alist);
  return 0;
}

void XttGe::ge_eventlog_cb(void* ge_ctx, void* data, unsigned int size)
{
  XttGe* ge = (XttGe*)ge_ctx;

  if (ge->eventlog_cb)
    (ge->eventlog_cb)(ge->parent_ctx, ge, xttlog_eCategory_Event, data, size);
}

void XttGe::ge_keyboard_cb(void* ge_ctx, int action, int type)
{
  XttGe* ge = (XttGe*)ge_ctx;

  if (ge->keyboard_cb)
    (ge->keyboard_cb)(ge->parent_ctx, ge, action, type);
}

void XttGe::message_cb(void* ctx, char severity, const char* msg)
{
  ((XttGe*)ctx)->message(severity, msg);
}

void XttGe::message(char severity, const char* msg)
{
  if (!streq(msg, ""))
    printf("** XttGe: %s\n", msg);
}

int XttGe::set_object_focus(const char* name, int empty)
{
  return graph->set_object_focus(name, empty);
}

int XttGe::set_folder_index(const char* name, int idx)
{
  return graph->set_folder_index(name, idx);
}

int XttGe::set_subwindow_source(const char* name, char* source, char* object)
{
  return graph->set_subwindow_source(name, source, object);
}

XttGe::~XttGe()
{
}

void XttGe::print()
{
  pwr_tFileName filename;
  pwr_tCmd cmd;

  dcli_translate_filename(filename, "$pwrp_tmp/graph.ps");
  graph->print(filename);

  sprintf(cmd, "$pwr_exe/rt_print.sh %s 1", filename);
  system(cmd);
}

void XttGe::export_image(char* filename)
{
  pwr_tFileName fname;

  dcli_translate_filename(fname, filename);
  graph->export_image(fname);
}

void XttGe::swap(int mode)
{
  graph->swap(mode);
}

void XttGe::update_color_theme(int theme)
{
  color_theme = theme;
  graph->update_color_theme(color_theme);
}

void XttGe::signal_send(char* signalname)
{
  graph->signal_send(signalname);
}

void XttGe::event_exec(int type, void* event, unsigned int size)
{
  switch (type) {
  case xttlog_eCategory_Event:
    graph->event_exec(event, size);
    break;
  case xttlog_eCategory_GeConfirmOk:
    confirm_reply(1);
    break;
  case xttlog_eCategory_GeConfirmCancel:
    confirm_reply(0);
    break;
  default:;
  }
}

void XttGe::set_text_coding(lng_eCoding coding)
{
  graph->set_text_coding(coding);
}

int XttGe::key_pressed(int key)
{
  return graph->key_pressed(key);
}

void XttGe::close_input_all()
{
  graph->close_input_all();
}

int XttGe::get_object_name(unsigned int idx, int size, char* name)
{
  return graph->get_object_name(idx, size, name);
}

XttGe::XttGe(void* xg_parent_ctx, const char* xg_name, const char* xg_filename,
    int xg_scrollbar, int xg_menu, int xg_navigator, int xg_width,
    int xg_height, int x, int y, double scan_time, const char* object_name,
    int use_default_access, unsigned int access, unsigned int xg_options,
    int xg_color_theme, int (*xg_command_cb)(void*, char*, char*, void*),
    int (*xg_get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
    int (*xg_is_authorized_cb)(void*, unsigned int),
    void (*xg_keyboard_cb)(void*, void*, int, int))
    : parent_ctx(xg_parent_ctx), scrollbar(xg_scrollbar),
      navigator(xg_navigator), menu(xg_menu), current_value_object(0),
      current_confirm_object(0), value_input_open(0), confirm_open(0),
      command_cb(xg_command_cb), close_cb(0), help_cb(0), display_in_xnav_cb(0),
      is_authorized_cb(xg_is_authorized_cb), popup_menu_cb(0),
      call_method_cb(0), get_current_objects_cb(xg_get_current_objects_cb),
      sound_cb(0), eventlog_cb(0), keyboard_cb(xg_keyboard_cb), width(xg_width),
      height(xg_height), options(xg_options), color_theme(xg_color_theme)
{
  strcpy(filename, xg_filename);
  strcpy(name, xg_name);
}
