/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_xnav_qt.cpp -- Display plant and node hierarchy */

#include <stdio.h>
#include <stdlib.h>

#include "co_string.h"

#include "cow_login_qt.h"
#include "cow_wow_qt.h"

#include "flow_browwidget_qt.h"

#include "ge_curve_qt.h"

#include "xtt_block_qt.h"
#include "xtt_clog_qt.h"
#include "xtt_ev_qt.h"
#include "xtt_fast_qt.h"
#include "xtt_fileview_qt.h"
#include "xtt_ge_qt.h"
#include "xtt_hist_qt.h"
#include "xtt_keyboard_qt.h"
#include "xtt_multiview_qt.h"
#include "xtt_op_qt.h"
#include "xtt_otree_qt.h"
#include "xtt_sevhist_qt.h"
#include "xtt_stream_qt.h"
#include "xtt_tcurve_qt.h"
#include "xtt_trace_qt.h"
#include "xtt_trend_qt.h"
#include "xtt_xatt_qt.h"
#include "xtt_xattone_qt.h"
#include "xtt_xcolwind_qt.h"
#include "xtt_xcrr_qt.h"
#include "xtt_xnav_qt.h"

#include "xtt_item.h"

#include <QApplication>

XNavQt::XNavQt(void* xn_parent_ctx, const char* xn_name, QWidget** w,
    xnav_sStartMenu* root_menu, char* xn_opplace_name, int xn_op_close_button,
    pwr_tStatus* status) : XNav(xn_parent_ctx, xn_name, root_menu,
                                xn_opplace_name, xn_op_close_button, status)
{
  form_widget = scrolledbrowwidgetqt_new(init_brow_base_cb, this, &brow_widget);

  displayed = 1;

  // Create the root item
  *w = form_widget;

  menu_tree_build(root_menu);
  gbl.load_config(this);

  for (int i = 0; i < XNAV_LOGG_MAX; i++) {
    logg[i].init(i, (void*)this);
  }

  wow = new CoWowQt(form_widget);
  trace_timerid = wow->timer_new();
  autoack_timerid = wow->timer_new();

  *status = 1;

  popup_obj = new XNavQtPopupObject(this);
}

XNavQt::~XNavQt()
{
  closing_down = 1;

  delete autoack_timerid;
  delete trace_timerid;

  if (mcp) {
    free(mcp);
    mcp = 0;
  }
  menu_tree_free();
  delete (ItemMenu*)root_item;

  for (int i = 0; i < brow_cnt; i++) {
    brow_stack[i]->free_pixmaps();
    if (i != 0) {
      brow_DeleteSecondaryCtx(brow_stack[i]->ctx);
    }
    delete brow_stack[i];
  }
  collect_brow->free_pixmaps();
  brow_DeleteSecondaryCtx(collect_brow->ctx);
  delete collect_brow;
  delete brow;
  if (ev) {
    delete ev;
  }
  if (op) {
    delete op;
  }
  form_widget->close();
}

void XNavQt::set_inputfocus()
{
  if (displayed) {
    brow_widget->setFocus();
  }
}

void XNavQt::create_popup_menu(pwr_sAttrRef attrref, xmenu_eItemType item_type,
    xmenu_mUtility caller, unsigned int priv, char* arg, int x, int y)
{
  int x1, y1;

  CoWowQt::PopupPosition(brow_widget, x + 8, y, &x1, &y1);
  get_popup_menu(attrref, item_type, caller, priv, arg, x1, y1);
}

//
//  Pop xnav window
//
void XNavQt::pop()
{
  ::pop(form_widget);
  displayed = 1;
}

void XNavQt::set_clock_cursor()
{
  form_widget->window()->setCursor(Qt::WaitCursor);
}

void XNavQt::reset_cursor()
{
  form_widget->window()->unsetCursor();
}

void XNavQt::set_transient(void* basewidget)
{
  form_widget->window()->setWindowModality(Qt::WindowModal);
}

RtTrace* XNavQt::plctrace_new(pwr_tOid oid, pwr_tStatus* sts)
{
  return new RtTraceQt(this, oid, sts);
}

XAtt* XNavQt::xatt_new(pwr_tAttrRef* arp, int advanced_user, pwr_tStatus* sts)
{
  return new XAttQt(this, arp, advanced_user, sts);
}

XCrr* XNavQt::xcrr_new(pwr_tAttrRef* arp, int advanced_user, pwr_tStatus* sts)
{
  return new XCrrQt(this, arp, advanced_user, sts);
}

XColWind* XNavQt::xcolwind_new(pwr_tAttrRef* ar_list, char* title,
    int advanced_user, int type, pwr_tStatus* sts)
{
  return new XColWindQt(this, ar_list, title, advanced_user,
      (xcolwind_eType)type, sts);
}

Ev* XNavQt::ev_new(char* eve_name, char* ala_name, char* blk_name,
    pwr_tObjid ev_user, int display_ala, int display_eve, int display_blk,
    int display_return, int display_ack, int ev_beep, pwr_tMask ev_pop_mask,
    int ev_eventname_seg, pwr_tStatus* status)
{
  return new EvQt(this, eve_name, ala_name, blk_name, ev_user,
      display_ala, display_eve, display_blk, display_return, display_ack,
      ev_beep, ev_pop_mask, ev_eventname_seg, status);
}

Hist* XNavQt::hist_new(char* title, pwr_tAttrRef* arp, pwr_tStatus* sts)
{
  return new HistQt(this, title, arp, sts);
}

Block* XNavQt::block_new(
    pwr_tAttrRef* arp, char* name, unsigned int priv, pwr_tStatus* sts)
{
  return new BlockQt(this, arp, name, priv, sts);
}

Op* XNavQt::op_new(char* opplace, pwr_tStatus* sts)
{
  return new OpQt(this, opplace, sts);
}

XttTrend* XNavQt::xtttrend_new(char* name, pwr_tAttrRef* objar,
    pwr_tAttrRef* plotgroup, int width, int height, unsigned int options,
    int color_theme, void* basewidget, pwr_tStatus* sts)
{
  QWidget* w;

  return new XttTrendQt(this, name, &w, objar, plotgroup, width,
      height, options, color_theme, basewidget, sts);
}

XttSevHist* XNavQt::xttsevhist_new(char* name, pwr_tOid* oidv,
    pwr_tOName* anamev, pwr_tOName* onamev, bool* sevhistobjectv,
    sevcli_tCtx scctx, char* filename, int width, int height,
    unsigned int options, int color_theme, time_ePeriod time_range,
    void* basewidget, pwr_tStatus* sts)
{
  QWidget* w;

  if (!filename) {
    return new XttSevHistQt(this, name, &w, oidv, anamev, onamev,
        sevhistobjectv, scctx, width, height, options, color_theme, time_range,
        basewidget, sts);
  } else {
    return new XttSevHistQt(
        this, name, &w, filename, color_theme, basewidget, sts);
  }
}

XttTCurve* XNavQt::xtttcurve_new(char* name, pwr_tAttrRef* arefv, int width,
    int height, unsigned int options, int color_theme, void* basewidget,
    pwr_tStatus* sts)
{
  QWidget* w;

  return new XttTCurveQt(this, name, &w, arefv, width, height,
      options, color_theme, basewidget, sts);
}

XttFast* XNavQt::xttfast_new(char* name, pwr_tAttrRef* objar, int width,
    int height, unsigned int options, char* filename, int color_theme,
    void* basewidget, pwr_tStatus* sts)
{
  QWidget* w;

  if (!filename) {
    return new XttFastQt(this, name, &w, objar, width, height,
        options, color_theme, basewidget, sts);
  } else {
    return new XttFastQt(
        this, name, &w, filename, color_theme, basewidget, sts);
  }
}

XAttOne* XNavQt::xattone_new(
    pwr_tAttrRef* objar, char* title, unsigned int priv, pwr_tStatus* sts)
{
  return new XAttOneQt(this, objar, title, priv, sts);
}

CLog* XNavQt::clog_new(const char* name, pwr_tStatus* sts)
{
  return new CLogQt(this, name, sts);
}

XttOTree* XNavQt::tree_new(const char* title, pwr_tAttrRef* itemlist,
    int itemcnt, unsigned int options,
    pwr_tStatus (*action_cb)(void*, pwr_tAttrRef*))
{
  return new XttOTreeQt(
      this, title, itemlist, itemcnt, options, action_cb);
}

XttGe* XNavQt::xnav_ge_new(const char* name, const char* filename,
    int scrollbar, int menu, int navigator, int width, int height, int x, int y,
    double scan_time, const char* object_name, int use_default_access,
    unsigned int access, unsigned int options, void* basewidget,
    double* borders, int color_theme, int dashboard,
    int (*command_cb)(void*, char*, char*, char*, void*),
    int (*get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
    int (*is_authorized_cb)(void*, unsigned int),
    void (*keyboard_cb)(void*, void*, int, int))
{
  return new XttGeQt(this, name, filename, scrollbar, menu,
      navigator, width, height, x, y, scan_time, object_name,
      use_default_access, access, options, basewidget, borders, color_theme, dashboard,
      command_cb, get_current_objects_cb, is_authorized_cb, keyboard_cb);
}

XttMultiView* XNavQt::multiview_new(const char* name, pwr_tAttrRef* aref,
    int width, int height, int x, int y, unsigned int options, void* basewidget,
    int color_theme, pwr_tStatus* sts,
    int (*command_cb)(void*, char*, char*, char*, void*),
    int (*get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
    int (*is_authorized_cb)(void*, unsigned int),
    void (*keyboard_cb)(void*, void*, int, int))
{
  return new XttMultiViewQt(this, name, aref, width, height, x, y,
      options, basewidget, color_theme, sts, command_cb, get_current_objects_cb,
      is_authorized_cb, keyboard_cb);
}

XttStream* XNavQt::stream_new(const char* name, const char* uri, int width,
    int height, int x, int y, double scan_time, unsigned int options,
    int embedded, pwr_tAttrRef* arp, pwr_tStatus* sts)
{
  return new XttStreamQt(this, name, uri, width, height, x, y,
      scan_time, options, embedded, arp, sts);
}

GeCurve* XNavQt::gecurve_new(char* name, char* filename, GeCurveData* data,
    int pos_right, unsigned int options, int color_theme, void* basewidget)
{
  return new GeCurveQt(this, name, filename, data, pos_right, 0, 0,
      options, color_theme, basewidget);
}

XttFileview* XNavQt::fileview_new(pwr_tOid oid, char* title, char* dir,
    char* pattern, int type, char* target_attr, char* trigger_attr,
    char* filetype)
{
  return new XttFileviewQt(this, NULL, oid, title, dir, pattern, type,
      target_attr, trigger_attr, filetype);
}

CoLogin* XNavQt::login_new(const char* name, const char* groupname,
    void (*bc_success)(void*), void (*bc_cancel)(void*), void* basewidget,
    pwr_tStatus* status)
{
  return new CoLoginQt(this, NULL, name, groupname, bc_success, bc_cancel,
      basewidget, status);
}

XttKeyboard* XNavQt::keyboard_new(const char* name, keyboard_eKeymap keymap,
    keyboard_eType type, int color_theme, pwr_tStatus* sts)
{
  QWidget* w;
  return new XttKeyboardQt(
      this, NULL, name, &w, keymap, type, color_theme, sts);
}

void XNavQt::bell(int time)
{
  QApplication::beep();
}

void XNavQt::get_popup_menu(pwr_sAttrRef attrref, xmenu_eItemType item_type,
    xmenu_mUtility caller, unsigned int priv, char* arg, int x, int y)
{
  QMenu* popup;
  int i = 0;

  get_popup_menu_items(attrref, item_type, caller, priv, arg);

  popup = build_menu(SLOT(popup_button_cb()), (xmenu_sMenuItem*)mcp->ItemList, &i);
  if (!popup) {
    return;
  }

  popup->popup(QPoint(x, y));
}

QMenu* XNavQt::build_menu(const char* Callback, xmenu_sMenuItem* Items, int* idx)
{
  QMenu* menu = new QMenu();
  int i;
  unsigned int Level = Items[*idx].Level;

  for (; Items[*idx].Level != 0 && Items[*idx].Level >= Level; (*idx)++) {
    switch (Items[*idx].Item) {
    case xmenu_eMenuItem_Cascade: {
      // Check that the Cascade contains any pushbuttons
      int found = 0;
      unsigned int cascade_level = Items[*idx].Level;
      int cidx;
      for (cidx = *idx + 1;
           Items[cidx].Level != 0 && Items[cidx].Level > cascade_level;
           cidx++) {
        if (Items[cidx].Item == xmenu_eMenuItem_Ref
            || Items[cidx].Item == xmenu_eMenuItem_Button) {
          found = 1;
          break;
        }
      }
      if (!found) {
        break;
      } // else fall through and run the code for xmenu_eMenuItem_Ref
    }
    case xmenu_eMenuItem_Ref: {
      i = *idx;
      (*idx)++;
      QMenu* w = build_menu(Callback, Items, idx);
      (*idx)--;
      w->setTitle(translate_utf8(Items[i].Name));
      menu->addMenu(w);
      break;
    }
    case xmenu_eMenuItem_Separator:
      // Separator
      menu->addSeparator();
      break;
    case xmenu_eMenuItem_Button: {
      // Pushbutton
      QAction* w = menu->addAction(translate_utf8(Items[*idx].Name));
      w->setEnabled(Items[*idx].Flags.f.Sensitive);
      w->setData(*idx);
      if (Callback) {
        QObject::connect(w, SIGNAL(triggered()), popup_obj, Callback);
      }
      break;
    }
    default:;
    }
  }

  return menu;
}

void XNavQtPopupObject::popup_button_cb()
{
  xnav->mcp->ChosenItem = ((QAction*)sender())->data().toInt();
  pwr_tStatus sts = xnav->CallMenuMethod(xnav->mcp, xnav->mcp->ChosenItem);
  if (EVEN(sts)) {
    xnav->message('E', XNav::get_message(sts));
  }
}

static void xnav_confirm_dialog_ok(void* ctx, void* data)
{
  ((XNav*)ctx)->dialog_ok = 1;
}

static void xnav_confirm_dialog_cancel(void* ctx, void* data)
{
}

int XNavQt::confirm_dialog(char* title, char* text)
{
  dialog_ok = 0;
  wow->DisplayQuestion(
      this, title, text, xnav_confirm_dialog_ok, xnav_confirm_dialog_cancel, 0);

  if (dialog_ok) {
    return 1;
  }
  return 0;
}