/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* co_statusmon_nodelist.cpp -- Status Monitor */

#include <stdlib.h>

#include "co_cdh.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_xnav_msg.h"

#include "cow_statusmon_nodelist.h"
#include "cow_wow.h"
#include "cow_xhelp.h"

Nodelist::Nodelist(void* nodelist_parent_ctx, const char* nodelist_name,
    int nodelist_mode, int nodelist_view_node_descr, pwr_tStatus* status)
    : parent_ctx(nodelist_parent_ctx), nodelistnav(NULL), nodelist_displayed(0),
      help_cb(0), close_cb(0), mode(nodelist_mode),
      view_node_descr(nodelist_view_node_descr)
{
  strcpy(remote_gui, "");
  *status = 1;
}

//
//  Delete nodelist
//
Nodelist::~Nodelist()
{
}

void Nodelist::activate_help()
{
  CoXHelp::dhelp("opg_statusmonitor", 0, navh_eHelpFile_Other,
      "$pwr_lang/man_opg.dat", true);
}

void Nodelist::find_node_cb(void* ctx, pwr_tOid oid)
{
  Nodelist* nodelist = (Nodelist*)ctx;

  if (nodelist->nodelistnav->select_node(oid.oix))
    nodelist->pop();
}

void Nodelist::add_node_ok(
    Nodelist* nodelist, char* node_name, char* address, char* busid, char* description, 
    char* opplace)
{
  int bus;
  sscanf(busid, "%d", &bus);
  nodelist->nodelistnav->add_node(node_name, address, bus, description, opplace);
}

void Nodelist::activate_add_node()
{
  open_add_input_dialog(
      "Node name", "Address", "Busid", "Description", "Operatorplace", 
      "Add Node", "", add_node_ok);
}

void Nodelist::mod_node_ok(
    Nodelist* nodelist, char* node_name, char *address, char* busid, char* description, 
    char* opplace)
{
  int bus;
  sscanf(busid, "%d", &bus);
  nodelist->nodelistnav->set_node_data(nodelist->selected_idx, node_name, address,
      bus, opplace, description);
}

void Nodelist::activate_modify_node()
{
  static char node_name[80];
  char title[100];
  char address[40];
  int busid;
  char busidstr[20];
  int sts;
  pwr_tOName opplace;
  char descr[80];

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Remove Node", "Select a node");
    return;
  }

  sts = nodelistnav->get_selected_node_idx(&selected_idx);
  if (EVEN(sts))
    return;
  sts = nodelistnav->get_selected_opplace(address, &busid, opplace, descr);
  if (EVEN(sts))
    return;

  sprintf(busidstr, "%d", busid); 
  sprintf(title, "Modify node %s", node_name);

  open_mod_input_dialog("Node", "Address", "Busid", "Description", "Operatorplace", title,
			node_name, address, busidstr, descr, opplace, mod_node_ok);
}

void remove_node_ok(void* ctx, void* data)
{
  Nodelist* nodelist = (Nodelist*)ctx;

  nodelist->nodelistnav->remove_node((char*)data);
}

void Nodelist::activate_remove_node()
{
  static char node_name[80];
  int sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Remove Node", "Select a node");
    return;
  }
  char msg[27 + sizeof(node_name) + 1];
  sprintf(msg, "Do you want to remove node %s", node_name);

  nodelistnav->wow->DisplayQuestion(
      this, "Remove Node", msg, remove_node_ok, NULL, node_name);
}

void Nodelist::activate_open_xtt()
{
  char node_name[80];
  int sts;
  char address[40];

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Open Xtt", "Select a node");
    return;
  }
  sts = nodelistnav->get_selected_opplace(address, 0, 0, 0);

  pwr_tCmd cmd;
  sprintf(cmd, "ssh pwrp@%s -X rt_xtt&", address);
  printf("cmd %s\n", cmd);
  system(cmd);
}

void Nodelist::activate_open_opplace()
{
  int sts;
  char node_name[80];
  pwr_tOName opplace;
  char address[40];

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Open Xtt", "Select a node");
    return;
  }
  sts = nodelistnav->get_selected_opplace(address, 0, opplace, 0);

  pwr_tCmd cmd;
  sprintf(cmd, "ssh pwrp@%s -X rt_xtt %s&", address, opplace);
  printf("cmd %s\n", cmd);
  system(cmd);

}

void Nodelist::activate_open_rtmon()
{
  char node_name[80];
  int sts;
  char address[40];

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Open Runtime Monitor", "Select a node");
    return;
  }

  sts = nodelistnav->get_selected_opplace(address, 0, 0, 0);

  pwr_tCmd cmd;
  sprintf(cmd, "ssh pwrp@%s -X pwr_rtmon&", address);
  printf("cmd %s\n", cmd);
  system(cmd);

}

void Nodelist::activate_save()
{
  nodelistnav->save();
}

void Nodelist::activate_reconnect()
{
  nodelistnav->reconnect();
}
