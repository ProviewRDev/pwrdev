/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2024 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* co_statusmon_nodelist.cpp -- Status Monitor */

#include <stdlib.h>

#include "co_cdh.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_xnav_msg.h"

#include "cow_statusmon_nodelist.h"
#include "cow_ge.h"
#include "cow_wow.h"
#include "cow_xhelp.h"

static int nodelist_ge_is_authorized_cb(void* xnav, unsigned int access);
static int nodelist_ge_command_cb(void* ctx, char* command, char* script, 
    char *scriptargs, void* caller);
static void nodelist_ge_close_cb(void* xnl, void* ctx);
static int nodelist_ge_extern_connect_cb(void* xnl, char* name, void** p, pwr_tRefId* id);


Nodelist::Nodelist(void* nodelist_parent_ctx, const char* nodelist_name,
    int nodelist_mode, nl_mLayout nodelist_layout, pwr_tStatus* status)
    : parent_ctx(nodelist_parent_ctx), nodelistnav(NULL), nodelist_displayed(0),
      help_cb(0), close_cb(0), mode(nodelist_mode),
      layout(nodelist_layout), map_gectx(0), scriptmode(0), verify(0),
      ccm_func_registred(0), command_open(0)
{
  strcpy(remote_gui, "");
  *status = 1;
}

//
//  Delete nodelist
//
Nodelist::~Nodelist()
{
}

void Nodelist::activate_help()
{
  CoXHelp::dhelp("opg_statusmonitor", 0, navh_eHelpFile_Other,
      "$pwr_lang/man_opg.dat", true);
}

void Nodelist::find_node_cb(void* ctx, pwr_tOid oid)
{
  Nodelist* nodelist = (Nodelist*)ctx;

  if (nodelist->nodelistnav->select_node(oid.oix))
    nodelist->pop();
}

void Nodelist::add_node_ok(
    Nodelist* nodelist, char* node_name, char* address, char* busid, char* description, 
    char* opplace)
{
  int bus;
  sscanf(busid, "%d", &bus);
  nodelist->nodelistnav->add_node(node_name, address, bus, description, opplace);
}

void Nodelist::activate_add_node()
{
  open_add_input_dialog(
      "Node name", "Address", "Busid", "Description", "Operatorplace", 
      "Add Node", "", add_node_ok);
}

void Nodelist::mod_node_ok(
    Nodelist* nodelist, char* node_name, char *address, char* busid, char* description, 
    char* opplace)
{
  int bus;
  sscanf(busid, "%d", &bus);
  nodelist->nodelistnav->set_node_data(nodelist->selected_idx, node_name, address,
      bus, opplace, description);
}

void Nodelist::activate_modify_node()
{
  static char node_name[80];
  char title[100];
  char address[40];
  int busid;
  char busidstr[20];
  int sts;
  pwr_tOName opplace;
  char descr[80];

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Remove Node", "Select a node");
    return;
  }

  sts = nodelistnav->get_selected_node_idx(&selected_idx);
  if (EVEN(sts))
    return;
  sts = nodelistnav->get_selected_opplace(address, &busid, opplace, descr);
  if (EVEN(sts))
    return;

  sprintf(busidstr, "%d", busid); 
  sprintf(title, "Modify node %s", node_name);

  open_mod_input_dialog("Node", "Address", "Busid", "Description", "Operatorplace", title,
			node_name, address, busidstr, descr, opplace, mod_node_ok);
}

void remove_node_ok(void* ctx, void* data)
{
  Nodelist* nodelist = (Nodelist*)ctx;

  nodelist->nodelistnav->remove_node((char*)data);
}

void Nodelist::activate_remove_node()
{
  static char node_name[80];
  int sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Remove Node", "Select a node");
    return;
  }
  char msg[27 + sizeof(node_name) + 1];
  sprintf(msg, "Do you want to remove node %s", node_name);

  nodelistnav->wow->DisplayQuestion(
      this, "Remove Node", msg, remove_node_ok, NULL, node_name);
}

void Nodelist::activate_open_xtt()
{
  char node_name[80];
  int sts;

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Open Xtt", "Select a node");
    return;
  }

  pwr_tCmd cmd;
  sprintf(cmd, "ssh pwrp@%s -X rt_xtt&", node_name);
  printf("cmd %s\n", cmd);
  system(cmd);
}

void Nodelist::activate_open_opplace()
{
  int sts;
  char node_name[80];
  pwr_tOName opplace;

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Open Xtt", "Select a node");
    return;
  }
  sts = nodelistnav->get_selected_opplace(0, 0, opplace, 0);

  pwr_tCmd cmd;
  sprintf(cmd, "ssh pwrp@%s -X rt_xtt %s&", node_name, opplace);
  printf("cmd %s\n", cmd);
  system(cmd);
}

void Nodelist::activate_open_rtmon()
{
  char node_name[80];
  int sts;

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Open Runtime Monitor", "Select a node");
    return;
  }

  pwr_tCmd cmd;
  sprintf(cmd, "ssh pwrp@%s -X pwr_rtmon&", node_name);
  printf("cmd %s\n", cmd);
  system(cmd);
}

void Nodelist::activate_open_map()
{
  if (map_gectx) {
    map_gectx->pop();
  } else {
    pwr_tCmd cmd;

    sprintf(cmd, "open graph statusmon_map /title=Map");
    command(cmd);
  }
}

static int nodelist_ge_is_authorized_cb(void* xnav, unsigned int access)
{
  return 1;
}

static int nodelist_ge_command_cb(
    void* ctx, char* command, char* script, char *scriptargs, void* caller)
{
  Nodelist* nl = (Nodelist*)ctx;

  nl->command(command);
  return 1;
}

static void nodelist_ge_close_cb(void* xnl, void* ctx)
{
  Nodelist* nl = (Nodelist*)xnl;
  CowGe* gectx = (CowGe*)ctx;

  if (gectx == nl->map_gectx)
    nl->map_gectx = 0;
  else
    nl->appl.remove(gectx);
}

static int nodelist_ge_extern_connect_cb(void* xnl, char* name, void** p, pwr_tRefId* id)
{
  Nodelist* nl = (Nodelist*)xnl;
  char node[160];
  char attr[80];
  char *s;

  strncpy(node, name, sizeof(node));
  s = strchr(node, '.');
  if (!s)
    return 0;
  *s = 0;  
  strncpy(attr, s+1, sizeof(attr));
  
  for (int i = 0; i < (int)nl->nodelistnav->node_list.size(); i++) {
    if (streq(node, nl->nodelistnav->node_list[i].node_name)) {
      if (streq(attr, "SystemStatus"))
	*p = &nl->nodelistnav->node_list[i].item->data.SystemStatus;
      if (streq(attr, "CurrentStatus"))
	*p = &nl->nodelistnav->node_list[i].item->data.CurrentStatus;
      else if (streq(attr, "Description"))
	*p = &nl->nodelistnav->node_list[i].description;
      *id = pwr_cNRefId;
      return 1;
    }
  }

  printf("Name: %s\n", name);
  return 0;
}

void Nodelist::activate_save()
{
  nodelistnav->save();
}

void Nodelist::activate_reconnect()
{
  nodelistnav->reconnect();
}

void Nodelist::message(char severity, const char *msg)
{
  printf("SMON-%c, %s\n", severity, msg);
}

int Nodelist::open_graph(char *name, char *title, int width, int height)
{
  CowGe *gectx;

  if ((gectx = appl.find(name)) ) {
    gectx->pop();
  } else {
    pwr_tFileName fname;
    int width = 0;
    int height = 0;
    int x = 0;
    int y = 0;
    double scantime = 0.5;

    if (!title)
      title = name;
    if (strchr(name, '/'))
      strcpy(fname, name);
    else {
      strcpy(fname, "$pwrp_exe/");
      strcat(fname, name);
    }
    if (strchr(name, ','))
      strcat(fname, ".pwg");
	
    gectx = ge_new(title, fname, 0, 0, 0, width,
        height, x, y, scantime, 0, 0, ~0,
	0, 0, 0, 0, 0, 
        &nodelist_ge_command_cb, 0, 
	&nodelist_ge_is_authorized_cb, 0, &nodelist_ge_extern_connect_cb);
    gectx->close_cb = nodelist_ge_close_cb;

    NlApplListElem e;
    strcpy(e.name,name);
    e.gectx = gectx;
    appl.add(e);
  }
  return 1;
}
