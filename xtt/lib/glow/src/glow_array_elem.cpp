/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <string.h>

#include "glow_growctx.h"
#include "glow_growgroup.h"
#include "glow_msg.h"

GlowArrayElem::GlowArrayElem(GrowCtx* gctx) : ctx(gctx), parent(0)
{
  strcpy(n_name, "");
}

GlowArrayElem::GlowArrayElem() : ctx(0), parent(0)
{
  strcpy(n_name, "");
}

GlowArrayElem::GlowArrayElem(const GlowArrayElem& x) : ctx(x.ctx), parent(x.parent)
{
  strcpy(n_name, x.n_name);
}

GlowArrayElem& GlowArrayElem::operator=(const GlowArrayElem& x)
{
  ctx = x.ctx;
  parent = x.parent;
  strcpy(n_name, x.n_name);
  return *this;
}

void GlowArrayElem::set_parent(GlowArrayElem* p)
{
  if (p == &ctx->a)
    parent = 0;
  else
    parent = p;
}

int GlowArrayElem::in_active_layer()
{
  if ((ctx->layer->is_background() && parent == 0 && ctx->layer->is_active()) ||
      (ctx->layer == parent))
    return 1;
  return 0;
}

int GlowArrayElem::get_object_name(char* name, int size, glow_eName ntype)
{
  int sts;

  switch (ntype) {
  case glow_eName_Object:
    if ((int)strlen(n_name) + 1 > size)
      return GLOW__BUFF_SMALL;
    strcpy(name, n_name);
    break;
  case glow_eName_Path:
    if (parent) {
      sts = parent->get_path(name, size);
      if (EVEN(sts))
        return sts;

      if (strlen(name) == 0) {
	if ((int)strlen(name) + (int)strlen(n_name) + 1 > size)
	  return GLOW__BUFF_SMALL;
	strcat(name, n_name);
      } else {
	if ((int)strlen(name) + (int)strlen(n_name) + 2 > size)
	  return GLOW__BUFF_SMALL;
	strcat(name, "-");
	strcat(name, n_name);
      }
    } else {
      if ((int)strlen(n_name) + 1 > size)
        return GLOW__BUFF_SMALL;
      strcpy(name, n_name);
    }
    break;
  case glow_eName_Layer: {
    GlowArrayElem *e, *p;
    e = this;
    while ((p = e->parent)) 
      e = p;
    if (e->type() == glow_eObjectType_GrowLayer) {
      if ((int)strlen(e->n_name) + 1 > size)
        return GLOW__BUFF_SMALL;
      strcpy(name, e->n_name);
    } else
      return GLOW__NOLAYER;
    break;
  }
  }
  return GLOW__SUCCESS;
}

void GlowArrayElem::set_object_name(char* name)
{
  strcpy(n_name, name);
}

int GlowArrayElem::get_path(char* name, int size)
{
  if (parent) {
    parent->get_path(name, size);
    if ((int)strlen(name) + (int)strlen(n_name) + 2 > size)
      return GLOW__BUFF_SMALL;
    strcat(name, "-");
    strcat(name, n_name);
  } else {
    if ((int)strlen(n_name) + 1 > size)
      return GLOW__BUFF_SMALL;
    strncpy(name, n_name, size);
  }
  return GLOW__SUCCESS;
}
