/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2024 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <iostream>

#include "co_string.h"

#include "glow_growctx.h"
#include "glow_growlayer.h"
#include "glow_draw.h"
#include "glow_exportscript.h"
#include "glow_nodegroup.h"
#include "glow_msg.h"

GrowLayer::GrowLayer(GrowCtx* glow_ctx, const char* name)
  : GrowNode(glow_ctx, name, 0, 0, 0), a(50,50), hide(0), active(0),
    is_bg(0)
{
  object_type = glow_eObjectType_GrowLayer;
  nc = new GlowNodeClass(ctx, "__layer_class");
  get_node_borders();
}

GrowLayer::~GrowLayer()
{
  GlowArrayElem *element;

  ctx->set_nodraw();
  // Delete Cons first
  for (int i = 0; i < a.a_size; i++) {
    if (a[i]->type() != glow_eObjectType_Con)
      continue;
    element = a[i];
    remove(element);
    ctx->select_remove(element);
    ctx->move_remove(element);
    delete element;
    i--;
  }
  for (int i = 0; i < a.a_size; i++) {
    element = a[i];
    remove(element);
    ctx->select_remove(element);
    ctx->move_remove(element);
    ctx->object_deleted(element);
    delete element;
    i--;
  }
  delete nc;
  ctx->reset_nodraw();
  ctx->redraw();
}

void GrowLayer::save(std::ofstream& fp, glow_eSaveMode mode)
{
  fp << int(glow_eSave_GrowLayer) << '\n';
  fp << int(glow_eSave_GrowLayer_array_part) << '\n';
  a.save(fp, mode);
  fp << int(glow_eSave_GrowLayer_grownode_part) << '\n';
  GrowNode::save(fp, mode);
  fp << int(glow_eSave_End) << '\n';
}

void GrowLayer::save(int nochildren, std::ofstream& fp, glow_eSaveMode mode)
{
  int size;

  if (nochildren) {
    size = a.a_size;
    a.a_size = 0;
  }

  save(fp, mode);

  if (nochildren)
    a.a_size = size;
}

void GrowLayer::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GrowLayer: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_GrowLayer:
      break;
    case glow_eSave_GrowLayer_array_part:
      a.open(ctx, fp);
      break;
    case glow_eSave_GrowLayer_grownode_part:
      GrowNode::open(fp);
      break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GrowLayer:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
  a.set_parent(this);
  get_node_borders();
}

void GrowLayer::set_active(int act)
{
  for (int i = 0; i < ctx->a.size(); i++) {
    if (ctx->a[i]->type() == glow_eObjectType_GrowLayer)
      ((GrowLayer*)ctx->a[i])->active = 0;
  }
  ctx->a.active = 0;

  if (act) {
    ctx->layer = this;
    active = 1;
  }
  else
    ctx->layer = &ctx->a;
  
}

void GrowLayer::copy_from(GrowLayer& layer)
{
  copy_from(layer.a);
}

void GrowLayer::draw()
{
  if (is_bg)
    ctx->redraw();
  else
    GrowNode::draw();
}

void GrowLayer::draw(GlowWind* w, int ll_x, int ll_y, int ur_x, int ur_y)
{
#if 0
  int tmp;

  if (ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if (ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if (x_right * w->zoom_factor_x - w->offset_x + 1 >= ll_x
      && x_left * w->zoom_factor_x - w->offset_x <= ur_x
      && y_high * w->zoom_factor_y - w->offset_y + 1 >= ll_y
      && y_low * w->zoom_factor_y - w->offset_y <= ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, (void*)this, NULL, NULL);
  }
#endif
  draw(w, (GlowTransform*)NULL, highlight, hot, (void*)this, NULL, NULL);
}

void GrowLayer::draw(GlowWind* w, int* ll_x, int* ll_y, int* ur_x, int* ur_y)
{
#if 0
  int tmp;
  int obj_ur_x = int(x_right * w->zoom_factor_x) - w->offset_x;
  int obj_ll_x = int(x_left * w->zoom_factor_x) - w->offset_x;
  int obj_ur_y = int(y_high * w->zoom_factor_y) - w->offset_y;
  int obj_ll_y = int(y_low * w->zoom_factor_y) - w->offset_y;

  if (*ll_x > *ur_x) {
    /* Shift */
    tmp = *ll_x;
    *ll_x = *ur_x;
    *ur_x = tmp;
  }
  if (*ll_y > *ur_y) {
    /* Shift */
    tmp = *ll_y;
    *ll_y = *ur_y;
    *ur_y = tmp;
  }

  if (obj_ur_x >= *ll_x && obj_ll_x <= *ur_x && obj_ur_y >= *ll_y
      && obj_ll_y <= *ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, (void*)this, NULL);

    // Increase the redraw area
    if (obj_ur_x > *ur_x)
      *ur_x = obj_ur_x;
    if (obj_ur_y > *ur_y)
      *ur_y = obj_ur_y;
    if (obj_ll_x < *ll_x)
      *ll_x = obj_ll_x;
    if (obj_ll_y < *ll_y)
      *ll_y = obj_ll_y;
  }
#endif
  draw(w, (GlowTransform*)NULL, highlight, hot, (void*)this, NULL, NULL);
}

void GrowLayer::draw(GlowWind* w, GlowTransform* t, int highlight, int hot,
    void* node, void* colornode, void *transpnode)
{
  int node_highlight;

  if (invisible)
    return;

  if (w == &ctx->navw) {
    if (ctx->no_nav)
      return;
    hot = 0;
  }
  node = (void*)this;

  for (int i = 0; i < a.a_size; i++) {
    node_highlight = highlight || a[i]->get_highlight();
    a[i]->draw(w, &trf, node_highlight, a[i]->get_hot(), node, node, node);
  }
}

int GrowLayer::event_handler(GlowWind* w, glow_eEvent event, int x, int y, 
    double fx, double fy) 
{
  int sts;

  if ((ctx->environment == glow_eEnv_Development && !active) || invisible || dimmed)
    return 0;

  switch (event) {
  case glow_eEvent_CursorMotion: {
    for (int i = a.a_size - 1; i >= 0; i--) {
      sts = a[i]->event_handler(w, event, x, y, fx, fy);
    }
    break;
  }
  default:
    for (int i = a.a_size - 1; i >= 0; i--) {
      sts = a[i]->event_handler(w, event, x, y, fx, fy);
      if (sts)
	return sts;
    }
  }
  return 0;
}

void GrowLayer::get_borders(GlowTransform* t, double* x1_right, double* x1_left,
    double* y1_high, double* y1_low)
{
    for (int i = 0; i < a.a_size; i++) {
      a[i]->get_borders(&trf, x1_right, x1_left, y1_high, y1_low);
    }
}

void GrowLayer::get_node_borders()
{
#if 0
  x_left = y_low = -1e4;
  x_right = y_high = 1e4;
#endif
  x_left = y_low = 1e37;
  x_right = y_high = -1e37;
  for (int i = 0; i < a.a_size; i++) {
    a[i]->get_borders(&trf, &x_right, &x_left, &y_high, &y_low);
  }
  x_left -= 1;
  y_low -= 1;
  x_right += 1;
  y_high += 1;
}

int GrowLayer::trace_scan()
{
  int sts;

  if (trace.p && ctx->trace_scan_func) {
    sts = ctx->trace_scan_func((void*)this, trace.p);
    if (sts == GLOW__TERMINATED || sts == GLOW__SUBTERMINATED
        || sts == GLOW__SWAPTERMINATED)
      return sts;
  }

  return a.trace_scan();
}

int GrowLayer::trace_init()
{
  int sts;

  //  if ( !streq( trace.data[0], ""))
  sts = ctx->trace_connect_func((void*)this, &trace);

  a.trace_init();
  return sts;
}

void GrowLayer::trace_close()
{
  if (trace.p)
    ctx->trace_disconnect_func((void*)this);

  a.trace_close();
}

int GrowLayer::insert(GlowArrayElem* element) 
{
  int sts;

  sts = a.insert(element);
  element->set_parent(this);
  get_node_borders();
  return sts;
}

int GrowLayer::remove(GlowArrayElem* element) 
{
  int sts;

  sts = a.remove(element);
  if (ODD(sts)) {
    element->set_parent(0);
    element->set_rootnode(0);
    if (!ctx->closing_down)
      get_node_borders();
  }
  return sts;
}

int GrowLayer::export_script(GlowExportScript* es, void* o, void* m)
{
  return es->layer(this, o, m);
}

void GrowLayer::set_original_fill_color(glow_eDrawType drawtype) {
  if (ctx->environment == glow_eEnv_Development)
    return;
  GrowNode::set_original_fill_color(drawtype);
}

void GrowLayer::set_original_border_color(glow_eDrawType drawtype) {
  if (ctx->environment == glow_eEnv_Development)
    return;
  GrowNode::set_original_border_color(drawtype);
}

void GrowLayer::set_original_text_color(glow_eDrawType drawtype) {
  if (ctx->environment == glow_eEnv_Development)
    return;
  GrowNode::set_original_text_color(drawtype);
}

