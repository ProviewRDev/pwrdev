/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "glow_draw_gtk.h"
#include "glow_keyboardctx.h"
#include "glow_keyboardwidget_gtk.h"

typedef struct _KeyboardWidgetGtk KeyboardWidgetGtk;
typedef struct _KeyboardWidgetGtkClass KeyboardWidgetGtkClass;
typedef struct _KeyboardWidgetGtkPrivate KeyboardWidgetGtkPrivate;

struct _KeyboardWidgetGtk {
  GtkDrawingArea bin;
  KeyboardWidgetGtkPrivate *priv;
};

struct _KeyboardWidgetGtkPrivate {
  GdkWindow *window;
  void* keyboard_ctx;
  void* draw_ctx;
  int (*init_proc)(GlowCtx* ctx, void* clien_data);
  int is_navigator;
  void* client_data;
  GtkWidget* main_keyboard_widget;
  GtkWidget* form;
  int destroyed;
};

struct _KeyboardWidgetGtkClass {
  GtkDrawingAreaClass parent_class;
};

G_DEFINE_TYPE_WITH_CODE(KeyboardWidgetGtk, keyboardwidgetgtk, GTK_TYPE_DRAWING_AREA,
			G_ADD_PRIVATE(KeyboardWidgetGtk));

static int keyboard_init_proc(GtkWidget* w, GlowCtx* fctx, void* client_data)
{
  KeyboardCtx* ctx;

  ctx = (KeyboardCtx*)((KeyboardWidgetGtk*)w)->priv->keyboard_ctx;

  ctx->configure();

  if (((KeyboardWidgetGtk*)w)->priv->init_proc)
    return (((KeyboardWidgetGtk*)w)->priv->init_proc)(ctx, client_data);
  else
    return 1;
}

static gboolean keyboardwidgetgtk_expose(GtkWidget* widget, cairo_t* cr)
{
  KeyboardWidgetGtk* keyboard = (KeyboardWidgetGtk*)widget;

  ((GlowDrawGtk*)((KeyboardCtx*)keyboard->priv->keyboard_ctx)->gdraw)->
      expose(cr, keyboard->priv->is_navigator);
  return TRUE;
}

static void keyboardwidgetgtk_destroy(GtkWidget* widget)
{
  KeyboardWidgetGtk* keyboard = (KeyboardWidgetGtk*)widget;

  if (!keyboard->priv->destroyed) {
    keyboard->priv->destroyed = 1;
    if (keyboard->priv->is_navigator) {
      if (keyboard->priv->keyboard_ctx
	  && !((KeyboardWidgetGtk*)keyboard->priv->main_keyboard_widget)->priv->destroyed)
	((KeyboardCtx*)keyboard->priv->keyboard_ctx)->no_nav = 1;
    } else
      delete (GlowDrawGtk*)keyboard->priv->draw_ctx;
  }
#if 0
  if (keyboard->is_navigator && keyboard->keyboard_ctx) {
    ((KeyboardCtx*)keyboard->keyboard_ctx)->no_nav = 1;
  }
#endif
  GTK_WIDGET_CLASS(keyboardwidgetgtk_parent_class)->destroy(widget);
}

static gboolean keyboardwidgetgtk_event(GtkWidget* keyboard, GdkEvent* event)
{
  if (((KeyboardWidgetGtk*)keyboard)->priv->destroyed)
    return TRUE;

  if (event->type == GDK_MOTION_NOTIFY) {
    GdkEvent* next = gdk_event_peek();
    if (next && next->type == GDK_MOTION_NOTIFY) {
      gdk_event_free(next);
      return TRUE;
    } else if (next)
      gdk_event_free(next);
  }

  ((GlowDrawGtk*)((KeyboardCtx*)((KeyboardWidgetGtk*)keyboard)->priv->keyboard_ctx)
          ->gdraw)
      ->event_handler(*event);
  return TRUE;
}

static void keyboardwidgetgtk_realize(GtkWidget* widget)
{
  GdkWindowAttr attr;
  gint attr_mask;
  KeyboardWidgetGtk* keyboard;
  GtkAllocation allocation;

  g_return_if_fail(widget != NULL);
  g_return_if_fail(IS_KEYBOARDWIDGETGTK(widget));

  gtk_widget_set_realized(widget, TRUE);
  keyboard = KEYBOARDWIDGETGTK(widget);

  gtk_widget_get_allocation(widget, &allocation);
  attr.x = allocation.x;
  attr.y = allocation.y;
  attr.width = allocation.width;
  attr.height = allocation.height;
  attr.wclass = GDK_INPUT_OUTPUT;
  attr.window_type = GDK_WINDOW_CHILD;
  attr.event_mask = gtk_widget_get_events(widget) | GDK_EXPOSURE_MASK
      | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_KEY_PRESS_MASK
      | GDK_POINTER_MOTION_MASK | GDK_BUTTON_MOTION_MASK | GDK_ENTER_NOTIFY_MASK
      | GDK_LEAVE_NOTIFY_MASK;
  attr.visual = gtk_widget_get_visual(widget);

  attr_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL;
  keyboard->priv->window = gdk_window_new(gtk_widget_get_parent_window(widget), &attr, attr_mask);
  gtk_widget_set_window(widget, keyboard->priv->window);
  gtk_widget_register_window(widget, keyboard->priv->window);
  //widget->style = gtk_style_attach(widget->style, widget->window);
  //gtk_style_set_background(widget->style, widget->window, GTK_STATE_ACTIVE);

  gtk_widget_set_can_focus(widget, TRUE);

  if (keyboard->priv->is_navigator) {
    if (!keyboard->priv->keyboard_ctx) {
      KeyboardWidgetGtk* main_keyboard
          = (KeyboardWidgetGtk*)keyboard->priv->main_keyboard_widget;

      keyboard->priv->keyboard_ctx = main_keyboard->priv->keyboard_ctx;
      keyboard->priv->draw_ctx = main_keyboard->priv->draw_ctx;
      ((GlowDrawGtk*)keyboard->priv->draw_ctx)->init_nav(widget);
    }
  } else {
    if (!keyboard->priv->keyboard_ctx) {
      keyboard->priv->draw_ctx = new GlowDrawGtk(widget, &keyboard->priv->keyboard_ctx,
          keyboard_init_proc, keyboard->priv->client_data, glow_eCtxType_Keyboard);
    }
  }
}

static void keyboardwidgetgtk_class_init(KeyboardWidgetGtkClass* klass)
{
  GtkWidgetClass* widget_class;
  widget_class = GTK_WIDGET_CLASS(klass);
  widget_class->realize = keyboardwidgetgtk_realize;
  widget_class->draw = keyboardwidgetgtk_expose;
  widget_class->event = keyboardwidgetgtk_event;
  widget_class->destroy = keyboardwidgetgtk_destroy;
}

static void keyboardwidgetgtk_init(KeyboardWidgetGtk* keyboard)
{
  keyboard->priv = (KeyboardWidgetGtkPrivate *)keyboardwidgetgtk_get_instance_private(keyboard);
}

GtkWidget* keyboardwidgetgtk_new(
    int (*init_proc)(GlowCtx* ctx, void* client_data), void* client_data)
{
  KeyboardWidgetGtk* w;
  w = (KeyboardWidgetGtk*)g_object_new(KEYBOARDWIDGETGTK_TYPE, NULL);
  w->priv->init_proc = init_proc;
  w->priv->keyboard_ctx = 0;
  w->priv->is_navigator = 0;
  w->priv->client_data = client_data;
  w->priv->destroyed = 0;
  return (GtkWidget*)w;
}

GtkWidget* keyboardnavwidgetgtk_new(GtkWidget* main_keyboard)
{
  KeyboardWidgetGtk* w;
  w = (KeyboardWidgetGtk*)g_object_new(KEYBOARDWIDGETGTK_TYPE, NULL);
  w->priv->init_proc = 0;
  w->priv->keyboard_ctx = 0;
  w->priv->is_navigator = 1;
  w->priv->main_keyboard_widget = main_keyboard;
  w->priv->client_data = 0;
  w->priv->destroyed = 0;
  return (GtkWidget*)w;
}
