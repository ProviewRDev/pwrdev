/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2023 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*
  Converts previsously generated xml files of the configurator to format
  matching the current configurator/runtime.

  It works by reading the GSDML file of which the configuration is based.
  This information is present in all configuration files. The tool has to
  be able to find the GSDML file within the ProviewR project file structure.

  It then fetches all values from the GSDML that it needs given the old
  configuration and then saves it in the newer configuration format.

  Current version: 5.9.x -> 6.0.x

  Usage: pn_convert_xml
*/

#include <iostream>
#include <string.h>
#include <sstream>
#include <map>
#include <list>
#include <cstdlib>

#include "co_dcli.h"
#include "co_cdh.h"
#include "co_pugixml.hpp"

#include "wb_orepwbl.h"
#include "wb_env.h"
#include "wb_session.h"

#include "pwr_baseclasses.h"
#include "pwr_profibusclasses.h"

#define PWR_SCHEMA_VERSION 1

int main(int argc, char* argv[])
{
  pwr_tFileName pwr_pn_xml_filename, pwr_pn_xml_filename_old;
  pwr_tObjName volume;
  wb_env env;
  pugi::xml_document old_xml, new_xml, gsdml;
  pwr_tStatus sts;

  if (argc != 2)
  {
    std::cerr << "Wrong number of arguments. Usage:\nwb_convert_pn_xml [volume]" << std::endl;
    return EXIT_FAILURE;
  }

  memcpy(volume, argv[1], sizeof(volume));

  env.load(volume);

  wb_volume vol;
  for (vol = env.volume(); vol.oddSts(); vol.next())
  {
    if (vol.cid() == pwr_eClass_RootVolume || vol.cid() == pwr_eClass_SubVolume ||
        vol.cid() == pwr_eClass_SharedVolume)
    {
      break;
    }
  }
  if (vol.evenSts())
    exit(vol.sts());

  wb_session session(vol);
  pwr_tCid cid = pwr_cClass_PnDevice;

  pwr_tAttrRef aref;
  for (session.aref(cid, &aref); session.oddSts(); session.nextAref(cid, &aref, &aref))
  {
    try
    {
      wb_attribute pwr_pn_device_attr = session.attribute(&aref);
      std::ostringstream xml_file_ss;

      char const* pwrp_load = getenv("pwrp_load");
      if (pwrp_load == NULL)
      {
        std::cerr << "Couldn't resolve environment variable $pwrp_load. Skipping conversion of "
                  << pwr_pn_device_attr.longName().c_str() << std::endl;
        continue;
      }

      xml_file_ss << pwrp_load << "/pwr_pn_" << cdh_ObjidToFnString(0, pwr_pn_device_attr.aoid()) << ".xml";
      memcpy(pwr_pn_xml_filename, xml_file_ss.str().c_str(), sizeof(pwr_pn_xml_filename));
      xml_file_ss << "_backup";
      memcpy(pwr_pn_xml_filename_old, xml_file_ss.str().c_str(), sizeof(pwr_pn_xml_filename_old));
      pugi::xml_parse_result parse_result = old_xml.load_file(pwr_pn_xml_filename);

      if (parse_result.status == pugi::status_ok)
      {
        std::cout << "Checking PnDevice <" << pwr_pn_device_attr.longName().c_str() << "> ..." << std::endl;

        // Check versioning (i.e. do we even need to convert?)
        if (!old_xml.child("PnDevice").attribute("GsdmlFile"))
        {
          // Skip since it's not an old format
          continue;
        }
        else
        {
          new_xml.reset();
          std::cout << "Found PnDevice <" << pwr_pn_device_attr.longName().c_str()
                    << "> with old configuration details..." << std::endl;
          std::cout << "Creating backup " << pwr_pn_xml_filename_old << std::endl;
          old_xml.save_file(pwr_pn_xml_filename_old);
          wb_attribute gsdml_attr(pwr_pn_device_attr, 0, "GSDMLfile");
          if (gsdml_attr.evenSts())
            continue;

          pwr_tString80 gsdml_filename;
          gsdml_attr.value(&gsdml_filename);
          if (gsdml_attr.evenSts())
          {
            std::cerr << "Error reading GSDMLfile from PnDevice " << pwr_pn_device_attr.name()
                      << ". Reconfigure this device manually!" << std::endl;
            continue;
          }

          printf("GSDMLfile: %s\n", gsdml_filename);
          sts = dcli_translate_filename(gsdml_filename, gsdml_filename);
          if (EVEN(sts))
          {
            std::cerr << "Error resolving GSDML filename for device " << pwr_pn_device_attr.name()
                      << ". Reconfigure this device manually!" << std::endl;
            continue;
          }

          parse_result = gsdml.load_file(gsdml_filename);

          if (parse_result.status != pugi::status_ok)
          {
            std::cerr << "Error parsing " << gsdml_filename << ". You should reconfigure device "
                      << pwr_pn_device_attr.name() << " manually!" << std::endl;

            std::cerr << parse_result.description() << std::endl;
            continue;
          }

          // "Root" node PnDevice
          pugi::xml_node pn_device = new_xml.append_child("PnDevice");
          pn_device.append_attribute("GSDML_Source") =
              old_xml.child("PnDevice").attribute("GsdmlFile").as_string();
          pn_device.append_attribute("VendorId") =
              old_xml.child("PnDevice").attribute("VendorId").as_string();
          pn_device.append_attribute("DeviceId") =
              old_xml.child("PnDevice").attribute("DeviceId").as_string();
          pn_device.append_attribute("Instance") =
              old_xml.child("PnDevice").attribute("Instance").as_string();
          pn_device.append_attribute("ModuleInfoName") =
              old_xml.child("PnDevice").attribute("DeviceText").as_string();
          pn_device.append_attribute("PwrSchemaVersion") = PWR_SCHEMA_VERSION;

          // Old xml used an index (which could reference invalid DAPs). Fetch the DAP from
          // the corresponding index and replace with the more resilient ID that according to
          // spec ain't allowed to change for the sake of backwards compatibility.
          pugi::xpath_variable_set vars;
          vars.add("dap_index", pugi::xpath_type_number);
          vars.add("module_index", pugi::xpath_type_number);
          vars.add("module_id", pugi::xpath_type_string);
          vars.add("subslot_number", pugi::xpath_type_number);

          vars.set("dap_index", old_xml.child("PnDevice").attribute("DeviceNumber").as_double());
          pugi::xml_node DAP =
              gsdml.select_node("//DeviceAccessPointList/DeviceAccessPointItem[number($dap_index)]", &vars)
                  .node();
          if (DAP)
          {
            std::cout << "Found corresponding DAP module (" << DAP.attribute("ID").as_string() << ")..."
                      << std::endl;
            pn_device.append_attribute("DAP_ID") = DAP.attribute("ID").as_string();
          }
          else
          {
            std::cerr << "Could not find the DAP module! This device needs to be manually reconfigured after "
                         "the upgrade process!"
                      << std::endl;
          }

          // NetworkSettings
          pugi::xml_node old_network_settings = old_xml.child("PnDevice").child("NetworkSettings");
          pugi::xml_node network_settings = pn_device.append_child("NetworkSettings");
          network_settings.append_attribute("DeviceName") =
              old_network_settings.attribute("DeviceName").as_string();
          network_settings.append_attribute("IP_Address") =
              old_network_settings.attribute("IP_Address").as_string();
          network_settings.append_attribute("SubnetMask") =
              old_network_settings.attribute("SubnetMask").as_string();
          network_settings.append_attribute("MAC_Address") =
              old_network_settings.attribute("MAC_Address").as_string();
          network_settings.append_attribute("Skip_IP_Assignment") =
              false; // Previous version didn't have this so default to false

          // <api_profile_id, list<slot_number>>
          std::map<uint, std::list<uint>> api_refs;

          // Parse them slots!
          for (auto const& old_slot : old_xml.child("PnDevice").children("Slot"))
          {
            // Slot attributes
            auto new_slot = pn_device.append_child("Slot");
            new_slot.append_attribute("SlotNumber") = old_slot.attribute("SlotNumber").as_string();
            uint slot_number = old_slot.attribute("SlotNumber").as_uint();
            new_slot.append_attribute("ModuleIdentNumber") =
                old_slot.attribute("ModuleIdentNumber").as_string();
            new_slot.append_attribute("ModuleClass") =
                old_slot.attribute("ModuleClass")
                    .as_string(); // The new version instantiate a pnmodule for the DAP aswell, but leaving
                                  // this at 0 won't cause any problems since the new version can cope with
                                  // that and automagically assign the correct moduleclass upon saving a new
                                  // config.
            auto module_id = new_slot.append_attribute("ModuleID");

            // The old xml files used, again, an index that could change. But we look it up and replace it
            // with an ID instead All "inserted" modules do have an ident number and an enum number except for
            // the dap itself which has the value 0 Normal module
            bool is_dap = false;
            if (old_slot.attribute("ModuleIdentNumber").as_int() > 0)
            {
              if (old_slot.attribute("ModuleEnumNumber").as_int() == 0) // DAP
              {
                module_id = DAP.attribute("ID").as_string();
                is_dap = true;
              }
              else // Standard Module
              {
                vars.set("module_index", old_slot.attribute("ModuleEnumNumber").as_double());
                pugi::xml_node module_ref =
                    DAP.select_node("UseableModules/ModuleItemRef[number($module_index)]", &vars).node();
                module_id = module_ref.attribute("ModuleItemTarget").as_string();

                // Save the ModuleID for reference later
                vars.set("module_id", module_ref.attribute("ModuleItemTarget").as_string());
              }
            }

            // Subslots
            for (auto const& old_subslot : old_slot.children("Subslot"))
            {
              auto new_subslot = new_slot.append_child("Subslot");
              new_subslot.append_attribute("SubslotNumber") =
                  old_subslot.attribute("SubslotNumber").as_string();
              uint subslot_number = old_subslot.attribute("SubslotNumber").as_uint();

              new_subslot.append_attribute("SubmoduleIdentNumber") =
                  old_subslot.attribute("SubmoduleIdentNumber").as_string();
              new_subslot.append_attribute("API") = old_subslot.attribute("API").as_string();
              api_refs[old_subslot.attribute("API").as_uint()].push_back(slot_number);
              new_subslot.append_attribute("IOInputLength") =
                  old_subslot.attribute("IOInputLength").as_string();
              new_subslot.append_attribute("IOOutputLength") =
                  old_subslot.attribute("IOOutputLength").as_string();

              for (auto const& old_data_record : old_subslot.children("DataRecord"))
              {
                auto new_data_record = new_subslot.append_child("DataRecord");
                new_data_record.append_attribute("Index") = old_data_record.attribute("Index").as_string();
                new_data_record.append_attribute("TransferSequence") =
                    old_data_record.attribute("TransferSequence").as_string();
                new_data_record.append_attribute("DataLength") =
                    old_data_record.attribute("DataLength").as_string();
                new_data_record.append_attribute("Data") = old_data_record.attribute("Data").as_string();
              }

              // Now the IDs. Much more trickier now since these submodules isn't something that the old
              // version kept track of :( They are all enumerated with index 0.

              vars.set("subslot_number", static_cast<double>(subslot_number));
              if (is_dap)
              {
                switch (subslot_number)
                {
                case 0x8000: // Interface Submodule
                  new_subslot.append_attribute("ID") =
                      DAP.select_node("SystemDefinedSubmoduleList/"
                                      "InterfaceSubmoduleItem[@SubslotNumber = "
                                      "number($subslot_number)]",
                                      &vars)
                          .node()
                          .attribute("ID")
                          .as_string();
                  break;
                case 0x8001: // Port Submodule
                case 0x8002: // Port Submodule
                  new_subslot.append_attribute("ID") =
                      DAP.select_node("SystemDefinedSubmoduleList/PortSubmoduleItem[@SubslotNumber = "
                                      "number($subslot_number)]",
                                      &vars)
                          .node()
                          .attribute("ID")
                          .as_string();
                  break;
                default: // Virtual Submodule
                  new_subslot.append_attribute("ID") =
                      DAP.select_node("VirtualSubmoduleList/VirtualSubmoduleItem[number($subslot_number)]",
                                      &vars)
                          .node()
                          .attribute("ID")
                          .as_string();
                }
              }
              else // Standard submodule
              {
                auto submodule_id = gsdml
                                        .select_node("//ModuleList/ModuleItem[@ID = "
                                                     "string($module_id)]/VirtualSubmoduleList/"
                                                     "VirtualSubmoduleItem[number($subslot_number)]",
                                                     &vars)
                                        .node()
                                        .attribute("ID")
                                        .as_string();
                new_subslot.append_attribute("ID") = submodule_id;
              }
            } // Subslots
          }   // Slots

          // APIs and IOCRs
          auto apis = pn_device.append_child("APIs");
          uint ref_index = 0;
          for (auto& api_ref : api_refs)
          {
            // Make the list of modules for each API unique
            api_ref.second.unique([](uint a, uint b) { return a == b; });

            auto api = apis.append_child("API");
            api.append_attribute("ProfileID") = api_ref.first;
            api.append_attribute("RefIndex") = ref_index++;

            // Reference each module
            for (auto const& slot_number : api_ref.second)
            {
              auto module = api.append_child("Module");
              module.append_attribute("Slot") = slot_number;
            }
          }

          auto iocrs = pn_device.append_child("IOCRs");
          for (auto const& old_iocr : old_xml.child("PnDevice").children("IOCR"))
          {
            auto new_iocr = iocrs.append_child("IOCR");
            new_iocr.append_attribute("Type") = old_iocr.attribute("Type").as_string();
            new_iocr.append_attribute("SendClockFactor") = old_iocr.attribute("SendClockFactor").as_string();
            new_iocr.append_attribute("ReductionRatio") = old_iocr.attribute("ReductionRatio").as_string();
            new_iocr.append_attribute("Phase") = old_iocr.attribute("Phase").as_string();
            new_iocr.append_attribute("RT_CLASS") =
                "RT_CLASS_1"; // The previous tool had no support for anything else
            new_iocr.append_attribute("StartupMode") =
                "Legacy"; // The previous tool had no support for anything else
            auto apis = new_iocr.append_child("APIs");
            ref_index = 0;
            for (auto const& api_ref : api_refs)
            {
              auto ref = apis.append_child("Ref");
              ref.append_attribute("Index") = ref_index++;
              (void)api_ref; // Remove compilation warning :)
            }
          }

          // Diagnostics, we can pretty much copy these as is. We might loose extended diagnostics but things
          // will still work. One could always reconfigure the device manually and everything is updated as it
          // should be.
          auto new_diagnostics = pn_device.append_child("ChannelDiagnostics");
          for (auto const& old_channeldiag : old_xml.child("PnDevice").children("ChannelDiag"))
          {
            new_diagnostics.append_copy(old_channeldiag);
          }

          // TODO Add UnitDiagType diagnostics aswell....or skip?

          new_xml.save_file(pwr_pn_xml_filename);
        } // if "this is a valid and old xml file"
      }
      else
      { // Error parsing, inform the user!
        std::cerr << "Error parsing " << pwr_pn_xml_filename << ". You should reconfigure device "
                  << pwr_pn_device_attr.name() << " manually!" << std::endl;

        std::cerr << parse_result.description() << std::endl;
        continue;
      }
    }
    catch (wb_error& e)
    {
      std::cerr << "An error occured during iteration of the PnDevices: " << e.what() << std::endl;
      continue;
    }
  } // for (session.aref(cid, &aref); session.oddSts(); session.nextAref(cid, &aref, &aref))

  return EXIT_SUCCESS;
} // main
