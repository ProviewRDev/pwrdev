/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

/**
 * @file wb_print_wbl.cpp
 *
 * Prints a volume on wbl format
 *
 */

#include <cfloat>
#include <assert.h>
#include <stdio.h>
#include <ostream>
#include <cstring>

#include "wb_print_wbl.h"

#include "pwr_version.h"
#include "co_time.h"
#include "co_cdh.h"

#include "wb_attribute.h"
#include "wb_object.h"
#include "wb_volume.h"
#include "wb_bdef.h"

wb_print_wbl::wb_print_wbl(ostream& os, int levelIndentation) :
  m_errCnt(0),
  m_idxFlag(true),
  m_noFoCodeFlag(false),
  m_timeFlag(true),
  m_level(0),
  m_levelInd(levelIndentation),
  m_keepName(false),
  m_isTemplateObject(false),
  m_os(os)
{
  memset(m_indBuf, ' ', sizeof(m_indBuf));
  m_indBuf[sizeof(m_indBuf) -1] = 0;
}


wb_print_wbl::~wb_print_wbl()
{
}







//
// printAttribute
//
void wb_print_wbl::printAttribute(wb_volume& v, 
                                  wb_attribute& attr, 
                                  wb_attribute& tattr, ///< template 
                                  wb_adef& adef, 
				  int force)
{
  if ( !force &&
       (adef.flags() & PWR_MASK_POINTER || 
	adef.flags() & PWR_MASK_NOWBL))
    return;

  if (attr.isClass() && adef.cid() == pwr_eClass_Buffer)
    printBuffer(v, attr, tattr, adef);
  else if (attr.isClass())
    printClass(v, attr, tattr, adef);
  else {
    switch (adef.cid()) {
    case pwr_eClass_Param:
    case pwr_eClass_Input:
    case pwr_eClass_Intern:
    case pwr_eClass_Output:
    case pwr_eClass_TargetAttribute:
    case pwr_eClass_ObjXRef:
      printParameter(v, attr, tattr, adef);
      break;
    default:
      m_os << "! %%WBDUMP-E-Error Unknown attribute class: " 
           << adef.name() << ", cid: " << adef.cid() << endl;
      m_errCnt++;
      break;
    }
  }
  
}

//
// printBody
//
void wb_print_wbl::printBody(wb_volume& v, 
                             wb_object& o, 
                             wb_object& templ,
                             wb_cdef& cdef,
                             pwr_eBix bix)
{
  wb_adef adef;
  wb_attribute attr;
  wb_attribute tattr;
  const char* bname;
  char timestr[40] = " ";
  int force = 0;
    
  wb_bdef bdef = cdef.bdef(bix);
    

  if (!bdef)
    return;

  bname = bdef.name();

  wb_bdef tbdef = templ.bdef(bix);
  if (!tbdef) {
    m_errCnt++;
    m_os << "Couldn't find template body def for object " << o.name() << endl;
    return;
  }
    
  if ( m_timeFlag) {
    // Get body time
    pwr_tTime btime;
    switch ( bix) {
    case pwr_eBix_rt:
      btime = o.rbTime();

      // Bugcheck in 4.2 btime can be corrupt
      if ( btime.tv_nsec < 0 || btime.tv_nsec >= 1000000000)
	break;

      strcpy( timestr, " ");
      time_AtoAscii( &btime, time_eFormat_DateAndTime, &timestr[1], sizeof(timestr)-1);
      break;
    case pwr_eBix_dev:
      btime = o.dbTime();
      strcpy( timestr, " ");
      time_AtoAscii( &btime, time_eFormat_DateAndTime, &timestr[1], sizeof(timestr)-1);
      break;
    default: ;
    }
  }

  indent(1) << "Body " << bdef.name() << timestr << endl;
  for (adef = bdef.adef(); adef; adef = adef.next()) {
    if ( cdef.cid() == pwr_eClass_Param && strcmp( adef.name(), "Size") == 0) {
      // Print Size for Pointers that is not private
      wb_attribute flags_attr = o.attribute(bname, "Flags");
      pwr_tMask *flagsp = (pwr_tMask *)flags_attr.value();
      if (*flagsp & PWR_MASK_POINTER && !(*flagsp & PWR_MASK_PRIVATE))
	force = 1;
    }

    attr = o.attribute(bname, adef.name());
    tattr = templ.attribute(bname, adef.name());
    //    if (tattr == attr)
    //  continue;
    printAttribute(v, attr, tattr, adef, force);
  }

  indent(-1) << "EndBody" << endl;
    
  return;
}


//
// printBuffer
//
void wb_print_wbl::printBuffer(wb_volume& v,
                              wb_attribute& attr,
                              wb_attribute& tattr,
                              wb_adef& adef) 
{
  pwr_tCid subClass = attr.subClass();
  wb_object templ;
  wb_object sysbo;
  wb_attribute tattr2;
  wb_attribute attr2;
  wb_adef adef2;
  const char* bname;

  if ( strcmp( attr.name(), "Template") == 0 && cdh_isClassVolumeClass( v.cid()))
    // The parser can't handle subclasses in template objects yet...
    return;

  wb_object co = v.object(cdh_ClassIdToObjid(subClass));
  if (!co) {
    m_os << "! %WBDUMP-E-Error Unknown sub class: " << subClass << endl;
    m_errCnt++;
    return;
  }

  wb_cdef cdef = v.cdef(subClass);
  if (!cdef) {
    m_os << "! %WBDUMP-E-Error Unknown sub class: " << subClass << endl;
    m_errCnt++;
    return;
  }

  wb_name t("Template");
  
  templ = co.child(t);
  if (!templ) {
    m_errCnt++;
    m_os << "! %WBDUMP-E-Error Template not found for class " << cdef.longName() << endl;
    return;
  }

  wb_bdef bdef = cdef.bdef(pwr_eBix_sys);
  if (!bdef) {
    m_os << "! %WBDUMP-E-Error sub class: " << subClass 
         << " not defined" << endl;
    m_errCnt++;
    return;
  }    
  bname = bdef.name();

  for (int i = 0; i < adef.nElement(); i++) {
    if (adef.flags() & PWR_MASK_ARRAY)
      indent(1) << "Buffer " << adef.name() << "[" << i << "]" << endl;
    else
      indent(1) << "Buffer " << adef.name() << endl;


    adef2 = bdef.adef(); 
    attr2 = attr.first(i);
    
    while (1) {
      tattr2 = templ.attribute(bname, adef2.name());
      printAttribute(v, attr2, tattr2, adef2, 0);

      if (!(adef2 = adef2.next()))
        break;
      
      if (!(attr2 = attr2.after()))
        break;
    }                   

    indent(-1) << "EndBuffer" << endl;
  }
}

//
// printClass
//
void wb_print_wbl::printClass(wb_volume& v,
                              wb_attribute& attr,
                              wb_attribute& tattr,
                              wb_adef& adef) 
{
  pwr_tCid subClass = attr.subClass();
  wb_object templ;
  wb_object sysbo;
  wb_attribute tattr2;
  wb_attribute attr2;
  wb_adef adef2;

  //  if ( strcmp( attr.name(), "Template") == 0 && v.cid() == pwr_eClass_ClassVolume)
    // The parser can't handle subclasses in template objects yet...
  //  return;

  wb_cdef cdef = v.cdef(attr.cid());
  if (!cdef) {
    m_os << "! %WBDUMP-E-Error Unknown sub class: " << subClass << endl;
    m_errCnt++;
    return;
  }

  wb_bdef bdef = cdef.bdef(pwr_eBix_sys);
  if (!bdef) {
    m_os << "! %WBDUMP-E-Error sub class: " << subClass 
         << " not defined" << endl;
    m_errCnt++;
    return;
  }    

  for (int i = 0; i < adef.nElement(); i++) {
    attr2 = attr.first(i);
    tattr2 = tattr.first(i);
  
    while ( attr2.oddSts()) {

      adef2 = bdef.adef( attr2.attrName()); 
      
      printAttribute(v, attr2, tattr2, adef2, 0);
    
      attr2 = attr2.after();
      if ( tattr2.oddSts())
	tattr2 = tattr2.after();
    }
  }

#if 0
  wb_object co = v.object(cdh_ClassIdToObjid(subClass));
  if (!co) {
    m_os << "! %WBDUMP-E-Error Unknown sub class: " << subClass << endl;
    m_errCnt++;
    return;
  }

  wb_cdef cdef = v.cdef(subClass);
  if (!cdef) {
    m_os << "! %WBDUMP-E-Error Unknown sub class: " << subClass << endl;
    m_errCnt++;
    return;
  }

  wb_name t("Template");
  
  templ = co.child(t);
  if (!templ) {
    m_errCnt++;
    m_os << "! %WBDUMP-E-Error Template not found for class " << cdef.longName() << endl;
    return;
  }

  wb_bdef bdef = cdef.bdef(pwr_eBix_sys);
  if (!bdef) {
    m_os << "! %WBDUMP-E-Error sub class: " << subClass 
         << " not defined" << endl;
    m_errCnt++;
    return;
  }    
  bname = bdef.name();

  for (int i = 0; i < adef.nElement(); i++) {

    if (adef.flags() & PWR_MASK_ARRAY)
      indent(1) << "Buffer " << adef.name() << "[" << i << "]" << endl;
    else
      indent(1) << "Buffer " << adef.name() << endl;


    adef2 = bdef.adef(); 
    attr2 = attr.first(i);
    
    while (1) {
      tattr2 = templ.attribute(bname, adef2.name());
      printAttribute(v, attr2, tattr2, adef2, 0);

      if (!(adef2 = adef2.next()))
        break;
      
      if (!(attr2 = attr2.after()))
        break;
    }                   

    indent(-1) << "EndBuffer" << endl;

    if (adef.flags() & PWR_MASK_ARRAY)
      indent(1) << "Buffer " << adef.name() << "[" << i << "]" << endl;
    else
      indent(1) << "Buffer " << adef.name() << endl;


    adef2 = bdef.adef(); 
    attr2 = attr.first(i);
    
    while (1) {
      strcpy( aname, adef.subName());
      strcat( aname, ".");
      strcat( aname, attr2.name());

      attr2
      tattr2 = templ.attribute(bname, adef2.name());
      printAttribute(v, attr2, tattr2, adef2, 0);

      if (!(adef2 = adef2.next()))
        break;
      
      if (!(attr2 = attr2.after()))
        break;
    }                   

  }
#endif
}

//
// printHierarchy
//
void wb_print_wbl::printHierarchy(wb_volume& v, wb_object& o)
{
  if (v.object() == o)
    indent(1) << "SObject " << v.name() << ":" << endl;
  else
    indent(1) << "SObject " << o.parent().longName() << endl;
  
  printObject(v, o);
  
  indent(-1) << "EndSObject" << endl;
}


//
// printObject
//
void wb_print_wbl::printObject(wb_volume& v, wb_object& o, bool recursive)
{
  wb_object to = o;
  wb_object templ;
  cdh_uObjid	uid;
  unsigned int idx;
  wb_cdef cdef = v.cdef(o);
  if ( !cdef) {
    m_os << "! %WBDUMP-E-Error Failed to get object class" << endl;
    m_errCnt++;
    // return;
    cdef = v.cdef( pwr_eClass_ClassLost);
  }
  const char* cname = cdef.name();
  char *block;
  int size;

  if ( o.docBlock( &block, &size) && strcmp( block, "") != 0) {
    indent(0) << "!/**" << endl;
    indent(0) << "! ";
    for ( char *s = block; *s; s++) {
      if ( *s == '\n') {
	m_os << *s;
	indent(0) << "! ";
	continue;
      }
      m_os << *s;
    }
    m_os << endl;
    indent(0) << "!*/" << endl;
  }

  indent(1) << "Object " << o.name() << " " << cname;

  if (m_idxFlag) {
    switch (cdef.cid()) {
    case pwr_eClass_ClassDef:
      uid.pwr = o.oid();
      idx = uid.c.cix;
      break;
    case pwr_eClass_TypeDef:
      uid.pwr = o.oid();
      idx = uid.t.tix;
      break;
    case pwr_eClass_ObjBodyDef:
      uid.pwr = o.oid();
      idx = uid.c.bix;
      break;
    case pwr_eClass_Param:
    case pwr_eClass_Input:
    case pwr_eClass_Output:
    case pwr_eClass_Intern:
    case pwr_eClass_TargetAttribute:
    case pwr_eClass_Buffer:
    case pwr_eClass_ObjXRef:
      uid.pwr = o.oid();
      idx = uid.c.aix;
      break;
    default:
      idx = (unsigned long) o.oix();
    }
    m_os << " " << idx;
  }
  if ( m_timeFlag) {
    // Get oh time
    char timestr[40];
    pwr_tTime ohtime = o.ohTime();
    time_AtoAscii( &ohtime, time_eFormat_DateAndTime, timestr, sizeof(timestr));

    m_os << " " << timestr;
  }
  m_os << endl;

  wb_object co = v.object(cdh_ClassIdToObjid(cdef.cid()));
  wb_name t("Template");
  
  templ = co.child(t);
  if (!templ) {
    m_errCnt++;
    m_os << "Template not found for class " << cdef.name() << endl;
    return;
  }

  if ( v.cid() == pwr_eClass_ClassVolume &&
       strcmp( o.name(), "Template") == 0)
    m_isTemplateObject = true;
  else
    m_isTemplateObject = false;
  
 
  printBody(v, o, templ, cdef, pwr_eBix_rt);
  printBody(v, o, templ, cdef, pwr_eBix_dev);

  if (recursive) {
    if ( !(m_noFoCodeFlag && isFoCodeObject( v, o))) {
      for (to = o.first(); to; to = to.after())
	printObject(v, to);
    }
  }    

  indent(-1) << "EndObject" << endl;
}

//
// printParameter
//
void wb_print_wbl::printParameter(wb_volume& v, 
                                  wb_attribute& attr, 
                                  wb_attribute& tattr, ///< template 
                                  wb_adef& adef)
{

  int nElement = adef.nElement();
  int varSize = adef.size() / nElement;
  char* valueb = (char *)attr.value();
  char* val;
  char* tvalueb;
  char* tval;
  char* svalp;
  int varOffset;
  bool parValOk;
  bool print_all = false;
  const char* name = adef.subName();   

  if (valueb == NULL) {
    m_os << "! %WBDUMP-E-Error Failed to get attribute address for " 
         << adef.name() << endl;
    m_errCnt++;
    return;
  }

  if (adef.type() == pwr_eType_Text) {
    printText(v, adef, valueb, adef.size());
    return;
  }

  if ( tattr.evenSts()) {
    // Template attribute not found, should not happen
    tvalueb = (char *)calloc( 1, attr.size());
    print_all = true;
  }
  else if ( attr == tattr || m_isTemplateObject)
    // This is the template object itself, print all nonzero
    tvalueb = (char *)calloc( 1, tattr.size());
  else
    tvalueb = (char *)tattr.value();

  for (int i = 0; i < nElement; i++) {
    switch (adef.type()) {
    case pwr_eType_Boolean:
    case pwr_eType_Float32:
    case pwr_eType_Float64:
    case pwr_eType_Char:
    case pwr_eType_String:
    case pwr_eType_ProString:
    case pwr_eType_Int8:
    case pwr_eType_Int16:
    case pwr_eType_Int32:
    case pwr_eType_Int64:
    case pwr_eType_UInt8:
    case pwr_eType_UInt16:
    case pwr_eType_UInt32:
    case pwr_eType_UInt64:
    case pwr_eType_Objid:
    case pwr_eType_TypeId:
    case pwr_eType_CastId:
    case pwr_eType_DisableAttr:
    case pwr_eType_ClassId:
    case pwr_eType_AttrRef:
    case pwr_eType_Time:
    case pwr_eType_VolumeId:
    case pwr_eType_ObjectIx:
    case pwr_eType_RefId:
    case pwr_eType_DeltaTime:
    case pwr_eType_Mask:
    case pwr_eType_Enum:
    case pwr_eType_Status:
    case pwr_eType_NetStatus:
    case pwr_eType_DataRef:
      varOffset = varSize * i;
      val = valueb + varOffset;
      tval = tvalueb + varOffset;
            
      if (memcmp(val, tval, varSize) == 0 && !(adef.flags() & PWR_MASK_ALWAYSWBL) && !print_all)
        continue;

      parValOk = printValue(v, adef, val, varSize, &svalp);
      if (parValOk)
        indent();
      else
        m_os << "! %WBDUMP-E-Error ";
      
      if (adef.flags() & PWR_MASK_ARRAY) {
        m_os << "Attr " << name << "[" << i << "] = " << svalp << endl;
      } else {
        m_os << "Attr " << name << " = " << svalp << endl;
      }
      break;
    case pwr_eType_Array:
      m_os << "! %WBDUMP-E-Error Type pwr_eType_Array is not yet implemented" << endl;
      m_errCnt++;
      break;
    case pwr_eType_Buffer:
      m_os << "! %WBDUMP-E-Error Type pwr_eType_Buffer is not yet implemented" << endl; 
      m_errCnt++;
      break;
    case pwr_eType_Struct:
      m_os << "! %WBDUMP-E-Error Type pwr_eType_Struct is not yet implemented" << endl;
      m_errCnt++;
      break;
    default:
      m_os << "! %WBDUMP-E-Error Attribute " << adef.name() 
           << " is of unknown type: " <<  adef.type() <<  endl;
      m_errCnt++;
      break;
    }
  }
  if ( tattr.evenSts() || attr == tattr)
    free( tvalueb);
}

//
// printText
//
void wb_print_wbl::printText(wb_volume& v, 
                             wb_adef& adef,
                             const char *text,
                             int varSize)
{
  const char* ip;
  int i;
  int end = varSize - 1;
  const char* name = adef.subName();   

  indent() << "Attr " << name << " = \"";

  for (ip = text, i = 0; *ip != 0 && i < end; ip++) {
    if (*ip == '"')
      m_os << "\\";
    else if (*ip == '\\')
      m_os << "\\";
    m_os << *ip;
  }
    
  m_os << "\"" << endl;
    
  return;      
}


//
// printValue
//
bool wb_print_wbl::printValue (wb_volume& v,
                               wb_adef& adef,
                               void *val,
                               int varSize,
                               char **svalp) 
{
  unsigned long sts;
  char timbuf[24];
  char str[40];
  static char sval[512];
  bool retval = true;
  pwr_tOid oid;
  wb_object o;
  

  sval[0] = '\0';

  if (adef.flags() & PWR_MASK_POINTER) {
    sprintf(sval, "%u", *(unsigned int *) val);
    *svalp = sval;
    return TRUE;
  }

  switch (adef.type()) {
  case pwr_eType_Boolean:
    sprintf(sval, "%d", *(pwr_tBoolean *) val);
    break;
  case pwr_eType_Float32:
    if ( *(pwr_tFloat32 *)val == FLT_MIN)
      strcpy( sval, "FLT_MIN");
    else if ( *(pwr_tFloat32 *)val == FLT_MAX)
      strcpy( sval, "FLT_MAX");
    else
      sprintf(sval, "%.*e", FLT_DIG, *(pwr_tFloat32 *) val);
    break;
  case pwr_eType_Float64:
    sprintf(sval, "%.*e", DBL_DIG, *(pwr_tFloat64 *) val);
    break;
  case pwr_eType_Char:
    if (*(pwr_tChar *) val == 0)
      sprintf(sval, "\"\"");
    else
      sprintf(sval, "\"%c\"", *(pwr_tChar *) val);
    break;
  case pwr_eType_Int8:
    sprintf(sval, "%d", *(pwr_tInt8 *) val);
    break;
  case pwr_eType_Int16:
    sprintf(sval, "%d", *(pwr_tInt16 *) val);
    break;
  case pwr_eType_Int32:
    if ( *(pwr_tInt32 *)val == INT_MIN)
      strcpy( sval, "INT_MIN");
    else if ( *(pwr_tInt32 *)val == INT_MAX)
      strcpy( sval, "INT_MAX");
    else
      sprintf(sval, "%d", *(pwr_tInt32 *) val);
    break;
  case pwr_eType_Int64:
    sprintf(sval, pwr_dFormatInt64, *(pwr_tInt64 *) val);
    break;
  case pwr_eType_UInt8:
    sprintf(sval, "%u", *(pwr_tUInt8 *) val);
    break;
  case pwr_eType_UInt16:
    sprintf(sval, "%u", *(pwr_tUInt16 *) val);
    break;
  case pwr_eType_UInt32:
  case pwr_eType_DisableAttr:
    sprintf(sval, "%u", *(pwr_tUInt32 *) val);
    break;
  case pwr_eType_UInt64:
    sprintf(sval, pwr_dFormatUInt64, *(pwr_tUInt64 *) val);
    break;
  case pwr_eType_Mask:
    sprintf(sval, "%u", *(pwr_tUInt32 *) val);
    break;
  case pwr_eType_Enum:
    sprintf(sval, "%u", *(pwr_tUInt32 *) val);
    break;
  case pwr_eType_RefId:
    sprintf(sval, "0");
    break;
  case pwr_eType_Objid:
    if (cdh_ObjidIsNull(*(pwr_tOid *) val))
      sprintf(sval, "\"_O0.0.0.0:0\"");
    else {
      o = v.object(*(pwr_tOid *)val);
      if (o) {
	if ( o.oid().vid >= cdh_cUserVolMin && o.oid().vid != v.vid() && !m_keepName)
	  // Other user volume. Loadfile might not be created yet at load time.
	  sprintf(sval, "\"%s\"", cdh_ObjidToString(*(pwr_tObjid *)val, 1));
	else
	  sprintf(sval, "\"%s\"", o.longName().c_str());	  
      }
      else 
        sprintf(sval, "\"%s\"", cdh_ObjidToString(*(pwr_tObjid *)val, 1));
    }    
    break;
  case pwr_eType_ObjectIx:
    if ( *(pwr_tObjectIx *) val == 0)
      sprintf(sval, "0");
    else {
      cdh_ObjectIxToString(str, sizeof(str), *(pwr_tObjectIx*)val, 1);
      sprintf(sval, "\"%s\"", str);
    }
    break;
  case pwr_eType_VolumeId:
    if ( *(pwr_tVolumeId *) val == 0)
      sprintf(sval, "0");
    else
      sprintf(sval, "\"%s\"", cdh_VolumeIdToString(0, 0, *(pwr_tVolumeId *) val,1,0));
    break;
  case pwr_eType_ClassId:
    if (*(pwr_tClassId *) val == 0)
      sprintf(sval, "0");
    else {
      wb_cdef cdef = v.cdef(*(pwr_tCid *)val);
      if (cdef)
        sprintf(sval, "\"%s\"", cdef.longName().c_str());
      else {
        sprintf(sval, "Unknown class, identity: %d", (*(pwr_tClassId *) val));
        m_errCnt++;
        retval = false;
      }
            
    }
    break;
  case pwr_eType_TypeId: /** @todo Modify when wb_tdef is OK q*/
  case pwr_eType_CastId:
    if (*(pwr_tTypeId *) val == 0)
      sprintf(sval, "0");
    else {
      oid = cdh_TypeIdToObjid(*(pwr_tTid *)val);
      o = v.object(oid);
      if (o)
        sprintf(sval, "\"%s\"", o.longName().c_str());
      else {
        sprintf(sval, "Unknown type, identity: %d", (*(pwr_tTypeId *) val));
        m_errCnt++;
        retval = false;
      }
    }    
    break;
  case pwr_eType_AttrRef: /** @todo */
    if (cdh_ObjidIsNull(((pwr_sAttrRef*)val)->Objid))
      sprintf(sval, "\"_O0.0.0.0:0\"");
    else {
      try {
	wb_attribute a = v.attribute((pwr_sAttrRef*)val);
	if (a)
	  sprintf(sval, "\"%s\"", a.longName().c_str());
	else {
	  sprintf(sval, "\"%s\"", cdh_AttrRefToString((pwr_sAttrRef*)val, 1));
	}
      } catch ( wb_error &e) {
	if ( ldh_isSymbolicVid( ((pwr_sAttrRef *)val)->Objid.vid))
	  sprintf(sval, "\"%s\"", cdh_AttrRefToString((pwr_sAttrRef*)val, 1));
	else {
	  sprintf(sval, "Unknown attribute reference");
	  m_errCnt++;
	  retval = FALSE;
	}
      }
    }
#if 0      
    } else {
      ConvertObjectName( root, sp, conv_name);
      sprintf(sval, "\"%s\"", conv_name);
    }
#endif
    break;
  case pwr_eType_DataRef:
    if (cdh_ObjidIsNull(((pwr_tDataRef*)val)->Aref.Objid))
      sprintf(sval, "0");
    else {
      wb_attribute a = v.attribute( &((pwr_tDataRef*)val)->Aref);
      if (a)
        sprintf(sval, "\"%s\"", a.longName().c_str());
      else {
        sprintf(sval, "\"%s\"", cdh_AttrRefToString(&((pwr_tDataRef*)val)->Aref, 1));
      }
    }

    break;
  case pwr_eType_String:
  case pwr_eType_ProString: {
    char *s = sval;
    char *t = (char *)val;
    *s++ = '"';
    for ( int i = 0; i < varSize; i++) {
      if ( *t == 0)
	break;
      if ( *t == '"')
	*s++ = '\\'; 
      *s++ = *t++;
    }
    *s++ = '"';
    *s = 0;
    // sprintf(sval, "\"%.*s\"", varSize, (char *)val);
    break;
  }
  case pwr_eType_Time: {
    if ( memcmp( val, &pwr_cAtMin, sizeof(pwr_tTime)) == 0)
      strcpy( sval, "ATTIME_MIN");
    else if ( memcmp( val, &pwr_cAtMax, sizeof(pwr_tTime)) == 0)
      strcpy( sval, "ATTIME_MAX");
    else if (memcmp(val, &pwr_cNotATime, sizeof(pwr_tTime)) == 0)
      strcpy(sval, "NotATime");
    else {
      sts = time_AtoAscii((pwr_tTime *)val, time_eFormat_DateAndTime,
			  timbuf, sizeof(timbuf)); 
      if (ODD(sts)) {
	sprintf(sval, "\"%s\"", timbuf);
      } else {
	sprintf(sval, "Bad time value");
	m_errCnt++;
	retval = FALSE;
      }
    }
    break;
  }
  case pwr_eType_DeltaTime: {
    if ( memcmp( val, &pwr_cDtMin, sizeof(pwr_tDeltaTime)) == 0)
      strcpy( sval, "DTTIME_MIN");
    else if ( memcmp( val, &pwr_cDtMax, sizeof(pwr_tDeltaTime)) == 0)
      strcpy( sval, "DTTIME_MAX");
    else if (memcmp(val, &pwr_cNotADeltaTime, sizeof(pwr_tDeltaTime)) == 0)
      strcpy(sval, "NotADeltaTime");
     else {
      sts = time_DtoAscii((pwr_tDeltaTime *)val, 1, timbuf, sizeof(timbuf));
      if (ODD(sts)) {
	sprintf(sval, "\"%s\"", timbuf);
      } else {
	sprintf(sval, "Bad time value");
	m_errCnt++;
	retval = FALSE;
      }
    }
    break;
  }
  case pwr_eType_Status:
    sprintf(sval, "%d", *(pwr_tStatus *) val);
    break;
  case pwr_eType_NetStatus:
    sprintf(sval, "%d", *(pwr_tNetStatus *) val);
    break;
  default:
    sprintf(sval, "Unknown attribute type: %d", adef.type());
    m_errCnt++;
    retval = FALSE;
    break;
}

*svalp = sval;
return retval;
}

//
// printVolume
//
void wb_print_wbl::printVolume(wb_volume& v, bool recursive)
{
  if (!v) {
    m_os << "%WBDUMP-E-Error Not a valid volume" << endl;
    m_errCnt++;
    return;
  }

  char timstr[40];
  time_AtoAscii(0, time_eFormat_DateAndTime, timstr, sizeof(timstr));
  indent() << "!     Generated by wb_print_wbl " << timstr << "\n";
  indent() << "!     Volume " << v.name() << " \n";
  indent() << "!     Version " pwrv_cPwrVersionStr "\n";

  wb_object o = v.object();
  const char* cname = v.cdef(v.cid()).name();
    
    
  indent(1) << "Volume " << v.name() << " " <<  cname << " "
            << cdh_VolumeIdToString(0, 0, v.vid(), 0, 0) << " " << endl;


  // Print volume body
  pwr_tOid oid;
  oid.vid = v.vid();
  oid.oix= 0;
  wb_object vo = v.object( oid);
  wb_cdef cdef = v.cdef(vo);

  wb_object co = v.object(cdh_ClassIdToObjid(v.cid()));
  wb_name t("Template");
  
  wb_object templ = co.child(t);
  if (!templ) {
    m_errCnt++;
    m_os << "Template not found for class " << cdef.name() << endl;
    return;
  }
  printBody(v, vo, templ, cdef, pwr_eBix_sys);

  // Print top objects and their children 
  if (recursive) {
    for (; o; o = o.after())
      printObject(v, o, recursive);
  }
    
  indent(-1) << "EndVolume" << endl;
}


//
// indent
//
ostream& wb_print_wbl::indent(int levelIncr)
{

  if (levelIncr < 0)
    m_level += levelIncr;

  assert(m_level >= 0);
    
  m_indBuf[m_level * m_levelInd] = '\0';

  m_os << m_indBuf;

  m_indBuf[m_level * m_levelInd] = ' ';

  if (levelIncr > 0) 
    m_level += levelIncr;
    
  return m_os;
}

bool wb_print_wbl::isFoCodeObject( wb_volume& v, wb_object& o)
{
  pwr_tInt32 compmethod;

  // Check if object has GraphPlcNode body and compmethod 58
  wb_cdef cd = v.cdef( o);
  if ( !cd)
    return false;

  wb_object go = cd.classBody( "GraphPlcNode");
  if ( !go) 
    return false;

  wb_attribute a = v.attribute( go, "compmethod");
  if ( !a) 
    return false;

  a.value( &compmethod);

  if ( compmethod == 58)
    return true;
  return false;
}
