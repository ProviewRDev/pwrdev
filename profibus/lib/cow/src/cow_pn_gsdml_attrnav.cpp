/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* cow_pn_gsdml_attrnav.cpp -- GSDML Attribute Navigator

  The GSDML Attribute Navigator is the engineering tool in ProviewR
  for configuration of PROFINET devices.

  Note: There's no support for PROFISafe.

  2022-02-11 <marcus.nordenberg@sssab.com> Major rework - Compliant towards
  PNIO 2.35
*/

#include <stdlib.h>
#include <sstream>
#include <string>
#include <memory>
#include <arpa/inet.h>
#include <typeinfo>
#include <regex>
#include <iomanip>
#include <stdexcept>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"
#include "co_fs_util.h"

#include "rt_pb_msg.h"
#include "rt_profinet.h"

#include "cow_wow.h"

#include "flow_msg.h"

#include "glow_growapi.h"

#include "cow_pn_gsdml_attrnav.h"

#include "pwr_baseclasses.h"

#define ATTRNAV__INPUT_SYNTAX 2
//#define ATTRNAV__OBJNOTFOUND 4
#define ATTRNAV__STRINGTOLONG 6
//#define ATTRNAV__ITEM_NOCREA 8

static char null_str[] = "";

/*
  Instantiates the correct template class depending on the type of value
  encountered in the GSDML file.
  Also creates an appropriate infotext helping the user when there's no help in the GSDML.
*/
void create_parameter_value_class(GsdmlAttrNav* attrnav, const char* name, std::shared_ptr<GSDML::Ref> ref,
                                  void* data, brow_tNode node)
{
  bool create_selection = false;
  std::string help = "No help available...";

  if (ref->_ValueItem && ref->_ValueItem->_Assignments.size())
    create_selection = true;

  if (ref && ref->_ValueItem && ref->_ValueItem->_Help)
    help = *ref->_ValueItem->_Help;

  std::ostringstream infotext(help, std::ios_base::ate);

  if (!ref->_AllowedValues.empty())
    infotext << std::endl
             << "Allowed values: " << ref->_AllowedValues.min() << " - " << ref->_AllowedValues.max();
  else
    infotext << std::endl
             << "No known allowed values. The datatype will limit the value "
                "entered...";

  if (ref->_ID != "")
    infotext << std::endl << "ID: " << ref->_ID;

  switch (ref->_DataType)
  {
  case GSDML::ValueDataType_Bit:
    new ItemPnParameterSelection<uint8_t>(attrnav, name, (uint8_t*)data, node, flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_BitArea:
    if (create_selection)
      new ItemPnParameterSelection<uint8_t>(attrnav, name, (uint8_t*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<uint8_t>(
          attrnav, name, (uint8_t*)data,
          (std::string("Integer8 (BitArea) value input. ") + infotext.str()).c_str(), node,
          flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Integer8:
    if (create_selection)
      new ItemPnParameterSelection<int8_t>(attrnav, name, (int8_t*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<int8_t>(attrnav, name, (int8_t*)data,
                                       (std::string("Integer8 value input. ") + infotext.str()).c_str(), node,
                                       flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Unsigned8:
    if (create_selection)
      new ItemPnParameterSelection<uint8_t>(attrnav, name, (uint8_t*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<uint8_t>(attrnav, name, (uint8_t*)data,
                                        (std::string("Unsigned8 value input. ") + infotext.str()).c_str(),
                                        node, flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Integer16:
    if (create_selection)
      new ItemPnParameterSelection<int16_t>(attrnav, name, (int16_t*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<int16_t>(attrnav, name, (int16_t*)data,
                                        (std::string("Integer16 value input. ") + infotext.str()).c_str(),
                                        node, flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Unsigned16:
    if (create_selection)
      new ItemPnParameterSelection<uint16_t>(attrnav, name, (uint16_t*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<uint16_t>(attrnav, name, (uint16_t*)data,
                                         (std::string("Unsigned16 value input. ") + infotext.str()).c_str(),
                                         node, flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Integer32:
    if (create_selection)
      new ItemPnParameterSelection<int32_t>(attrnav, name, (int32_t*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<int32_t>(attrnav, name, (int32_t*)data,
                                        (std::string("Integer32 value input. ") + infotext.str()).c_str(),
                                        node, flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Unsigned32:
    if (create_selection)
      new ItemPnParameterSelection<uint32_t>(attrnav, name, (uint32_t*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<uint32_t>(attrnav, name, (uint32_t*)data,
                                         (std::string("Unsigned32 value input. ") + infotext.str()).c_str(),
                                         node, flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Integer64:
    if (create_selection)
      new ItemPnParameterSelection<int64_t>(attrnav, name, (int64_t*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<int64_t>(attrnav, name, (int64_t*)data,
                                        (std::string("Integer64 value input. ") + infotext.str()).c_str(),
                                        node, flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Unsigned64:
    if (create_selection)
      new ItemPnParameterSelection<uint64_t>(attrnav, name, (uint64_t*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<uint64_t>(attrnav, name, (uint64_t*)data,
                                         (std::string("Unsigned64 value input. ") + infotext.str()).c_str(),
                                         node, flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Float32:
    if (create_selection)
      new ItemPnParameterSelection<float>(attrnav, name, (float*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<float>(attrnav, name, (float*)data,
                                      (std::string("Float32 value input. ") + infotext.str()).c_str(), node,
                                      flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_Float64:
    if (create_selection)
      new ItemPnParameterSelection<double>(attrnav, name, (double*)data, node, flow_eDest_IntoLast, ref);
    else
      new ItemPnParameterInput<double>(attrnav, name, (double*)data,
                                       (std::string("Float64 value input. ") + infotext.str()).c_str(), node,
                                       flow_eDest_IntoLast, ref);
    break;
  case GSDML::ValueDataType_VisibleString:
    new ItemPnParameterInput<std::string>(attrnav, name, (char*)data, ref->_Length,
                                          (std::string("String input. ") + infotext.str()).c_str(), node,
                                          flow_eDest_IntoLast, ref);
    break;
  default:
    std::cerr << "Unhandled GSDML Datatype for parameter Ref element in create_parameter_value_class()"
              << std::endl;
  }
}

void GsdmlAttrNav::message(char sev, const char* text) { (message_cb)(parent_ctx, sev, text); }

//
//  Free pixmaps
//
void GsdmlAttrNavBrow::free_pixmaps()
{
  brow_FreeAnnotPixmap(ctx, pixmap_leaf);
  brow_FreeAnnotPixmap(ctx, pixmap_map);
  brow_FreeAnnotPixmap(ctx, pixmap_openmap);
  brow_FreeAnnotPixmap(ctx, pixmap_attr);
  brow_FreeAnnotPixmap(ctx, pixmap_attrarray);
  brow_FreeAnnotPixmap(ctx, pixmap_attrenum);
}

//
//  Create pixmaps for leaf, closed map and open map
//
void GsdmlAttrNavBrow::allocate_pixmaps()
{
  brow_LoadPBMs(ctx, "xnav_bitmap_leaf", &pixmap_leaf);
  brow_LoadPBMs(ctx, "xnav_bitmap_map", &pixmap_map);
  brow_LoadPBMs(ctx, "xnav_bitmap_openmap", &pixmap_openmap);
  brow_LoadPBMs(ctx, "xnav_bitmap_attr", &pixmap_attr);
  brow_LoadPBMs(ctx, "xnav_bitmap_attrarra", &pixmap_attrarray);
  brow_LoadPBMs(ctx, "xnav_bitmap_attrenum", &pixmap_attrenum);
}

//
// Create the navigator widget
//
GsdmlAttrNav::GsdmlAttrNav(void* xn_parent_ctx, const char* xn_name, pn_gsdml* xn_gsdml, int xn_edit_mode,
                           std::shared_ptr<ProfinetRuntimeData> pwr_pn_data, pwr_tStatus* status)
    : parent_ctx(xn_parent_ctx), gsdml(xn_gsdml), edit_mode(xn_edit_mode), trace_started(0), message_cb(0),
      change_value_cb(0), device_confirm_active(0), device_read(0), viewio(0),
      order_moduletype(attr_eOrderModuleType_Default), m_modified(false)
{
  strcpy(m_name, xn_name);
  pn_runtime_data = pwr_pn_data;

  *status = 1;
}

//
//  Delete a nav context
//
GsdmlAttrNav::~GsdmlAttrNav() { delete m_wow; }

GsdmlAttrNavBrow::~GsdmlAttrNavBrow() { free_pixmaps(); }

//
//  Get current zoom factor
//
void GsdmlAttrNav::get_zoom(double* zoom_factor) { brow_GetZoom(brow->ctx, zoom_factor); }

//
//  Zoom
//
void GsdmlAttrNav::zoom(double zoom_factor) { brow_Zoom(brow->ctx, zoom_factor); }

//
//  Return to base zoom factor
//
void GsdmlAttrNav::unzoom() { brow_UnZoom(brow->ctx); }

//
// Collapse
//
void GsdmlAttrNav::collapse()
{
  brow_tObject* olist;
  int ocnt;
  ItemPn* item;

  brow_SetNodraw(brow->ctx);

  brow_GetObjectList(brow->ctx, &olist, &ocnt);
  for (int i = ocnt - 1; i >= 0; i--)
  {
    if (brow_GetObjectLevel(olist[i]) == 0)
    {
      brow_GetUserData(olist[i], (void**)&item);

      item->close(this, 0, 0);
    }
  }

  brow_CenterObject(brow->ctx, olist[0], 0);

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
}

//
// Expand all items
//
void GsdmlAttrNav::expand_all()
{
  brow_tObject* olist;
  int ocnt;
  ItemPn* item;

  brow_SetNodraw(brow->ctx);

  collapse();

  brow_GetObjectList(brow->ctx, &olist, &ocnt);
  for (int i = 0; i < ocnt; i++)
  {
    brow_GetUserData(olist[i], (void**)&item);

    if (item->m_type & attrnav_mItemType_ExpandForSave)
    {
      item->open_children(this, 0, 0);
    }

    brow_GetObjectList(brow->ctx, &olist, &ocnt);
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
}

// Get selected item
int GsdmlAttrNav::get_select(ItemPn** item)
{
  brow_tNode* node_list;
  int node_count;
  ItemPn* base_item;

  brow_GetSelectedNodes(brow->ctx, &node_list, &node_count);
  if (!node_count)
    return 0;

  brow_GetUserData(node_list[0], (void**)&base_item);
  free(node_list);

  *item = base_item;
  return 1;
}

//
// Set attribute value
//
int GsdmlAttrNav::set_attr_value(const char* value_str)
{
  brow_tNode* node_list;
  int node_count;
  ItemPn* base_item;

  brow_GetSelectedNodes(brow->ctx, &node_list, &node_count);
  if (!node_count)
    return 0;

  brow_GetUserData(node_list[0], (void**)&base_item);
  free(node_list);

  base_item->value_changed(this, value_str);

  return 1;
}

//
// Check that the current selected item is valid for change
//
int GsdmlAttrNav::check_attr_value(std::string& p_value)
{
  brow_tNode* node_list;
  int node_count;
  ItemPn* base_item;

  brow_GetSelectedNodes(brow->ctx, &node_list, &node_count);
  if (!node_count)
    return PB__NOATTRSEL;

  brow_GetUserData(node_list[0], (void**)&base_item);
  free(node_list);

  switch (base_item->m_type)
  {
  case attrnav_mItemType_Changeable:
    if (base_item->m_noedit)
    {
      p_value = "";
      return PB__ATTRNOEDIT;
    }

    // Call into the base item to fetch the string value
    p_value = base_item->to_string();

    break;
  default:
    return PB__ATTRNOEDIT;
  }
  return PB__SUCCESS;
}

//
// Callbacks from brow
//
int GsdmlAttrNav::brow_cb(FlowCtx* ctx, flow_tEvent event)
{
  GsdmlAttrNav* attrnav;
  ItemPn* item;

  if (event->event == flow_eEvent_ObjectDeleted)
  {
    brow_GetUserData(event->object.object, (void**)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData((BrowCtx*)ctx, (void**)&attrnav);
  attrnav->message(' ', null_str);
  switch (event->event)
  {
  case flow_eEvent_Key_Up:
  {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(attrnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
    {
      sts = brow_GetLastVisible(attrnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    }
    else
    {
      if (!brow_IsVisible(attrnav->brow->ctx, node_list[0], flow_eVisible_Partial))
      {
        sts = brow_GetLastVisible(attrnav->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      }
      else
      {
        sts = brow_GetPrevious(attrnav->brow->ctx, node_list[0], &object);
        if (EVEN(sts))
        {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }

    brow_SelectClear(attrnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(attrnav->brow->ctx, object);
    attrnav->display_attr_help_text();
    if (!brow_IsVisible(attrnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(attrnav->brow->ctx, object, 0.25);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_Key_Down:
  {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(attrnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
    {
      sts = brow_GetFirstVisible(attrnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    }
    else
    {
      if (!brow_IsVisible(attrnav->brow->ctx, node_list[0], flow_eVisible_Partial))
      {
        sts = brow_GetFirstVisible(attrnav->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      }
      else
      {
        sts = brow_GetNext(attrnav->brow->ctx, node_list[0], &object);
        if (EVEN(sts))
        {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }
    brow_SelectClear(attrnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(attrnav->brow->ctx, object);
    attrnav->display_attr_help_text();
    if (!brow_IsVisible(attrnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(attrnav->brow->ctx, object, 0.75);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_SelectClear:
    brow_ResetSelectInverse(attrnav->brow->ctx);
    break;
  case flow_eEvent_MB1Click:
    // Select
    double ll_x, ll_y, ur_x, ur_y;
    int sts;

    switch (event->object.object_type)
    {
    case flow_eObjectType_Node:
      brow_MeasureNode(event->object.object, &ll_x, &ll_y, &ur_x, &ur_y);
      if (event->object.x < ll_x + 1.0)
      {
        // Simulate doubleclick
        flow_tEvent doubleclick_event;

        doubleclick_event = (flow_tEvent)calloc(1, sizeof(*doubleclick_event));
        memcpy(doubleclick_event, event, sizeof(*doubleclick_event));
        doubleclick_event->event = flow_eEvent_MB1DoubleClick;
        sts = brow_cb(ctx, doubleclick_event);
        free((char*)doubleclick_event);
        return sts;
      }

      if (brow_FindSelectedObject(attrnav->brow->ctx, event->object.object))
      {
        brow_SelectClear(attrnav->brow->ctx);
      }
      else
      {
        brow_SelectClear(attrnav->brow->ctx);
        brow_SetInverse(event->object.object, 1);
        brow_SelectInsert(attrnav->brow->ctx, event->object.object);
        attrnav->display_attr_help_text();
      }
      break;
    default:
      brow_SelectClear(attrnav->brow->ctx);
    }
    break;
  case flow_eEvent_MB2Click:
  {
    // Select
    brow_tNode* node_list;
    int node_count;

    if (!attrnav->edit_mode)
    {
      attrnav->message('E', "Not in edit mode");
      break;
    }

    switch (event->object.object_type)
    {
    case flow_eObjectType_Node:
      brow_GetSelectedNodes(attrnav->brow->ctx, &node_list, &node_count);
      if (!node_count)
      {
        attrnav->message('E', "Select a slot");
        break;
      }
      else if (node_count > 1)
      {
        attrnav->message('E', "Select one slot");
        free(node_list);
        break;
      }

      ItemPnSlot *item_dest, *item_src;
      brow_GetUserData(node_list[0], (void**)&item_src);
      brow_GetUserData(event->object.object, (void**)&item_dest);

      if (item_src->m_type != attrnav_mItemType_Movable)
      {
        attrnav->message('E', "Unable to move this object");
        free(node_list);
        break;
      }
      if (item_dest->m_type != attrnav_mItemType_Movable)
      {
        attrnav->message('E', "Invalid destination");
        free(node_list);
        break;
      }

      free(node_list);

      break;
    default:
      brow_SelectClear(attrnav->brow->ctx);
    }
    break;
  }
  case flow_eEvent_Key_Left:
  {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(attrnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    if (brow_IsOpen(node_list[0]))
      // Close this node
      object = node_list[0];
    else
    {
      // Close parent
      sts = brow_GetParent(attrnav->brow->ctx, node_list[0], &object);
      if (EVEN(sts))
      {
        free(node_list);
        return 1;
      }
    }
    brow_GetUserData(object, (void**)&item);
    item->close(attrnav, 0, 0);

    free(node_list);
    break;
  }
  case flow_eEvent_Key_Right:
  {
    brow_tNode* node_list;
    int node_count;

    brow_GetSelectedNodes(attrnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    brow_GetUserData(node_list[0], (void**)&item);

    if (item->m_type & attrnav_mItemType_Changeable)
    {
      if (attrnav->change_value_cb)
        attrnav->change_value_cb(attrnav->parent_ctx);
    }
    else if (item->m_type & attrnav_mItemType_Selectable)
    {
      item->selected(attrnav);
    }
    else if (item->m_type & attrnav_mItemType_Parent)
    {
      item->open_children(attrnav, 0, 0);
    }
    break;
  }
  case flow_eEvent_MB1DoubleClick:
    switch (event->object.object_type)
    {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);
      item->open_children(attrnav, event->object.x, event->object.y);
      break;
    default:;
    }
    break;
  case flow_eEvent_MB1DoubleClickCtrl:
    break;
  case flow_eEvent_Radiobutton:
  {
    if (!attrnav->edit_mode)
    {
      attrnav->message('E', "Not in edit mode");
      break;
    }
    switch (event->object.object_type)
    {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);
      if (item->m_type & attrnav_mItemType_Selectable)
        item->selected(attrnav);
      break;
    default:;
    }

    break;
  }
  case flow_eEvent_Key_PageDown:
  {
    brow_Page(attrnav->brow->ctx, 0.8);
    break;
  }
  case flow_eEvent_Key_PageUp:
  {
    brow_Page(attrnav->brow->ctx, -0.8);
    break;
  }
  case flow_eEvent_ScrollDown:
  {
    brow_Page(attrnav->brow->ctx, 0.1);
    break;
  }
  case flow_eEvent_ScrollUp:
  {
    brow_Page(attrnav->brow->ctx, -0.1);
    break;
  }
  default:;
  }
  return 1;
}

void GsdmlAttrNav::trace_scan(void* data)
{
  GsdmlAttrNav* attrnav = (GsdmlAttrNav*)data;
  int time = 200;

  if (attrnav->trace_started)
  {
    brow_TraceScan(attrnav->brow->ctx);

    attrnav->trace_timerid->add(time, trace_scan, attrnav);
  }
}

void GsdmlAttrNav::force_trace_scan()
{
  if (trace_started)
    brow_TraceScan(brow->ctx);
}

/*
  Called when the user accepts that we will recreate configuration
  since teh DAPs are not compatible...
*/
void GsdmlAttrNav::device_change_reset_ok(void* ctx, void* data)
{
  GsdmlAttrNav* attrnav = (GsdmlAttrNav*)ctx;

  attrnav->pn_runtime_data->m_PnDevice->m_slot_list.clear();
  device_changed_ok(ctx, (void*)0);
}

/*
  When the device changes and everything is OK, i.e. the modules are directly
  compatible with the old DAP/Device or the user has accepted that they are not
  and that all settings will be lost. This is called to recreate everything.
*/
void GsdmlAttrNav::device_changed_ok(void* ctx, void* data)
{
  GsdmlAttrNav* attrnav = (GsdmlAttrNav*)ctx;

  // Do an update of underlying data structures
  GsdmlAttrNav::device_update_change(attrnav);

  // Delete all nodes, we will start all over
  brow_DeleteAll(attrnav->brow->ctx);

  // Recreate everything
  attrnav->object_attr();
  attrnav->device_confirm_active = 0;

  attrnav->set_modified(true);
}

/*
  Update the device data upon a change of DAP
*/
void GsdmlAttrNav::device_update_change(void* ctx)
{
  GsdmlAttrNav* attrnav = (GsdmlAttrNav*)ctx;
  size_t slot_index = 0;

  // Our new DAP_ID is already updated, let's grab it...
  std::string const& new_dap_id = attrnav->pn_runtime_data->m_PnDevice->m_DAP_ID;

  // Update selected DAP
  attrnav->m_selected_device_item = attrnav->gsdml->getDeviceAccessPointMap()[new_dap_id];

  // The number of physical slots are not always the same in each DAP so we need
  // to adjust the slot count. If the new size is smaller the slots will be
  // removed from the end. If it's bigger they will be default constructed. The
  // PhysicalSlots starts at zero, hence the max() + 1.
  attrnav->pn_runtime_data->m_PnDevice->m_slot_list.resize(
      attrnav->m_selected_device_item->_PhysicalSlots.max() + 1);

  for (auto& slot : attrnav->pn_runtime_data->m_PnDevice->m_slot_list)
  {
    // Since we might come from a resize (they might be default constructed with
    // slot number of 0) of the slot list we give them all their respective slot
    // number again :)
    slot.m_slot_number = slot_index++;

    // The DAP
    if (slot.m_slot_number == 0)
    {
      slot.m_subslot_map.clear();
      slot.m_module_ident_number = attrnav->m_selected_device_item->_ModuleIdentNumber;
      slot.m_module_ID = new_dap_id;
      continue;
    }
  }
}

// Check to see if the new DAP is compatible with the already selected modules
// in the configurator. If not we need to scrap the data and reconfigure the DAP
// completely since they are not compatible...
pwr_tBoolean GsdmlAttrNav::device_check_change_ok(void* ctx)
{
  GsdmlAttrNav* attrnav = (GsdmlAttrNav*)ctx;

  // This is the newly selected DAP
  // int device_num = attrnav->pn_runtime_data->m_PnDevice->m_device_num;
  std::string const& new_dap_id = attrnav->pn_runtime_data->m_PnDevice->m_DAP_ID;

  // Get a reference to the new selected device
  auto const new_dap = attrnav->gsdml->getDeviceAccessPointMap()[new_dap_id];

  // So we are to check if the modules already selected are valid on this new
  // DAP We will check if the module ID is allowed to be in the respective slot.
  // Start looping through all slots of the previously selected DAP (since these
  // slots aren't updated yet)
  for (auto const& slot : attrnav->pn_runtime_data->m_PnDevice->m_slot_list)
  {
    // Skip the DAP itself and any "unconfigured" slots i.e. module ident number
    // is 0
    if (slot.m_slot_number == 0 || slot.m_module_ident_number == 0)
      continue;

    // If we have no ID the slot is unused...
    if (slot.m_module_ID == "")
      continue;

    // Check if the module is allowed. This also makes sure that we notify of
    // data loss in case we have populated more slots with data than are
    // available in the new DAP
    try
    {
      auto module_item_ref = new_dap->_UseableModules.at(slot.m_module_ID);
      if (!module_item_ref->_AllowedInSlots.inList(slot.m_slot_number))
        return false;
    }
    catch (std::out_of_range& oor)
    {
      // There was no such ID in that DAPs usable modules list...We have
      // incompatibilities...
      std::cerr << "Exception in device_check_change_ok(): " << oor.what() << std::endl;
      return false;
    }
  }
  // We made it this far :) This DAP seems to work with the already selected
  // modules
  return true;
}

void GsdmlAttrNav::device_changed_cancel(void* ctx, void* data)
{
  std::string const& old_dap_id = *((std::string*)data);
  GsdmlAttrNav* attrnav = (GsdmlAttrNav*)ctx;

  attrnav->pn_runtime_data->m_PnDevice->m_DAP_ID = old_dap_id;
  attrnav->device_confirm_active = 0;
}

void GsdmlAttrNav::redraw()
{
  brow_DeleteAll(brow->ctx);
  object_attr();
}

int GsdmlAttrNav::trace_scan_bc(brow_tObject object, void* p)
{
  ItemPn* base_item;
  GsdmlAttrNav* attrnav;

  brow_GetUserData(object, (void**)&base_item);
  brow_GetCtxUserData(brow_GetCtx(object), (void**)&attrnav);

  base_item->scan(attrnav, p);

  return 1;
}

int GsdmlAttrNav::trace_connect_bc(brow_tObject object, char* name, char* attr, flow_eTraceType m_type,
                                   void** p)
{
  ItemPn* base_item;
  GsdmlAttrNav* attrnav;

  if (streq(name, ""))
    return 1;

  brow_GetCtxUserData(brow_GetCtx(object), (void**)&attrnav);

  brow_GetUserData(object, (void**)&base_item);

  if (base_item->m_type & attrnav_mItemType_Traceable)
    base_item->set_trace_value(p);
  else
    std::cerr << "SetTrace called for class (" << base_item->m_name
              << ") not explicitly setting attrnav_mItemType_Traceable attribute type" << std::endl;

  return 1;
}

int GsdmlAttrNav::trace_disconnect_bc(brow_tObject object)
{
  ItemPn* base_item;

  brow_GetUserData(object, (void**)&base_item);
  switch (base_item->m_type)
  {
  default:;
  }
  return 1;
}

//
// Create nodeclasses
//
void GsdmlAttrNavBrow::create_nodeclasses()
{
  allocate_pixmaps();

  // Create common-class

  brow_CreateNodeClass(ctx, "NavigatorDefault", flow_eNodeGroup_Common, &nc_object);
  brow_AddAnnotPixmap(nc_object, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap(nc_object, 1, 1.1, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_object, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_object, 7, 0.6, 1, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_object, 12, 0.6, 2, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_object, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create attribute nodeclass

  brow_CreateNodeClass(ctx, "NavigatorGsdmlAttr", flow_eNodeGroup_Common, &nc_attr);
  brow_AddAnnotPixmap(nc_attr, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_attr, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_attr, 12, 0.6, 1, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_attr, 24, 0.6, 2, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_attr, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create a more "airy" attribute class for parameters

  brow_CreateNodeClass(ctx, "NavigatorGsdmlAttrParameter", flow_eNodeGroup_Common, &nc_attr_parameter);
  brow_AddAnnotPixmap(nc_attr_parameter, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_attr_parameter, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_attr_parameter, 22, 0.6, 1, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_attr_parameter, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create multiline attribute nodeclass

  brow_CreateNodeClass(ctx, "NavigatorGsdmlAttrMultiLine", flow_eNodeGroup_Common, &nc_attr_multiline);
  brow_AddAnnotPixmap(nc_attr_multiline, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_attr_multiline, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_attr_multiline, 8, 0.6, 1, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_MultiLine, 1);
  brow_AddFrame(nc_attr_multiline, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create attribute nodeclass

  brow_CreateNodeClass(ctx, "NavigatorEnum", flow_eNodeGroup_Common, &nc_enum);
  brow_AddRadiobutton(nc_enum, 18, 0.03, 0.7, 0.7, 0, flow_eDrawType_Line, 1);
  brow_AddAnnotPixmap(nc_enum, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_enum, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_enum, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  brow_CreateNodeClass(ctx, "NavigatorEnumMType", flow_eNodeGroup_Common, &nc_enum_mtype);
  brow_AddRadiobutton(nc_enum_mtype, 30, 0.03, 0.7, 0.7, 0, flow_eDrawType_Line, 1);
  brow_AddAnnotPixmap(nc_enum_mtype, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_enum_mtype, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_enum_mtype, 20, 0.6, 1, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_enum_mtype, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create table nodeclass

  brow_CreateNodeClass(ctx, "NavigatorTable", flow_eNodeGroup_Common, &nc_table);
  brow_AddAnnotPixmap(nc_table, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap(nc_table, 1, 1.1, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_table, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table, 8, 0.6, 1, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 12, 0.6, 2, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 16, 0.6, 3, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 20, 0.6, 4, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 24, 0.6, 5, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 28, 0.6, 6, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 32, 0.6, 7, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 35, 0.6, 8, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 38, 0.6, 9, flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_table, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create Header

  brow_CreateNodeClass(ctx, "NavigatorHead", flow_eNodeGroup_Common, &nc_header);
  brow_AddAnnotPixmap(nc_header, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_header, 2, 0.6, 0, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_header, 8, 0.6, 1, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_header, 0, 0, 20, 0.83, flow_eDrawType_LineGray, 2, 1);

  // Create TableHeader

  brow_CreateNodeClass(ctx, "NavigatorTableHead", flow_eNodeGroup_Common, &nc_table_header);
  brow_AddAnnotPixmap(nc_table_header, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_table_header, 2, 0.6, 0, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table_header, 8, 0.6, 1, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table_header, 12, 0.6, 2, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table_header, 16, 0.6, 3, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table_header, 20, 0.6, 4, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table_header, 24, 0.6, 5, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table_header, 28, 0.6, 6, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table_header, 32, 0.6, 7, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table_header, 35, 0.6, 8, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table_header, 38, 0.6, 9, flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_table_header, 0, 0, 20, 0.83, flow_eDrawType_LineGray, 2, 1);
}

void GsdmlAttrNav::print(char* filename) { brow_Print(brow->ctx, filename); }

int GsdmlAttrNav::object_attr()
{
  if (pn_runtime_data->m_gsdml_mismatch)
  {
    std::string msg(
        "New GSDML file detected.\n\n GSDML files should be backwards compatible with older ones. IDs and\n"
        "such are not allowed to change according to specification. However, we cannot promise that \n"
        "everyone follow the specifications, and as such this message is here to make you aware. It's\n"
        "perfectly fine in most cases to update your GSDML file since most, if not all, suppliers\n"
        "of PROFINET devices follow the specification. However, you should glance through your settings\n"
        "just to be sure.");

    m_wow->DisplayText("New GSDML file detected", msg.c_str());
    pn_runtime_data->m_gsdml_mismatch = false; // Reset this since we've made the use aware :)
  }

  brow_SetNodraw(brow->ctx);

  // Add a network folder that contains the network settings used for the device
  new ItemPnNetwork(this, "NetworkSettings", NULL, flow_eDest_IntoLast, "General network settings.");

  // Just some general device information from the GSDML file
  new ItemPnDeviceInfo(this, "DeviceInfo", NULL, flow_eDest_IntoLast,
                       "Information about this device family.");

  // Add an item to select DAP
  new ItemPnDAPSelection(this, "DAP Selection", NULL, flow_eDest_IntoLast,
                         "Choose DAP (Device Access Point)");

  // Have we chosen a DAP?
  if (m_selected_device_item)
  {
    // Loop through all physical slots
    for (auto& slot : pn_runtime_data->m_PnDevice->m_slot_list)
    {
      // The DAP is always in slot 0. It has an attribute "FixedInSlots" but is
      // nevertheless always in slot 0...
      if (slot.m_slot_number == DAP_SLOT)
      {
        new ItemPnDAP(this, "DAP", &slot, NULL, flow_eDest_IntoLast,
                      "Configure the DAP here. Some DAPs may let you select "
                      "what submodules goes where. Be sure to select according "
                      "to your hardware specification.");
        continue;
      }

      // Create a super awesome name for the slot.
      std::ostringstream slot_string("Slot ", std::ios_base::ate);
      slot_string << slot.m_slot_number;

      new ItemPnSlot(this, slot_string.str().c_str(), &slot, NULL, flow_eDest_IntoLast,
                     "Select a module for this slot. Remember that some modules can only "
                     "go in specific slots. It all depends on the hardware device and how "
                     "the manufacturer have planned the device.");
    }
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return PB__SUCCESS;
}

void GsdmlAttrNavBrow::brow_setup()
{
  brow_sAttributes brow_attr;
  unsigned long mask;

  mask = 0;
  mask |= brow_eAttr_indentation;
  brow_attr.indentation = 0.5;
  mask |= brow_eAttr_annotation_space;
  brow_attr.annotation_space = 0.5;
  brow_SetAttributes(ctx, &brow_attr, mask);
  brow_SetCtxUserData(ctx, attrnav);

  brow_EnableEvent(ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_MB2Click, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_MB1DoubleClickCtrl, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_PF3, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Radiobutton, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack, GsdmlAttrNav::brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int GsdmlAttrNav::init_brow_cb(FlowCtx* fctx, void* client_data)
{
  GsdmlAttrNav* attrnav = (GsdmlAttrNav*)client_data;
  BrowCtx* ctx = (BrowCtx*)fctx;
  int sts;

  attrnav->brow = new GsdmlAttrNavBrow(ctx, (void*)attrnav);

  attrnav->brow->brow_setup();
  attrnav->brow->create_nodeclasses();

  // Create the root item
  attrnav->object_attr();

  sts = brow_TraceInit(ctx, trace_connect_bc, trace_disconnect_bc, trace_scan_bc);
  attrnav->trace_started = 1;

  trace_scan(attrnav);

  return 1;
}

int GsdmlAttrNav::save()
{
  int sts = PB__SUCCESS;

  if (pn_runtime_data->m_PnDevice->m_DAP_ID == "")
    return PB__NODEVICE;

  // Be sure all items are initialized, expand all (the ones marked with "expand for save")
  brow_SetNodraw(brow->ctx);
  expand_all();

  pn_runtime_data->m_PnDevice->m_vendor_id = gsdml->m_DeviceIdentity->_VendorID;
  pn_runtime_data->m_PnDevice->m_device_id = gsdml->m_DeviceIdentity->_DeviceID;
  pn_runtime_data->m_PnDevice->m_instance = m_selected_device_item->_ObjectUUID_LocalIndex;
  pn_runtime_data->m_PnDevice->m_moduleinfo_name = *m_selected_device_item->_ModuleInfo._Name;
  pn_runtime_data->m_PnDevice->m_gsdml_source_file = basename(gsdml->m_gsdml_file);

  // Go through and save all diagnostics available
  // TODO Should we also save the extvalue diag? Do we need that??
  for (auto const& diag_item : gsdml->getChannelDiagMap())
  {
    pn_runtime_data->m_PnDevice->m_channel_diag_map[diag_item.first].m_name = *diag_item.second._Name;

    // Not all diag items do have a help item (it's optional)
    if (diag_item.second._Help)
    {
      pn_runtime_data->m_PnDevice->m_channel_diag_map[diag_item.first].m_help = *diag_item.second._Help;
    }

    for (auto const& ext_diag_item : diag_item.second._ExtChannelDiagList)
    {
      if (ext_diag_item.second._Help)
      {
        pn_runtime_data->m_PnDevice->m_channel_diag_map[diag_item.first]
            .m_ext_channel_diag_map[ext_diag_item.first]
            .m_help = *ext_diag_item.second._Help;
      }

      pn_runtime_data->m_PnDevice->m_channel_diag_map[diag_item.first]
          .m_ext_channel_diag_map[ext_diag_item.first]
          .m_name = *ext_diag_item.second._Name;
    }
  }

  // Make sure we copy INPUT_CR to OUTPUT_CR
  pn_runtime_data->m_PnDevice->m_IOCR_map[PROFINET_IO_CR_TYPE_OUTPUT] =
      pn_runtime_data->m_PnDevice->m_IOCR_map.at(PROFINET_IO_CR_TYPE_INPUT);

  if (!pn_runtime_data->save())
    m_wow->DisplayError("Error saving", "An error occured while saving the runtime configuration file.");

  collapse();
  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);

  return sts;
}

int ItemPn::open_children(GsdmlAttrNav* attrnav, double x, double y)
{
  double node_x, node_y;

  brow_GetNodePosition(m_node, &node_x, &node_y);

  if (brow_IsOpen(m_node))
  {
    close(attrnav, node_x, node_y);
  }
  else
  {
    brow_SetNodraw(attrnav->brow->ctx);

    open_children_impl(); // Specific implementation goes here

    brow_SetOpen(m_node, attrnav_mOpen_Children);
    brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_openmap);
    brow_ResetNodraw(attrnav->brow->ctx);
    brow_Redraw(attrnav->brow->ctx, node_y);
  }
  return 1;
}

void ItemPn::selected(GsdmlAttrNav* attrnav)
{

  if (selected_impl(attrnav))
    attrnav->set_modified(true);
}

void ItemPn::value_changed(GsdmlAttrNav* attrnav, const char* value_str)
{
  if (value_changed_impl(attrnav, value_str))
    attrnav->set_modified(true);
}

int ItemPn::close(GsdmlAttrNav* attrnav, double x, double y, bool reopen_after_close)
{
  double node_x, node_y;

  brow_GetNodePosition(m_node, &node_x, &node_y);

  if (brow_IsOpen(m_node))
  {
    // Close
    brow_SetNodraw(attrnav->brow->ctx);
    brow_CloseNode(attrnav->brow->ctx, m_node);

    if (brow_IsOpen(m_node) & attrnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(m_node, 1);

    if (brow_IsOpen(m_node) & attrnav_mOpen_Children)
    {
      brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
    }

    brow_ResetOpen(m_node, attrnav_mOpen_All);
    brow_SelectClear(attrnav->brow->ctx);
    brow_SetInverse(m_node, 1);
    brow_SelectInsert(attrnav->brow->ctx, m_node);
    brow_ResetNodraw(attrnav->brow->ctx);
    brow_Redraw(attrnav->brow->ctx, node_y);

    if (!brow_IsVisible(attrnav->brow->ctx, m_node, flow_eVisible_Full))
      brow_CenterObject(attrnav->brow->ctx, m_node, 0.25);
  }

  if (reopen_after_close)
  {
    open_children(m_attrnav, 0.0, 0.0);
  }

  return 1;
}

ItemPnInfo::ItemPnInfo(GsdmlAttrNav* attrnav, const char* name, const char* trace_attr_name,
                       pwr_eType pwr_type_id, size_t attr_size, void const* value_p, brow_tNode dest,
                       flow_eDest dest_code, const char* infotext)
    : ItemPn(attrnav, attrnav_mItemType_, name, infotext), m_pwr_type_id(pwr_type_id)
{
  m_closed_annotation = attrnav->brow->pixmap_attr;
  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);
  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());

  std::string value = value_to_string(m_pwr_type_id, value_p);

  brow_SetAnnotation(m_node, 1, value.c_str(), value.length());
}

std::string ItemPnInfo::value_to_string(int type_id, void const* value_ptr)
{
  std::ostringstream result(std::ios_base::out);

  if (value_ptr == 0)
  {
    result << "Undefined (Null pointer argument)";
    return result.str();
  }

  switch (type_id)
  {
  case pwr_eType_Boolean:
    result << (*(pwr_tBoolean*)value_ptr ? "Yes" : "No");
    break;
  case pwr_eType_Float32:
    result << *(pwr_tFloat32*)value_ptr;
    break;
  case pwr_eType_UInt8:
    result << *(pwr_tUInt8*)value_ptr;
    break;
  case pwr_eType_UInt16:
    result << *(pwr_tUInt16*)value_ptr;
    break;
  case pwr_eType_UInt32:
    result << *(pwr_tUInt32*)value_ptr;
    break;
  case pwr_eType_Int8:
    result << *(pwr_tInt8*)value_ptr;
    break;
  case pwr_eType_Int16:
    result << *(pwr_tInt16*)value_ptr;
    break;
  case pwr_eType_Int32:
    result << *(pwr_tInt32*)value_ptr;
    break;
  case pwr_eType_String:
  {
    result << *(std::string*)value_ptr;
    break;
  }
  default:;
  }

  return result.str();
}

ItemPnIDSelectValue::ItemPnIDSelectValue(GsdmlAttrNav* attrnav, const char* name,
                                         std::string const order_number, std::string id_enum_value,
                                         std::string* id_p, brow_tNode dest, flow_eDest dest_code,
                                         const char* infotext)
    : ItemPn(attrnav, (attrnav_mItemType_Traceable | attrnav_mItemType_Selectable), name, infotext),
      m_id_enum_value(id_enum_value), m_id(id_p)
{
  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_enum_mtype, dest, dest_code,
                  (void*)this, 1, &m_node);

  brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_attr);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
  brow_SetAnnotation(m_node, 1, order_number.c_str(), order_number.length());

  // Set if this is selected or not
  brow_SetRadiobutton(m_node, 0, (*m_id == m_id_enum_value ? 1 : 0));

  brow_SetTraceAttr(m_node, m_name.c_str(), "", flow_eTraceType_User);
}

bool ItemPnIDSelectValue::selected_impl(GsdmlAttrNav* attrnav)
{
  int value;
  if (!attrnav->edit_mode)
  {
    attrnav->message('E', "Not in edit mode");
    return false;
  }

  brow_GetRadiobutton(m_node, 0, &value);

  if (!value)
  {
    brow_SetRadiobutton(m_node, 0, 1);

    *m_id = m_id_enum_value;
    return true;
  }
  return false;
}

int ItemPnIDSelectValue::scan(GsdmlAttrNav* attrnav, void* id_p)
{
  if (!m_first_scan)
  {
    if (m_old_value == *(std::string*)id_p)
      // No change since last time
      return 1;
  }
  else
    m_first_scan = 0;

  if (*(std::string*)id_p == m_id_enum_value)
    brow_SetRadiobutton(m_node, 0, 1);
  else
    brow_SetRadiobutton(m_node, 0, 0);

  m_old_value = *(std::string*)id_p;
  return 1;
}

ItemPnDAPSelection::ItemPnDAPSelection(GsdmlAttrNav* attrnav, const char* name, brow_tNode dest,
                                       flow_eDest dest_code, const char* infotext)
    : ItemPn(attrnav, attrnav_mItemType_Traceable | attrnav_mItemType_Parent, name, "Choose DAP"),
      m_old_value("")
{
  m_closed_annotation = attrnav->brow->pixmap_attrenum;
  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);
  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
  brow_SetTraceAttr(m_node, m_name.c_str(), "", flow_eTraceType_User);

  // Setup
  if (m_attrnav->pn_runtime_data->m_PnDevice->m_DAP_ID != "")
  {
    try
    {
      m_attrnav->m_selected_device_item =
          m_attrnav->gsdml->getDeviceAccessPointMap().at(m_attrnav->pn_runtime_data->m_PnDevice->m_DAP_ID);
    }
    catch (std::out_of_range& oor)
    {
      // This is not good...
      // The GSDML file might have changed and the supplier haven't followed the specification regarding the
      // part where it says that IDs mustn't change. We reset evertything and start anew...
      m_attrnav->pn_runtime_data->reset_to_default();

      std::ostringstream message(std::ios_base::out);
      message
          << "The ID for the DAP cannot be found! This shouldn't happen if the supplier of the GSDML followed"
          << std::endl
          << "the specification. We have to reset all configuration in order to continue..." << std::endl
          << std::endl
          << "If you would like to solve this yourself by checking the GSDML file and the runtime "
             "configuration hit cancel"
          << std::endl
          << "in the configuration window and your settings are still safe and sound in: " << std::endl
          << m_attrnav->pn_runtime_data->m_pwr_pn_filename;

      attrnav->m_wow->DisplayText("Oh oh!", message.str().c_str());
    }
  }
}

int ItemPnDAPSelection::open_children_impl()
{
  for (auto const& dap_item : m_attrnav->gsdml->getDeviceAccessPointMap())
  {
    std::string module_name = *dap_item.second->_ModuleInfo._Name;
    std::ostringstream order_number(std::ios_base::out);
    order_number << "<" << dap_item.second->_ModuleInfo._OrderNumber << ">";

    new ItemPnIDSelectValue(m_attrnav, module_name.c_str(), order_number.str(), dap_item.first.c_str(),
                            &m_attrnav->pn_runtime_data->m_PnDevice->m_DAP_ID, m_node, flow_eDest_IntoLast,
                            dap_item.second->_ModuleInfo._InfoText->c_str());
  }

  return 1;
}

int ItemPnDAPSelection::scan(GsdmlAttrNav* attrnav, void* value_p)
{

  // Note, first scan is set the two first scans to detect load from data file
  if (!m_first_scan)
  {
    if (m_old_value == *(std::string*)value_p)
      // No change since last time
      return 1;
  }

  if (attrnav->device_confirm_active)
    return 1;

  if (!m_first_scan)
  {
    if (m_old_value == "")
    {
      // When we go from nothing we skip the check...
      GsdmlAttrNav::device_changed_ok(attrnav, (void*)&m_old_value);
      return 1;
    }
    else
    {
      if (GsdmlAttrNav::device_check_change_ok(attrnav))
      {
        GsdmlAttrNav::device_changed_ok(attrnav, (void*)&m_old_value);
        return 1;
      }
      else
      {
        attrnav->m_wow->DisplayQuestion(attrnav, "Device Changed",
                                        "All configuration data will be lost when changing the device.\n"
                                        "Do you really want to change the device ?",
                                        GsdmlAttrNav::device_change_reset_ok,
                                        GsdmlAttrNav::device_changed_cancel, (void*)&m_old_value);
        attrnav->device_confirm_active = 1;
        return 1;
      }
    }
  }

  std::string annotation;
  auto dap_item = attrnav->m_selected_device_item;

  if (*(std::string*)value_p == "")
    annotation = "None";
  else
  {
    std::ostringstream dap_item_display_text(*dap_item->_ModuleInfo._Name, std::ios_base::ate);
    dap_item_display_text << " (" << dap_item->_ModuleInfo._OrderNumber << ")";

    annotation = dap_item_display_text.str();
  }

  brow_SetAnnotation(m_node, 1, annotation.c_str(), annotation.length());

  m_old_value = attrnav->pn_runtime_data->m_PnDevice->m_DAP_ID;

  if (m_first_scan)
    m_first_scan = 0;

  return 1;
}

ItemPnSlot::ItemPnSlot(GsdmlAttrNav* attrnav, const char* name, ProfinetSlot* slot_data, brow_tNode dest,
                       flow_eDest dest_code, const char* infotext)
    : ItemPn(attrnav,
             attrnav_mItemType_Parent | attrnav_mItemType_ExpandForSave | attrnav_mItemType_Copyable |
                 attrnav_mItemType_Movable,
             name, infotext),
      m_slot_data(slot_data)
{
  m_closed_annotation = attrnav->brow->pixmap_map;

  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);
  brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_map);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());

  // Attach a module if we have some data available in our ID
  if (m_slot_data->m_module_ID != "")
  {
    // Try to attach the module
    try
    {
      attach_module(m_attrnav->gsdml->getModuleMap().at(m_slot_data->m_module_ID));

      // We also need to check if this is fixed or not since it affects the "look n
      // feel" of this slot
      if (m_attrnav->m_selected_device_item->_UseableModules.at(m_slot_data->m_module_ID)
              ->_FixedInSlots.inList(m_slot_data->m_slot_number))
      {
        m_is_fixed = true;
      }
    }
    catch (std::out_of_range& oor)
    {
      std::cerr << "Module ID (" << m_slot_data->m_module_ID
                << ") not found in the ModuleList of the GSDML! Reset of slot " << m_slot_data->m_slot_number
                << std::endl;
      attach_module(nullptr, true); // Reset the whole slot!
    }
  }

  // We have no attached module
  if (!m_attached_module_item)
  {
    // Setup
    // First check if this slot has a module that is fixed to it.
    for (auto const& module_item_ref : m_attrnav->m_selected_device_item->_UseableModules)
    {
      if (!module_item_ref.second->_FixedInSlots.empty())
      {
        if (module_item_ref.second->_FixedInSlots.inList(m_slot_data->m_slot_number))
        { // We have a fixed module, attach it...
          m_is_fixed = true;
          attach_module(module_item_ref.second->_ModuleItemTarget);
        }
      }
    }
  }
  else // We already have data...TODO Should we check it??
  {
    // Noop atm
  }

  if (m_attached_module_item)
  {
    if (m_attached_module_item->_ModuleInfo._Name)
    {
      brow_SetAnnotation(m_node, 1, m_attached_module_item->_ModuleInfo._Name->c_str(),
                         m_attached_module_item->_ModuleInfo._Name->length());
    }
  }
}

int ItemPnSlot::open_children_impl()
{
  if (!m_is_fixed)
    new ItemPnModuleSelection(
        m_attrnav, "Module Selection", m_slot_data, &m_slot_data->m_module_ID, m_node, flow_eDest_IntoLast,
        "Select what module to put in this slot.\n Changing the module to something not directly compatible "
        "with the current channel configuration will result in incompatible data areas. The reason is "
        "because ProviewR will not delete any channels for you (except when changing module class). This is "
        "for your sake, to not loose channel connection information. Move your channels elsewhere or delete "
        "them before applying this new configuration and ProviewR will happily create them for you.");

  if (m_attached_module_item)
  {
    // Let's create shorthand versions for readability
    auto module = m_attached_module_item;

    // This is used by ProviewR to "populate" the modules with data containers such as channel objects and
    // such
    new ItemPnModuleClass(m_attrnav, "Module Class", &m_slot_data->m_module_class, m_node,
                          flow_eDest_IntoLast);

    // Display information
    new ItemPnModuleInfo(m_attrnav, "ModuleInfo", &module->_ModuleInfo, m_node, flow_eDest_IntoLast,
                         "Module information.");

    // First we create the virtual submodules if any (usually at least one...)
    // The virtual submodules start at subslot 1. And ISO 15745-4 says that
    // there must not be more than 1 virtual submodule item. But standards
    // change so we might as well loop through it since the name does imply a
    // list :) Who knows...
    size_t subslot_number = 1;
    for (auto const& virtual_submodule_item : module->_VirtualSubmoduleList)
    {
      std::ostringstream subslot_name("Subslot ", std::ios_base::ate);
      subslot_name << subslot_number << " (" << *virtual_submodule_item.second->_ModuleInfo._Name << ")";

      new ItemPnSubslot(m_attrnav, subslot_name.str().c_str(), m_slot_data,
                        &m_slot_data->m_subslot_map[subslot_number], module, subslot_number,
                        virtual_submodule_item.second, m_node, flow_eDest_IntoLast,
                        "Virtual submodule of this module/DAP.");

      subslot_number++;
    }

    // If we have physical subslots add those extra subslots. This is schema
    // >= 2.1
    // TODO Check what to use, The subslot list or the physical subslot attribute...
    if (!module->_PhysicalSubslots.empty())
    {
      for (auto it = module->_PhysicalSubslots.begin(); it != module->_PhysicalSubslots.end(); ++it)
      {
        std::ostringstream subslot_name("Subslot ", std::ios_base::ate);
        subslot_name << it.value();

        new ItemPnSubslot(m_attrnav, subslot_name.str().c_str(), m_slot_data,
                          &m_slot_data->m_subslot_map[it.value()], module, it.value(), nullptr, m_node,
                          flow_eDest_IntoLast, "Subslot from the modules physical subslot list.");
      }
    }
  }

  return 1;
}

void ItemPnSlot::attach_module(std::shared_ptr<GSDML::ModuleItem> module, bool reset_subslots)
{
  if (module)
  {
    m_attached_module_item = module;
    m_slot_data->m_module_ID = module->_ID;
    m_slot_data->m_module_ident_number = module->_ModuleIdentNumber;
  }
  else
  {
    m_attached_module_item.reset();
    m_slot_data->m_module_ID = "";
    m_slot_data->m_module_ident_number = 0;
    m_slot_data->m_module_class = 0;
  }

  // TODO Should we update API here aswell???

  // This might get called from a module selection so we make sure we start from
  // a clean slate. These call set the reset_subslots of course ...
  if (reset_subslots)
    m_slot_data->m_subslot_map.clear(); // Delete all subslot data. Destructors in ProfinetDataRecord
                                        // class will free data record data
}

ItemPnSubslot::ItemPnSubslot(GsdmlAttrNav* attrnav, const char* name, ProfinetSlot* parent_slot_data,
                             ProfinetSubslot* subslot_data,
                             std::shared_ptr<GSDML::ModuleItem> parent_module_item, uint subslot_number,
                             std::shared_ptr<GSDML::SubmoduleItem> attached_submodule_item, brow_tNode dest,
                             flow_eDest dest_code, const char* infotext)
    : ItemPn(attrnav, attrnav_mItemType_Parent | attrnav_mItemType_ExpandForSave, name, infotext, 1),
      m_parent_slot_data(parent_slot_data), m_subslot_data(subslot_data),
      m_parent_module_item(parent_module_item), m_subslot_number(subslot_number), m_is_selectable(false),
      m_attached_submodule_item(attached_submodule_item)
{
  m_closed_annotation = attrnav->brow->pixmap_map;
  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);

  // Always set our subslot_number
  subslot_data->m_subslot_number = m_subslot_number;

  if (attached_submodule_item)
    attach_submodule(attached_submodule_item);

  // Setup if not directly attached with constructor argument
  // "attached_submodule_item"
  if (!m_attached_submodule_item)
  {
    // Do we belong in a DAP?
    if (m_parent_module_item->_ModuleItemType == GSDML::ModuleItemType_DAP)
    {
      auto parent = std::static_pointer_cast<GSDML::DeviceAccessPointItem>(m_parent_module_item);

      // Check system defined submodule list to see if this slot is "defined by
      // the system"
      for (auto const& submodule : parent->_SystemDefinedSubmoduleList)
      {
        if (submodule.second->_SubslotNumber == m_subslot_number)
        {
          attach_submodule(submodule.second);
          break;
        }
      }
    }

    // We still have no attached submodule item
    if (!m_attached_submodule_item)
    {
      /*
        Should we load default values or from already read data
      */
      for (auto const& submodule_item_ref : m_parent_module_item->_UseableSubmodules)
      {
        if (submodule_item_ref.second->_AllowedInSubslots.inList(m_subslot_number))
        {
          // First check if this is a fixed subslot
          if (!submodule_item_ref.second->_FixedInSubslots.empty() &&
              submodule_item_ref.second->_FixedInSubslots.inList(m_subslot_number))
          {
            attach_submodule(submodule_item_ref.second->_SubmoduleItemTarget);
            m_is_selectable = false;
            break;
          }

          // If we have no data already selected pick the default subslot from the
          // start
          if (m_subslot_data->m_submodule_ID == "")
          {
            if (!submodule_item_ref.second->_UsedInSubslots.empty() &&
                submodule_item_ref.second->_UsedInSubslots.inList(m_subslot_number))
            {
              attach_submodule(submodule_item_ref.second->_SubmoduleItemTarget);
            }
          }
          else
          {
            // Load matching ID, if this data is wrong (maybe the GSDML file
            // actually changed between versions even though it shouldn't) Nothing
            // is pre loaded and one have to choose making the user aware...
            if (submodule_item_ref.first == m_subslot_data->m_submodule_ID)
            {
              attach_submodule(submodule_item_ref.second->_SubmoduleItemTarget);
              // m_attached_submodule_item = submodule_item.second->_SubmoduleItemTarget;
            }
          }

          m_is_selectable = true;
        }
      }
    }
  }

  // Okay so we have something attached, set annotations for some subslots
  if (m_attached_submodule_item)
  {
    if (m_attached_submodule_item->_ModuleInfo._Name)
      brow_SetAnnotation(m_node, 1, m_attached_submodule_item->_ModuleInfo._Name->c_str(),
                         m_attached_submodule_item->_ModuleInfo._Name->length());
  }

  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
}

uint ItemPnSubslot::calculate_input_length(GSDML::Input const* input)
{
  uint input_length = 0;
  for (auto const& data_item : input->_DataItem)
  {
    // All data items have this attribute, it's calculated from datatype if missing when parsing...
    if (data_item._Length)
    {
      input_length += data_item._Length;
    }
    else
    {
      std::cerr << "Warning: 0 length data item. Unhandled datatype or Length attribute missing..."
                << std::endl;
    }
  }
  return input_length;
}

uint ItemPnSubslot::calculate_output_length(GSDML::Output const* output)
{
  uint output_length = 0;
  for (auto const& data_item : output->_DataItem)
  {
    // All data items have this attribute, it's calculated from datatype if missing when parsing...
    if (data_item._Length)
    {
      output_length += data_item._Length;
    }
    else
    {
      std::cerr << "Warning: 0 length data item. Unhandled datatype or Length attribute missing..."
                << std::endl;
    }
  }
  return output_length;
}

int ItemPnSubslot::open_children_impl()
{
  // This is a subslot in which you can select different submodules
  if (m_is_selectable)
  {
    new ItemPnSubmoduleSelection(m_attrnav, "Submodule Selection", m_parent_module_item, m_subslot_data,
                                 &m_subslot_data->m_submodule_ID, m_node, flow_eDest_IntoLast,
                                 "Select a submodule to go into this subslot...");
  }

  // Do we have an attached submodule in this slot?
  if (m_attached_submodule_item)
  {
    switch (m_attached_submodule_item->_SubmoduleItemType)
    {
    case GSDML::SubmoduleItemType_Virtual:
    case GSDML::SubmoduleItemType_Submodule:
    {
      // IOData
      if (m_attrnav->viewio && m_attached_submodule_item->_IOData.has_data())
      {
        new ItemPnIOData(m_attrnav, "IOData", &m_attached_submodule_item->_IOData, m_subslot_data, m_node,
                         flow_eDest_IntoLast, "IO Data for this submodule.");
      }

      // RecordDataList
      // Loop through and add the data
      for (auto const& record_data : m_attached_submodule_item->_RecordDataList)
      {
        // Skip if we already have this data loaded/initialized
        // count returns either 1 or 0 depending on if key exists
        if (m_subslot_data->m_data_record_map.count(record_data._Index) <= 0)
        {
          m_subslot_data->m_data_record_map.emplace(record_data._Index, ProfinetDataRecord());
        }

        ProfinetDataRecord* pdr = &m_subslot_data->m_data_record_map.at(record_data._Index);
        new ItemPnParameterRecordDataItem(m_attrnav, record_data._Name->c_str(), &record_data, pdr, m_node,
                                          flow_eDest_IntoLast,
                                          "A block of configurable parameters for the module.");
      }
      break;
    }
    case GSDML::SubmoduleItemType_Port:
      display_port_submodule();
      break;
    case GSDML::SubmoduleItemType_Interface:
      display_interface_submodule();
      break;
    default:
      std::cerr << "Unknown submodule in  ItemPnSubslot::open_children_impl()" << std::endl;
    }
  }
  // This is a subslot with no attached submodule
  else
  {
    // Perfectly fine... Nothing to do...
  }

  return 1;
}

void ItemPnSubslot::display_port_submodule()
{
  // Display information and settings for a port submodule
  auto port_submodule = std::static_pointer_cast<GSDML::PortSubmoduleItem>(m_attached_submodule_item);

  if (port_submodule->_MaxPortRxDelay)
  {
    new ItemPnInfo(m_attrnav, "MaxPortRxDelay", "LocalGsdmlAttr", pwr_eType_UInt16, 0,
                   &port_submodule->_MaxPortRxDelay, m_node, flow_eDest_IntoLast, "");
  }

  if (port_submodule->_MaxPortRxDelay)
  {
    new ItemPnInfo(m_attrnav, "MaxPortTxDelay", "LocalGsdmlAttr", pwr_eType_UInt16, 0,
                   &port_submodule->_MaxPortTxDelay, m_node, flow_eDest_IntoLast, "");
  }

  if (!port_submodule->_LinkStateDiagnosisCapability.empty())
  {
    new ItemPnInfo(m_attrnav, "LinkStateDiagnosisCapability", "LocalGsdmlAttr", pwr_eType_String,
                   port_submodule->_LinkStateDiagnosisCapability.length(),
                   &port_submodule->_LinkStateDiagnosisCapability, m_node, flow_eDest_IntoLast, "");
  }

  new ItemPnInfo(m_attrnav, "PortDeactivationSupported", "LocalGsdmlAttr", pwr_eType_Boolean, 0,
                 &port_submodule->_PortDeactivationSupported, m_node, flow_eDest_IntoLast, "");

  if (port_submodule->_MAUTypes)
  {
    new ItemPnInfo(m_attrnav, "MAUTypes", "LocalGsdmlAttr", pwr_eType_UInt16, 0, &port_submodule->_MAUTypes,
                   m_node, flow_eDest_IntoLast, "");
  }

  new ItemPnInfo(m_attrnav, "CheckMAUTypeSupported", "LocalGsdmlAttr", pwr_eType_Boolean, 0,
                 &port_submodule->_CheckMAUTypeSupported, m_node, flow_eDest_IntoLast, "");

  new ItemPnInfo(m_attrnav, "CheckMAUTypeDifferenceSupported", "LocalGsdmlAttr", pwr_eType_Boolean, 0,
                 &port_submodule->_CheckMAUTypeDifferenceSupported, m_node, flow_eDest_IntoLast, "");

  new ItemPnInfo(m_attrnav, "SupportsRingportConfig", "LocalGsdmlAttr", pwr_eType_Boolean, 0,
                 &port_submodule->_SupportsRingportConfig, m_node, flow_eDest_IntoLast, "");

  new ItemPnInfo(m_attrnav, "IsDefaultRingport", "LocalGsdmlAttr", pwr_eType_Boolean, 0,
                 &port_submodule->_IsDefaultRingport, m_node, flow_eDest_IntoLast, "");

  if (!port_submodule->_Writeable_IM_Records.empty())
  {
    new ItemPnInfo(m_attrnav, "Writeable_IM_Records", "LocalGsdmlAttr", pwr_eType_String,
                   port_submodule->_Writeable_IM_Records.as_string().length(),
                   &port_submodule->_Writeable_IM_Records.as_string(), m_node, flow_eDest_IntoLast, "");
  }
}

void ItemPnSubslot::display_interface_submodule()
{
  // Display information and settings for a port submodule
  auto interface_submodule =
      std::static_pointer_cast<GSDML::InterfaceSubmoduleItem>(m_attached_submodule_item);

  // TODO Add lots of info...
}

void ItemPnSubslot::attach_submodule(std::shared_ptr<GSDML::SubmoduleItem> submodule)
{
  if (submodule)
  {
    m_attached_submodule_item = submodule;
    m_subslot_data->m_submodule_ID = submodule->_ID;
    m_subslot_data->m_submodule_ident_number = submodule->_SubmoduleIdentNumber;

    m_subslot_data->m_io_input_length = calculate_input_length(&m_attached_submodule_item->_IOData._Input);
    m_subslot_data->m_io_output_length = calculate_output_length(&m_attached_submodule_item->_IOData._Output);
  }
  else
  {
    m_attached_submodule_item.reset();
    m_subslot_data->m_submodule_ID = "";
    m_subslot_data->m_submodule_ident_number = 0;
    m_subslot_data->m_data_record_map.clear();
    m_subslot_data->m_io_input_length = 0;
    m_subslot_data->m_io_output_length = 0;
  }
}

ItemPnDAP::ItemPnDAP(GsdmlAttrNav* attrnav, const char* name, ProfinetSlot* item_slotdata, brow_tNode dest,
                     flow_eDest dest_code, const char* infotext)
    : ItemPn(attrnav, attrnav_mItemType_Parent | attrnav_mItemType_ExpandForSave, name, infotext, 1),
      m_slot_data(item_slotdata)
{
  m_closed_annotation = attrnav->brow->pixmap_map;
  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_object, dest, dest_code, (void*)this,
                  1, &m_node);

  brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_map);

  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
}

int ItemPnDAP::open_children_impl()
{
  // If this is created we do have a DAP selected but we check anyways...
  if (m_attrnav->m_selected_device_item)
  {
    // Let's create shorthand versions for readability
    auto dap = m_attrnav->m_selected_device_item;
    auto ppd = m_attrnav->pn_runtime_data->m_PnDevice; // ( pwr_pn_data == ppd :D )

    // Display information
    new ItemPnModuleInfo(m_attrnav, "ModuleInfo", &dap->_ModuleInfo, m_node, flow_eDest_IntoLast,
                         "Module information.");

    // First we create the virtual submodules if any (usually at least one...)
    // The virtual submodules start at subslot 1. And ISO 15745-4 says that
    // there must not be more than 1 virtual submodule item. But standards
    // change so we might as well loop through it since the name does imply a
    // list :) Who knows...
    size_t subslot_number = 1;
    for (auto const& virtual_submodule_item : dap->_VirtualSubmoduleList)
    {
      std::ostringstream subslot_name("Subslot ", std::ios_base::ate);
      subslot_name << subslot_number << " (" << *virtual_submodule_item.second->_ModuleInfo._Name << ")";

      new ItemPnSubslot(m_attrnav, subslot_name.str().c_str(), m_slot_data,
                        &m_slot_data->m_subslot_map[subslot_number], dap, subslot_number,
                        virtual_submodule_item.second, m_node, flow_eDest_IntoLast,
                        "Virtual submodule of this module/DAP.");

      subslot_number++;
    }

    if (dap->_SystemDefinedSubmoduleList.size() > 0) // Do we have a systemdefined subslot list?
    {
      for (auto const& submodule : dap->_SystemDefinedSubmoduleList)
      {
        std::ostringstream subslot_name("Subslot ", std::ios_base::ate);
        subslot_name << submodule.second->_SubslotNumber << " (" << *submodule.second->_Text << ")";

        new ItemPnSubslot(m_attrnav, subslot_name.str().c_str(), m_slot_data,
                          &m_slot_data->m_subslot_map[submodule.second->_SubslotNumber], dap,
                          submodule.second->_SubslotNumber, nullptr, m_node, flow_eDest_IntoLast,
                          "System defined subslot");
      }
    }

    // If we have physical subslots, we add them. If we don't we should have the rest in the systemdefined
    // list
    if (!dap->_PhysicalSubslots.empty())
    {
      for (auto it = dap->_PhysicalSubslots.begin(); it != dap->_PhysicalSubslots.end(); ++it)
      {
        std::ostringstream subslot_name("Subslot ", std::ios_base::ate);
        subslot_name << it.value();

        new ItemPnSubslot(m_attrnav, subslot_name.str().c_str(), m_slot_data,
                          &m_slot_data->m_subslot_map[it.value()], dap, it.value(), nullptr, m_node,
                          flow_eDest_IntoLast, "Physical subslot of the DAP.");
      }
    }

    // Add timing properties
    new ItemPnTimingProperties(m_attrnav, "Timing Properties", dap, m_node, flow_eDest_IntoLast);
  }

  return 1;
}

ItemPnNetwork::ItemPnNetwork(GsdmlAttrNav* attrnav, const char* name, brow_tNode dest, flow_eDest dest_code,
                             const char* infotext)
    : ItemPn(attrnav, attrnav_mItemType_Parent, name,
             "Network settings. Do note that it's not necessary to set the MAC "
             "address. Only do this if you know what you're doing and why you "
             "are doing it. If the latter is unknown then leave it be.",
             1)
{
  m_closed_annotation = attrnav->brow->pixmap_map;

  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_object, dest, dest_code, (void*)this,
                  1, &m_node);
  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
}

int ItemPnNetwork::open_children_impl()
{
  ProfinetNetworkSettings& network_settings = m_attrnav->pn_runtime_data->m_PnDevice->m_NetworkSettings;

  new ItemPnDeviceNameInput(m_attrnav, "Device Name", &network_settings.m_device_name,
                            "Device name. Adhere to standard hostname naming policies (RFC 1123). "
                            "For clarity one could use the hostname followed by a hyphen (-) and "
                            "then the device name. Example: mnutv-et200sp1",
                            m_node, flow_eDest_IntoLast);
  new ItemPnIPv4Input(m_attrnav, "IP Address", &network_settings.m_ip_address, "Example: 192.168.90.1",
                      m_node, flow_eDest_IntoLast);
  new ItemPnIPv4Input(m_attrnav, "Subnet Mask", &network_settings.m_subnet_mask, "Example: 255.255.255.0",
                      m_node, flow_eDest_IntoLast);
  new ItemPnMACInput(m_attrnav, "MAC Address", &network_settings.m_mac_address,
                     "Example: aa:BB:c1:D2:34:56\nRemember that you do not, in "
                     "most cases, need to edit this. If you know for certain "
                     "that this is needed and why then go ahead.",
                     m_node, flow_eDest_IntoLast);
  new ItemPnSkipIPAssignment(m_attrnav, "Skip IP Assignment", &network_settings.m_skip_ip_assignment, m_node,
                             flow_eDest_IntoLast);

  return 1;
}

ItemPnDeviceInfo::ItemPnDeviceInfo(GsdmlAttrNav* attrnav, const char* name, brow_tNode dest,
                                   flow_eDest dest_code, const char* infotext)
    : ItemPn(attrnav, attrnav_mItemType_Parent, name, "Show information about this device family.", 1)
{
  m_closed_annotation = attrnav->brow->pixmap_map;
  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_object, dest, dest_code, (void*)this,
                  1, &m_node);
  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
}

int ItemPnDeviceInfo::open_children_impl()
{
  new ItemPnInfo(m_attrnav, "Vendor", "LocalGsdmlAttr", pwr_eType_String,
                 m_attrnav->gsdml->m_DeviceIdentity->_VendorName.length(),
                 &m_attrnav->gsdml->m_DeviceIdentity->_VendorName, m_node, flow_eDest_IntoLast, "");
  new ItemPnInfo(m_attrnav, "VendorID", "LocalGsdmlAttr", pwr_eType_UInt32, 0,
                 &m_attrnav->gsdml->m_DeviceIdentity->_VendorID, m_node, flow_eDest_IntoLast, "");
  new ItemPnInfo(m_attrnav, "Info", "LocalGsdmlAttr", pwr_eType_String,
                 m_attrnav->gsdml->m_DeviceIdentity->_InfoText->length(),
                 &(*m_attrnav->gsdml->m_DeviceIdentity->_InfoText), m_node, flow_eDest_IntoLast, "");
  new ItemPnInfo(m_attrnav, "DeviceID", "LocalGsdmlAttr", pwr_eType_UInt32, 0,
                 &m_attrnav->gsdml->m_DeviceIdentity->_DeviceID, m_node, flow_eDest_IntoLast, "");
  new ItemPnInfo(m_attrnav, "MainFamily", "LocalGsdmlAttr", pwr_eType_String,
                 m_attrnav->gsdml->m_DeviceFunction->_MainFamily.length(),
                 &m_attrnav->gsdml->m_DeviceFunction->_MainFamily, m_node, flow_eDest_IntoLast, "");
  new ItemPnInfo(m_attrnav, "ProductFamily", "LocalGsdmlAttr", pwr_eType_String,
                 m_attrnav->gsdml->m_DeviceFunction->_ProductFamily.length(),
                 &m_attrnav->gsdml->m_DeviceFunction->_ProductFamily, m_node, flow_eDest_IntoLast, "");
  return 1;
}

ItemPnModuleInfo::ItemPnModuleInfo(GsdmlAttrNav* attrnav, const char* name, GSDML::ModuleInfo* item_info,
                                   brow_tNode dest, flow_eDest dest_code, const char* infotext)
    : ItemPn(attrnav, attrnav_mItemType_Parent, name, infotext, 1), m_module_info(item_info)
{
  m_closed_annotation = attrnav->brow->pixmap_map;
  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_object, dest, dest_code, (void*)this,
                  1, &m_node);

  brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_map);

  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
}

int ItemPnModuleInfo::open_children_impl()
{

  if (m_module_info->_Name->length())
    new ItemPnInfo(m_attrnav, "Name", "LocalGsdmlAttr", pwr_eType_String, m_module_info->_Name->length(),
                   &(*m_module_info->_Name), m_node, flow_eDest_IntoLast, "");
  if (m_module_info->_VendorName.length())
    new ItemPnInfo(m_attrnav, "VendorName", "LocalGsdmlAttr", pwr_eType_String,
                   m_module_info->_VendorName.length(), &m_module_info->_VendorName, m_node,
                   flow_eDest_IntoLast, "");
  if (m_module_info->_OrderNumber.length())
    new ItemPnInfo(m_attrnav, "OrderNumber", "LocalGsdmlAttr", pwr_eType_String,
                   m_module_info->_OrderNumber.length(), &m_module_info->_OrderNumber, m_node,
                   flow_eDest_IntoLast, "");
  if (m_module_info->_HardwareRelease.length())
    new ItemPnInfo(m_attrnav, "HardwareRelease", "LocalGsdmlAttr", pwr_eType_String,
                   m_module_info->_HardwareRelease.length(), &m_module_info->_HardwareRelease, m_node,
                   flow_eDest_IntoLast, "");
  if (m_module_info->_SoftwareRelease.length())
    new ItemPnInfo(m_attrnav, "SoftwareRelease", "LocalGsdmlAttr", pwr_eType_String,
                   m_module_info->_SoftwareRelease.length(), &m_module_info->_SoftwareRelease, m_node,
                   flow_eDest_IntoLast, "");

  return 1;
}

ItemPnParameterRecordDataItem::ItemPnParameterRecordDataItem(
    GsdmlAttrNav* attrnav, const char* name, GSDML::ParameterRecordDataItem const* parameter_record_data_item,
    ProfinetDataRecord* data_record, brow_tNode dest, flow_eDest dest_code, const char* infotext)
    : ItemPn(attrnav, attrnav_mItemType_Parent, name, infotext),
      m_parameter_record_data_item(parameter_record_data_item), m_data_record(data_record)
{
  m_closed_annotation = attrnav->brow->pixmap_map;
  if (m_parameter_record_data_item->_Ref.size())
    m_is_parent = 1;

  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);

  if (m_is_parent)
    brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_map);
  else
    brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_leaf);

  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());

  // Inititalize the parameter record
  // create convienence pointers for readability
  auto prdi = m_parameter_record_data_item;
  bool empty_state = false;

  if (m_data_record->m_data_length == 0 && prdi->_Length > 0)
  {
    empty_state = true;
    // We come from an empty state, initialize the data, the data will be free'd
    // by the container class
    m_data_record->m_data = new unsigned char[prdi->_Length](); // () at the end zero initializes
                                                                // the vector
    m_data_record->m_data_length = prdi->_Length;
    m_data_record->m_index = prdi->_Index;
    m_data_record->m_transfer_sequence = prdi->_TransferSequence;
  }

  // Now read all Const data if we come from an empty state. And fill our data
  // container accordingly The getData() function returns a pointer to all the
  // data from all the Const items.
  if (empty_state)
  {
    memcpy(m_data_record->m_data, prdi->getData(), prdi->_Length);

    /*
      Fetch all the default values. It's weird how they implemented this stuff
      like this. Wouldn't it be easier to just let the Const data actually BE
      the default. Instead the defaults are in the Refs, and sometimes even
      contradicting what the Const says....super weird....
      ET200S Example:
      <Const Data="0x04,0x01,0x00,0x00,0x03,0x02,0x02" ByteOffset="0"/>
      <Ref ValueItemTarget="Slot reference junction" DataType="BitArea"
      ByteOffset="6" BitOffset="0" BitLength="6" DefaultValue="1"
      AllowedValues="1..63" Changeable="true" Visible="true" TextId="Slot
      reference junction"/>

      Anyways...go through all the refs and set default data
    */

    set_default_data();
  }
}

void ItemPnParameterRecordDataItem::set_default_data()
{
  // TODO Fix for all remaining datatypes like time/date thingies and stuff like that...

  for (auto const& ref : m_parameter_record_data_item->_Ref)
  {
    switch (ref.second->_DataType)
    {
    case GSDML::ValueDataType_Float32:
    {
#if (pwr_dHost_byteOrder == pwr_dLittleEndian)
      *((float*)&m_data_record->m_data[ref.second->_ByteOffset]) =
          GSDML::reverse_type((float)ref.second->_DefaultValue);
#else
      *((float*)&m_data_record->m_data[ref.second->_ByteOffset]) = (float)ref.second->_DefaultValue;
#endif
      break;
    }
    case GSDML::ValueDataType_Float64:
    {
#if (pwr_dHost_byteOrder == pwr_dLittleEndian)
      *((double*)&m_data_record->m_data[ref.second->_ByteOffset]) =
          GSDML::reverse_type(ref.second->_DefaultValue);
#else
      *((double*)&m_data_record->m_data[ref.second->_ByteOffset]) = (double)ref.second->_DefaultValue;
#endif
      break;
    }
    case GSDML::ValueDataType_Bit:
    case GSDML::ValueDataType_BitArea:
    {
      // Create a mask TODO BitLength is propably default 1 if it's not
      // present...check into that in the spec
      uint8_t mask = ((1 << ref.second->_BitLength) - (ref.second->_BitLength ? 1 : 0))
                     << ref.second->_BitOffset;
      m_data_record->m_data[ref.second->_ByteOffset] &= ~mask; // Clear current value since Const data can
                                                               // actually already be present...
      m_data_record->m_data[ref.second->_ByteOffset] |= (uint8_t)ref.second->_DefaultValue
                                                        << ref.second->_BitOffset;
      break;
    }
    case GSDML::ValueDataType_Unsigned8:
    case GSDML::ValueDataType_Integer8:
    {
      m_data_record->m_data[ref.second->_ByteOffset] = (uint8_t)ref.second->_DefaultValue;
      break;
    }
    case GSDML::ValueDataType_Unsigned16:
    case GSDML::ValueDataType_Integer16:
    {
#if (pwr_dHost_byteOrder == pwr_dLittleEndian)
      *((ushort*)&m_data_record->m_data[ref.second->_ByteOffset]) =
          bswap_16((ushort)ref.second->_DefaultValue);
#else
      *((ushort*)&m_data_record->m_data[ref.second->_ByteOffset]) = (ushort)ref.second->_DefaultValue;
#endif
      break;
    }
    case GSDML::ValueDataType_Unsigned32:
    case GSDML::ValueDataType_Integer32:
    {
#if (pwr_dHost_byteOrder == pwr_dLittleEndian)
      *((uint*)&m_data_record->m_data[ref.second->_ByteOffset]) = bswap_32((uint)ref.second->_DefaultValue);
#else
      *((uint*)&m_data_record->m_data[ref.second->_ByteOffset]) = (uint)ref.second->_DefaultValue;
#endif
      break;
    }
    case GSDML::ValueDataType_Unsigned64:
    case GSDML::ValueDataType_Integer64:
    {
#if (pwr_dHost_byteOrder == pwr_dLittleEndian)
      *((ulong*)&m_data_record->m_data[ref.second->_ByteOffset]) = bswap_64((ulong)ref.second->_DefaultValue);
#else
      *((ulong*)&m_data_record->m_data[ref.second->_ByteOffset]) = (ulong)ref.second->_DefaultValue;
#endif
      break;
    }
    case GSDML::ValueDataType_VisibleString:
    {
      memcpy((char*)&m_data_record->m_data[ref.second->_ByteOffset], ref.second->_DefaultValueString.c_str(),
             ref.second->_DefaultValueString.length());
      break;
    }
    default:
      printf("Unhandeled ValueDataType in ItemPnParRecord::set_default_data(): "
             "%d\n",
             (int)ref.second->_DefaultValue);
    }
  }
}

int ItemPnParameterRecordDataItem::open_children_impl()
{
  // Once here we have either saved data or data from the Const elements (not
  // to mix up with default values since they are in the Ref's). But the default
  // values should be loaded by now if we come from an empty state. Now we map
  // each Ref to the respective data. And the conf is network byte ordered

  for (auto const& ref : m_parameter_record_data_item->_Ref)
  {
    // Set a name for this ref, the ref must have a TextId according to spec
    std::string node_name = *ref.second->_Text;

    // Create a parameter node only if it's visible
    if (ref.second->_Visible)
    {
      create_parameter_value_class(m_attrnav, node_name.c_str(), ref.second, m_data_record->m_data, m_node);
    }
  }
  return 1;
}

ItemPnIOData::ItemPnIOData(GsdmlAttrNav* attrnav, const char* name, GSDML::IOData* iodata,
                           ProfinetSubslot* subslot, brow_tNode dest, flow_eDest dest_code,
                           const char* infotext)
    : ItemPn(attrnav, attrnav_mItemType_Parent, name, infotext), m_iodata(iodata), m_subslot(subslot)
{
  if (m_iodata->_Input._DataItem.size() || m_iodata->_Output._DataItem.size())
    m_closed_annotation = attrnav->brow->pixmap_map;

  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);
  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
}

int ItemPnIOData::open_children_impl()
{
  if (m_iodata->_Input._DataItem.size())
  {
    new ItemPnInput(m_attrnav, "Input", &m_iodata->_Input, m_node, flow_eDest_IntoLast);
  }
  if (m_iodata->_Output._DataItem.size())
  {
    new ItemPnOutput(m_attrnav, "Output", &m_iodata->_Output, m_node, flow_eDest_IntoLast);
  }

  return 1;
}

ItemPnInput::ItemPnInput(GsdmlAttrNav* attrnav, const char* name, GSDML::Input const* input, brow_tNode dest,
                         flow_eDest dest_code)
    : ItemPn(attrnav, attrnav_mItemType_Parent, name, "Infotext Input"), m_input(input)
{
  if (input->_DataItem.size())
    m_closed_annotation = attrnav->brow->pixmap_map;

  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);
  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
}

int ItemPnInput::open_children_impl()
{
  for (auto const& data_item : m_input->_DataItem)
  {
    new ItemPnDataItem(m_attrnav, data_item._Text->c_str(), &data_item, m_node, flow_eDest_IntoLast);
  }
  return 1;
}

ItemPnOutput::ItemPnOutput(GsdmlAttrNav* attrnav, const char* name, GSDML::Output const* output,
                           brow_tNode dest, flow_eDest dest_code)
    : ItemPn(attrnav, attrnav_mItemType_Parent, name, "Infotext Output"), m_output(output)
{
  if (output->_DataItem.size())
    m_closed_annotation = attrnav->brow->pixmap_map;

  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);
  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
}

int ItemPnOutput::open_children_impl()
{
  for (auto const& data_item : m_output->_DataItem)
  {
    new ItemPnDataItem(m_attrnav, data_item._Text->c_str(), &data_item, m_node, flow_eDest_IntoLast);
  }
  return 1;
}

ItemPnDataItem::ItemPnDataItem(GsdmlAttrNav* attrnav, const char* name, GSDML::DataItem const* data_item,
                               brow_tNode dest, flow_eDest dest_code)
    : ItemPn(attrnav, attrnav_mItemType_Parent, name, "Data I/O"), m_data_item(data_item)
{
  if (m_data_item->_UseAsBits)
  {
    if (m_data_item->_BitDataItem.size())
    {
      m_closed_annotation = attrnav->brow->pixmap_map;
    }
    else
    {
      m_closed_annotation = attrnav->brow->pixmap_leaf;
      m_type &= ~attrnav_mItemType_Parent; // Remove parent bit
    }
  }
  else
  {
    m_closed_annotation = attrnav->brow->pixmap_leaf;
    m_type &= ~attrnav_mItemType_Parent; // Remove parent bit
  }

  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);

  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);

  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());

  std::ostringstream annotation(m_data_item->_DataTypeString, std::ios_base::ate);

  if (m_data_item->_DataType == GSDML::ValueDataType_OctetString)
  {
    annotation << " (" << m_data_item->_Length << " octets)";
    brow_SetAnnotation(m_node, 1, annotation.str().c_str(), annotation.str().length());
  }
  else
  {
    if (m_data_item->_UseAsBits && !m_data_item->_BitDataItem.size())
    {
      annotation << " (Implicitly as bits)";
    }

    brow_SetAnnotation(m_node, 1, annotation.str().c_str(), annotation.str().length());
  }
}

int ItemPnDataItem::open_children_impl()
{
  if (m_data_item->_UseAsBits && m_data_item->_BitDataItem.size())
  {
    for (auto const& bit_data_item : m_data_item->_BitDataItem)
    {
      new ItemPnBitDataItem(m_attrnav, bit_data_item._Text->c_str(), bit_data_item._BitOffset, m_node,
                            flow_eDest_IntoLast);
    }
  }

  return 1;
}

ItemPnBitDataItem::ItemPnBitDataItem(GsdmlAttrNav* attrnav, const char* name, ushort bit_offset,
                                     brow_tNode dest, flow_eDest dest_code)
    : ItemPn(attrnav, attrnav_mItemType_, name, "Infotext ItemPnBitDataItem")
{
  m_closed_annotation = attrnav->brow->pixmap_leaf;
  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);
  brow_SetAnnotPixmap(m_node, 0, m_closed_annotation);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
  std::string bit_offset_string = std::to_string(bit_offset);
  brow_SetAnnotation(m_node, 1, bit_offset_string.c_str(), bit_offset_string.length());
}

/* ======================================= Menu node ======================================= */
ItemPnMenu::ItemPnMenu(GsdmlAttrNav* attrnav, std::string const& category_name, std::string const& infotext,
                       brow_tNode dest, flow_eDest dest_code,
                       std::multimap<std::string, std::shared_ptr<GSDML::ModuleItem>>& items,
                       ItemPnModuleSelection* parent)
    : ItemPn(attrnav, attrnav_mItemType_Parent, category_name, infotext), m_items(items), m_parent(parent)
{
  m_closed_annotation = attrnav->brow->pixmap_attrenum;
  brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest, dest_code, (void*)this, 1,
                  &m_node);

  brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_attrenum);
  brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
}

int ItemPnMenu::open_children_impl()
{
  auto range = m_items.equal_range(m_name);
  for (auto it = range.first; it != range.second; ++it)
  {
    std::string module_name = *it->second->_ModuleInfo._Name;
    std::ostringstream order_number(std::ios_base::out);
    if (it->second->_ModuleInfo._OrderNumber != "")
      order_number << "<" << it->second->_ModuleInfo._OrderNumber << ">";
    std::string infotext = *it->second->_ModuleInfo._InfoText;
    new ItemPnValueSelectItem<std::string>(m_attrnav, module_name.c_str(), order_number.str(), m_parent,
                                           &m_parent->m_slot_data->m_module_ID, it->second->_ID,
                                           infotext.c_str(), m_node, flow_eDest_IntoLast);
  }

  return 1;
}
/* ======================================= END Menu node ======================================= */

/* ======================================= Module Selection node ======================================= */

ItemPnModuleSelection::ItemPnModuleSelection(GsdmlAttrNav* attrnav, const char* name, ProfinetSlot* slot_data,
                                             std::string* id_value_p, brow_tNode dest, flow_eDest dest_code,
                                             const char* infotext)
    : ValueSelection<std::string>(attrnav, attrnav_mItemType_Parent, name, infotext, dest, dest_code,
                                  id_value_p),
      m_slot_data(slot_data)
{
  m_closed_annotation = m_attrnav->brow->pixmap_attrenum;
  setup_node();
}

int ItemPnModuleSelection::open_children_impl()
{
  // Add selection for "No Module"
  new ItemPnValueSelectItem<std::string>(m_attrnav, "No Module", "", this, &m_slot_data->m_module_ID, "",
                                         "Select to remove module from slot", m_node, flow_eDest_IntoLast);
  for (auto const& category : m_categories)
  {
    new ItemPnMenu(m_attrnav, category.first, category.second, m_node, flow_eDest_IntoLast, m_category_map,
                   this);
  }

  return 1;
}

void ItemPnModuleSelection::select(ItemPnValueSelectItem<std::string>* selected_item)
{
  // Store data (This is traced by the subslot which will detect this and close
  // itself just to reopen itself again to update the sendclock class)
  *m_value_p = selected_item->value();

  // We now close and reopen the parent to reset the entire tree since send
  // clock for instance is dependent on this value
  brow_tNode parent_node;
  void* parent;
  brow_GetParent(m_attrnav->brow->ctx, m_node, &parent_node);
  brow_GetUserData(parent_node, &parent);

  // Bold move but we're pretty confident what our parent actually is...
  ItemPnSlot* slot = (ItemPnSlot*)parent;

  // Check if we are attaching a (new) module or removing a module
  if (m_value_p->empty())
  {
    slot->attach_module(nullptr, true);
    brow_SetAnnotation(slot->m_node, 1, "", 0);
  }
  else
  {
    auto module = m_attrnav->gsdml->getModuleMap().at(*m_value_p);
    slot->attach_module(module, true);
    brow_SetAnnotation(slot->m_node, 1, module->_ModuleInfo._Name->c_str(),
                       module->_ModuleInfo._Name->length());
  }

  // Set this slot to modified state. Will be used to check if we should try to create channels.
  // If there's already channels present and we modify a slot the user will get a notification.
  slot->m_slot_data->m_is_modified = true;

  slot->close(m_attrnav, 0, 0, true); // Close AND reopen
}

void ItemPnModuleSelection::setup_node()
{
  m_noedit = 0; // Enable edit

  // Populate a multimap with all allowed modules and also gather all unique
  // categories (keys)
  for (auto const& module : m_attrnav->m_selected_device_item->_UseableModules)
  {
    if (module.second->_AllowedInSlots.inList(m_slot_data->m_slot_number))
    {
      if (module.second->_ModuleItemTarget->_ModuleInfo._CategoryItemText &&
          module.second->_ModuleItemTarget->_ModuleInfo._CategoryItemInfoText)
      {
        m_categories.emplace(*module.second->_ModuleItemTarget->_ModuleInfo._CategoryItemText,
                             *module.second->_ModuleItemTarget->_ModuleInfo._CategoryItemInfoText);
        m_category_map.emplace(*module.second->_ModuleItemTarget->_ModuleInfo._CategoryItemText,
                               module.second->_ModuleItemTarget);
      }
      else
      {
        // If we have no categories for our modules we place them in one big
        // happy family "Available Modules"
        m_categories.emplace("Uncategorized Modules", "Uncategorized modules that don't belong to any "
                                                      "category family...");
        m_category_map.emplace("Uncategorized Modules", module.second->_ModuleItemTarget);
      }
    }
  }

  if (*m_value_p != "")
  {
    // Fetch the name from the GSDML
    std::string name = *m_attrnav->gsdml->getModuleMap()[*m_value_p]->_ModuleInfo._Name;
    brow_SetAnnotation(m_node, 1, name.c_str(), name.length());
  }
}

void ItemPnModuleSelection::scan_impl(ItemPnValueSelectItem<std::string> const* selected_item) const
{
  // Control the radiobuttons
  if (*this->m_value_p == selected_item->value())
    brow_SetRadiobutton(selected_item->m_node, 0, 1);
  else
    brow_SetRadiobutton(selected_item->m_node, 0, 0);
}

/* ==================================== END Module Selection node ==================================== */

/* ======================================= Submodule Selection node ======================================= */

ItemPnSubmoduleSelection::ItemPnSubmoduleSelection(GsdmlAttrNav* attrnav, const char* name,
                                                   std::shared_ptr<GSDML::ModuleItem> module_item,
                                                   ProfinetSubslot* subslot_data, std::string* id_value_p,
                                                   brow_tNode dest, flow_eDest dest_code,
                                                   const char* infotext)
    : ValueSelection<std::string>(attrnav, attrnav_mItemType_Parent, name, infotext, dest, dest_code,
                                  id_value_p),
      m_module_item(module_item), m_subslot_data(subslot_data)
{
  m_closed_annotation = m_attrnav->brow->pixmap_attrenum;
  setup_node();
}

int ItemPnSubmoduleSelection::open_children_impl()
{
  // Add selection for "No Module"
  new ItemPnValueSelectItem<std::string>(m_attrnav, "No Submodule", "", this, &m_subslot_data->m_submodule_ID,
                                         "", "Select to remove the submodule from this subslot", m_node,
                                         flow_eDest_IntoLast);
  for (auto const& submodule : m_module_item->_UseableSubmodules)
  {
    std::string submodule_name = *submodule.second->_SubmoduleItemTarget->_ModuleInfo._Name;
    std::ostringstream submodule_order_number(std::ios_base::out);
    submodule_order_number << "<"
                           << (submodule.second->_SubmoduleItemTarget->_ModuleInfo._OrderNumber.empty()
                                   ? *submodule.second->_SubmoduleItemTarget->_ModuleInfo._Name
                                   : submodule.second->_SubmoduleItemTarget->_ModuleInfo._OrderNumber)
                           << ">";
    std::string infotext;
    if (submodule.second->_SubmoduleItemTarget->_ModuleInfo._InfoText)
      infotext = *submodule.second->_SubmoduleItemTarget->_ModuleInfo._InfoText;
    else
      infotext = "No further help available about this submodule...";

    if (submodule.second->_AllowedInSubslots.inList(m_subslot_data->m_subslot_number))
    {
      new ItemPnValueSelectItem<std::string>(
          m_attrnav, submodule_name.c_str(), submodule_order_number.str().c_str(), this,
          &m_subslot_data->m_submodule_ID, submodule.first, infotext.c_str(), m_node, flow_eDest_IntoLast);
    }
  }

  return 1;
}

void ItemPnSubmoduleSelection::select(ItemPnValueSelectItem<std::string>* selected_item)
{
  *m_value_p = selected_item->value();

  // We now close and reopen the parent to reset the entire tree since send
  // clock for instance is dependent on this value
  brow_tNode parent_node;
  void* parent;
  brow_GetParent(m_attrnav->brow->ctx, m_node, &parent_node);
  brow_GetUserData(parent_node, &parent);

  // Bold move but we're pretty confident what our parent actually is...
  ItemPnSubslot* subslot = (ItemPnSubslot*)parent;

  // Check if we are attaching a (new) module or removing a module
  if (m_value_p->empty())
  {
    subslot->attach_submodule(nullptr);
    brow_SetAnnotation(subslot->m_node, 1, "", 0);
  }
  else
  {
    auto submodule = m_attrnav->gsdml->getSubmoduleMap().at(*m_value_p);
    subslot->attach_submodule(submodule);
    brow_SetAnnotation(subslot->m_node, 1, submodule->_ModuleInfo._Name->c_str(),
                       submodule->_ModuleInfo._Name->length());
  }

  // Set the entire module to a modified state since we've just updated the subslot
  subslot->m_parent_slot_data->m_is_modified = true;

  subslot->close(m_attrnav, 0, 0, true); // Close AND reopen
}

void ItemPnSubmoduleSelection::setup_node()
{
  m_noedit = 0; // Enable edit

  if (*m_value_p != "")
  {
    // Fetch the name from the GSDML
    std::string name = *m_attrnav->gsdml->getSubmoduleMap()[*m_value_p]->_ModuleInfo._Name;
    brow_SetAnnotation(m_node, 1, name.c_str(), name.length());
  }
}

void ItemPnSubmoduleSelection::scan_impl(ItemPnValueSelectItem<std::string> const* selected_item) const
{
  // Control the radiobuttons
  if (*this->m_value_p == selected_item->value())
    brow_SetRadiobutton(selected_item->m_node, 0, 1);
  else
    brow_SetRadiobutton(selected_item->m_node, 0, 0);
}

/* ==================================== END Submodule Selection node ==================================== */

/* ==================================== RT_CLASS Selection node ==================================== */

ItemPnEnumRTClass::ItemPnEnumRTClass(GsdmlAttrNav* attrnav, const char* name,
                                     std::shared_ptr<GSDML::InterfaceSubmoduleItem> interface_submodule_item,
                                     std::string* pwr_pn_value_p, brow_tNode dest, flow_eDest dest_code)
    : ValueSelection<std::string>(attrnav, attrnav_mItemType_Parent, name,
                                  "Choose (from supported classes) what RT Class you "
                                  "want.\nRT_CLASS_UDP: RT over UDP/IP (Not used much "
                                  "nowadays)\nRT_CLASS_1: RT (for CC-A and CC-B)\nRT_CLASS_2: IRT (Not "
                                  "used today, deprecated)\nRT_CLASS_3: IRT (CC-C)",
                                  dest, dest_code, pwr_pn_value_p),
      m_interface_submodule_item(interface_submodule_item)
{
  m_closed_annotation = attrnav->brow->pixmap_attrenum;
  setup_node();
}

int ItemPnEnumRTClass::open_children_impl()
{
  // Create our enum values if we have more than one value to choose from :)
  if (m_interface_submodule_item && m_interface_submodule_item->_SupportedRT_Classes.getList().size() > 1)
  {
    for (auto const& rt_class : m_interface_submodule_item->_SupportedRT_Classes.getList())
    {
      new ItemPnValueSelectItem<std::string>(m_attrnav, rt_class.c_str(), "", this, m_value_p, rt_class,
                                             rt_class.c_str(), m_node, flow_eDest_IntoLast);
    }
  }
  else if (m_interface_submodule_item &&
           m_interface_submodule_item->_SupportedRT_Classes.getList().size() == 1)
  {
    auto const& rt_class = m_interface_submodule_item->_SupportedRT_Classes.getList()[0];
    new ItemPnValueSelectItem<std::string>(m_attrnav, rt_class.c_str(), "", this, m_value_p, rt_class,
                                           rt_class.c_str(), m_node, flow_eDest_IntoLast);
  }
  else
  {
    // Default if no interface submodule exists at all (older specs don't have
    // this and the default is RT_CLASS_1, regular RT)
    std::string rt_class("RT_CLASS_1");
    new ItemPnValueSelectItem<std::string>(m_attrnav, rt_class.c_str(), "", this, m_value_p, rt_class,
                                           rt_class.c_str(), m_node, flow_eDest_IntoLast);
  }

  return 1;
}

void ItemPnEnumRTClass::select(ItemPnValueSelectItem<std::string>* selected_item)
{
  // Store data (This is traced by the subslot which will detect this and close
  // itself just to reopen itself again to update the sendclock class)
  *m_value_p = selected_item->value();

  // We now close and reopen the parent to reset the entire tree since send
  // clock for instance is dependent on this value
  brow_tNode parent_node;
  void* parent;
  brow_GetParent(m_attrnav->brow->ctx, m_node, &parent_node);
  brow_GetUserData(parent_node, &parent);

  // Bold move but we're pretty confident what our parent actually is...
  ItemPnSubslot* subslot = (ItemPnSubslot*)parent;
  subslot->close(m_attrnav, 0, 0, true); // Close AND reopen
}

void ItemPnEnumRTClass::setup_node()
{
  m_noedit = 0; // Enable editing of this...

  std::string value;
  // No value set (either from read file or from earlier selections)
  if (*m_value_p == "")
  {
    if (m_interface_submodule_item->_SupportedRT_Classes.getList().size())
      value = m_interface_submodule_item->_SupportedRT_Classes.getList()[0];
    else
      value = "RT_CLASS_1";
  }
  else
  {
    value = *m_value_p;
  }

  *m_value_p = value;
  brow_SetAnnotation(m_node, 1, m_value_p->c_str(), m_value_p->length());

  // Here we set the startup mode, since it depends on RT_CLASS selection but it's not a choice, we choost
  // advanced if possible otherwise legacy...
  if (m_interface_submodule_item->_ApplicationRelations._StartupMode.getList().size())
  {
    if (m_interface_submodule_item->_ApplicationRelations._StartupMode.inList("Advanced"))
      m_attrnav->pn_runtime_data->m_PnDevice->m_IOCR_map[PROFINET_IO_CR_TYPE_INPUT].m_startup_mode =
          "Advanced";
    else
      m_attrnav->pn_runtime_data->m_PnDevice->m_IOCR_map[PROFINET_IO_CR_TYPE_INPUT].m_startup_mode = "Legacy";
  }
  else
  {
    m_attrnav->pn_runtime_data->m_PnDevice->m_IOCR_map[PROFINET_IO_CR_TYPE_INPUT].m_startup_mode = "Legacy";
  }
}

void ItemPnEnumRTClass::scan_impl(ItemPnValueSelectItem<std::string> const* selected_item) const
{
  // Control the radiobuttons
  if (*selected_item->m_value_p == selected_item->m_select_value)
    brow_SetRadiobutton(selected_item->m_node, 0, 1);
  else
    brow_SetRadiobutton(selected_item->m_node, 0, 0);
}

/* ==================================== END RT_CLASS Selection node ==================================== */

/* ==================================== Skip IP Assignment node ==================================== */

ItemPnSkipIPAssignment::ItemPnSkipIPAssignment(GsdmlAttrNav* attrnav, const char* name, bool* pwr_pn_value_p,
                                               brow_tNode dest, flow_eDest dest_code)
    : ValueSelection<bool>(attrnav, attrnav_mItemType_Parent, name,
                           "Select yes here if you want another supervisor or "
                           "controller to handle the IP assignment",
                           dest, dest_code, pwr_pn_value_p)
{
  m_closed_annotation = attrnav->brow->pixmap_map;
  setup_node();
}

int ItemPnSkipIPAssignment::open_children_impl()
{
  new ItemPnValueSelectItem<bool>(m_attrnav, "Yes", "", this, m_value_p, true, "Select to skip IP assignment",
                                  m_node, flow_eDest_IntoLast);
  new ItemPnValueSelectItem<bool>(m_attrnav, "No", "", this, m_value_p, false,
                                  "Select to let ProviewR handle the IP assignment", m_node,
                                  flow_eDest_IntoLast);

  return 1;
}

void ItemPnSkipIPAssignment::select(ItemPnValueSelectItem<bool>* selected_item)
{
  // Store data
  *m_value_p = selected_item->value();

  if (*m_value_p)
    brow_SetAnnotation(m_node, 1, "Yes", sizeof("Yes"));
  else
    brow_SetAnnotation(m_node, 1, "No", sizeof("No"));

  // Close this node, for this class we have a saved reference to attrnav as e
  // member variable
  double node_x, node_y;
  brow_GetNodePosition(m_node, &node_x, &node_y);
  ItemPn::close(m_attrnav, node_x, node_y);
}

void ItemPnSkipIPAssignment::setup_node()
{
  m_noedit = 0; // Enable changing this
  if (*m_value_p)
    brow_SetAnnotation(m_node, 1, "Yes", sizeof("Yes"));
  else
    brow_SetAnnotation(m_node, 1, "No", sizeof("No"));
}

void ItemPnSkipIPAssignment::scan_impl(ItemPnValueSelectItem<bool> const* selected_item) const
{
  // Control the radiobuttons
  if (*selected_item->m_value_p == selected_item->m_select_value)
    brow_SetRadiobutton(selected_item->m_node, 0, 1);
  else
    brow_SetRadiobutton(selected_item->m_node, 0, 0);
}

/* ==================================== END Skip IP Assignment node ==================================== */

/* ==================================== Send Clock Selection node ==================================== */

ItemPnSendClock::ItemPnSendClock(GsdmlAttrNav* attrnav, const char* name,
                                 GSDML::ApplicationRelations& application_relations, uint16_t* pwr_pn_value_p,
                                 brow_tNode dest, flow_eDest dest_code)
    : ValueSelection<uint16_t>(attrnav, attrnav_mItemType_Parent, name,
                               "Choose (from supported modes) what Send Clock factor you "
                               "want.\nThis is the speed at which data aquisition will be performed "
                               "at on the bus. Each RT cycle is 31.25us. That cycle time is then "
                               "multiplied with the send clock factor to get our cycle time. On top "
                               "of that we have the reduction ratio that is multiplied with the "
                               "cycle time to get the resulting bus cycle time.\nExample: Send "
                               "clock factor 32 is chosen together with a reduction ratio of 16, "
                               "(31.25us * 32) * 16 -> (1ms) * 16 -> 16ms.",
                               dest, dest_code, pwr_pn_value_p),
      m_application_relations(application_relations)
{
  m_closed_annotation = attrnav->brow->pixmap_attrenum;
  setup_node();
}

int ItemPnSendClock::open_children_impl()
{
  for (auto it = m_send_clock_list->begin(); it != m_send_clock_list->end(); ++it)
  {
    std::ostringstream select_value(std::ios_base::out);
    select_value << it.value();
    new ItemPnValueSelectItem<uint16_t>(m_attrnav, select_value.str().c_str(), "", this, m_value_p,
                                        it.value(), "Send Clock factor selection item...", m_node,
                                        flow_eDest_IntoLast);
  }

  return 1;
}

void ItemPnSendClock::select(ItemPnValueSelectItem<uint16_t>* selected_item)
{
  // Store data
  *m_value_p = selected_item->value();

  std::string value = to_string();
  brow_SetAnnotation(m_node, 1, value.c_str(), value.length());
  // Close this node, for this class we have a saved reference to attrnav as e
  // member variable
  double node_x, node_y;
  brow_GetNodePosition(m_node, &node_x, &node_y);
  ItemPn::close(m_attrnav, node_x, node_y);
}

void ItemPnSendClock::setup_node()
{
  m_noedit = 0; // We want to be able to edit this one

  // Check if RT_CLASS_3 is chosen, if not we use the non RT_CLASS_3 settings.
  // The _SendClock valuelists are created with default values if there are no
  // corresponding elements in the GSDML file...so this is safe...
  if (m_attrnav->pn_runtime_data->m_PnDevice->m_IOCR_map[PROFINET_IO_CR_TYPE_INPUT].m_rt_class ==
      "RT_CLASS_3")
    m_send_clock_list = &m_application_relations._RT_Class3TimingProperties._SendClock;
  else
    m_send_clock_list = &m_application_relations._TimingProperties._SendClock;

  // We have no value? Value is 0...
  if (!*m_value_p)
  {
    // Choose a default.
    // To make it easy we set the send clock to the max. And in the
    // reductionratio class we set it to the lowest, placing us somehere
    // inbetween if the user should choose not to care about these settings.
    *m_value_p = m_send_clock_list->max();
  }

  // Last but not least, check if the value is in our send_clock_list since one
  // can change RT_CLASS at any time. And the different classes use different
  // timing properties. Set the default max as we did above in these cases...
  if (!m_send_clock_list->inList(*m_value_p))
    *m_value_p = m_send_clock_list->max();

  std::string value = to_string();
  brow_SetAnnotation(m_node, 1, value.c_str(), value.length());
}

void ItemPnSendClock::scan_impl(ItemPnValueSelectItem<uint16_t> const* selected_item) const
{
  // Control the radiobuttons
  if (*selected_item->m_value_p == selected_item->m_select_value)
    brow_SetRadiobutton(selected_item->m_node, 0, 1);
  else
    brow_SetRadiobutton(selected_item->m_node, 0, 0);
}

/* ================================= END Send Clock Selection node ================================= */

/* ================================= Reduction Ratio Selection node ================================= */

ItemPnReductionRatio::ItemPnReductionRatio(GsdmlAttrNav* attrnav, const char* name,
                                           GSDML::ApplicationRelations& application_relations,
                                           uint16_t* pwr_pn_value_p, brow_tNode dest, flow_eDest dest_code)
    : ValueSelection<uint16_t>(attrnav, attrnav_mItemType_Parent, name,
                               "Choose (from supported modes) what Reduction Ratio you want.\nThis "
                               "is used together with the Send Clock Factor to determine the bus "
                               "cycle time. See Send Clock Factor selection for more information.",
                               dest, dest_code, pwr_pn_value_p),
      m_application_relations(application_relations)
{
  m_closed_annotation = attrnav->brow->pixmap_attrenum;
  setup_node();
}

int ItemPnReductionRatio::open_children_impl()
{
  for (auto it = m_reduction_ratio_list->begin(); it != m_reduction_ratio_list->end(); ++it)
  {
    std::ostringstream select_value(std::ios_base::out);
    select_value << it.value();
    new ItemPnValueSelectItem<uint16_t>(m_attrnav, select_value.str().c_str(), "", this, m_value_p,
                                        it.value(), "Send Clock factor selection item...", m_node,
                                        flow_eDest_IntoLast);
  }

  return 1;
}

void ItemPnReductionRatio::select(ItemPnValueSelectItem<uint16_t>* selected_item)
{
  // Store data
  *m_value_p = selected_item->value();

  std::string value = to_string();
  brow_SetAnnotation(m_node, 1, value.c_str(), value.length());
  // Close this node, for this class we have a saved reference to attrnav as e
  // member variable
  double node_x, node_y;
  brow_GetNodePosition(m_node, &node_x, &node_y);
  ItemPn::close(m_attrnav, node_x, node_y);
}

void ItemPnReductionRatio::setup_node()
{
  m_noedit = 0; // We want to be able to edit this one

  // Check if RT_CLASS_3 is chosen, if not we use the non RT_CLASS_3 settings.
  // The _reductionRatio valuelists are created with default values if there are
  // no corresponding elements in the GSDML file...so this is safe...
  if (m_attrnav->pn_runtime_data->m_PnDevice->m_IOCR_map[PROFINET_IO_CR_TYPE_INPUT].m_rt_class ==
      "RT_CLASS_3")
    m_reduction_ratio_list = &m_application_relations._RT_Class3TimingProperties._ReductionRatioPow2;
  else
    m_reduction_ratio_list = &m_application_relations._TimingProperties._ReductionRatioPow2;

  // We have no value? Value is 0...
  if (!*m_value_p)
  {
    // Choose a default.
    // To make it easy we set the reductionratio to the min. And in the send
    // clock class we set it to the highest, placing us somehere inbetween if
    // the user should choose not to care about these settings.
    *m_value_p = m_reduction_ratio_list->min();
  }

  // Last but not least, check if the value is in our reduction ratio list since
  // one can change RT_CLASS at any time. And the different classes use
  // different timing properties. Set the default min as we did above in these
  // cases...
  if (!m_reduction_ratio_list->inList(*m_value_p))
    *m_value_p = m_reduction_ratio_list->min();

  std::string value = to_string();
  brow_SetAnnotation(m_node, 1, value.c_str(), value.length());
}

void ItemPnReductionRatio::scan_impl(ItemPnValueSelectItem<uint16_t> const* selected_item) const
{
  // Control the radiobuttons
  if (*selected_item->m_value_p == selected_item->m_select_value)
    brow_SetRadiobutton(selected_item->m_node, 0, 1);
  else
    brow_SetRadiobutton(selected_item->m_node, 0, 0);
}

/* ================================= END Reduction Ratio Selection node ================================= */

/* ==================================== Module Class Selection node ==================================== */

ItemPnModuleClass::ItemPnModuleClass(GsdmlAttrNav* attrnav, const char* name, uint32_t* pwr_pn_value_p,
                                     brow_tNode dest, flow_eDest dest_code)
    : ValueSelection<uint32_t>(attrnav, attrnav_mItemType_Parent, name,
                               "Choose a Pn Module to represent the data for this module. Most of "
                               "the time it's enough to choose PnModule and ProviewR will populate "
                               "according to GSDML file.\nRemember that if you do change the module class"
                               "the module and all channel items underneath it will be removed, and the"
                               "module will of course be replaced with the new module class object. Keep"
                               "that in mind. Maybe what you want is to move the channel items before"
                               "applying this new configuration in order to \"save\" the io connections.",
                               dest, dest_code, pwr_pn_value_p)
{
  m_closed_annotation = attrnav->brow->pixmap_attrenum;
  setup_node();
}

int ItemPnModuleClass::open_children_impl()
{
  for (int i = 0; m_attrnav->gsdml->module_classlist[i].cid; i++)
  {
    new ItemPnValueSelectItem<uint32_t>(m_attrnav, m_attrnav->gsdml->module_classlist[i].name, "", this,
                                        m_value_p, m_attrnav->gsdml->module_classlist[i].cid,
                                        "Module class selection item...", m_node, flow_eDest_IntoLast);
  }
  return 1;
}

void ItemPnModuleClass::select(ItemPnValueSelectItem<uint32_t>* selected_item)
{
  // Store data
  *m_value_p = selected_item->value();

  // Set a nicer name than the actual interger value...
  std::string name;
  for (int i = 0; m_attrnav->gsdml->module_classlist[i].cid; i++)
  {
    if (m_attrnav->gsdml->module_classlist[i].cid == *m_value_p)
      name = m_attrnav->gsdml->module_classlist[i].name;
  }

  brow_SetAnnotation(m_node, 1, name.c_str(), name.length());

  // Close this node
  double node_x, node_y;
  brow_GetNodePosition(m_node, &node_x, &node_y);
  ItemPn::close(m_attrnav, node_x, node_y);
}

void ItemPnModuleClass::setup_node()
{
  m_noedit = 0; // We want to be able to edit this one

  std::string value;

  // We have no value? Value is 0...
  if (!*m_value_p)
  {
    // Select a default
    for (int i = 0; m_attrnav->gsdml->module_classlist[i].cid; i++)
    {
      value = m_attrnav->gsdml->module_classlist[i].name;
      if (value == "PnModule")
      {
        *m_value_p = m_attrnav->gsdml->module_classlist[i].cid;
        break;
      }
    }
  }
  else
  {
    for (int i = 0; m_attrnav->gsdml->module_classlist[i].cid; i++)
    {
      if (m_attrnav->gsdml->module_classlist[i].cid == *m_value_p)
        value = m_attrnav->gsdml->module_classlist[i].name;
    }
  }

  brow_SetAnnotation(m_node, 1, value.c_str(), value.length());
}

void ItemPnModuleClass::scan_impl(ItemPnValueSelectItem<uint32_t> const* selected_item) const
{
  // Control the radiobuttons
  if (*selected_item->m_value_p == selected_item->m_select_value)
    brow_SetRadiobutton(selected_item->m_node, 0, 1);
  else
    brow_SetRadiobutton(selected_item->m_node, 0, 0);
}

/* ================================= END Module Class Selection node ================================= */

/* ======================================= IPv4 Input Node ======================================= */

bool ItemPnIPv4Input::do_value_changed(GsdmlAttrNav* attrnav, const char* value_str)
{
  std::regex const ipv4_regex(
      "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)");

  if (std::regex_match(value_str, ipv4_regex))
  {
    *m_value_p = value_str;
    brow_SetAnnotation(m_node, 1, m_value_p->c_str(), m_value_p->length());
  }
  else
  {
    attrnav->message('E', "Invalid format!");
    return false;
  }
  return true;
}

/* ======================================= END IPv4 Input Node ======================================= */

/* ======================================= MAC Address Input Node ======================================= */

bool ItemPnMACInput::do_value_changed(GsdmlAttrNav* attrnav, const char* value_str)
{
  std::regex const mac_regex("^([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2})");

  if (std::regex_match(value_str, mac_regex))
  {
    *m_value_p = value_str;
    brow_SetAnnotation(m_node, 1, m_value_p->c_str(), m_value_p->length());
  }
  else
  {
    attrnav->message('E', "Invalid format! Separation is done using a colon. "
                          "Hyphen is not supported.");
    return false;
  }
  return true;
}

/* ==================================== END MAC Address Input Node ==================================== */

/* ======================================= Device Name Input Node ======================================= */

bool ItemPnDeviceNameInput::do_value_changed(GsdmlAttrNav* attrnav, const char* value_str)
{
  std::regex const hostname_regex("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-"
                                  "Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])");

  if (std::regex_match(value_str, hostname_regex))
  {
    *m_value_p = value_str;
    brow_SetAnnotation(m_node, 1, m_value_p->c_str(), m_value_p->length());
  }
  else
  {
    attrnav->message('E', "Invalid name! PROFINET Device names follow RFC 1123. Make sure you do to ;)");
    return false;
  }
  return true;
}

/* ==================================== END Device Name Input Node ==================================== */

/* ======================================= Phase Input Node ======================================= */

bool ItemPnPhaseInput::do_value_changed(GsdmlAttrNav* attrnav, const char* value_str)
{
  std::regex const phase_regex("^[1-9][0-9]*");

  if (std::regex_match(value_str, phase_regex))
  {
    uint value;
    std::istringstream input(value_str, std::ios_base::in);
    input >> value;
    if (value <= *m_reduction_ratio->m_value_p)
    {
      *m_value_p = value;
      brow_SetAnnotation(m_node, 1, input.str().c_str(), input.str().length());
    }
    else
    {
      attrnav->message('E', "Phase cannot exceed reduction ratio.");
      return false;
    }
  }
  else
  {
    attrnav->message('E', "Invalid format! Enter a value 1 - Reduction Ratio");
    return false;
  }
  return true;
}

/* ======================================= END Phase Input Node ======================================= */