/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef cow_pn_gsdml_attrnav_h
#define cow_pn_gsdml_attrnav_h

/* cow_pn_gsdml_attrnav.h -- Profibus gsd configurator navigator */

#include <memory>

#include "flow_browapi.h"

#include "cow_pn_gsdml_attr.h"

#define pn_cModuleClassFile "$pwr_exe/pn_module_classes.dat"

typedef enum
{
  attrnav_eItemType_,
  //attrnav_eItemType_PnBase, // Base item for input values such as IP, MAC
  attrnav_eItemType_PnEnumValue, // Generic Enumeration value, used in PnEnum's
  attrnav_eItemType_PnDevice, // The DAP selection class, need a better name
  
  
  attrnav_eItemType_PnEnumYesNo, // Simple enum for a Yes/No selection
  
  
  attrnav_eItemType_PnSubslotPhys, // Not used yet
  
  attrnav_eItemType_PnSubmoduleType, // Selects a submodule to go in a subslot. Need a new name
  attrnav_eItemType_PnParRecord, // A ParameterRecordDataItem
  attrnav_eItemType_PnParValue, // A Parameter value input
  attrnav_eItemType_PnParEnum, // A Parameter enumeration when selecting from a (often smaller) known set of values
  attrnav_eItemType_PnParEnumBit, // THe actual value selection when ParEnum is a bit
  attrnav_eItemType_PnParEnumValue, // The actual value selection when ParEnum is not a bit.
  attrnav_eItemType_PnModuleClass,
  attrnav_eItemType_PnIOData,
  attrnav_eItemType_PnInput,
  attrnav_eItemType_PnOutput,
  attrnav_eItemType_PnDataItem,
  attrnav_eItemType_PnBitDataItem,
  attrnav_eItemType_PnEnumByteOrder,
  attrnav_eItemType_PnEnumTimeRatio,
  //attrnav_eItemType_PnEnumSendClock,
  attrnav_eItemType_PnEnumValueMType,

  attrnav_eItemType_PnIDSelectValue, // Selection of ID for a module or submodule
  
  attrnav_eItemType_PnMenu, // A simple menu item for categories of modules...
  attrnav_eItemType_PnNetwork, // Displays the network settings
  attrnav_eItemType_PnDeviceInfo,
  attrnav_eItemType_PnDAP, // The actual DAP selected by the PnDevice class
  attrnav_eItemType_PnInterfaceSubmodule, // Represents the interface submodule in the DAP
  attrnav_eItemType_PnPortSubmodule, // Represents the selcted port submodule in the DAP
  attrnav_eItemType_PnSubmoduleSelection,
  attrnav_eItemType_PnSlot, // A slot in which you can fit a Module
  attrnav_eItemType_PnSubslot, // A subslot in which a Submodule can go
  attrnav_eItemType_PnModuleInfo, // Displays the element ModuleInfo
  attrnav_eItemType_PnModuleSelection, // Selects a module to go in a Slot for instance
  attrnav_eItemType_PnValueSelection,
  attrnav_eItemType_PnValueSelectItem,
  attrnav_eItemType_PnValueInput,
  attrnav_eItemType_PnEnumRTClass,
  attrnav_eItemType_PnSkipIPAssignment,
  attrnav_eItemType_PnParameterSelection,
  attrnav_eItemType_PnTimingProperties,
  attrnav_eItemType_PnSendClock,
  attrnav_eItemType_PnReductionRatio
} attrnav_eItemType;

typedef enum
{
  attrnav_mOpen_All = ~0,
  attrnav_mOpen_Children = 1 << 0,
  attrnav_mOpen_Attributes = 1 << 1
} attrnav_mOpen;

class ItemPn;

//! Class for handling of brow.
class GsdmlAttrNavBrow
{
public:
  GsdmlAttrNavBrow(BrowCtx* brow_ctx, void* xn) : ctx(brow_ctx), attrnav(xn) {}
  ~GsdmlAttrNavBrow();

  BrowCtx* ctx;
  void* attrnav;
  brow_tNodeClass nc_object;
  brow_tNodeClass nc_attr;
  brow_tNodeClass nc_attr_multiline;
  brow_tNodeClass nc_table;
  brow_tNodeClass nc_header;
  brow_tNodeClass nc_table_header;
  brow_tNodeClass nc_enum;
  brow_tNodeClass nc_enum_mtype;
  flow_sAnnotPixmap* pixmap_leaf;
  flow_sAnnotPixmap* pixmap_map;
  flow_sAnnotPixmap* pixmap_openmap;
  flow_sAnnotPixmap* pixmap_attr;
  flow_sAnnotPixmap* pixmap_attrarray;
  flow_sAnnotPixmap* pixmap_attrenum;

  void free_pixmaps();
  void allocate_pixmaps();
  void create_nodeclasses();
  void brow_setup();
};

class CoWow;
class CoWowTimer;

//! The navigation area of the attribute editor.
class GsdmlAttrNav
{
public:
  GsdmlAttrNav(void* xn_parent_ctx, const char* xn_name, pn_gsdml* xn_gsd,
               int xn_edit_mode,
               std::shared_ptr<ProfinetRuntimeData> pwr_pn_data,
               pwr_tStatus* status);
  virtual ~GsdmlAttrNav();

  virtual void display_attr_help_text() {}
  virtual void set_inputfocus() {}

  void start_trace(pwr_tObjid Objid, char* object_str);
  int set_attr_value(const char* value_str);
  int check_attr_value(std::string& p_value);
  int get_select(pwr_sAttrRef* attrref, int* is_attr);
  void message(char sev, const char* text);
  void force_trace_scan();
  int object_attr();
  void print(char* filename);
  int get_select(ItemPn** item);
  void zoom(double zoom_factor);
  void unzoom();
  void get_zoom(double* zoom_factor);
  void set_modified(bool value) { modified = value; }
  bool is_modified() { return modified; }
  int save(const char* filename);
  int open(const char* filename);
  void collapse();
  void expand_all();
  void redraw();
  void set_viewio(int set) { viewio = set; }
  int search_class(const char* filename, const char* model, const char* module,
                   char* mclass);
  void set_order_moduletype(attr_eOrderModuleType type)
  {
    order_moduletype = type;
  }

  /* static member function */
  /* Trace thingies */
  static void trace_scan(void* data);
  static int trace_scan_bc(brow_tObject object, void* p);
  static int trace_connect_bc(brow_tObject object, char* name, char* attr,
                              flow_eTraceType type, void** p);
  static int trace_disconnect_bc(brow_tObject object);
  
  /* Brow thingies */
  static int init_brow_cb(FlowCtx* fctx, void* client_data);
  static int brow_cb(FlowCtx* ctx, flow_tEvent event);
  
  /* device / DAP related */
  static void device_changed_ok(void* ctx, void* data);
  static void device_changed_cancel(void* ctx, void* data);
  static pwr_tBoolean device_check_change_ok(void* ctx);
  static void device_update_change(void* ctx);

  /* member variables */
  void* parent_ctx;
  pn_gsdml* gsdml;
  pwr_tString256 m_name;
  GsdmlAttrNavBrow* brow;
  attr_sItem* itemlist;
  int item_cnt;
  int edit_mode;
  int trace_started;
  void (*message_cb)(void*, char, const char*);
  void (*change_value_cb)(void*);
  CoWow* m_wow;
  CoWowTimer* trace_timerid;

  std::shared_ptr<GSDML::DeviceAccessPointItem> m_selected_device_item;
  int device_confirm_active;
  GsdmlDeviceData dev_data;

  std::shared_ptr<ProfinetRuntimeData> pn_runtime_data;
  int device_read;
  int viewio;

  attr_eOrderModuleType order_moduletype;

private:
  bool modified;
};

class ItemPn
{
public:  
  ItemPn(GsdmlAttrNav* attrnav, attrnav_eItemType type, std::string name, std::string infotext,
         int is_parent = 0)
      : m_type(type), m_value_type(pwr_eType_), m_name(name), m_is_parent(is_parent), m_infotext(infotext),
        m_first_scan(1), m_noedit(1), m_attrnav(attrnav), m_closed_annotation(attrnav->brow->pixmap_leaf)
  {    
  }

  attrnav_eItemType m_type;  
  pwr_eType m_value_type; // If a subclass of this class is a carrier of data we can deduce what type of data using this.
  brow_tNode m_node;
  std::string m_name;
  int m_is_parent;
  std::string m_infotext;
  int m_first_scan;
  int m_noedit;
  //bool m_has_settings;
  GsdmlAttrNav* m_attrnav;
  flow_sAnnotPixmap* m_closed_annotation;

  virtual ~ItemPn() = default;

  // Open the node, missleading name saying open children...
  virtual int open_children(GsdmlAttrNav* attrnav, double x, double y) final;
  virtual int open_children_impl() = 0;


  // The item is selected, such as an enum being selected, a parent about to be
  // opened, or a parameter value...
  // Use ( in brow_cb() ) to call templated implementation specifics to regain RTTI
  virtual void selected(GsdmlAttrNav* attrnav){};

  // Called when user types input in a command input field
  // Use to call templated implementation specifics to regain RTTI
  virtual void value_changed(GsdmlAttrNav* attrnav, const char* value_str) {}

  // If this is a value of some sort. Return string representation
  virtual std::string to_string() { return std::string(""); }

  int virtual close(GsdmlAttrNav* attrnav, double x, double y, bool reopen_after_close = false) final;
  virtual int scan(GsdmlAttrNav* attrnav, void* p) { return 1; }
  
  virtual void update(GsdmlAttrNav* attrnav) {} //TODO What's this?
};

/*
  Display Information as text/numbers
*/
class ItemPnInfo : public ItemPn
{
public:
  ItemPnInfo(GsdmlAttrNav* attrnav, const char* item_name,
             const char* trace_attr_name, pwr_eType pwr_type_id, size_t attr_size,
             void const* value_p, brow_tNode dest, flow_eDest dest_code, const char* infotext);

  pwr_eType m_pwr_type_id;

  int open_children_impl() override { return 1; } // Must override for concrete class
};

/*
  A normal attribute, int, float, string and so on.
*/
// class ItemPnBase : public ItemPn
// {
// public:
//   ItemPnBase(GsdmlAttrNav* attrnav, const char* item_name,
//              const char* trace_attr_name, pwr_eType attr_type, size_t attr_size,
//              double attr_min_limit, double attr_max_limit, void* attr_value_p,
//              int attr_noedit, brow_tNode dest, flow_eDest dest_code, const char* infotext);

//   void* m_value_p;
//   void const* m_const_value_p;
//   pwr_tString256 m_old_value;
  
//   size_t m_size;
//   double m_min_limit;
//   double m_max_limit;
//   //int m_subgraph;

//   virtual int scan(GsdmlAttrNav* attrnav, void* value) override;
//   virtual void value_changed(GsdmlAttrNav* attrnav,
//                              const char* value_str) override;
//   int open_children_impl() override { return 1; }
// };

class ItemPnIDSelectValue : public ItemPn
{
public:
  ItemPnIDSelectValue(GsdmlAttrNav* attrnav, const char* item_name,
                   std::string id_enum_value, std::string* id_p,
                   brow_tNode dest, flow_eDest dest_code,
                   const char* info_text = 0);
  std::string m_id_enum_value;
  std::string* m_id;
  std::string m_old_value;

  void selected(GsdmlAttrNav* attrnav) override;
  int scan(GsdmlAttrNav* attrnav, void* mod_id_p);
  int open_children_impl() override { return 1; }
};

//! Item for a generic enum attribute.
class ItemPnEnumValue : public ItemPn
{
public:
  ItemPnEnumValue(GsdmlAttrNav* attrnav, const char* item_name,
                  int item_enum_value, pwr_eType item_type_id,
                  void* attr_value_p, brow_tNode dest, flow_eDest dest_code,
                  const char* info_text = 0);
  int m_enum_value;
  pwr_eType m_type_id;
  void* m_value_p;
  int m_old_value;

  int scan(GsdmlAttrNav* attrnav, void* p);
  int open_children_impl() override { return 1; }
};

//! Item for an enum attribute.
// class ItemPnEnumValueMType : public ItemPn
// {
// public:
//   ItemPnEnumValueMType(GsdmlAttrNav* attrnav, const char* item_name,
//                        const char* item_number, int item_num, int item_type_id,
//                        void* attr_value_p, brow_tNode dest,
//                        flow_eDest dest_code, const char* info_text = 0);
//   int num;
//   int type_id;
//   void* value_p;
//   int old_value;
//   int first_scan;
//   char number[80];

//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for a device aka DAP. A DAP can be considered just like a module only that it's always mounted in slot 0.
// Therefore it makes use of the ItemPnModuleEnumValue for selecting what DAP to use...
class ItemPnDevice : public ItemPn
{
public:
  ItemPnDevice(GsdmlAttrNav* attrnav, const char* item_name, brow_tNode dest,
               flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnDevice() {}

  std::string m_old_value;

  int open_children_impl();
  int scan(GsdmlAttrNav* attrnav, void* value_p);
};

//! Item for a slot.
// class ItemPnDAP : public ItemPn
// {
// public:
//   ItemPnDAP(GsdmlAttrNav* attrnav, const char* item_name,
//             ProfinetSlot* item_slotdata, brow_tNode dest, flow_eDest dest_code, const char* infotext);

//   ProfinetSlot* m_slotdata;

//   virtual int open_children_impl();
// };
class ItemPnSlot : public ItemPn
{
public:
  ItemPnSlot(GsdmlAttrNav* attrnav, const char* name,
             ProfinetSlot* slotdata,
             brow_tNode dest, flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnSlot() {}

  ProfinetSlot* m_slotdata;

  std::string m_old_value;

  int open_children_impl();
  int scan(GsdmlAttrNav* attrnav, void* p);
};

//! Item for a subslot.
class ItemPnSubslot : public ItemPn
{
public:
  ItemPnSubslot(GsdmlAttrNav* attrnav, const char* item_name,
                ProfinetSubslot* subslot_data,
                std::shared_ptr<GSDML::ModuleItem> parent_module_item,
                uint subslot_number,
                std::shared_ptr<GSDML::SubmoduleItem> attached_submodule_item,
                brow_tNode dest, flow_eDest dest_code, const char* infotext);

  ProfinetSubslot* m_subslot_data;
  std::shared_ptr<GSDML::ModuleItem> m_parent_module_item;
  uint m_subslot_number;
  bool m_is_selectable; 
  std::shared_ptr<GSDML::SubmoduleItem> m_attached_submodule_item;   

  // Trace compare
  std::string m_old_value;

  int open_children_impl() override;
  int scan(GsdmlAttrNav* attrnav, void* dummy_p) override;

private:
  void display_interface_submodule();
  void display_port_submodule();
};

//! Item for a physical subslot.
class ItemPnSubmoduleSelection : public ItemPn
{
public:
  ItemPnSubmoduleSelection(GsdmlAttrNav* attrnav, const char* item_name,
                    ProfinetSubslot* subslot_data,
                    uint subslot_number,
                    std::shared_ptr<GSDML::ModuleItem> module_item,
                    brow_tNode dest, flow_eDest dest_code, const char* infotext);
  
  ProfinetSubslot* m_subslot_data;  
  std::shared_ptr<GSDML::ModuleItem> m_module_item;
  int m_subslot_number;
  std::string m_old_value;

  int open_children_impl();
  int scan(GsdmlAttrNav* attrnav, void* id_p);
};

//! Item for the DeviceAccessPoint, slot 0
class ItemPnDAP : public ItemPn
{
public:
  ItemPnDAP(GsdmlAttrNav* attrnav, const char* item_name,
            ProfinetSlot* item_slotdata, brow_tNode dest, flow_eDest dest_code, const char* infotext);

  ProfinetSlot* m_slotdata;

  virtual int open_children_impl();
};

//! Item for Network settings
class ItemPnNetwork final : public ItemPn
{
public:
  ItemPnNetwork(GsdmlAttrNav* attrnav, const char* item_name, brow_tNode dest,
                flow_eDest dest_code, const char* infotext);

  int open_children_impl() final;
};

//! Item for Network settings
class ItemPnDeviceInfo : public ItemPn
{
public:
  ItemPnDeviceInfo(GsdmlAttrNav* attrnav, const char* item_name,
                   brow_tNode dest, flow_eDest dest_code, const char* infotext);
  
  int open_children_impl() override;
};

//! Item for an InterfaceSubmoduleItem (Not a subslot but the actual module)
// class ItemPnInterfaceSubmodule : public ItemPn
// {
// public:
//   ItemPnInterfaceSubmodule(GsdmlAttrNav* attrnav, const char* item_name,
//                            std::shared_ptr<GSDML::InterfaceSubmoduleItem> interface_submodule_item,
//                            ProfinetSubslot* subslot_data, brow_tNode dest, flow_eDest dest_code);  

//   std::shared_ptr<GSDML::InterfaceSubmoduleItem> m_interface_submodule_item;
//   ProfinetSubslot* m_subslot_data;
  
//   int open_children(GsdmlAttrNav* attrnav, double x, double y) override;
// };

//! Item for a PortSubmoduleItem
// class ItemPnPortSubmodule : public ItemPn
// {
// public:
//   ItemPnPortSubmodule(GsdmlAttrNav* attrnav, const char* item_name,
//                       std::shared_ptr<GSDML::PortSubmoduleItem> port_submodule_item,
//                       ProfinetSubslot* subslot_data, brow_tNode dest,
//                       flow_eDest dest_code);

//   std::shared_ptr<GSDML::PortSubmoduleItem> m_port_submodule_item;
//   ProfinetSubslot* m_subslot_data;
  
//   int open_children(GsdmlAttrNav* attrnav, double x, double y) override;
// };

//! Item for a moduleinfo.
class ItemPnModuleInfo : public ItemPn
{
public:
  ItemPnModuleInfo(GsdmlAttrNav* attrnav, const char* item_name,
                   GSDML::ModuleInfo* item_info, brow_tNode dest,
                   flow_eDest dest_code, const char* infotext);

  GSDML::ModuleInfo* m_module_info;

  virtual int open_children_impl();
};

// ! Item for module type selection.
// class ItemPnModuleSelect : public ItemPn
// {
// public:
//   ItemPnModuleSelect(GsdmlAttrNav* attrnav, const char* item_name,
//                    int item_slot_number, int item_slot_idx, brow_tNode dest,
//                    flow_eDest dest_code);
//   virtual ~ItemPnModuleSelect() {}

//   int m_slot_number;
//   int m_slot_idx;
//   int m_old_value; // Use string?  

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for submodule type selection.
// class ItemPnSubmoduleType : public ItemPn
// {
// public:
//   ItemPnSubmoduleType(GsdmlAttrNav* attrnav, const char* item_name,
//                       int item_subslot_number, int item_slot_idx,
//                       int item_subslot_idx, gsdml_UseableSubmodules* item_us,
//                       brow_tNode dest, flow_eDest dest_code);
//   virtual ~ItemPnSubmoduleType() {}

//   int subslot_number;
//   int slot_idx;
//   int subslot_idx;
//   gsdml_UseableSubmodules* us;
//   int old_value;
//   int first_scan;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for module type selection.
class ItemPnParameterRecordDataItem : public ItemPn
{
public:
  ItemPnParameterRecordDataItem(
      GsdmlAttrNav* attrnav, const char* item_name,
      GSDML::ParameterRecordDataItem const* parameter_record_data_item,
      ProfinetDataRecord* data_record, brow_tNode dest, flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnParameterRecordDataItem() {}

  GSDML::ParameterRecordDataItem const* m_parameter_record_data_item;
  ProfinetDataRecord* m_data_record;

  virtual int open_children_impl();

private:
  void set_default_data();
};

//! Item for module type selection.
// class ItemPnParValue : public ItemPn
// {
// public:
//   ItemPnParValue(GsdmlAttrNav* attrnav, const char* item_name, std::shared_ptr<GSDML::Ref> ref,
//                  unsigned char* data, brow_tNode dest, flow_eDest dest_code, const char* infotext);
//   ~ItemPnParValue() { if (m_old_value) delete m_old_value; m_old_value = (unsigned char*)0; };

//   std::shared_ptr<GSDML::Ref> m_ref;
//   GSDML::eValueDataType m_gsdml_datatype;
//   unsigned char* m_data;
//   unsigned int m_byte_offset;
//   unsigned int m_size;
//   unsigned char* m_old_value;

//   int scan(GsdmlAttrNav* attrnav, void* p);
//   void value_changed(GsdmlAttrNav* attrnav, const char* value_str);
//   int open_children_impl() override { return 1; }
// };

// class ParEnumValue
// {
// public:
//   ParEnumValue() {}
//   //unsigned int value;
//   int value;
//   //char text[160];
//   std::string text;
// };

// //! Item for module type selection.
// class ItemPnParEnum : public ItemPn
// {
// public:
//   ItemPnParEnum(GsdmlAttrNav* attrnav, const char* item_name, std::shared_ptr<GSDML::Ref> ref, unsigned char* data,
//                 brow_tNode dest, flow_eDest dest_code, const char* infotext);
//   ~ItemPnParEnum() = default;

//   std::shared_ptr<GSDML::Ref> m_ref;
//   GSDML::eValueDataType m_gsdml_datatype;
//   unsigned char* m_data;
//   unsigned int m_byte_offset;
//   unsigned int m_bit_offset;
//   unsigned int m_bit_length;
//   std::vector<ParEnumValue> m_values; // Will be populated with valid values from which we can choose from, depending on valueitemttargets and the allowed values.
//   unsigned int m_mask;
//   unsigned int m_old_value;

//   int open_children_impl() override;
//   int scan(GsdmlAttrNav* attrnav, void* p) override;
// };

// //! Item for module type selection.
// class ItemPnParEnumBit : public ItemPn
// {
// public:
//   ItemPnParEnumBit(GsdmlAttrNav* attrnav, const char* item_name,
//                    GSDML::eValueDataType gsdml_datatype, unsigned char* data,
//                    unsigned int byte_offset, unsigned int enum_value,
//                    unsigned int mask, int noedit, brow_tNode dest,
//                    flow_eDest dest_code, const char* infotext);
//   virtual ~ItemPnParEnumBit() {}

//   //gsdml_Assign* assign;
//   GSDML::eValueDataType m_gsdml_datatype;
//   unsigned char* m_data;
//   unsigned int m_byte_offset;
//   unsigned int m_enum_value;
//   unsigned int m_mask;
//   unsigned int m_old_value;

//   int scan(GsdmlAttrNav* attrnav, void* p);
//   void update(GsdmlAttrNav* attrnav);
//   int open_children_impl() override { return 1; }
// };

// class ItemPnParEnumValue : public ItemPn
// {
// public:
//   ItemPnParEnumValue(GsdmlAttrNav* attrnav, const char* item_name,
//                      GSDML::eValueDataType gsdml_datatype,
//                      unsigned char* data, unsigned int byte_offset, unsigned int enum_value,
//                      unsigned int mask, int noedit, brow_tNode dest,
//                      flow_eDest dest_code, const char* infotext);
//   virtual ~ItemPnParEnumValue() {}

//   //std::shared_ptr<GSDML::Assign> m_assign;
//   GSDML::eValueDataType m_gsdml_datatype;
//   unsigned char* m_data;
//   unsigned int m_byte_offset;
//   unsigned int m_enum_value;
//   unsigned int m_mask;
//   unsigned int m_old_value;

//   int scan(GsdmlAttrNav* attrnav, void* p);
//   void update(GsdmlAttrNav* attrnav);
//   int open_children_impl() override { return 1; }
// };

//! Item for a IOData.
class ItemPnIOData : public ItemPn
{
public:
  ItemPnIOData(GsdmlAttrNav* attrnav, const char* item_name,
               GSDML::IOData* iodata, ProfinetSubslot* subslot, brow_tNode dest,
               flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnIOData() {}

  GSDML::IOData* m_iodata;
  ProfinetSubslot* m_subslot;

  int open_children_impl();
};

//! Item for a Input.
// class ItemPnInput : public ItemPn
// {
// public:
//   ItemPnInput(GsdmlAttrNav* attrnav, const char* item_name,
//               gsdml_Input* item_input, brow_tNode dest, flow_eDest dest_code);
//   virtual ~ItemPnInput() {}

//   gsdml_Input* input;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
// };

//! Item for a Output.
// class ItemPnOutput : public ItemPn
// {
// public:
//   ItemPnOutput(GsdmlAttrNav* attrnav, const char* item_name,
//                gsdml_Output* item_output, brow_tNode dest,
//                flow_eDest dest_code);
//   virtual ~ItemPnOutput() {}

//   gsdml_Output* output;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
// };

//! Item for a DataItem.
// class ItemPnDataItem : public ItemPn
// {
// public:
//   ItemPnDataItem(GsdmlAttrNav* attrnav, const char* item_name,
//                  gsdml_DataItem* item_dataitem, brow_tNode dest,
//                  flow_eDest dest_code);
//   virtual ~ItemPnDataItem() {}

//   gsdml_DataItem* dataitem;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
// };

//! Item for a BitDataItem.
// class ItemPnBitDataItem : public ItemPn
// {
// public:
//   ItemPnBitDataItem(GsdmlAttrNav* attrnav, const char* item_name,
//                     gsdml_BitDataItem* item_bitdataitem, brow_tNode dest,
//                     flow_eDest dest_code);
//   virtual ~ItemPnBitDataItem() {}

//   gsdml_BitDataItem* bitdataitem;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
// };

//! Item for module class selection.
class ItemPnModuleClass : public ItemPn
{
public:
  ItemPnModuleClass(GsdmlAttrNav* attrnav, const char* item_name,
                    GsdmlSlotData* item_slotdata, brow_tNode dest,
                    flow_eDest dest_code);
  virtual ~ItemPnModuleClass() {}

  GsdmlSlotData* slotdata;
  int old_value;
  int first_scan;

  int open_children_impl(GsdmlAttrNav* attrnav, double x, double y);
  int scan(GsdmlAttrNav* attrnav, void* p);
};

//! Item for slave byte order.
// class ItemPnEnumByteOrder : public ItemPnBase
// {
// public:
//   ItemPnEnumByteOrder(GsdmlAttrNav* attrnav, const char* item_name,
//                       const char* attr, pwr_eType attr_type, int attr_size,
//                       void* attr_value_p, int attr_noedit, brow_tNode dest,
//                       flow_eDest dest_code);
//   virtual ~ItemPnEnumByteOrder() {}

//   int old_value;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for time ratio.
// class ItemPnEnumTimeRatio : public ItemPn
// {
// public:
//   ItemPnEnumTimeRatio(GsdmlAttrNav* attrnav, const char* item_name,
//                       gsdml_InterfaceSubmoduleItem* item_interfacesubmodule,
//                       void* attr_value_p, brow_tNode dest,
//                       flow_eDest dest_code);
//   virtual ~ItemPnEnumTimeRatio() {}

//   gsdml_InterfaceSubmoduleItem* interfacesubmodule;
//   void* value_p;
//   char valuelist_str[200];
//   int first_scan;
//   int old_value;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for send clock.
// class ItemPnEnumSendClock : public ItemPn
// {
// public:
//   ItemPnEnumSendClock(GsdmlAttrNav* attrnav, const char* item_name,
//                       gsdml_InterfaceSubmoduleItem* item_interfacesubmodule,
//                       void* attr_value_p, brow_tNode dest,
//                       flow_eDest dest_code);
//   virtual ~ItemPnEnumSendClock() {}

//   gsdml_InterfaceSubmoduleItem* interfacesubmodule;
//   void* value_p;
//   char valuelist_str[200];
//   int first_scan;
//   int old_value;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

class ItemPnEnumYesNo : public ItemPn
{
public:
  ItemPnEnumYesNo(GsdmlAttrNav* attrnav, const char* item_name,
                  int* attr_value_p, brow_tNode dest, flow_eDest dest_code,
                  char const* infotext = 0);
  virtual ~ItemPnEnumYesNo() {}

  int* m_value_p;
  int m_old_value;

  int open_children_impl() override;
  int scan(GsdmlAttrNav* attrnav, void* value_p) override;
};

// template<typename T>
// class ISelectable
// {
// public:
//   explicit ISelectable(IHasSelectables<T>* parent, T select_value) : m_select_value(select_value), m_parent(parent) {}
//   virtual ~ISelectable() = default;

//   virtual void unselect() = 0;
//   virtual void select() = 0;

//   bool m_is_selected;
//   T m_select_value;
//   IHasSelectables<T>* m_parent;
// };

// template<typename T>
// class IHasSelectables
// {
// public:
//   explicit IHasSelectables(T* value_p) : m_value_p(value_p) {}
//   virtual ~IHasSelectables() = default;
//   virtual void select(ISelectable<T>* selectable) final {
//     for (auto s : m_selectables)
//       s.second->unselect();
//     selectable->select();
//     select_impl(selectable);
//   }
//   virtual void select_impl(ISelectable<T>* selectable) = 0;

//   T* m_value_p;
//   std::map<size_t, ISelectable<T>*> m_selectables;
// };

// template<typename T>
// class ItemPnValueSelectionItem : public ItemPn, public ISelectable<T>
// {
// public:
//   ItemPnValueSelectionItem(GsdmlAttrNav* attrnav, pwr_eType value_type, const char* name,
//       IHasSelectables<T>* parent, T select_value, const char* infotext,
//       brow_tNode dest, flow_eDest dest_code) 
//     : ItemPn(attrnav_eItemType_PnValueSelectionItem, name, infotext),
//       ISelectable<T>(parent, select_value)
//   {
//     m_value_type = value_type;
//     brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_enum, dest,
//                   dest_code, (void*)this, 1, &m_node);

//     brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_attr);
//     brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
    
//     // Set if this is selected or not    
//     brow_SetRadiobutton(m_node, 0, 0);
//     // add call to parent->select("this") to brow_cb
//     //brow_SetTraceAttr(m_node, m_name.c_str(), "", flow_eTraceType_User);
//   }
  
//   void select() override { brow_SetRadiobutton(m_node, 0, 1); }

//   void unselect() override { brow_SetRadiobutton(m_node, 0, 0); }
// };

// TODO continue with the templated value item input/select classes that use the "trace functionality" to replace all other
// brow_cb need to cast depending on parent_type, and event is catched using ItemPnValueSelectItem/ItemPnValueInput class enums

/*
==================================================== NEW CLASSES ====================================================
*/

/*
======================= TEMPLATES CLASSES FOR CHANGING CONFIGURATION PROPERTIES =======================
*/

template<typename T>
class ItemPnValueSelectItem;

template<typename T>
class ValueSelection : public ItemPn
{
public:
  explicit ValueSelection(GsdmlAttrNav* attrnav, attrnav_eItemType type, std::string name, std::string infotext, 
                    brow_tNode dest, flow_eDest dest_code,
                    T* value_p)
    : ItemPn(attrnav, attrnav_eItemType_PnValueSelection, name, infotext),
      m_value_p(value_p)  
  {
    brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest,
                  dest_code, (void*)this, 1, &m_node);
    brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_attrenum);
    brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
  }
  virtual ~ValueSelection() = default;
  virtual void select(ItemPnValueSelectItem<T>* selected_item) = 0;
  virtual void scan_impl(ItemPnValueSelectItem<T> const* selected_item) const = 0;
  virtual void setup_node() = 0;

  std::string to_string() override
  {
    std::ostringstream result(std::ios_base::out);
    result.precision(12); // For when this is a float/double    
    result << std::fixed << *m_value_p;
    
    std::string value(result.str());
    return value;
  }

  T* m_value_p;  
};

template<typename T>
class ItemPnValueSelectItem : public ItemPn
{
public:
  ItemPnValueSelectItem(GsdmlAttrNav* attrnav, const char* annotation_1, std::string annotation_2,
      ValueSelection<T>* parent, T const* value_p, T select_value, const char* infotext,
      brow_tNode dest, flow_eDest dest_code) 
    : ItemPn(attrnav, attrnav_eItemType_PnValueSelectItem, annotation_1, infotext),
      m_parent(parent), m_value_p(value_p), m_select_value(select_value)
  {    
    brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_enum_mtype, dest,
                  dest_code, (void*)this, 1, &m_node);

    brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_attr);
    brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
    if (annotation_2 != "")
      brow_SetAnnotation(m_node, 1, annotation_2.c_str(), annotation_2.length());
    brow_SetTraceAttr(m_node, m_name.c_str(), "", flow_eTraceType_User);
  }

  brow_tNode get_node() const { return ItemPn::m_node; }
  
  int scan(GsdmlAttrNav* attrnav, void* dummy) override
  {    
    if (!m_first_scan)
    {
      if (*m_value_p == m_old_value)
        return 1;
    }
    else
    {
      m_first_scan = 0;
    }
    
    m_parent->scan_impl(this);

    m_old_value = *m_value_p;

    return 1;
  }

  void selected(GsdmlAttrNav* attrnav) override
  {
    m_parent->select(this);
  }

  T const& value() const { return m_select_value; }

  int open_children_impl() override { return 1; }

  ValueSelection<T>* m_parent;
  T const* m_value_p;
  T const m_select_value;
  T m_old_value;
};

template<typename T>
class ItemPnValueInput : public ItemPn
{
public:
  ItemPnValueInput(GsdmlAttrNav* attrnav, const char* annotation_1,
      T* value_p, const char* infotext, brow_tNode dest, flow_eDest dest_code) 
    : ItemPn(attrnav, attrnav_eItemType_PnValueInput, annotation_1, infotext),
      m_value_p(value_p)
  {    
    m_noedit = 0; 
    brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest,
                  dest_code, (void*)this, 1, &m_node);

    brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_attr);
    brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
    std::string current_value(to_string());
    brow_SetAnnotation(m_node, 1, current_value.c_str(), current_value.length());
  }
  
  void set_changeable(bool changeable) { m_noedit = !changeable; }

  void value_changed(GsdmlAttrNav* attrnav, const char* value_str) override
  {
    std::cout << "Value changed called, value: " << value_str << std::endl;

    value_changed_impl(attrnav, value_str);
  }

  std::string to_string() override
  {
    std::ostringstream result(std::ios_base::out);
    result.precision(12); // For when this is a float/double    
    result << std::fixed << *m_value_p;
    
    std::string value(result.str());
    return value;    
  }

  virtual void value_changed_impl(GsdmlAttrNav* attrnav, const char* value_str) = 0;

  int open_children_impl() override { return 1; }

protected:  
  T* m_value_p;  
  //T m_old_value;
};



/*
  ======================================== "CONCRETE" IMPLEMENTATIONS ========================================
*/

/*
  Module Selection item
*/
class ItemPnModuleSelection : public ValueSelection<std::string>
{
public:
  ItemPnModuleSelection(GsdmlAttrNav* attrnav, const char* name, ProfinetSlot* slot_data,
                  std::string* id_value_p, brow_tNode dest, flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnModuleSelection() {}
  
  int open_children_impl() override;  
  void select(ItemPnValueSelectItem<std::string>* selected_item) override;  
  void setup_node() override;
  void scan_impl(ItemPnValueSelectItem<std::string> const* selected_item) const override;

  ProfinetSlot* m_slot_data;
  std::map<std::string, std::string> m_categories;
  std::multimap<std::string, std::shared_ptr<GSDML::ModuleItem>> m_category_map;
};

class ItemPnMenu : public ItemPn
{
public:
  ItemPnMenu(GsdmlAttrNav* attrnav, std::string const& category_name, std::string const& infotext, brow_tNode dest, flow_eDest dest_code,
              std::multimap<std::string, std::shared_ptr<GSDML::ModuleItem>>& items, ItemPnModuleSelection* parent);  

  int open_children_impl() override;

  std::multimap<std::string, std::shared_ptr<GSDML::ModuleItem>>& m_items;  
  ItemPnModuleSelection* m_parent;
};

/*
  RT_CLASS Selection item
*/
class ItemPnEnumRTClass : public ValueSelection<std::string>
{
public:
  ItemPnEnumRTClass(GsdmlAttrNav* attrnav, const char* name,
                    std::shared_ptr<GSDML::InterfaceSubmoduleItem> interface_submodule_item,
                  std::string* pwr_pn_value_p, brow_tNode dest, flow_eDest dest_code);
  virtual ~ItemPnEnumRTClass() {}

  std::shared_ptr<GSDML::InterfaceSubmoduleItem> m_interface_submodule_item;  
  
  int open_children_impl() override;  
  void select(ItemPnValueSelectItem<std::string>* selected_item) override;
  void setup_node() override;
  void scan_impl(ItemPnValueSelectItem<std::string> const* selected_item) const override;

};

class ItemPnSkipIPAssignment : public ValueSelection<bool>
{
public:
  ItemPnSkipIPAssignment(GsdmlAttrNav* attrnav, const char* name,
                  bool* pwr_pn_value_p, brow_tNode dest, flow_eDest dest_code);
  virtual ~ItemPnSkipIPAssignment() {}

  int open_children_impl() override;  
  void select(ItemPnValueSelectItem<bool>* selected_item) override;
  void setup_node() override;
  void scan_impl(ItemPnValueSelectItem<bool> const* selected_item) const override;
};

class ItemPnSendClock : public ValueSelection<uint16_t>
{
public:
  ItemPnSendClock(GsdmlAttrNav* attrnav, const char* name,
                  GSDML::ApplicationRelations& application_relations,
                  uint16_t* pwr_pn_value_p, brow_tNode dest, flow_eDest dest_code);
  virtual ~ItemPnSendClock() {}

  int open_children_impl() override;  
  void select(ItemPnValueSelectItem<uint16_t>* selected_item) override;
  void setup_node() override;
  void scan_impl(ItemPnValueSelectItem<uint16_t> const* selected_item) const override;

private:
  GSDML::ApplicationRelations& m_application_relations;
  GSDML::ValueList<uint>* m_send_clock_list;  
};

class ItemPnReductionRatio : public ValueSelection<uint16_t>
{
public:
  ItemPnReductionRatio(GsdmlAttrNav* attrnav, const char* name,
                  GSDML::ApplicationRelations& application_relations,
                  uint16_t* pwr_pn_value_p, brow_tNode dest, flow_eDest dest_code);
  virtual ~ItemPnReductionRatio() {}

  int open_children_impl() override;  
  void select(ItemPnValueSelectItem<uint16_t>* selected_item) override;
  void setup_node() override;
  void scan_impl(ItemPnValueSelectItem<uint16_t> const* selected_item) const override;

private:
  GSDML::ApplicationRelations& m_application_relations;
  GSDML::ValueList<uint>* m_reduction_ratio_list;  
};

/*
  Class for a IPv4 input field. It make sure the input is in the correct
  format. It does not check wether it's a valid IPv4 address. Not yet anyways :)
*/
class ItemPnIPv4Input : public ItemPnValueInput<std::string>
{
public:
  ItemPnIPv4Input(GsdmlAttrNav* attrnav, const char* name,
      std::string* value_p, const char* infotext, brow_tNode dest, flow_eDest dest_code)
  : ItemPnValueInput<std::string>(attrnav, name, value_p, infotext, dest, dest_code) {}
  virtual ~ItemPnIPv4Input() {}

  void value_changed_impl(GsdmlAttrNav* attrnav, const char* value_str) override;
};

/*
  Class for a MAC address input field. It make sure the input is in the correct
  format. It does not check wether it's a valid MAC address. Not yet anyways :)
*/
class ItemPnMACInput : public ItemPnValueInput<std::string>
{
public:
  ItemPnMACInput(GsdmlAttrNav* attrnav, const char* name,
      std::string* value_p, const char* infotext, brow_tNode dest, flow_eDest dest_code)
  : ItemPnValueInput<std::string>(attrnav, name, value_p, infotext, dest, dest_code) {}
  virtual ~ItemPnMACInput() {}

  void value_changed_impl(GsdmlAttrNav* attrnav, const char* value_str) override;
};

/*
  Class for a MAC address input field. It make sure the input is in the correct
  format. It does not check wether it's a valid MAC address. Not yet anyways :)
*/
class ItemPnDeviceNameInput : public ItemPnValueInput<std::string>
{
public:
  ItemPnDeviceNameInput(GsdmlAttrNav* attrnav, const char* name,
      std::string* value_p, const char* infotext, brow_tNode dest, flow_eDest dest_code)
  : ItemPnValueInput<std::string>(attrnav, name, value_p, infotext, dest, dest_code) {}
  virtual ~ItemPnDeviceNameInput() {}

  void value_changed_impl(GsdmlAttrNav* attrnav, const char* value_str) override;
};

class ItemPnPhaseInput : public ItemPnValueInput<uint>
{
public:
  ItemPnPhaseInput(GsdmlAttrNav* attrnav, const char* name,
      uint* value_p, const char* infotext, brow_tNode dest, flow_eDest dest_code)
  : ItemPnValueInput<uint>(attrnav, name, value_p, infotext, dest, dest_code) {}
  virtual ~ItemPnPhaseInput() {}

  void value_changed_impl(GsdmlAttrNav* attrnav, const char* value_str) override;
};

// Just a container for the timing properties values
class ItemPnTimingProperties : public ItemPn
{
public:
  ItemPnTimingProperties(GsdmlAttrNav* attrnav, const char* name,
      std::shared_ptr<GSDML::DeviceAccessPointItem> dap,
      brow_tNode dest, flow_eDest dest_code)
    : ItemPn(attrnav, attrnav_eItemType_PnTimingProperties, name, "Timing Properties such as what RT_CLASS to run, what Send Clock factor to use and also Reduction Ratio."),
      m_dap(dap)
  {
    m_closed_annotation = attrnav->brow->pixmap_map;

    brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest,
                  dest_code, (void*)this, 1, &m_node);
    brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_map);
    brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());

    // Setup our interface submodule if there is one available...
    for (auto const& submodule_item : dap->_SystemDefinedSubmoduleList)
    {
      if (submodule_item.second->_SubmoduleItemType == GSDML::SubmoduleItemType_Interface)
      {
        m_interface_submodule = std::static_pointer_cast<GSDML::InterfaceSubmoduleItem>(submodule_item.second);
      }
    }

    // In the olden days, interface submodule items did not exist. We create a default one for this purpose
    // to make our children happy.
    if (!m_interface_submodule)
      m_interface_submodule.reset(new GSDML::InterfaceSubmoduleItem());    
  }

  virtual ~ItemPnTimingProperties() {}

  int open_children_impl() override
  {    
    new ItemPnEnumRTClass(m_attrnav, "RT_CLASS", m_interface_submodule, &m_attrnav->pn_runtime_data->m_PnDevice->m_IOCR.RT_CLASS, m_node, flow_eDest_IntoLast);

    new ItemPnSendClock(m_attrnav, "Send Clock", m_interface_submodule->_ApplicationRelations, &m_attrnav->pn_runtime_data->m_PnDevice->m_IOCR.m_send_clock_factor, m_node, flow_eDest_IntoLast);

    new ItemPnReductionRatio(m_attrnav, "Reduction Ratio", m_interface_submodule->_ApplicationRelations, &m_attrnav->pn_runtime_data->m_PnDevice->m_IOCR.m_reduction_ratio, m_node, flow_eDest_IntoLast);

    new ItemPnPhaseInput(m_attrnav, "Phase", &m_attrnav->pn_runtime_data->m_PnDevice->m_IOCR.m_phase, "Phases explained here (TODO)", m_node, flow_eDest_IntoLast);

    return 1;
  }
private:
  std::shared_ptr<GSDML::DeviceAccessPointItem> m_dap;
  std::shared_ptr<GSDML::InterfaceSubmoduleItem> m_interface_submodule;
};

/*
  =============================  Device Parameter Classes (used to change device parameters) =============================
  There are two types of top classes. One where you select from a list of allowed values and one where you type a value into
  an input prompt.
*/

/* Helper class for converting between host values and big endian values used in the profinet configuration */
template<typename T>
class ValueInterpreter
{
public:
  // Convert a string to the current template datatype
  T to_value(std::string string_representation)
  {
    T value;
    std::istringstream input(string_representation, std::ios_base::in);
    input.precision(12); // For when this is a float/double    
    input >> std::fixed >> value;
    
    if (input.fail())
      throw std::string("Conversion error");
    
    return std::move(value);    
  }

  // Convert a value to PNIO order
  T to_pn_value(T value)
  {
    switch (sizeof(T))
    {
      case 2:
        value = htons(value);
        break;
      case 4:
        value = htonl(value);
        break;
      case 8:
        // TODO Implement
        std::cout << "NYI 8 byte long datatype" << std::endl;    
        break;
      default:
        break;
    }
    return value;
  }

  // Convert value to host order
  T to_host_value(T value)
  {
    switch (sizeof(T))
    {
      case 2:
        value = ntohs(value);
        break;
      case 4:
        value = ntohl(value);
        break;
      case 8:
        std::cout << "NYI 8 byte long datatype" << std::endl;    
        break;
      default:
        break;
    }
    return value;
  }
};

/* 
  Template class for all datatypes available 
  This is an input style type of item. No selections...
  It takes a Ref element as a constructor parameter in order to check where the data should go and what 
  the allowed values are...

  TODO Test this with string datavalue types. Might need more template specialization for that
*/
template<typename T>
class ItemPnParameterInput : public ItemPnValueInput<T>
{
public:
  ItemPnParameterInput(GsdmlAttrNav* attrnav, const char* name,
      T* value_p, const char* infotext, brow_tNode dest, flow_eDest dest_code,
      std::shared_ptr<GSDML::Ref> ref)
    : ItemPnValueInput<T>(attrnav, name,
      value_p, infotext, dest, dest_code), m_ref(ref)
  {
    // Set the value pointer to point to our offset in the Const data
    this->m_value_p = (T*)&((unsigned char*)this->m_value_p)[ref->_ByteOffset];
    
    this->set_changeable(m_ref->_Changeable);

    std::string value = this->to_string();
    brow_SetAnnotation(this->m_node, 1, value.c_str(), value.length());
  }
  virtual ~ItemPnParameterInput() = default;

  void value_changed_impl(GsdmlAttrNav* attrnav, const char* value_str) override
  {
    T value;
    
    try {
      value = interpreter.to_value(value_str);
    } catch (std::string& e)
    {
      attrnav->message('E', "Not a valid input for this datatype.");
      return;
    }

    std::cout << "Value (before): " << value << std::endl;

    // Check allowed values if it is present
    if (!m_ref->_AllowedValues.empty() && !m_ref->_AllowedValues.inList(value))
    {
      attrnav->message('E', "Value is outside allowed ranges");
      return;
    }

    // Store the value
    value = interpreter.to_pn_value(value);
    *this->m_value_p = value;

    // All ok, update annotation to reflect stored value...
    std::string value_string = this->to_string();
    brow_SetAnnotation(this->m_node, 1, value_string.c_str(), value_string.length());

    std::cout << "Value (after): " << value << std::endl;

    ItemPn::m_attrnav->pn_runtime_data->save_to_file("testxmlfile");
  }

  std::string to_string() override
  {
    T temp = interpreter.to_host_value(*this->m_value_p);
    std::ostringstream result(std::ios_base::out);
    result.precision(12); // For when this is a float/double    
    result << std::fixed << temp;    

    std::string value(result.str());
    return value;    
  }

private:
  ValueInterpreter<T> interpreter;
  std::shared_ptr<GSDML::Ref> m_ref;
};

template<typename T>
class ItemPnParameterSelection : public ValueSelection<T>
{
public:
  ItemPnParameterSelection(GsdmlAttrNav* attrnav, const char* name,
                  T* pwr_pn_value_p, brow_tNode dest, flow_eDest dest_code,
                  std::shared_ptr<GSDML::Ref> ref)
    : ValueSelection<T>(attrnav, attrnav_eItemType_PnParameterSelection, name, "No help text available", dest, dest_code, pwr_pn_value_p),
      m_ref(ref), m_is_bitarea(false), m_is_bit(false)
  {
    ItemPn::m_closed_annotation = attrnav->brow->pixmap_attrenum;

    // Set InfoText to the Value Item help element reference text...
    if (m_ref->_ValueItem && m_ref->_ValueItem->_Help)
      ItemPn::m_infotext = *m_ref->_ValueItem->_Help;

    // Set the value pointer to point to our offset in the Const data
    this->m_value_p = (T*)&((unsigned char*)this->m_value_p)[ref->_ByteOffset]; 
    this->m_noedit = !m_ref->_Changeable;

    // ParameterSelections can be Bit/BitArea types. If so, we need to pinpoint the bits correctly.
    // The size of these are always 1 byte. Create a bitmask to use...
    // TODO Check specification for the default value of a bitlength element. ought to be 1 so this
    // expression can be simplified when this is confirmed...
    m_mask = (1 << ref->_BitLength) - (ref->_BitLength ? 1 : 0);
    m_mask <<= ref->_BitOffset;

    if (ref->_DataType == GSDML::ValueDataType_Bit)
      m_is_bit = true;
    if (ref->_DataType == GSDML::ValueDataType_BitArea)
      m_is_bitarea = true;

    std::cout << "Mask: " << +m_mask << std::endl;

    setup_node();
  }

  virtual ~ItemPnParameterSelection() = default;

  void scan_impl(ItemPnValueSelectItem<T> const* selected_item) const
  { 
    T value = *this->m_value_p;
    if (m_is_bit || m_is_bitarea)
    {
      value = *this->m_value_p & m_mask;
    }
    else
    {
      value = *this->m_value_p;
    }

    if (value == selected_item->value())
      brow_SetRadiobutton(selected_item->get_node(), 0, 1);
    else
      brow_SetRadiobutton(ItemPn::m_node, 0, 0);
  }

  int open_children_impl() override
  {
    if (m_is_bit)
    {
      new ItemPnValueSelectItem<T>(ItemPn::m_attrnav, "On", "", this, this->m_value_p, 1 << m_ref->_BitOffset, "Select to enable this feature.", ItemPn::m_node, flow_eDest_IntoLast);
      new ItemPnValueSelectItem<T>(ItemPn::m_attrnav, "Off", "", this, this->m_value_p, 0, "Select to disable this feature.", ItemPn::m_node, flow_eDest_IntoLast);
      return 1;
    }

    // TODO If the need arises, implement something to populate a list of values when there are no assignments

    // If we have assignments
    for (auto const& assign : m_ref->_ValueItem->_Assignments)
    {
      if (m_ref->_AllowedValues.inList(assign._Content))
      {
        if (m_is_bitarea)
          new ItemPnValueSelectItem<T>(ItemPn::m_attrnav, assign._Text->c_str(), "", this, this->m_value_p, static_cast<T>(assign._Content) << m_ref->_BitOffset, assign._Text->c_str(), ItemPn::m_node, flow_eDest_IntoLast);
        else
          new ItemPnValueSelectItem<T>(ItemPn::m_attrnav, assign._Text->c_str(), "", this, this->m_value_p, static_cast<T>(assign._Content), assign._Text->c_str(), ItemPn::m_node, flow_eDest_IntoLast);
      }
    }
    return 1;
  }

  void select(ItemPnValueSelectItem<T>* selected_item) override
  {
    if (m_is_bit || m_is_bitarea)
    {
      *this->m_value_p &= ~m_mask; // Clear the bits
      //*this->m_value_p |= (selected_item->value() << m_ref->_BitOffset);
      *this->m_value_p |= selected_item->value();
    }
    else
      *this->m_value_p = selected_item->value();    
    
    brow_SetAnnotation(ItemPn::m_node, 1, selected_item->m_name.c_str(), selected_item->m_name.length());
    // Close this node, for this class we have a saved reference to attrnav as e member variable
    double node_x, node_y;
    brow_GetNodePosition(ItemPn::m_node, &node_x, &node_y);
    ItemPn::close(ItemPn::m_attrnav, node_x, node_y);
  }

  std::string to_string() override
  {
    T temp = interpreter.to_host_value(*this->m_value_p);
    std::ostringstream result(std::ios_base::out);
    result.precision(12); // For when this is a float/double    
    result << std::fixed << temp;    

    std::string value(result.str());
    return value;    
  }

  void setup_node() override
  {
    std::string annotation;
    T value;
    if (m_is_bitarea || m_is_bit)
    {
      value = (*this->m_value_p & m_mask);
    }
    else
    {
      value = interpreter.to_host_value(*this->m_value_p);
    }    

    // Is this a Bit?
    if (m_is_bit)
    {
      annotation = (value ? "On" : "Off");
    }    
    else if (m_ref->_ValueItem)
    {
      for (auto const& assign : m_ref->_ValueItem->_Assignments)
      {
        if (assign._Content == value)
        {
          annotation = *assign._Text;
          break;
        }
      }
    }

    brow_SetAnnotation(ItemPn::m_node, 1, annotation.c_str(), annotation.length());
  }

private:
  ValueInterpreter<T> interpreter;
  std::shared_ptr<GSDML::Ref> m_ref;
  uint8_t m_mask;
  bool m_is_bitarea;
  bool m_is_bit;
};


/*
  ========================================= Specializations for ParameterSelection =======================================

  Template specializations for our ParameterSelection classes. Float/Double has no bitwise operations. 
  So we specialize those functions here.
*/

template<>
inline void ItemPnParameterSelection<float>::scan_impl(ItemPnValueSelectItem<float> const* selected_item) const
{ 
  float value = *this->m_value_p;
  float selected_value = selected_item->value();
  if (feqf(value, selected_value))      
    brow_SetRadiobutton(selected_item->get_node(), 0, 1);
  else
    brow_SetRadiobutton(ItemPn::m_node, 0, 0);
}

template<>
inline void ItemPnParameterSelection<double>::scan_impl(ItemPnValueSelectItem<double> const* selected_item) const
{   
  double value = *this->m_value_p;
  double selected_value = selected_item->value();
  if (feq(value, selected_value))  
    brow_SetRadiobutton(selected_item->get_node(), 0, 1);
  else
    brow_SetRadiobutton(ItemPn::m_node, 0, 0);
}

template<>
inline void ItemPnParameterSelection<float>::select(ItemPnValueSelectItem<float>* selected_item)
{
  *this->m_value_p = selected_item->value();    
    
  brow_SetAnnotation(ItemPn::m_node, 1, selected_item->m_name.c_str(), selected_item->m_name.length());
  // Close this node, for this class we have a saved reference to attrnav as e member variable
  double node_x, node_y;
  brow_GetNodePosition(ItemPn::m_node, &node_x, &node_y);
  ItemPn::close(ItemPn::m_attrnav, node_x, node_y);
}

template<>
inline void ItemPnParameterSelection<double>::select(ItemPnValueSelectItem<double>* selected_item)
{
  *this->m_value_p = selected_item->value();    
    
  brow_SetAnnotation(ItemPn::m_node, 1, selected_item->m_name.c_str(), selected_item->m_name.length());
  // Close this node, for this class we have a saved reference to attrnav as e member variable
  double node_x, node_y;
  brow_GetNodePosition(ItemPn::m_node, &node_x, &node_y);
  ItemPn::close(ItemPn::m_attrnav, node_x, node_y);
}

template<>
inline void ItemPnParameterSelection<float>::setup_node()
{
  std::string annotation;
  float value = *this->m_value_p;
  
  if (m_ref->_ValueItem)
  {
    for (auto const& assign : m_ref->_ValueItem->_Assignments)
    {
      if (assign._Content == value)
      {
        annotation = *assign._Text;
        break;
      }
    }
  }
  brow_SetAnnotation(ItemPn::m_node, 1, annotation.c_str(), annotation.length());
}

template<>
inline void ItemPnParameterSelection<double>::setup_node()
{
  std::string annotation;
  double value = *this->m_value_p;
  
  // Do we do this for doubles??? TODO 
  // value = interpreter.to_host_value(*this->m_value_p);    
  if (m_ref->_ValueItem)
  {
    for (auto const& assign : m_ref->_ValueItem->_Assignments)
    {
      if (assign._Content == value)
      {
        annotation = *assign._Text;
        break;
      }
    }
  }
  brow_SetAnnotation(ItemPn::m_node, 1, annotation.c_str(), annotation.length());
}

// Mostly here to satisfy the compiler since i don't beleive there are floating point value items in existence
template<>
inline int ItemPnParameterSelection<float>::open_children_impl()
{
  // TODO If the need arises, implement something to populate a list of values when there are no assignments
  // If we have assignments
  for (auto const& assign : m_ref->_ValueItem->_Assignments)
  {
    new ItemPnValueSelectItem<float>(ItemPn::m_attrnav, assign._Text->c_str(), "", this, this->m_value_p, static_cast<float>(assign._Content), assign._Text->c_str(), ItemPn::m_node, flow_eDest_IntoLast);
  }
  return 1;
}

// Mostly here to satisfy the compiler since i don't beleive there are floating point value items in existence
template<>
inline int ItemPnParameterSelection<double>::open_children_impl()
{
  // TODO If the need arises, implement something to populate a list of values when there are no assignments
  // If we have assignments
  for (auto const& assign : m_ref->_ValueItem->_Assignments)
  {
    new ItemPnValueSelectItem<double>(ItemPn::m_attrnav, assign._Text->c_str(), "", this, this->m_value_p, static_cast<double>(assign._Content), assign._Text->c_str(), ItemPn::m_node, flow_eDest_IntoLast);
  }
  return 1;
}

/*
  ========================================= END Specializations for ParameterSelection =======================================
*/

#endif
