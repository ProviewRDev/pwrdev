/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef cow_pn_gsdml_attrnav_h
#define cow_pn_gsdml_attrnav_h

/* cow_pn_gsdml_attrnav.h -- Profibus gsd configurator navigator */

#include <memory>

#include "flow_browapi.h"

#include "cow_pn_gsdml_attr.h"

#define pn_cModuleClassFile "$pwr_exe/pn_module_classes.dat"

typedef enum
{
  attrnav_eItemType_,
  attrnav_eItemType_PnBase, // Base item for input values such as IP, MAC
  attrnav_eItemType_PnEnumValue, // Generic Enumeration value, used in PnEnum's
  attrnav_eItemType_PnDevice, // The DAP selection class, need a better name
  attrnav_eItemType_PnIDSelectValue, // Selection of ID for a module or submodule
  attrnav_eItemType_PnNetwork, // Displays the network settings
  attrnav_eItemType_PnEnumYesNo, // Simple enum for a Yes/No selection
  attrnav_eItemType_PnDeviceInfo,
  attrnav_eItemType_PnDAP, // The actual DAP selected by the PnDevice class
  attrnav_eItemType_PnInterfaceSubmodule, // Represents the interface submodule in the DAP
  attrnav_eItemType_PnPortSubmodule, // Represents the selcted port submodule in the DAP
  attrnav_eItemType_PnSlot, // A slot in which you can fit a Module
  attrnav_eItemType_PnSubslot, // A subslot in which a Submodule can go
  attrnav_eItemType_PnSubslotPhys, // Not used yet
  attrnav_eItemType_PnModuleInfo, // Displays the element ModuleInfo
  attrnav_eItemType_PnModuleSelect, // Selects a module to go in a Slot for instance
  attrnav_eItemType_PnSubmoduleSelection,
  attrnav_eItemType_PnSubmoduleType, // Selects a submodule to go in a subslot. Need a new name
  attrnav_eItemType_PnParRecord, // A ParameterRecordDataItem
  attrnav_eItemType_PnParValue, // A Parameter value input
  attrnav_eItemType_PnParEnum, // A Parameter enumeration when selecting from a (often smaller) known set of values
  attrnav_eItemType_PnParEnumBit, // THe actual value selection when ParEnum is a bit
  attrnav_eItemType_PnParEnumValue, // The actual value selection when ParEnum is not a bit.
  attrnav_eItemType_PnModuleClass,
  attrnav_eItemType_PnIOData,
  attrnav_eItemType_PnInput,
  attrnav_eItemType_PnOutput,
  attrnav_eItemType_PnDataItem,
  attrnav_eItemType_PnBitDataItem,
  attrnav_eItemType_PnEnumByteOrder,
  attrnav_eItemType_PnEnumTimeRatio,
  attrnav_eItemType_PnEnumSendClock,
  attrnav_eItemType_PnEnumValueMType,

  attrnav_eItemType_PnValueSelectItem,
  attrnav_eItemType_PnValueInput,
  attrnav_eItemType_PnEnumRTClass,
  attrnav_eItemType_PnSkipIPAssignment
} attrnav_eItemType;

typedef enum
{
  attrnav_mOpen_All = ~0,
  attrnav_mOpen_Children = 1 << 0,
  attrnav_mOpen_Attributes = 1 << 1
} attrnav_mOpen;

class ItemPn;

//! Class for handling of brow.
class GsdmlAttrNavBrow
{
public:
  GsdmlAttrNavBrow(BrowCtx* brow_ctx, void* xn) : ctx(brow_ctx), attrnav(xn) {}
  ~GsdmlAttrNavBrow();

  BrowCtx* ctx;
  void* attrnav;
  brow_tNodeClass nc_object;
  brow_tNodeClass nc_attr;
  brow_tNodeClass nc_attr_multiline;
  brow_tNodeClass nc_table;
  brow_tNodeClass nc_header;
  brow_tNodeClass nc_table_header;
  brow_tNodeClass nc_enum;
  brow_tNodeClass nc_enum_mtype;
  flow_sAnnotPixmap* pixmap_leaf;
  flow_sAnnotPixmap* pixmap_map;
  flow_sAnnotPixmap* pixmap_openmap;
  flow_sAnnotPixmap* pixmap_attr;
  flow_sAnnotPixmap* pixmap_attrarray;
  flow_sAnnotPixmap* pixmap_attrenum;

  void free_pixmaps();
  void allocate_pixmaps();
  void create_nodeclasses();
  void brow_setup();
};

class CoWow;
class CoWowTimer;

//! The navigation area of the attribute editor.
class GsdmlAttrNav
{
public:
  GsdmlAttrNav(void* xn_parent_ctx, const char* xn_name, pn_gsdml* xn_gsd,
               int xn_edit_mode,
               std::shared_ptr<ProfinetRuntimeData> pwr_pn_data,
               pwr_tStatus* status);
  virtual ~GsdmlAttrNav();

  virtual void display_attr_help_text() {}
  virtual void set_inputfocus() {}

  void start_trace(pwr_tObjid Objid, char* object_str);
  int set_attr_value(const char* value_str);
  int check_attr_value(std::string& p_value);
  int get_select(pwr_sAttrRef* attrref, int* is_attr);
  void message(char sev, const char* text);
  void force_trace_scan();
  int object_attr();
  void print(char* filename);
  int get_select(ItemPn** item);
  void zoom(double zoom_factor);
  void unzoom();
  void get_zoom(double* zoom_factor);
  void set_modified(bool value) { modified = value; }
  bool is_modified() { return modified; }
  int save(const char* filename);
  int open(const char* filename);
  void collapse();
  void expand_all();
  void redraw();
  void set_viewio(int set) { viewio = set; }
  int search_class(const char* filename, const char* model, const char* module,
                   char* mclass);
  void set_order_moduletype(attr_eOrderModuleType type)
  {
    order_moduletype = type;
  }

  /* static member function */
  static void trace_scan(void* data);
  static int trace_scan_bc(brow_tObject object, void* p);
  static int trace_connect_bc(brow_tObject object, char* name, char* attr,
                              flow_eTraceType type, void** p);
  static int trace_disconnect_bc(brow_tObject object);
  static int init_brow_cb(FlowCtx* fctx, void* client_data);
  // static int attr_string_to_value(int type_id, const char* value_str,
  //                                 void* buffer_ptr, int buff_size,
  //                                 int attr_size);
  // static void attr_value_to_string(int type_id, void const* value_ptr,
  //                                  char* str, int size, int* len, char* format);
  static int brow_cb(FlowCtx* ctx, flow_tEvent event);
  static void device_changed_ok(void* ctx, void* data);
  static void device_changed_cancel(void* ctx, void* data);
  static pwr_tBoolean device_check_change_ok(void* ctx);
  static void device_update_change(void* ctx);

  /* member variables */
  void* parent_ctx;
  pn_gsdml* gsdml;
  pwr_tString256 m_name;
  GsdmlAttrNavBrow* brow;
  attr_sItem* itemlist;
  int item_cnt;
  int edit_mode;
  int trace_started;
  void (*message_cb)(void*, char, const char*);
  void (*change_value_cb)(void*);
  CoWow* m_wow;
  CoWowTimer* trace_timerid;
  // unsigned int device_num; TODO Really needed? This data is always accessible
  // through pn_runtime_data....
  //gsdml_DeviceAccessPointItem* device_item;
  std::shared_ptr<GSDML::DeviceAccessPointItem> m_selected_device_item;
  int device_confirm_active;
  GsdmlDeviceData dev_data;
  // static ProfinetRuntimeData pn_runtime_data;
  std::shared_ptr<ProfinetRuntimeData> pn_runtime_data;
  int device_read;
  int viewio;
  // unsigned int time_ratio;
  // unsigned int send_clock;
  // unsigned int phase;
  attr_eOrderModuleType order_moduletype;

private:
  bool modified;
};

class ItemPn
{
public:
  // ItemPn() : m_value_type(pwr_eType_), m_is_parent(0), m_first_scan(1), m_noedit(1), m_has_settings(false) {}
  // ItemPn(char const* infotext)
  //     : m_value_type(pwr_eType_), m_is_parent(0), m_infotext(infotext ? infotext : ""), m_first_scan(1),
  //       m_noedit(1), m_has_settings(false)
  // {
  // }
  ItemPn(GsdmlAttrNav* attrnav, attrnav_eItemType type, std::string name, std::string infotext,
         int is_parent = 0)
      : m_type(type), m_value_type(pwr_eType_), m_name(name), m_is_parent(is_parent), m_infotext(infotext),
        m_first_scan(1), m_noedit(1), m_has_settings(false), m_attrnav(attrnav)
  {
  }

  attrnav_eItemType m_type;  
  pwr_eType m_value_type; // If a subclass of this class is a carrier of data we can deduce what type of data using this.
  brow_tNode m_node;
  std::string m_name;
  int m_is_parent;
  std::string m_infotext;
  int m_first_scan;
  int m_noedit;
  bool m_has_settings;
  GsdmlAttrNav* m_attrnav;

  virtual ~ItemPn() = default;

  // Open the node, missleading name saying open children...
  virtual int open_children(GsdmlAttrNav* attrnav, double x, double y) final;
  virtual int open_children_impl() = 0;


  // The item is selected, such as an enum being selected, a parent about to be
  // opened, or a parameter value...
  // Use ( in brow_cb() ) to call templated implementation specifics to regain RTTI
  virtual void selected(GsdmlAttrNav* attrnav){};

  // Called when user types input in a command input field
  // Use to call templated implementation specifics to regain RTTI
  virtual void value_changed(GsdmlAttrNav* attrnav, const char* value_str) {}

  // If this is a value of some sort. Return string representation as an rvalue ref
  virtual std::string&& to_string() { return std::move(std::string("")); }

  int virtual close(GsdmlAttrNav* attrnav, double x, double y) const final;
  virtual int scan(GsdmlAttrNav* attrnav, void* p) { return 1; }
  
  virtual void update(GsdmlAttrNav* attrnav) {} //TODO What's this?
};

/*
  Display Information as text/numbers
*/
class ItemPnInfo : public ItemPn
{
public:
  ItemPnInfo(GsdmlAttrNav* attrnav, const char* item_name,
             const char* trace_attr_name, pwr_eType pwr_type_id, size_t attr_size,
             void const* value_p, brow_tNode dest, flow_eDest dest_code, const char* infotext);

  pwr_eType m_pwr_type_id;

  int open_children_impl() override { return 1; } // Must override for concrete class
};

/*
  A normal attribute, int, float, string and so on.
*/
class ItemPnBase : public ItemPn
{
public:
  ItemPnBase(GsdmlAttrNav* attrnav, const char* item_name,
             const char* trace_attr_name, pwr_eType attr_type, size_t attr_size,
             double attr_min_limit, double attr_max_limit, void* attr_value_p,
             int attr_noedit, brow_tNode dest, flow_eDest dest_code, const char* infotext);

  void* m_value_p;
  void const* m_const_value_p;
  pwr_tString256 m_old_value;
  
  size_t m_size;
  double m_min_limit;
  double m_max_limit;
  //int m_subgraph;

  virtual int scan(GsdmlAttrNav* attrnav, void* value) override;
  virtual void value_changed(GsdmlAttrNav* attrnav,
                             const char* value_str) override;
  int open_children_impl() override { return 1; }
};

class ItemPnIDSelectValue : public ItemPn
{
public:
  ItemPnIDSelectValue(GsdmlAttrNav* attrnav, const char* item_name,
                   std::string id_enum_value, std::string* id_p,
                   brow_tNode dest, flow_eDest dest_code,
                   const char* info_text = 0);
  std::string m_id_enum_value;
  std::string* m_id;
  std::string m_old_value;

  void selected(GsdmlAttrNav* attrnav) override;
  int scan(GsdmlAttrNav* attrnav, void* mod_id_p);
  int open_children_impl() override { return 1; }
};

//! Item for a generic enum attribute.
class ItemPnEnumValue : public ItemPn
{
public:
  ItemPnEnumValue(GsdmlAttrNav* attrnav, const char* item_name,
                  int item_enum_value, pwr_eType item_type_id,
                  void* attr_value_p, brow_tNode dest, flow_eDest dest_code,
                  const char* info_text = 0);
  int m_enum_value;
  pwr_eType m_type_id;
  void* m_value_p;
  int m_old_value;

  int scan(GsdmlAttrNav* attrnav, void* p);
  int open_children_impl() override { return 1; }
};

//! Item for an enum attribute.
// class ItemPnEnumValueMType : public ItemPn
// {
// public:
//   ItemPnEnumValueMType(GsdmlAttrNav* attrnav, const char* item_name,
//                        const char* item_number, int item_num, int item_type_id,
//                        void* attr_value_p, brow_tNode dest,
//                        flow_eDest dest_code, const char* info_text = 0);
//   int num;
//   int type_id;
//   void* value_p;
//   int old_value;
//   int first_scan;
//   char number[80];

//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for a device aka DAP. A DAP can be considered just like a module only that it's always mounted in slot 0.
// Therefore it makes use of the ItemPnModuleEnumValue for selecting what DAP to use...
class ItemPnDevice : public ItemPn
{
public:
  ItemPnDevice(GsdmlAttrNav* attrnav, const char* item_name, brow_tNode dest,
               flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnDevice() {}

  std::string m_old_value;

  int open_children_impl();
  int scan(GsdmlAttrNav* attrnav, void* value_p);
};

//! Item for a slot.
class ItemPnSlot : public ItemPn
{
public:
  ItemPnSlot(GsdmlAttrNav* attrnav, const char* item_name,
             ProfinetSlot* item_slotdata, brow_tNode dest,
             flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnSlot() {}

  ProfinetSlot* m_slotdata;
  std::string m_old_value;

  int open_children_impl();
  int scan(GsdmlAttrNav* attrnav, void* p);
};

//! Item for a subslot.
class ItemPnSubslot : public ItemPn
{
public:
  ItemPnSubslot(GsdmlAttrNav* attrnav, const char* item_name,
                ProfinetSubslot* subslot_data,
                std::shared_ptr<GSDML::ModuleItem> parent_module_item,
                uint subslot_number,
                std::shared_ptr<GSDML::SubmoduleItem> attached_submodule_item,
                brow_tNode dest, flow_eDest dest_code, const char* infotext);

  ProfinetSubslot* m_subslot_data;
  std::shared_ptr<GSDML::ModuleItem> m_parent_module_item;
  uint m_subslot_number;
  bool m_is_selectable; 
  std::shared_ptr<GSDML::SubmoduleItem> m_attached_submodule_item;   

  // Trace compare
  std::string m_old_value;

  int open_children_impl() override;
  int scan(GsdmlAttrNav* attrnav, void* dummy_p) override;

private:
  void display_interface_submodule();
  void display_port_submodule();
};

//! Item for a physical subslot.
class ItemPnSubmoduleSelection : public ItemPn
{
public:
  ItemPnSubmoduleSelection(GsdmlAttrNav* attrnav, const char* item_name,
                    ProfinetSubslot* subslot_data,
                    uint subslot_number,
                    std::shared_ptr<GSDML::ModuleItem> module_item,
                    brow_tNode dest, flow_eDest dest_code, const char* infotext);
  
  ProfinetSubslot* m_subslot_data;  
  std::shared_ptr<GSDML::ModuleItem> m_module_item;
  int m_subslot_number;
  std::string m_old_value;

  int open_children_impl();
  int scan(GsdmlAttrNav* attrnav, void* id_p);
};

//! Item for the DeviceAccessPoint, slot 0
class ItemPnDAP : public ItemPn
{
public:
  ItemPnDAP(GsdmlAttrNav* attrnav, const char* item_name,
            ProfinetSlot* item_slotdata, brow_tNode dest, flow_eDest dest_code, const char* infotext);

  ProfinetSlot* m_slotdata;

  virtual int open_children_impl();
};

//! Item for Network settings
class ItemPnNetwork final : public ItemPn
{
public:
  ItemPnNetwork(GsdmlAttrNav* attrnav, const char* item_name, brow_tNode dest,
                flow_eDest dest_code, const char* infotext);

  int open_children_impl() final;
};

//! Item for Network settings
class ItemPnDeviceInfo : public ItemPn
{
public:
  ItemPnDeviceInfo(GsdmlAttrNav* attrnav, const char* item_name,
                   brow_tNode dest, flow_eDest dest_code, const char* infotext);
  
  int open_children_impl() override;
};

//! Item for an InterfaceSubmoduleItem (Not a subslot but the actual module)
// class ItemPnInterfaceSubmodule : public ItemPn
// {
// public:
//   ItemPnInterfaceSubmodule(GsdmlAttrNav* attrnav, const char* item_name,
//                            std::shared_ptr<GSDML::InterfaceSubmoduleItem> interface_submodule_item,
//                            ProfinetSubslot* subslot_data, brow_tNode dest, flow_eDest dest_code);  

//   std::shared_ptr<GSDML::InterfaceSubmoduleItem> m_interface_submodule_item;
//   ProfinetSubslot* m_subslot_data;
  
//   int open_children(GsdmlAttrNav* attrnav, double x, double y) override;
// };

//! Item for a PortSubmoduleItem
// class ItemPnPortSubmodule : public ItemPn
// {
// public:
//   ItemPnPortSubmodule(GsdmlAttrNav* attrnav, const char* item_name,
//                       std::shared_ptr<GSDML::PortSubmoduleItem> port_submodule_item,
//                       ProfinetSubslot* subslot_data, brow_tNode dest,
//                       flow_eDest dest_code);

//   std::shared_ptr<GSDML::PortSubmoduleItem> m_port_submodule_item;
//   ProfinetSubslot* m_subslot_data;
  
//   int open_children(GsdmlAttrNav* attrnav, double x, double y) override;
// };

//! Item for a moduleinfo.
class ItemPnModuleInfo : public ItemPn
{
public:
  ItemPnModuleInfo(GsdmlAttrNav* attrnav, const char* item_name,
                   GSDML::ModuleInfo* item_info, brow_tNode dest,
                   flow_eDest dest_code, const char* infotext);

  GSDML::ModuleInfo* m_module_info;

  virtual int open_children_impl();
};

// ! Item for module type selection.
// class ItemPnModuleSelect : public ItemPn
// {
// public:
//   ItemPnModuleSelect(GsdmlAttrNav* attrnav, const char* item_name,
//                    int item_slot_number, int item_slot_idx, brow_tNode dest,
//                    flow_eDest dest_code);
//   virtual ~ItemPnModuleSelect() {}

//   int m_slot_number;
//   int m_slot_idx;
//   int m_old_value; // Use string?  

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for submodule type selection.
// class ItemPnSubmoduleType : public ItemPn
// {
// public:
//   ItemPnSubmoduleType(GsdmlAttrNav* attrnav, const char* item_name,
//                       int item_subslot_number, int item_slot_idx,
//                       int item_subslot_idx, gsdml_UseableSubmodules* item_us,
//                       brow_tNode dest, flow_eDest dest_code);
//   virtual ~ItemPnSubmoduleType() {}

//   int subslot_number;
//   int slot_idx;
//   int subslot_idx;
//   gsdml_UseableSubmodules* us;
//   int old_value;
//   int first_scan;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for module type selection.
class ItemPnParRecord : public ItemPn
{
public:
  ItemPnParRecord(
      GsdmlAttrNav* attrnav, const char* item_name,
      GSDML::ParameterRecordDataItem const* parameter_record_data_item,
      ProfinetDataRecord* data_record, brow_tNode dest, flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnParRecord() {}

  GSDML::ParameterRecordDataItem const* m_parameter_record_data_item;
  ProfinetDataRecord* m_data_record;

  virtual int open_children_impl();

private:
  void set_default_data();
};

//! Item for module type selection.
class ItemPnParValue : public ItemPn
{
public:
  ItemPnParValue(GsdmlAttrNav* attrnav, const char* item_name, std::shared_ptr<GSDML::Ref> ref,
                 unsigned char* data, brow_tNode dest, flow_eDest dest_code, const char* infotext);
  ~ItemPnParValue() { if (m_old_value) delete m_old_value; m_old_value = (unsigned char*)0; };

  std::shared_ptr<GSDML::Ref> m_ref;
  GSDML::eValueDataType m_gsdml_datatype;
  unsigned char* m_data;
  unsigned int m_byte_offset;
  unsigned int m_size;
  unsigned char* m_old_value;

  int scan(GsdmlAttrNav* attrnav, void* p);
  void value_changed(GsdmlAttrNav* attrnav, const char* value_str);
  int open_children_impl() override { return 1; }
};

class ParEnumValue
{
public:
  ParEnumValue() {}
  //unsigned int value;
  int value;
  //char text[160];
  std::string text;
};

//! Item for module type selection.
class ItemPnParEnum : public ItemPn
{
public:
  ItemPnParEnum(GsdmlAttrNav* attrnav, const char* item_name, std::shared_ptr<GSDML::Ref> ref, unsigned char* data,
                brow_tNode dest, flow_eDest dest_code, const char* infotext);
  ~ItemPnParEnum() = default;

  std::shared_ptr<GSDML::Ref> m_ref;
  GSDML::eValueDataType m_gsdml_datatype;
  unsigned char* m_data;
  unsigned int m_byte_offset;
  unsigned int m_bit_offset;
  unsigned int m_bit_length;
  std::vector<ParEnumValue> m_values; // Will be populated with valid values from which we can choose from, depending on valueitemttargets and the allowed values.
  unsigned int m_mask;
  unsigned int m_old_value;

  int open_children_impl() override;
  int scan(GsdmlAttrNav* attrnav, void* p) override;
};

//! Item for module type selection.
class ItemPnParEnumBit : public ItemPn
{
public:
  ItemPnParEnumBit(GsdmlAttrNav* attrnav, const char* item_name,
                   GSDML::eValueDataType gsdml_datatype, unsigned char* data,
                   unsigned int byte_offset, unsigned int enum_value,
                   unsigned int mask, int noedit, brow_tNode dest,
                   flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnParEnumBit() {}

  //gsdml_Assign* assign;
  GSDML::eValueDataType m_gsdml_datatype;
  unsigned char* m_data;
  unsigned int m_byte_offset;
  unsigned int m_enum_value;
  unsigned int m_mask;
  unsigned int m_old_value;

  int scan(GsdmlAttrNav* attrnav, void* p);
  void update(GsdmlAttrNav* attrnav);
  int open_children_impl() override { return 1; }
};

class ItemPnParEnumValue : public ItemPn
{
public:
  ItemPnParEnumValue(GsdmlAttrNav* attrnav, const char* item_name,
                     GSDML::eValueDataType gsdml_datatype,
                     unsigned char* data, unsigned int byte_offset, unsigned int enum_value,
                     unsigned int mask, int noedit, brow_tNode dest,
                     flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnParEnumValue() {}

  //std::shared_ptr<GSDML::Assign> m_assign;
  GSDML::eValueDataType m_gsdml_datatype;
  unsigned char* m_data;
  unsigned int m_byte_offset;
  unsigned int m_enum_value;
  unsigned int m_mask;
  unsigned int m_old_value;

  int scan(GsdmlAttrNav* attrnav, void* p);
  void update(GsdmlAttrNav* attrnav);
  int open_children_impl() override { return 1; }
};

//! Item for a IOData.
class ItemPnIOData : public ItemPn
{
public:
  ItemPnIOData(GsdmlAttrNav* attrnav, const char* item_name,
               GSDML::IOData* iodata, ProfinetSubslot* subslot, brow_tNode dest,
               flow_eDest dest_code, const char* infotext);
  virtual ~ItemPnIOData() {}

  GSDML::IOData* m_iodata;
  ProfinetSubslot* m_subslot;

  int open_children_impl();
};

//! Item for a Input.
// class ItemPnInput : public ItemPn
// {
// public:
//   ItemPnInput(GsdmlAttrNav* attrnav, const char* item_name,
//               gsdml_Input* item_input, brow_tNode dest, flow_eDest dest_code);
//   virtual ~ItemPnInput() {}

//   gsdml_Input* input;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
// };

//! Item for a Output.
// class ItemPnOutput : public ItemPn
// {
// public:
//   ItemPnOutput(GsdmlAttrNav* attrnav, const char* item_name,
//                gsdml_Output* item_output, brow_tNode dest,
//                flow_eDest dest_code);
//   virtual ~ItemPnOutput() {}

//   gsdml_Output* output;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
// };

//! Item for a DataItem.
// class ItemPnDataItem : public ItemPn
// {
// public:
//   ItemPnDataItem(GsdmlAttrNav* attrnav, const char* item_name,
//                  gsdml_DataItem* item_dataitem, brow_tNode dest,
//                  flow_eDest dest_code);
//   virtual ~ItemPnDataItem() {}

//   gsdml_DataItem* dataitem;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
// };

//! Item for a BitDataItem.
// class ItemPnBitDataItem : public ItemPn
// {
// public:
//   ItemPnBitDataItem(GsdmlAttrNav* attrnav, const char* item_name,
//                     gsdml_BitDataItem* item_bitdataitem, brow_tNode dest,
//                     flow_eDest dest_code);
//   virtual ~ItemPnBitDataItem() {}

//   gsdml_BitDataItem* bitdataitem;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
// };

//! Item for module class selection.
class ItemPnModuleClass : public ItemPn
{
public:
  ItemPnModuleClass(GsdmlAttrNav* attrnav, const char* item_name,
                    GsdmlSlotData* item_slotdata, brow_tNode dest,
                    flow_eDest dest_code);
  virtual ~ItemPnModuleClass() {}

  GsdmlSlotData* slotdata;
  int old_value;
  int first_scan;

  int open_children_impl(GsdmlAttrNav* attrnav, double x, double y);
  int scan(GsdmlAttrNav* attrnav, void* p);
};

//! Item for slave byte order.
// class ItemPnEnumByteOrder : public ItemPnBase
// {
// public:
//   ItemPnEnumByteOrder(GsdmlAttrNav* attrnav, const char* item_name,
//                       const char* attr, pwr_eType attr_type, int attr_size,
//                       void* attr_value_p, int attr_noedit, brow_tNode dest,
//                       flow_eDest dest_code);
//   virtual ~ItemPnEnumByteOrder() {}

//   int old_value;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for time ratio.
// class ItemPnEnumTimeRatio : public ItemPn
// {
// public:
//   ItemPnEnumTimeRatio(GsdmlAttrNav* attrnav, const char* item_name,
//                       gsdml_InterfaceSubmoduleItem* item_interfacesubmodule,
//                       void* attr_value_p, brow_tNode dest,
//                       flow_eDest dest_code);
//   virtual ~ItemPnEnumTimeRatio() {}

//   gsdml_InterfaceSubmoduleItem* interfacesubmodule;
//   void* value_p;
//   char valuelist_str[200];
//   int first_scan;
//   int old_value;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

//! Item for send clock.
// class ItemPnEnumSendClock : public ItemPn
// {
// public:
//   ItemPnEnumSendClock(GsdmlAttrNav* attrnav, const char* item_name,
//                       gsdml_InterfaceSubmoduleItem* item_interfacesubmodule,
//                       void* attr_value_p, brow_tNode dest,
//                       flow_eDest dest_code);
//   virtual ~ItemPnEnumSendClock() {}

//   gsdml_InterfaceSubmoduleItem* interfacesubmodule;
//   void* value_p;
//   char valuelist_str[200];
//   int first_scan;
//   int old_value;

//   int open_children(GsdmlAttrNav* attrnav, double x, double y);
//   int scan(GsdmlAttrNav* attrnav, void* p);
// };

class ItemPnEnumYesNo : public ItemPn
{
public:
  ItemPnEnumYesNo(GsdmlAttrNav* attrnav, const char* item_name,
                  int* attr_value_p, brow_tNode dest, flow_eDest dest_code,
                  char const* infotext = 0);
  virtual ~ItemPnEnumYesNo() {}

  int* m_value_p;
  int m_old_value;

  int open_children_impl() override;
  int scan(GsdmlAttrNav* attrnav, void* value_p) override;
};

template<typename T>
class IHasSelectables;

// template<typename T>
// class ISelectable
// {
// public:
//   explicit ISelectable(IHasSelectables<T>* parent, T select_value) : m_select_value(select_value), m_parent(parent) {}
//   virtual ~ISelectable() = default;

//   virtual void unselect() = 0;
//   virtual void select() = 0;

//   bool m_is_selected;
//   T m_select_value;
//   IHasSelectables<T>* m_parent;
// };

// template<typename T>
// class IHasSelectables
// {
// public:
//   explicit IHasSelectables(T* value_p) : m_value_p(value_p) {}
//   virtual ~IHasSelectables() = default;
//   virtual void select(ISelectable<T>* selectable) final {
//     for (auto s : m_selectables)
//       s.second->unselect();
//     selectable->select();
//     select_impl(selectable);
//   }
//   virtual void select_impl(ISelectable<T>* selectable) = 0;

//   T* m_value_p;
//   std::map<size_t, ISelectable<T>*> m_selectables;
// };

// template<typename T>
// class ItemPnValueSelectionItem : public ItemPn, public ISelectable<T>
// {
// public:
//   ItemPnValueSelectionItem(GsdmlAttrNav* attrnav, pwr_eType value_type, const char* name,
//       IHasSelectables<T>* parent, T select_value, const char* infotext,
//       brow_tNode dest, flow_eDest dest_code) 
//     : ItemPn(attrnav_eItemType_PnValueSelectionItem, name, infotext),
//       ISelectable<T>(parent, select_value)
//   {
//     m_value_type = value_type;
//     brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_enum, dest,
//                   dest_code, (void*)this, 1, &m_node);

//     brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_attr);
//     brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
    
//     // Set if this is selected or not    
//     brow_SetRadiobutton(m_node, 0, 0);
//     // add call to parent->select("this") to brow_cb
//     //brow_SetTraceAttr(m_node, m_name.c_str(), "", flow_eTraceType_User);
//   }
  
//   void select() override { brow_SetRadiobutton(m_node, 0, 1); }

//   void unselect() override { brow_SetRadiobutton(m_node, 0, 0); }
// };

// TODO continue with the templated value item input/select classes that use the "trace functionality" to replace all other
// brow_cb need to cast depending on parent_type, and event is catched using ItemPnValueSelectItem/ItemPnValueInput class enums

/*
==================================================== NEW CLASSES ====================================================
*/

/*
======================= TEMPLATES CLASSES FOR CHANGING CONFIGURATION PROPERTIES =======================
*/

template<typename T>
class ItemPnValueSelectItem;

template<typename T>
class ISelection
{
public:
  explicit ISelection(T* value_p) : m_value_p(value_p) {}
  virtual ~ISelection() = default;
  virtual void select(ItemPnValueSelectItem<T> const* selected_item) const = 0;
  virtual void set_default(T default_value) = 0;

  T* m_value_p;  
};

template<typename T>
class ItemPnValueSelectItem : public ItemPn
{
public:
  ItemPnValueSelectItem(GsdmlAttrNav* attrnav, pwr_eType value_type, const char* annotation_1, const char* annotation_2,
      ISelection<T>* parent, T const* value_p, T select_value, const char* infotext,
      brow_tNode dest, flow_eDest dest_code) 
    : ItemPn(attrnav, attrnav_eItemType_PnValueSelectItem, annotation_1, infotext),
      m_parent(parent), m_value_p(value_p), m_select_value(select_value), m_annotation_2(annotation_2)
  {
    m_value_type = value_type;    
    brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_enum, dest,
                  dest_code, (void*)this, 1, &m_node);

    brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_attr);
    brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
    if (m_annotation_2 != "")
      brow_SetAnnotation(m_node, 1, m_annotation_2.c_str(), m_annotation_2.length());
    brow_SetTraceAttr(m_node, m_name.c_str(), "", flow_eTraceType_User);
  }
  
  int scan(GsdmlAttrNav* attrnav, void* dummy) override
  {    
    if (!m_first_scan)
    {
      if (*m_value_p == m_old_value)
        return 1;
    }
    else
    {
      m_first_scan = 0;
    }
    
    // Control the radiobuttons
    if (*m_value_p == m_select_value)
      brow_SetRadiobutton(m_node, 0, 1);
    else
      brow_SetRadiobutton(m_node, 0, 0);

    m_old_value = *m_value_p;

    return 1;
  }

  void selected(GsdmlAttrNav* attrnav) override
  {
    m_parent->select(this);
  }

  T const& value() const { return m_select_value; }

  int open_children_impl() override { return 1; }

private:
  ISelection<T> const* m_parent;
  T const* m_value_p;
  T const m_select_value;
  T m_old_value;
  std::string m_annotation_2;
};

template<typename T>
class ItemPnValueInput : public ItemPn
{
public:
  ItemPnValueInput(GsdmlAttrNav* attrnav, pwr_eType value_type, const char* annotation_1, const char* annotation_2,
      T* value_p, const char* infotext, brow_tNode dest, flow_eDest dest_code) 
    : ItemPn(attrnav, attrnav_eItemType_PnValueInput, annotation_1, infotext),
      m_value_p(value_p), m_annotation_2(annotation_2)
  {
    m_value_type = value_type;   
    m_noedit = 0; 
    brow_CreateNode(attrnav->brow->ctx, m_name.c_str(), attrnav->brow->nc_attr, dest,
                  dest_code, (void*)this, 1, &m_node);

    brow_SetAnnotPixmap(m_node, 0, attrnav->brow->pixmap_attr);
    brow_SetAnnotation(m_node, 0, m_name.c_str(), m_name.length());
    if (m_annotation_2 != "")
      brow_SetAnnotation(m_node, 1, m_annotation_2.c_str(), m_annotation_2.length());
    brow_SetTraceAttr(m_node, m_name.c_str(), "", flow_eTraceType_User);
  }
  
  int scan(GsdmlAttrNav* attrnav, void* value_p) override
  {  
    T* value = (T*)value_p;

    if (!m_first_scan)
    {
      if (*value == m_old_value)
        return 1;
    }
    else
    {
      m_first_scan = 0;
    }
    
    // Do something if the data has changed...    
    m_old_value = *value;

    return 1;
  }  

  void value_changed(GsdmlAttrNav* attrnav, const char* value_str) override
  {
    std::cout << "Value changed called, value: " << value_str << std::endl;

    value_changed_impl(attrnav, value_str);
  }

  std::string&& to_string() override
  {
    std::ostringstream result(std::ios_base::out);
    result.precision(12); // For when this is a float/double    
    result << std::fixed << *m_value_p;
    
    std::string value(result.str());
    return std::move(value);    
  }

  virtual void value_changed_impl(GsdmlAttrNav* attrnav, const char* value_str) = 0;

  int open_children_impl() override { return 1; }

private:  
  T* m_value_p;  
  T m_old_value;
  std::string m_annotation_2;
};



/*
  ======================================== "CONCRETE" IMPLEMENTATIONS ========================================
*/
/*
  RT_CLASS Selection item
  Used together with ItemPnEnumValue (for the values...)
*/
class ItemPnEnumRTClass : public ItemPn, public ISelection<std::string>
{
public:
  ItemPnEnumRTClass(GsdmlAttrNav* attrnav, const char* name,
                    std::shared_ptr<GSDML::InterfaceSubmoduleItem> interface_submodule_item,
                  std::string* pwr_pn_value_p, brow_tNode dest, flow_eDest dest_code);
  virtual ~ItemPnEnumRTClass() {}

  std::shared_ptr<GSDML::InterfaceSubmoduleItem> m_interface_submodule_item;  
  
  int open_children_impl() override;  
  void select(ItemPnValueSelectItem<std::string> const* selected_item) const override;
  void set_default(std::string default_value) override;
};

class ItemPnSkipIPAssignment : public ItemPn, public ISelection<bool>
{
public:
  ItemPnSkipIPAssignment(GsdmlAttrNav* attrnav, const char* name,
                  bool* pwr_pn_value_p, brow_tNode dest, flow_eDest dest_code);
  virtual ~ItemPnSkipIPAssignment() {}

  int open_children_impl() override;  
  void select(ItemPnValueSelectItem<bool> const* selected_item) const override;
  void set_default(bool default_value) override;
};

class ItemPnIPv4Input : public ItemPnValueInput<std::string>
{
public:
  ItemPnIPv4Input(GsdmlAttrNav* attrnav, const char* name, const char* extra_text,
      std::string* value_p, const char* infotext, brow_tNode dest, flow_eDest dest_code);
  virtual ~ItemPnIPv4Input() {}

  void value_changed_impl(GsdmlAttrNav* attrnav, const char* value_str) override;

  // int open_children_impl() override { return 1; };    
  // int scan(GsdmlAttrNav* attrnav, void* string_value) override;

  // void set_default(std::string default_value);
  // void update_value(std::string new_value);  
};

template<typename T>
class ItemPnParameterInput : public ItemPnValueInput<T>
{
public:
  ItemPnParameterInput(GsdmlAttrNav* attrnav, const char* name, const char* extra_text,
      T* value_p, const char* infotext, brow_tNode dest, flow_eDest dest_code,
      std::shared_ptr<GSDML::Ref> ref)
    : ItemPnValueInput<T>(attrnav, pwr_eType_, name, extra_text,
    value_p, infotext, dest, dest_code), m_ref(ref) {}
  virtual ~ItemPnParameterInput() = default;

  void value_changed_impl(GsdmlAttrNav* attrnav, const char* value_str) override
  {
    std::cout << "Implementation goes here for parameter input" << std::endl;
  }

private:
  std::shared_ptr<GSDML::Ref> m_ref;
  // int open_children_impl() override { return 1; };    
  // int scan(GsdmlAttrNav* attrnav, void* string_value) override;

  // void set_default(std::string default_value);
  // void update_value(std::string new_value);  
};


#endif
