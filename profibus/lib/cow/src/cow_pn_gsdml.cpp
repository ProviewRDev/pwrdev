/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2023 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* cow_pn_gsdml.cpp -- Parse gsdml file */

#include <stddef.h>
#include <stdlib.h>

#include <iostream>

#include "co_dcli.h"
#include "co_math.h"
#include "co_string.h"

#include "cow_pn_gsdml.h"
#include "rt_pb_msg.h"

pn_gsdml::pn_gsdml() { strcpy(m_gsdml_file, ""); }

pn_gsdml::~pn_gsdml() {}

void pn_gsdml::_build_diagnostics()
{
  for (pugi::xml_node& chanDiagItem : _xmlChannelDiagList->children("ChannelDiagItem"))
    _channelDiagMap.emplace(std::make_pair(chanDiagItem.attribute("ErrorType").as_uint(),
                                           GSDML::ChannelDiagItem(std::move(chanDiagItem), this)));

  for (pugi::xml_node& unitDiagTypeItem : _xmlUnitDiagTypeList->children("UnitDiagTypeItem"))
  {
    _unitDiagTypeMap.emplace(std::make_pair(unitDiagTypeItem.attribute("UserStructureIdentifier").as_uint(),
                                           GSDML::UnitDiagTypeItem(std::move(unitDiagTypeItem), this)));
  }
}

int pn_gsdml::read(const char* filename)
{
  pwr_tFileName translated_filename;

  strncpy(m_gsdml_file, filename, sizeof(m_gsdml_file));

  dcli_translate_filename(translated_filename,
                          filename); // Expand env variablies such as $pwrp_cnf to the absolute path...

  _doc.reset(new pugi::xml_document);

  pugi::xml_parse_result result = _doc->load_file(translated_filename);

  if (!result)
  {
    std::cerr << "Error reading GSDML file: " << result.description() << std::endl;
  }

  /*
    ExternalTextList - List of Text (We use PrimaryLanguage)
    Tags use attribute TextId to point out what Text tag to reference
  */
  _xmlTextIds =
      std::make_shared<pugi::xml_node>(_doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/"
                                                         "ExternalTextList/PrimaryLanguage")
                                           .node());
  _xmlCategoryList = std::make_shared<pugi::xml_node>(
      _doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/CategoryList").node());
  _xmlDeviceAccessPointList =
      std::make_shared<pugi::xml_node>(_doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/"
                                                         "DeviceAccessPointList")
                                           .node());
  _xmlModuleList = std::make_shared<pugi::xml_node>(
      _doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/ModuleList").node());
  _xmlSubmoduleList = std::make_shared<pugi::xml_node>(
      _doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/SubmoduleList").node());
  _xmlValueList = std::make_shared<pugi::xml_node>(
      _doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/ValueList").node());
  _xmlChannelDiagList = std::make_shared<pugi::xml_node>(
      _doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/ChannelDiagList").node());
  _xmlUnitDiagTypeList = std::make_shared<pugi::xml_node>(
      _doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/UnitDiagTypeList").node());

  _build_textIdList();
  _build_valueList();
  _build_diagnostics();
  _build_submoduleList();
  _build_moduleList();

  m_DeviceIdentity.reset(new GSDML::DeviceIdentity(
      _doc->select_node("/ISO15745Profile/ProfileBody/DeviceIdentity").node(), this));
  m_DeviceFunction.reset(new GSDML::DeviceFunction(
      _doc->select_node("/ISO15745Profile/ProfileBody/DeviceFunction").node(), this));

  _build_DAPs();

  return PB__SUCCESS;
}

std::shared_ptr<std::string> pn_gsdml::_get_TextId(std::string&& textId) { return _textIdMap[textId]; }

std::shared_ptr<std::string> pn_gsdml::_get_CategoryTextRef(std::string&& ID)
{
  std::string catTextId =
      _xmlCategoryList->find_child_by_attribute("CategoryItem", "ID", ID.c_str()).attribute("TextId").value();
  return _textIdMap[catTextId];
}

std::shared_ptr<std::string> pn_gsdml::_get_CategoryInfoTextRef(std::string&& ID)
{
  pugi::xml_node categoryItem = _xmlCategoryList->find_child_by_attribute("CategoryItem", "ID", ID.c_str());
  std::string textId = categoryItem.child("InfoText").attribute("TextId").value();
  return _textIdMap[textId];
}

void pn_gsdml::_build_moduleList(pugi::xml_node&& dataAccessPointItem)
{
  for (pugi::xml_node& moduleItemRef : dataAccessPointItem.child("UseableModules").children("ModuleItemRef"))
  {
    pugi::xpath_variable_set vars;
    vars.add("ID", pugi::xpath_type_string);
    std::string ID(moduleItemRef.attribute("ModuleItemTarget").value());
    vars.set("ID", ID.c_str());
    pugi::xml_node result = _xmlModuleList->select_node("//ModuleItem[@ID = $ID]", &vars).node();

    _moduleMap[std::move(ID)].reset(new GSDML::ModuleItem(std::move(result), this));
  }
}

void pn_gsdml::_build_submoduleList()
{
  // The SubmoduleList in GSDML contains both SubmoduleItem AND PortSubmoduleItem
  for (pugi::xml_node& submoduleItem : _xmlSubmoduleList->children("SubmoduleItem"))
  {
    std::string ID(submoduleItem.attribute("ID").value());
    _submoduleMap[std::move(ID)].reset(
        new GSDML::SubmoduleItem(std::move(submoduleItem), this, GSDML::SubmoduleItemType_Submodule));
  }

  for (pugi::xml_node& portSubmoduleItem : _xmlSubmoduleList->children("PortSubmoduleItem"))
  {
    std::string ID(portSubmoduleItem.attribute("ID").value());
    _submoduleMap[std::move(ID)].reset(new GSDML::PortSubmoduleItem(std::move(portSubmoduleItem), this));
  }
}

void pn_gsdml::_build_DAPs()
{
  for (pugi::xml_node& deviceAccessPointItem : _xmlDeviceAccessPointList->children("DeviceAccessPointItem"))
  {
    std::string ID(deviceAccessPointItem.attribute("ID").value());
    _deviceAccessPointMap[ID].reset(new GSDML::DeviceAccessPointItem(std::move(deviceAccessPointItem), this));
  }
}

void pn_gsdml::_build_moduleList()
{
  for (pugi::xml_node& moduleItem : _xmlModuleList->children("ModuleItem"))
  {
    std::string ID(moduleItem.attribute("ID").value());
    _moduleMap[ID].reset(new GSDML::ModuleItem(std::move(moduleItem), this));
  }
}

void pn_gsdml::_build_valueList()
{
  for (pugi::xml_node& valueItem : _xmlValueList->children("ValueItem"))
  {
    _valueMap[std::move(valueItem.attribute("ID").value())].reset(
        new GSDML::ValueItem(std::move(valueItem), this));
  }
}

void pn_gsdml::_build_textIdList()
{
  for (pugi::xml_node& text : _xmlTextIds->children("Text"))
  {
    _textIdMap[std::move(text.attribute("TextId").value())].reset(
        new std::string(text.attribute("Value").as_string()));
  }
}

std::unordered_map<ushort, GSDML::ChannelDiagItem>& pn_gsdml::getChannelDiagMap() { return _channelDiagMap; }
std::unordered_map<ushort, GSDML::UnitDiagTypeItem>& pn_gsdml::getUnitDiagTypeMap() { return _unitDiagTypeMap; }

std::unordered_map<std::string, std::shared_ptr<GSDML::ModuleItem>>& pn_gsdml::getModuleMap()
{
  return _moduleMap;
}

std::unordered_map<std::string, std::shared_ptr<GSDML::SubmoduleItem>>& pn_gsdml::getSubmoduleMap()
{
  return _submoduleMap;
}

std::unordered_map<std::string, std::shared_ptr<GSDML::ValueItem>>& pn_gsdml::getValueMap()
{
  return _valueMap;
}

std::unordered_map<std::string, std::shared_ptr<std::string>>& pn_gsdml::getTextIdMap() { return _textIdMap; }

std::unordered_map<std::string, std::shared_ptr<GSDML::DeviceAccessPointItem>>&
pn_gsdml::getDeviceAccessPointMap()
{
  return _deviceAccessPointMap;
}
