/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* cow_pn_gsdml.cpp -- Parse gsdml file */

#include <stddef.h>
#include <stdlib.h>

#include <iostream>

//#include "pwr_baseclasses.h"

#include "co_dcli.h"
#include "co_math.h"
#include "co_string.h"

#include "cow_pn_gsdml.h"
#include "rt_pb_msg.h"

pn_gsdml::pn_gsdml()
{
  strcpy(m_gsdml_file, "");
  //set_language("");
}

pn_gsdml::~pn_gsdml()
{
}

// void pn_gsdml::set_language(const char* lang)
// {
//   strncpy(current_lang, lang, sizeof(current_lang));
// }

void pn_gsdml::_build_diagnostics()
{
  for (pugi::xml_node& chanDiagItem : _xmlChannelDiagList->children("ChannelDiagItem"))
    _channelDiagMap.emplace(std::make_pair(chanDiagItem.attribute("ErrorType").as_uint(), GSDML::ChannelDiagItem(std::move(chanDiagItem), this)));
}

int pn_gsdml::read(const char* filename)
{
  //strncpy(_filename, filename, sizeof(_filename));
  pwr_tFileName translated_filename;

  strncpy(m_gsdml_file, filename, sizeof(m_gsdml_file));

  dcli_translate_filename(translated_filename, filename); // Expand env variablies such as $pwrp_cnf to the absolute path...

  _doc.reset(new pugi::xml_document);

  pugi::xml_parse_result result = _doc->load_file(translated_filename);

  /*
    ExternalTextList - List of Text (We use PrimaryLanguage)
    Tags use attribute TextId to point out what Text tag to reference
  */
  _xmlTextIds = std::make_shared<pugi::xml_node>(
      _doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/"
                        "ExternalTextList/PrimaryLanguage")
          .node());
  _xmlCategoryList = std::make_shared<pugi::xml_node>(
      _doc->select_node(
              "/ISO15745Profile/ProfileBody/ApplicationProcess/CategoryList")
          .node());
  _xmlDeviceAccessPointList = std::make_shared<pugi::xml_node>(
      _doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/"
                        "DeviceAccessPointList")
          .node());
  _xmlModuleList = std::make_shared<pugi::xml_node>(
      _doc->select_node(
              "/ISO15745Profile/ProfileBody/ApplicationProcess/ModuleList")
          .node());
  _xmlSubmoduleList = std::make_shared<pugi::xml_node>(
      _doc->select_node(
              "/ISO15745Profile/ProfileBody/ApplicationProcess/SubmoduleList")
          .node());
  _xmlValueList = std::make_shared<pugi::xml_node>(
      _doc->select_node(
              "/ISO15745Profile/ProfileBody/ApplicationProcess/ValueList")
          .node());
  _xmlChannelDiagList = std::make_shared<pugi::xml_node>(
      _doc->select_node(
              "/ISO15745Profile/ProfileBody/ApplicationProcess/ChannelDiagList")
          .node());  

  _build_textIdList();
  _build_valueList();
  _build_diagnostics();
  //pugi::xml_node DAP = _doc->select_node("/ISO15745Profile/ProfileBody/ApplicationProcess/DeviceAccessPointList/DeviceAccessPointItem[@ID='DIM ST V4.1']").node();
  //_build_moduleList(std::move(DAP));
  _build_submoduleList();
  _build_moduleList();

  m_DeviceIdentity.reset(new GSDML::DeviceIdentity(_doc->select_node(
              "/ISO15745Profile/ProfileBody/DeviceIdentity").node(), this));
  m_DeviceFunction.reset(new GSDML::DeviceFunction(_doc->select_node(
              "/ISO15745Profile/ProfileBody/DeviceFunction").node(), this));

  _build_DAPs();

  return PB__SUCCESS;
}





// int pn_gsdml::set_default_values(gsdml_eTag id, void* data, unsigned int size)
// {
//   for (unsigned int i = 0; i < sizeof(attrlist) / sizeof(attrlist[0]); i++)
//   {
//     if (attrlist[i].id == id && !streq(attrlist[i].default_value, ""))
//     {

//       if (attrlist[i].offset + attrlist[i].size > size)
//         continue;

//       string_to_value(attrlist[i].type, attrlist[i].size,
//                       attrlist[i].default_value,
//                       (char*)data + attrlist[i].offset);
//     }
//   }
//   return 1;
// }

// int pn_gsdml::data_to_ostring(unsigned char* data, int size, char* str,
//                               int strsize)
// {
//   int len = 0;
//   for (int i = 0; i < size; i++)
//   {
//     if (i == size - 1)
//     {
//       if (len + 5 >= strsize)
//         return 0;
//       len += sprintf(&str[i * 5], "0x%02hhx", data[i]);
//     }
//     else
//     {
//       if (len + 4 >= strsize)
//         return 0;
//       len += sprintf(&str[i * 5], "0x%02hhx,", data[i]);
//     }
//   }
//   return 1;
// }

// int pn_gsdml::ostring_to_data(unsigned char** data, const char* str, int size,
//                               int* rsize)
// {
//   char valstr[40];
//   int valcnt;
//   unsigned int val;
//   const char *s, *t;
//   int sts;

//   *data = (unsigned char*)calloc(1, size);
//   t = str;
//   valcnt = 0;
//   for (s = str;; s++)
//   {
//     if (valcnt > size)
//     {
//       printf("** Size error");
//       break;
//     }
//     if (*s == ',' || *s == 0)
//     {
//       strncpy(valstr, t, s - t);
//       valstr[s - t] = 0;
//       str_trim(valstr, valstr);
//       if (valstr[0] == '0' && valstr[1] == 'x')
//         sts = sscanf(&valstr[2], "%x", &val);
//       else
//         sts = sscanf(valstr, "%d", &val);
//       *(*data + valcnt++) = (unsigned char)val;
//       if (sts != 1)
//         printf("** GSDML-parser error, Syntax error in octet string, %s\n",
//                str);

//       t = s + 1;
//     }
//     if (*s == 0)
//       break;
//   }
//   if (rsize)
//     *rsize = valcnt;
//   return 1;
// }

std::shared_ptr<std::string> pn_gsdml::_get_TextId(std::string&& textId)
{
  // std::string value =
  //     _xmlTextIds->find_child_by_attribute("Text", "TextId", textId.c_str())
  //         .attribute("Value")
  //         .value();
  return _textIdMap[textId];
}

std::shared_ptr<std::string> pn_gsdml::_get_CategoryTextRef(std::string&& ID)
{
  std::string catTextId =
      _xmlCategoryList
          ->find_child_by_attribute("CategoryItem", "ID", ID.c_str())
          .attribute("TextId")
          .value();
  return _textIdMap[catTextId];
}

std::shared_ptr<std::string> pn_gsdml::_get_CategoryInfoTextRef(std::string&& ID)
{
  pugi::xml_node categoryItem = _xmlCategoryList->find_child_by_attribute(
      "CategoryItem", "ID", ID.c_str());
  std::string textId =
      categoryItem.child("InfoText").attribute("TextId").value();
  return _textIdMap[textId];
}

void pn_gsdml::_build_moduleList(pugi::xml_node&& dataAccessPointItem)
{
  for (pugi::xml_node& moduleItemRef : dataAccessPointItem.child("UseableModules").children("ModuleItemRef"))
  {
    pugi::xpath_variable_set vars;
    vars.add("ID", pugi::xpath_type_string);
    std::string ID(moduleItemRef.attribute("ModuleItemTarget").value());
    vars.set("ID", ID.c_str());
    pugi::xml_node result = _xmlModuleList->select_node("//ModuleItem[@ID = $ID]", &vars).node();

    _moduleMap[std::move(ID)].reset(new GSDML::ModuleItem(std::move(result), this)); 
  }
}

void pn_gsdml::_build_submoduleList()
{
  // The SubmoduleList in GSDML contains both SubmoduleItem AND PortSubmoduleItem
  for (pugi::xml_node& submoduleItem : _xmlSubmoduleList->children("SubmoduleItem"))
  {
    std::string ID(submoduleItem.attribute("ID").value());
    _submoduleMap[std::move(ID)].reset(new GSDML::SubmoduleItem(std::move(submoduleItem), this, GSDML::SubmoduleItemType_Submodule)); 
  } 

  for (pugi::xml_node& portSubmoduleItem : _xmlSubmoduleList->children("PortSubmoduleItem"))
  {
    std::string ID(portSubmoduleItem.attribute("ID").value());
    _submoduleMap[std::move(ID)].reset(new GSDML::PortSubmoduleItem(std::move(portSubmoduleItem), this)); 
  } 
}

void pn_gsdml::_build_DAPs()
{
  for (pugi::xml_node& deviceAccessPointItem : _xmlDeviceAccessPointList->children("DeviceAccessPointItem"))
  {
    std::string ID(deviceAccessPointItem.attribute("ID").value());    
    _deviceAccessPointMap[ID].reset(new GSDML::DeviceAccessPointItem(std::move(deviceAccessPointItem), this));
   // _deviceAccessPointList.push_back(_deviceAccessPointMap[ID]); // Also push it into the backwards compatible list...
  } 
}

void pn_gsdml::_build_moduleList()
{
  for (pugi::xml_node& moduleItem : _xmlModuleList->children("ModuleItem"))
  {
    std::string ID(moduleItem.attribute("ID").value());
    _moduleMap[ID].reset(new GSDML::ModuleItem(std::move(moduleItem), this));
    //_moduleList.push_back(_moduleMap[ID]); // Also push it into the backwards compatible list...
  } 
}

void pn_gsdml::_build_valueList()
{
  for (pugi::xml_node& valueItem : _xmlValueList->children("ValueItem"))
  {
    _valueMap[std::move(valueItem.attribute("ID").value())].reset(new GSDML::ValueItem(std::move(valueItem), this)); 
  } 
}

void pn_gsdml::_build_textIdList()
{
  for (pugi::xml_node& text : _xmlTextIds->children("Text"))
  {
    _textIdMap[std::move(text.attribute("TextId").value())].reset(new std::string(text.attribute("Value").as_string())); 
  } 
}

  // std::map<ushort, GSDML::ChannelDiagItem> _channelDiagMap;
  // std::map<std::string, std::shared_ptr<GSDML::ModuleItem>> _moduleList;
  // std::map<std::string, std::shared_ptr<GSDML::ValueItem>> _valueMap;
  // std::map<std::string, std::shared_ptr<std::string>> _textIdMap;
  // std::map<std::string, std::shared_ptr<GSDML::DeviceAccessPointItem>> _deviceAccessPointList;

std::unordered_map<ushort, GSDML::ChannelDiagItem>& pn_gsdml::getChannelDiagMap()
{
  return _channelDiagMap;
}

std::unordered_map<std::string, std::shared_ptr<GSDML::ModuleItem>>& pn_gsdml::getModuleMap()
{
  return _moduleMap;
}

std::unordered_map<std::string, std::shared_ptr<GSDML::SubmoduleItem>>& pn_gsdml::getSubmoduleMap()
{
  return _submoduleMap;
}

std::unordered_map<std::string, std::shared_ptr<GSDML::ValueItem>>& pn_gsdml::getValueMap()
{
  return _valueMap;
}

std::unordered_map<std::string, std::shared_ptr<std::string>>& pn_gsdml::getTextIdMap()
{
  return _textIdMap;
}

std::unordered_map<std::string, std::shared_ptr<GSDML::DeviceAccessPointItem>>& pn_gsdml::getDeviceAccessPointMap()
{
  return _deviceAccessPointMap;
}

// std::vector<std::shared_ptr<GSDML::DeviceAccessPointItem>>& pn_gsdml::getDeviceAccessPointList()
// {
//   return _deviceAccessPointList;
// }
