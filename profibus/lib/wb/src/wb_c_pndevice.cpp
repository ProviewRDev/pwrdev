/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_c_pndevice.c -- work bench methods of the PnDevice class. */

#include <stdlib.h>
#include <unistd.h>
#include <algorithm>
#include <regex>
#include <stdexcept>
#include <iomanip>

#include "pwr_baseclasses.h"
#include "pwr_profibusclasses.h"

#include "co_dcli.h"
#include "co_msg.h"
#include "co_string.h"
#include "co_fs_util.h"

#include "rt_pb_msg.h"

#include "flow_api.h"

#include "cow_msgwindow.h"
#include "cow_xhelp.h"

#include "wb_env.h"
#include "wb_ldh_msg.h"
#include "wb_pwrb_msg.h"
#include "wb_wnav.h"

#include "cow_pn_gsdml_attrnav.h"

#include "wb_c_pndevice.h"

static pwr_tStatus generate_viewer_data(device_sCtx* ctx);

class ChanItem
{
public:
  ChanItem() : representation(0), number(0), index(0), use_as_bit(false), cid(0) {}

  // unsigned int subslot_number;
  pwr_tEnum representation;
  unsigned int number;
  uint index;
  bool use_as_bit;
  pwr_tCid cid;
  std::string description;
  std::string name;
};

static int pndevice_populate_channel_vectors(device_sCtx* ctx, GSDML::IOData* io_data, int subslot_number,
                                             std::vector<ChanItem>& input_vect,
                                             std::vector<ChanItem>& output_vect);

// static int pndevice_check_io(device_sCtx* ctx,
//                              std::map<std::string, std::shared_ptr<GSDML::SubmoduleItem>> const& vsl,
//                              std::vector<ChanItem>& input_vect, std::vector<ChanItem>& output_vect);

static int set_attribute(ldh_tSession p_ldhses, void* p_value, size_t p_length, const char* p_attribute_name,
                         pwr_tAttrRef* p_aref)
{
  pwr_tStatus sts;
  pwr_tAttrRef attribute_aref;
  sts = ldh_ArefANameToAref(p_ldhses, p_aref, p_attribute_name, &attribute_aref);
  if (EVEN(sts))
    return sts;

  sts = ldh_WriteAttribute(p_ldhses, &attribute_aref, p_value, p_length);

  return sts;
}

static int create_channel(ldh_tSession ldhses, ChanItem const& chan, pwr_tOid target_oid,
                          ldh_eDest destination)
{
  pwr_tStatus sts;
  pwr_tOid chan_oid;
  sts = ldh_CreateObject(ldhses, &chan_oid, chan.name.c_str(), chan.cid, target_oid, destination);

  if (EVEN(sts))
    return sts;

  pwr_tAttrRef chan_aref = cdh_ObjidToAref(chan_oid);

  // Set Representation  
  sts = set_attribute(ldhses, (void*)&chan.representation, sizeof(chan.representation), "Representation",
                      &chan_aref);
  if (EVEN(sts))
    return sts;

  sts = set_attribute(ldhses, (void*)&chan.number, sizeof(chan.number), "Number", &chan_aref);
  if (EVEN(sts))
    return sts;

  sts = set_attribute(ldhses, (void*)chan.description.c_str(), sizeof(chan.description), "Description",
                      &chan_aref);

  return sts;
}


static std::string generate_channel_object_name(GSDML::DataItem const* data_item, size_t start_index, unsigned int number, bool channel_name_from_id = false)
{
  std::regex disallowed_characters_re(R"([^A-Za-z0-9_])"); // Match anything NOT in A-Z, a-z, 0-9 or _ i.e. all disallowed characters
  std::ostringstream name(std::ios_base::out);
  if (channel_name_from_id)
  {
    name << (data_item->_TextId != "" ? "" : "Ch") << std::setw(2) << std::setfill('0') << start_index << (data_item->_TextId != "" ? "_" + data_item->_TextId : "");
  }
  else
  {
    name << (data_item->_Text ? *data_item->_Text : "Ch") << "_" << start_index << "_" << number;
  }

  std::string new_name;
  new_name = name.str();
  new_name.erase(std::remove(new_name.begin(), new_name.end(), ' '),
                new_name.end());                           // Remove any whitespaces
  new_name = std::regex_replace(new_name, disallowed_characters_re, "_"); // Replace all illegal characters with a '_'      
  if (new_name.length() > 31) new_name.erase(31, std::string::npos); // We can only have 32 characters including null termination :(
  
  // In 999 out of 1000 cases we now have a unique name given the start_index and number within a sequence of bits for instance.
  // In some cases though one can choose the same submodule more than once for some specific modules. One shouldn't do that but it is
  // possible. If one does, the name will of course be a duplicate and the channel creation will fail. Should we care about this?

  return new_name;
}

static int pndevice_fill_io_vector_from_data_item(std::vector<ChanItem>& io_vector,
                                                  GSDML::DataItem const* data_item, size_t const& start_index,
                                                  bool is_output = false)
{
  ChanItem ci;  

  // If we have bits we fill with Di/Do
  if (data_item->_UseAsBits)
  {
    // Use as bits
    unsigned int bits;

    switch (data_item->_DataType)
    {
    case GSDML::ValueDataType_Integer8:
    case GSDML::ValueDataType_Unsigned8:    
    case GSDML::ValueDataType_OctetString: 
      ci.representation = pwr_eDataRepEnum_Bit8;
      bits = 8;
      break;
    case GSDML::ValueDataType_Integer16:
    case GSDML::ValueDataType_Unsigned16:
      ci.representation = pwr_eDataRepEnum_Bit16;
      bits = 16;
      break;
    case GSDML::ValueDataType_Integer32:
    case GSDML::ValueDataType_Unsigned32:
      ci.representation = pwr_eDataRepEnum_Bit32;
      bits = 32;
      break;
    case GSDML::ValueDataType_Integer64:
    case GSDML::ValueDataType_Unsigned64:
      ci.representation = pwr_eDataRepEnum_Bit64;
      bits = 64;
      break;
    default:
      bits = 0;
    }

    if (is_output)
      ci.cid = pwr_cClass_ChanDo;
    else
      ci.cid = pwr_cClass_ChanDi;

    ci.use_as_bit = true;

    // For those sloppy suppliers of GSDML that do not provide this list :/
    if (data_item->_BitDataItem.size() == 0)
    {
      // If this is a octetstring we multiply the biuts with length
      if (data_item->_DataType == GSDML::ValueDataType_OctetString)
        bits *= data_item->_Length;

      // Add default bits
      for (unsigned int number = 0; number < bits; number++)
      {
        // Add Channel
        ci.number = data_item->_DataType == GSDML::ValueDataType_OctetString ? number % 8 : number;
        ci.description = std::string("Bit ") + std::to_string(number); // Okay lots of overhead here...
        ci.name = generate_channel_object_name(data_item, start_index, number);

        io_vector.push_back(ci);
      }
    }
    else // Add only configured bit items
    {      
      for (auto const& bit_data_item : data_item->_BitDataItem)
      {
        // Add channel
        ci.number = bit_data_item._BitOffset;
        ci.description = bit_data_item._Text
                             ? *bit_data_item._Text
                             : std::string(" Bit ") + std::to_string(ci.number);       
        ci.name = generate_channel_object_name(data_item, start_index, ci.number);

        io_vector.push_back(ci);
      }
    }
    return PB__SUCCESS;
  }
  else
  {
    switch (data_item->_DataType)
    {
    case GSDML::ValueDataType_Integer8:
      ci.representation = pwr_eDataRepEnum_Int8;
      break;
    case GSDML::ValueDataType_Unsigned8:
    case GSDML::ValueDataType_OctetString:
      ci.representation = pwr_eDataRepEnum_UInt8;
      break;
    case GSDML::ValueDataType_Integer16:
      ci.representation = pwr_eDataRepEnum_Int16;
      break;
    case GSDML::ValueDataType_Unsigned16:
      ci.representation = pwr_eDataRepEnum_UInt16;
      break;
    case GSDML::ValueDataType_Integer32:
      ci.representation = pwr_eDataRepEnum_Int32;
      break;
    case GSDML::ValueDataType_Unsigned32:
      ci.representation = pwr_eDataRepEnum_UInt32;
      break;
    case GSDML::ValueDataType_Integer64:
      ci.representation = pwr_eDataRepEnum_Int64;
      break;
    case GSDML::ValueDataType_Unsigned64:
      ci.representation = pwr_eDataRepEnum_UInt64;
      break;
    case GSDML::ValueDataType_Float32:
      ci.representation = pwr_eDataRepEnum_Float32;
      break;
    case GSDML::ValueDataType_Float64:
      ci.representation = pwr_eDataRepEnum_Float64;
      break;
    default:
      printf("GSDML-Error, Unhandled datatype, unable to create channel\n");
      return PB__CREATECHAN;
    }

    ci.number = 0;
    ci.use_as_bit = 0;

    if (is_output)
    {
      ci.cid = data_item->_DataType == GSDML::ValueDataType_OctetString ? pwr_cClass_ChanIo : pwr_cClass_ChanAo;
    }
    else
    {
      ci.cid = data_item->_DataType == GSDML::ValueDataType_OctetString ? pwr_cClass_ChanIi : pwr_cClass_ChanAi;
    }

    ci.description = *data_item->_Text;

    // If this is octetstring we add one item for each byte
    if (data_item->_DataType == GSDML::ValueDataType_OctetString)
    {      
      for (size_t byte = 0; byte < data_item->_Length; byte++)
      {
        ci.name = generate_channel_object_name(data_item, start_index, byte);

        io_vector.push_back(ci);
      }
    }
    else
    {
      ci.name = generate_channel_object_name(data_item, start_index, ci.number, true);
      io_vector.push_back(ci);
    }
  }
  return PB__SUCCESS;
}

/*----------------------------------------------------------------------------*\
  Configure the slave from gsd file.
\*----------------------------------------------------------------------------*/

static void get_subcid(ldh_tSession ldhses, pwr_tCid cid, std::vector<pwr_tCid>& v)
{
  pwr_tCid subcid;
  pwr_tStatus sts;

  for (sts = ldh_GetSubClass(ldhses, cid, pwr_cNCid, &subcid); ODD(sts);
       sts = ldh_GetSubClass(ldhses, cid, subcid, &subcid))
  {
    v.push_back(subcid);
    get_subcid(ldhses, subcid, v);
  }
}

int pndevice_help_cb(void* sctx, const char* text)
{
  pwr_tCmd cmd;
  device_sCtx* ctx = (device_sCtx*)sctx;

  strcpy(cmd, "help ");
  strcat(cmd, text);
  return ((WNav*)ctx->editor_ctx)->command(cmd);
}

void pndevice_close_cb(void* sctx)
{
  device_sCtx* ctx = (device_sCtx*)sctx;
  ctx->pwr_pn_data.reset(); // For clarity
  delete ctx->attr;
  delete ctx->gsdml;
  free((char*)ctx);
}

int pndevice_save_cb(void* sctx)
{
  device_sCtx* ctx = (device_sCtx*)sctx;
  pwr_tStatus sts;
  pwr_tOid module_oid;

  // Syntax check
  if (ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_DAP_ID == "")
  {
    MsgWindow::message('E', "Device type not selected");
    return PB__SYNTAX;
  }

  ((WNav*)ctx->editor_ctx)->set_nodraw();

  // Reset all module object identities
  for (auto& slot : ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list)
    slot.m_module_oid = pwr_cNOid;

  // Check if we are indeed iterating over a pnmodule and that this module is "in use"
  // If both things above are true we save the oid of the PnModule. And we only save each slot number once.
  // If by some chance there's a duplicate slot_number only the first one is kept...
  {
    std::vector<size_t> traversed_slot_numbers;
    int size = 0;
    for (sts = ldh_GetChild(ctx->ldhses, ctx->aref.Objid, &module_oid); ODD(sts);
         sts = ldh_GetNextSibling(ctx->ldhses, module_oid, &module_oid))
    {
      unsigned int *slot_number_p, slot_number;
      sts = ldh_GetObjectPar(ctx->ldhses, module_oid, "RtBody", "Slot", (char**)&slot_number_p, &size);
      slot_number = *slot_number_p;
      free(slot_number_p);

      if (std::find(traversed_slot_numbers.begin(), traversed_slot_numbers.end(), slot_number) !=
          traversed_slot_numbers.end())
        continue;

      // We ignore this?? TODO Check into this...
      if (EVEN(sts))
      {
        MsgWindow::message('E', "Not a Profinet module object", msgw_ePop_Yes, module_oid);
        continue;
      }

      // This module is exceeding the allowed number of modules for the DAP.
      if (slot_number >= ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list.size())
      {
        MsgWindow::message('E', "Slot number exceeds maximum slot list size", msgw_ePop_Yes, module_oid);
        continue;
      }

      ProfinetSlot* slot = &ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list[slot_number];

      // Now check if the module is indeed present in our configuration, if it isn't we don't update the oid
      // (i.e. we mark it for removal)
      if (slot->m_module_ID == "")
        continue; // Leaving the oid untouched

      ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list[slot_number].m_module_oid = module_oid;
      traversed_slot_numbers.push_back(slot_number);
    }
  }

  // Remove modules that isn't configured any more OR have a changed module class (i.e. one has chosen a
  // custom derived PnModule in favor of the base class PnModule) One will loose all the connections but that
  // goes without saying...
  for (sts = ldh_GetChild(ctx->ldhses, ctx->aref.Objid, &module_oid); ODD(sts);)
  {
    auto& slot_list = ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list;
    // We want to find an object, if we do not find one we remove it. The predicate says we want
    // the same oid to be present in the saved conf and that the module class hasn't changed...
    pwr_tCid cid = pwr_cNCid;
    ldh_GetObjectClass(ctx->ldhses, module_oid, &cid); // Ignore return...
    auto result = std::find_if(
        std::begin(slot_list), std::end(slot_list),
        [&module_oid, &cid](auto& slot)
        { return (cdh_ObjidIsEqual(slot.m_module_oid, module_oid) && (slot.m_module_class == cid)); });

    // If we reached the end we didn't find a module matching our conf so this module has to go. It's either
    // removed or one changed the module class
    if (result == std::end(slot_list))
    {
      pwr_tOid purged_oid = module_oid;

      // Find and clear the saved oid for the module we are about to remove
      auto search_oid =
          std::find_if(std::begin(slot_list), std::end(slot_list),
                       [&module_oid](auto& slot) { return cdh_ObjidIsEqual(slot.m_module_oid, module_oid); });
      if (search_oid != std::end(slot_list))
        search_oid->m_module_oid = pwr_cNOid;

      sts = ldh_GetNextSibling(ctx->ldhses, purged_oid, &module_oid);
      sts = ldh_DeleteObjectTree(ctx->ldhses, purged_oid, 0);
      continue;
    }
    sts = ldh_GetNextSibling(ctx->ldhses, module_oid, &module_oid);
  }

  // Create new module objects
  pwr_tOid last_object = pwr_cNOid;
  for (auto& slot : ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list)
  {
    bool created = false;

    // Skip if if we have an oid (There's already an object in place, and we never remove existing configured
    // items) OR we do not have a module class, we need one to know what to create (The configurator forces
    // one to select a module class). The DAP does not have a module class though...TODO What if the DAP
    // carries data...does such DAPs exist?
    if (cdh_ObjidIsNotNull(slot.m_module_oid) || slot.m_module_class == pwr_cNCid)
      continue;

    // Create a fancy name like "M1" and so on and so forth...
    std::ostringstream module_name(std::ios_base::out);
    module_name << "M" << slot.m_slot_number;

    // We need to insert the module in the correct place! Find out where to insert module
    for (sts = ldh_GetChild(ctx->ldhses, ctx->aref.Objid, &module_oid); ODD(sts);
         sts = ldh_GetNextSibling(ctx->ldhses, module_oid, &module_oid))
    {
      // Boiler plate for extracting the slot number ....... TODO refactor, second use here...
      unsigned int *slot_number_p, slot_number;
      int size;
      sts = ldh_GetObjectPar(ctx->ldhses, module_oid, "RtBody", "Slot", (char**)&slot_number_p, &size);
      slot_number = *slot_number_p;
      free(slot_number_p);

      if (slot.m_slot_number < slot_number)
      {
        sts = ldh_CreateObject(ctx->ldhses, &slot.m_module_oid, module_name.str().c_str(),
                               slot.m_module_class, module_oid, ldh_eDest_Before);
        if (EVEN(sts))
        {
          MsgWindow::message('E', "Error creating module object", module_name.str().c_str());
          sts = 0;
          ((WNav*)ctx->editor_ctx)->reset_nodraw();
          return sts;
        }
        created = true; // Set created, we won't create another item :D
        break;
      }
      last_object = module_oid; // Update last object in case we reach the end
    }

    sts = PB__SUCCESS; // Reset the status once out of the loop...

    if (!created)
    {
      // We are either at the beginning or at the end
      if (cdh_ObjidIsNull(last_object))
      {
        sts = ldh_CreateObject(ctx->ldhses, &slot.m_module_oid, module_name.str().c_str(),
                               slot.m_module_class, ctx->aref.Objid, ldh_eDest_IntoFirst);
      }
      else // All subsequent pnmodules created
      {
        sts = ldh_CreateObject(ctx->ldhses, &slot.m_module_oid, module_name.str().c_str(),
                               slot.m_module_class, last_object, ldh_eDest_After);
      }
    }

    // Did everything go as planned?
    if (EVEN(sts))
    {
      MsgWindow::message('E', "Error creating module object", module_name.str().c_str());
      sts = 0;
      ((WNav*)ctx->editor_ctx)->reset_nodraw();
      return sts;
    }

    // Save last object id so that we can continue creating objects from there...
    last_object = slot.m_module_oid;

    // Update slot number in our module object and set a name for the attribute ModuleName
    pwr_tAttrRef module_aref = cdh_ObjidToAref(slot.m_module_oid);
    set_attribute(ctx->ldhses, &slot.m_slot_number, sizeof(slot.m_slot_number), "Slot", &module_aref);
    // Set both ModuleName and Description as a default.
    std::string name = *ctx->attr->attrnav->gsdml->getModuleMap().at(slot.m_module_ID)->_ModuleInfo._Name;
    set_attribute(ctx->ldhses, (void*)name.c_str(), name.length(), "ModuleName", &module_aref);
    set_attribute(ctx->ldhses, (void*)name.c_str(), name.length(), "Description", &module_aref);
  } // Done creating modules

  // Now we create all the channel items! :D
  // If we find channels already in place, we notify the user and skip this module. We don't want to enforce
  // removal of channel items. The user is responsible of move/deleting them. This is for not loosing channel
  // connection/configuration information. Go through all our PnModules
  for (sts = ldh_GetChild(ctx->ldhses, ctx->aref.Objid, &module_oid); ODD(sts);
       sts = ldh_GetNextSibling(ctx->ldhses, module_oid, &module_oid))
  {
    pwr_tCid module_cid;
    ldh_GetObjectClass(ctx->ldhses, module_oid, &module_cid);
    std::shared_ptr<GSDML::ModuleItem> module_item;

    unsigned int *slot_number_p, slot_number;
    int size;
    sts = ldh_GetObjectPar(ctx->ldhses, module_oid, "RtBody", "Slot", (char**)&slot_number_p, &size);
    slot_number = *slot_number_p;
    free(slot_number_p);

    auto& slot = ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list[slot_number];
    module_item = ctx->attr->attrnav->gsdml->getModuleMap().at(slot.m_module_ID);

    // Check if we have children, if we do AND this slot was modified in the configurator we have to notify
    // the user that he/she must move them temporary or remove them completely before ProviewR will create
    // channels.
    pwr_tOid chan_oid;
    if (ODD(ldh_GetChild(ctx->ldhses, module_oid, &chan_oid)) && slot.m_is_modified)
    {
      std::ostringstream message(std::ios_base::out);
      char object_name[200]; // Enough space? :D
      int size;
      ldh_ObjidToName(ctx->ldhses, module_oid, ldh_eName_Default, object_name, 200, &size);
      message << "PnModule " << object_name
              << " already have children. If ProviewR should handle creation of channel items please remove "
                 "them first. Skipping module.";
      MsgWindow::message('W', message.str().c_str());
      slot.m_is_modified =
          false; // Reset this flag so we won't get the message until we update the slot again.
      continue;
    }
    else if (ODD(ldh_GetChild(ctx->ldhses, module_oid, &chan_oid)))
    {
      // Silently ignore the creation of channels for this slot
      continue;
    }

    // Create
    if (module_cid == pwr_cClass_PnModule)
    {
      std::vector<ChanItem> input_vect;
      std::vector<ChanItem> output_vect;

      // Gather all IOData associated with the slot
      GSDML::IOData* io_data;
      for (auto const& subslot : slot.m_subslot_map)
      {
        if (module_item->_VirtualSubmoduleList.count(subslot.second.m_submodule_ID))
        {
          io_data = &module_item->_VirtualSubmoduleList.at(subslot.second.m_submodule_ID)->_IOData;
        }
        else if (module_item->_UseableSubmodules.count(subslot.second.m_submodule_ID))
        {
          io_data = &module_item->_UseableSubmodules.at(subslot.second.m_submodule_ID)
                         ->_SubmoduleItemTarget->_IOData;
        }
        else
        {
          continue;
        }

        // Populate channel vectors with the data collected for this subslot
        pndevice_populate_channel_vectors(ctx, io_data, subslot.first, input_vect, output_vect);
      }

      for (auto const& input_chan : input_vect)
      {
        sts = create_channel(ctx->ldhses, input_chan, module_oid, ldh_eDest_IntoLast);
        if (EVEN(sts))
        {
          ((WNav*)ctx->editor_ctx)->reset_nodraw();
          return sts;
        }
      }
      for (auto const& output_chan : output_vect)
      {
        sts = create_channel(ctx->ldhses, output_chan, module_oid, ldh_eDest_IntoLast);
        if (EVEN(sts))
        {
          ((WNav*)ctx->editor_ctx)->reset_nodraw();
          return sts;
        }
      }
      slot.m_is_modified = false; // Reset this flag since we now have our channels and we ain't really in a
                                  // modified state anymore...
    }
    else // This is NOT a PnModule, we then remove everything apparently
    {
      // Remove existing channels
      std::vector<pwr_tOid> chanvect;
      pwr_tCid cid;
      pwr_tOid chan_oid;

      for (sts = ldh_GetChild(ctx->ldhses, module_oid, &chan_oid); ODD(sts);
           sts = ldh_GetNextSibling(ctx->ldhses, chan_oid, &chan_oid))
      {
        sts = ldh_GetObjectClass(ctx->ldhses, chan_oid, &cid);
        if (EVEN(sts))
        {
          ((WNav*)ctx->editor_ctx)->reset_nodraw();
          return sts;
        }

        // Why not everything... :) TODO
        switch (cid)
        {
        case pwr_cClass_ChanDi:
        case pwr_cClass_ChanDo:
        case pwr_cClass_ChanAi:
        case pwr_cClass_ChanAo:
        case pwr_cClass_ChanIi:
        case pwr_cClass_ChanIo:
          chanvect.push_back(chan_oid);
          break;
        default:;
        }
      }

      for (unsigned int i = 0; i < chanvect.size(); i++)
      {
        sts = ldh_DeleteObject(ctx->ldhses, chanvect[i]);
        if (EVEN(sts))
        {
          ((WNav*)ctx->editor_ctx)->reset_nodraw();
          return sts;
        }
      }
    }
  }

  // Write data of all devices for profinet viewer
  // Data is device name, IP and MAC address
  sts = generate_viewer_data(ctx);

  sts = PB__SUCCESS;

  ((WNav*)ctx->editor_ctx)->reset_nodraw();
  return sts;
}

static pwr_tStatus generate_viewer_data(device_sCtx* ctx)
{
  pwr_tOid controller_oid;
  pwr_tCid controller_cid;  
  FILE* pnviewer_fp;
  pwr_tFileName fname;  
  pwr_tStatus sts;
  pwr_tOid child_module_oid;
  char* ethernet_device;
  int size;
  
  std::string device_text;
  std::string device_name;
  std::string ip_address;
  std::string mac_address;
  unsigned int vendor_id = 0;
  unsigned int device_id = 0;

  ProfinetRuntimeData profinet_rt_data;

  sts = ldh_GetParent(ctx->ldhses, ctx->aref.Objid, &controller_oid);
  if (EVEN(sts))
    return sts;

  sts = ldh_GetObjectClass(ctx->ldhses, controller_oid, &controller_cid);
  if (ODD(sts) && controller_cid == pwr_cClass_PnControllerSoftingPNAK)
  {
    // Extract ethernet device
    sts = ldh_GetObjectPar(ctx->ldhses, controller_oid, "RtBody", "EthernetDevice", (char**)&ethernet_device, &size);
    if (EVEN(sts))
      return sts;
    str_trim(ethernet_device, ethernet_device);
    str_ToLower(ethernet_device, ethernet_device);
    sprintf(fname, "$pwrp_load/pwr_pnviewer_%s.dat", ethernet_device);
    free(ethernet_device);
    dcli_translate_filename(fname, fname);    

    pnviewer_fp = fopen(fname, "w");
    if (!pnviewer_fp)
      return 0;

    for (sts = ldh_GetChild(ctx->ldhses, controller_oid, &child_module_oid); ODD(sts);
         sts = ldh_GetNextSibling(ctx->ldhses, child_module_oid, &child_module_oid))
    {
      sprintf(fname, "$pwrp_load/pwr_pn_%s.xml", cdh_ObjidToFnString(0, child_module_oid));
      dcli_translate_filename(fname, fname);

      // We can ignore that the GSDML file will not match the second argument "" since we don't care right now...
      if (profinet_rt_data.read_pwr_pn_xml(std::string(fname), ""))
      {
        device_name = profinet_rt_data.m_PnDevice->m_NetworkSettings.m_device_name;
        ip_address = profinet_rt_data.m_PnDevice->m_NetworkSettings.m_ip_address;
        device_text = profinet_rt_data.m_PnDevice->m_moduleinfo_name;
        mac_address = profinet_rt_data.m_PnDevice->m_NetworkSettings.m_mac_address;
        vendor_id = profinet_rt_data.m_PnDevice->m_vendor_id;
        device_id = profinet_rt_data.m_PnDevice->m_device_id;
      }
      else
      {
        MsgWindow::message('W', "Could not read pwr_pn xml file, creation of pwr_pnviewer xml file failed");
        fclose(pnviewer_fp);
        return 0;
      }
      
      fprintf(pnviewer_fp, "\"%s\" \"%s\" \"%s\" \"%s\" %d %d\n", device_text.c_str(), device_name.c_str(), ip_address.c_str(), mac_address.c_str(),
              vendor_id, device_id);
    }
    fclose(pnviewer_fp);
  }
  return 1;
}

static int pndevice_populate_channel_vectors(device_sCtx* ctx, GSDML::IOData* io_data, int subslot_number,
                                             std::vector<ChanItem>& input_vect,
                                             std::vector<ChanItem>& output_vect)
{
  pwr_tStatus sts;
  size_t index = 0;
  // Do all inputs first
  for (auto const& input_data_item : io_data->_Input._DataItem)
  {
    sts = pndevice_fill_io_vector_from_data_item(input_vect, &input_data_item, index++);

    if (EVEN(sts))
      return sts;
  }

  // Output!
  for (auto const& output_data_item : io_data->_Output._DataItem)
  {
    pndevice_fill_io_vector_from_data_item(output_vect, &output_data_item, index++, true);

    if (EVEN(sts))
      return sts;
  }

  return PB__SUCCESS;
}

pwr_tStatus pndevice_create_ctx(ldh_tSession ldhses, pwr_tAttrRef aref, void* editor_ctx, device_sCtx** ctxp,
                                char const* pwr_pn_data_file)
{
  pwr_tOName name;
  char* gsdmlfile;
  int size;
  int sts;
  pwr_tFileName fname;
  ldh_sSessInfo Info;
  std::vector<pwr_tCid> mcv;

  sts = ldh_GetSessionInfo(ldhses, &Info);

  sts = ldh_ObjidToName(ldhses, aref.Objid, ldh_eName_Hierarchy, name, sizeof(name), &size);
  if (EVEN(sts))
    return sts;

  sts = ldh_GetObjectPar(ldhses, aref.Objid, "RtBody", "GSDMLfile", &gsdmlfile, &size);
  if (EVEN(sts))
    return sts;
  if (streq(gsdmlfile, ""))
  {
    free(gsdmlfile);
    return PB__GSDATTR;
  }

  device_sCtx* ctx = (device_sCtx*)calloc(1, sizeof(device_sCtx));
  ctx->ldhses = ldhses;
  ctx->aref = aref;
  ctx->editor_ctx = editor_ctx;
  ctx->edit_mode = (ODD(sts) && Info.Access == ldh_eAccess_ReadWrite) && ldh_LocalObject(ldhses, aref.Objid);

  get_subcid(ctx->ldhses, pwr_cClass_PnModule, mcv);
  ctx->mc = (gsdml_sModuleClass*)calloc(mcv.size() + 2, sizeof(gsdml_sModuleClass));

  ctx->mc[0].cid = pwr_cClass_PnModule;
  sts = ldh_ObjidToName(ctx->ldhses, cdh_ClassIdToObjid(ctx->mc[0].cid), cdh_mName_object, ctx->mc[0].name,
                        sizeof(ctx->mc[0].name), &size);
  if (EVEN(sts))
  {
    free(ctx);
    return sts;
  }

  for (int i = 1; i <= (int)mcv.size(); i++)
  {
    ctx->mc[i].cid = mcv[i - 1];
    sts = ldh_ObjidToName(ctx->ldhses, cdh_ClassIdToObjid(ctx->mc[i].cid), cdh_mName_object, ctx->mc[i].name,
                          sizeof(ctx->mc[0].name), &size);
    if (EVEN(sts))
    {
      free(ctx);
      return sts;
    }
  }

  if (strchr(gsdmlfile, '/') == 0)
  {
    strcpy(fname, "$pwrp_exe/");
    strcat(fname, gsdmlfile);
  }
  else
    strcpy(fname, gsdmlfile);
  free(gsdmlfile);

  // TODO Load new parser data instead...

  ctx->gsdml = new pn_gsdml();
  sts = ctx->gsdml->read(fname);
  if (EVEN(sts))
  {
    free(ctx);
    return sts;
  }
  // ctx->gsdml->build();
  ctx->gsdml->set_classes(ctx->mc);

  // Now load the pwr_pn data if any. If there is none a default constructed object is created to start
  // working on
  char* name_of_gsdml_file;
  basename(fname, &name_of_gsdml_file); // We want only the actual filename not the path...
  ctx->pwr_pn_data.reset(new ProfinetRuntimeData());
  sts = ctx->pwr_pn_data->read_pwr_pn_xml(pwr_pn_data_file, name_of_gsdml_file);

  *ctxp = ctx;
  return 1;
}

/*
  TODO Rewrite this so that we use the SlotNumber attribute instead. AND also introduce moduleID as an attribute.
*/
pwr_tStatus pndevice_init(device_sCtx* ctx)
{
  pwr_tOid module_oid;
  int corrupt = 0;
  unsigned int idx;
  pwr_tStatus sts;

  // Identify module objects

  int size;
  pwr_tObjName module_name;

  for (sts = ldh_GetChild(ctx->ldhses, ctx->aref.Objid, &module_oid); ODD(sts);
       sts = ldh_GetNextSibling(ctx->ldhses, module_oid, &module_oid))
  {
    sts = ldh_ObjidToName(ctx->ldhses, module_oid, cdh_mName_object, module_name, sizeof(module_name), &size);
    if (EVEN(sts))
      return sts;

    if (!(sscanf(module_name, "M%d", &idx) == 1))
    {
      corrupt = 1;
      continue;
    }
    // if (idx >= ctx->attr->attrnav->dev_data.slot_data.size())
    if (idx >= ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list.size())
    {
      corrupt = 1;
      continue;
    }
    // ctx->attr->attrnav->dev_data.slot_data[idx]->module_oid = module_oid;
    ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list[idx].m_module_oid = module_oid;
  }

  if (corrupt)
  {
    corrupt = 0;

    // Not standard module names, get slot number from object order instead
    idx = 1;
    for (sts = ldh_GetChild(ctx->ldhses, ctx->aref.Objid, &module_oid); ODD(sts);
         sts = ldh_GetNextSibling(ctx->ldhses, module_oid, &module_oid))
    {
      // if (idx >= ctx->attr->attrnav->dev_data.slot_data.size())
      if (idx >= ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list.size())
      {
        corrupt = 1;
        break;
      }
      // ctx->attr->attrnav->dev_data.slot_data[idx]->module_oid = module_oid;
      ctx->attr->attrnav->pn_runtime_data->m_PnDevice->m_slot_list[idx].m_module_oid = module_oid;
      idx++;
    }
    if (corrupt)
      ctx->attr->wow->DisplayError("Configuration corrupt",
                                   "Configuration of module objects doesn't match device configuration");
  }
  return 1;
}

pwr_tStatus pndevice_postcopy(ldh_tSesContext Session, pwr_tOid Object, pwr_tOid Source, pwr_tCid Class)
{
  pwr_tCmd cmd;
  char soidstr[40];

  if (cdh_ObjidIsNotNull(Source))
  {
    printf("-- Create $pwrp_load/pwr_pn_%s.xml\n", cdh_ObjidToFnString(0, Object));
    strcpy(soidstr, cdh_ObjidToFnString(0, Source));
    sprintf(cmd, "cp $pwrp_load/pwr_pn_%s.xml $pwrp_load/pwr_pn_%s.xml", soidstr,
            cdh_ObjidToFnString(0, Object));
    system(cmd);    
  }

  return PWRB__SUCCESS;
}
