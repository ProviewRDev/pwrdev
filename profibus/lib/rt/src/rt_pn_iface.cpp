/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_pn_iface.cpp -- Profinet driver interface routines  */

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <map>
#include <regex>

#include <arpa/inet.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include "co_cdh.h"
#include "co_dcli.h"
#include "pwr_profibusclasses.h"

#include "rt_io_base.h"
#include "rt_io_bus.h"
#include "rt_io_msg.h"
//#include "rt_io_pn_locals.h"
#include "rt_io_pnak_locals.h"
#include "rt_pb_msg.h"
//#include "rt_pn_gsdml_data.h"
#include "rt_profinet.h"
#include "rt_pn_iface.h"

#include "rt_mh_appl.h"
#include <byteswap.h>

// char file_vect[2][80] = {
//     "pwr_pn_000_001_099_020_000000a2.xml",
//     "pwr_pn_000_001_099_020_000000e5.xml",
// };

void pack_set_ip_settings_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes, ProfinetDevice const* pn_device)
{
  T_PNAK_SERVICE_DESCRIPTION* service_desc;
  T_PN_SERVICE_SET_IP_SETTINGS_REQ* pSISR;
  unsigned offset = 0u;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[offset];

  service_desc->DeviceRef = 0u;
  service_desc->Instance = PN_SUPERVISOR;
  service_desc->Service = PN_SERVICE_SET_IP_SETTINGS;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;
  service_desc->DataLength = sizeof(T_PN_SERVICE_SET_IP_SETTINGS_REQ);

  /* Fill service */

  pSISR = (T_PN_SERVICE_SET_IP_SETTINGS_REQ*)(service_desc + 1);

  //  no_items = sscanf(xml_dev_data->mac_address,
  //  "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &havhb, &havlb, &mhb, &mlb, &lhb, &llb);

  std::regex test(R"(/([0-9A-Fa-f]{2})[:]{0,1}/g)");

  pSISR->DestMacAddress.HighAndVersionHighByte = pn_device->m_rt_macaddress[5];
  pSISR->DestMacAddress.HighAndVersionLowByte = pn_device->m_rt_macaddress[4];
  pSISR->DestMacAddress.MidHighByte = pn_device->m_rt_macaddress[3];
  pSISR->DestMacAddress.MidLowByte = pn_device->m_rt_macaddress[2];
  pSISR->DestMacAddress.LowHighByte = pn_device->m_rt_macaddress[1];
  pSISR->DestMacAddress.LowLowByte = pn_device->m_rt_macaddress[0];

  //  no_items = sscanf(xml_dev_data->ip_address, "%hhi.%hhi.%hhi.%hhi",
  //  &high_high_byte,
  //		    &high_low_byte, &low_high_byte, &low_low_byte);

  //  if (no_items == 4) {
  pSISR->AddressHighWordHighByte = pn_device->m_rt_ipaddress[3];
  pSISR->AddressHighWordLowByte = pn_device->m_rt_ipaddress[2];
  pSISR->AddressLowWordHighByte = pn_device->m_rt_ipaddress[1];
  pSISR->AddressLowWordLowByte = pn_device->m_rt_ipaddress[0];

  //  no_items = sscanf(xml_dev_data->subnet_mask, "%hhi.%hhi.%hhi.%hhi",
  //  &high_high_byte,
  //		    &high_low_byte, &low_high_byte, &low_low_byte);

  //  if (no_items == 4) {
  pSISR->SubnetMaskHighWordHighByte = pn_device->m_rt_subnetmask[3];
  pSISR->SubnetMaskHighWordLowByte = pn_device->m_rt_subnetmask[2];
  pSISR->SubnetMaskLowWordHighByte = pn_device->m_rt_subnetmask[1];
  pSISR->SubnetMaskLowWordLowByte = pn_device->m_rt_subnetmask[0];
}

// void pack_set_device_name_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes,  PnDeviceInfo* dev_info)
void pack_set_device_name_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes, ProfinetDevice* pn_device)
{
  T_PNAK_SERVICE_DESCRIPTION* service_desc;
  T_PN_SERVICE_SET_NAME_REQ* pSNR;
  unsigned short name_length;
  unsigned offset = 0u;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[offset];

  service_desc->DeviceRef = 0u;
  service_desc->Instance = PN_SUPERVISOR;
  service_desc->Service = PN_SERVICE_SET_DEVICE_NAME;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;
  service_desc->DataLength = sizeof(T_PN_SERVICE_SET_NAME_REQ);

  /* Fill service */

  pSNR = (T_PN_SERVICE_SET_NAME_REQ*)(service_desc + 1);

  //  no_items = sscanf(xml_dev_data->mac_address,
  //  "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &havhb, &havlb, &mhb, &mlb, &lhb, &llb);

  pSNR->DestMacAddress.HighAndVersionHighByte = pn_device->m_rt_macaddress[5];
  pSNR->DestMacAddress.HighAndVersionLowByte = pn_device->m_rt_macaddress[4];
  pSNR->DestMacAddress.MidHighByte = pn_device->m_rt_macaddress[3];
  pSNR->DestMacAddress.MidLowByte = pn_device->m_rt_macaddress[2];
  pSNR->DestMacAddress.LowHighByte = pn_device->m_rt_macaddress[1];
  pSNR->DestMacAddress.LowLowByte = pn_device->m_rt_macaddress[0];

  name_length = pn_device->m_NetworkSettings.m_device_name.length();

  pSNR->NameLengthHighByte = _PN_U16_HIGH_BYTE(name_length);
  pSNR->NameLengthLowByte = _PN_U16_LOW_BYTE(name_length);

  strncpy(pSNR->DeviceName, pn_device->m_NetworkSettings.m_device_name.c_str(), PN_MAX_DEVICE_NAME_LENGTH);
}
void pack_set_identification_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes)
{
  unsigned offset = 0u;

  T_PNAK_SERVICE_DESCRIPTION* service_desc;
  T_PN_SERVICE_SET_IDENTIFICATION_REQ* pSSIR;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[offset];

  service_desc->DeviceRef = PN_DEVICE_REFERENCE_THIS_STATION;
  service_desc->Instance = PN;
  service_desc->Service = PN_SERVICE_SET_IDENTIFICATION;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;

  /* Calculate length of service */

  service_desc->DataLength = sizeof(T_PN_SERVICE_SET_IDENTIFICATION_REQ);

  /* Fill service */

  pSSIR = (T_PN_SERVICE_SET_IDENTIFICATION_REQ*)(service_desc + 1);

  sprintf((char*)pSSIR->TypeOfStation, "PN-IO-CON-OC-Implementation");
  sprintf((char*)pSSIR->OrderId, "PN-IO-CON-OC       ");
  sprintf((char*)pSSIR->SerialNumber, "0700123456789099");
  pSSIR->HwRevisionHighByte = 0;
  pSSIR->HwRevisionLowByte = 1;
  pSSIR->SwRevisionHighWordHighByte = 0;
  pSSIR->SwRevisionHighWordLowByte = 60;
  pSSIR->SwRevisionLowWordHighByte = 0;
  pSSIR->SwRevisionLowWordLowByte = 'V';
  pSSIR->IdentAndMaintenanceVersionHighByte = 1;
  pSSIR->IdentAndMaintenanceVersionLowByte = 1;
}

void pack_get_device_state_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes, unsigned short device_ref)
{
  unsigned offset = 0u;

  T_PNAK_SERVICE_DESCRIPTION* service_desc;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[offset];

  service_desc->DeviceRef = device_ref;
  service_desc->Instance = PN_CONTROLLER;
  service_desc->Service = PN_SERVICE_GET_DEVICE_STATE;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;

  /* Calculate length of service */

  service_desc->DataLength = sizeof(T_PN_SERVICE_GET_DEVICE_STATE_REQ);
}

void pack_read_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes, unsigned short device_ref,
                   pwr_sClass_PnReadReq* read_request)
{
  unsigned offset = 0u;

  T_PNAK_SERVICE_DESCRIPTION* service_desc;
  T_PN_SERVICE_READ_REQ* pRR;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[offset];

  service_desc->DeviceRef = device_ref;
  service_desc->Instance = PN_CONTROLLER;
  service_desc->Service = PN_SERVICE_READ;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;
  service_desc->DataLength = sizeof(T_PN_SERVICE_READ_REQ);

  pRR = (T_PN_SERVICE_READ_REQ*)(service_desc + 1);

  pRR->VersionHighByte = 1;
  pRR->VersionLowByte = 0;
  pRR->APIHighWordHighByte = _PN_U32_HIGH_HIGH_BYTE(read_request->Api);
  pRR->APIHighWordLowByte = _PN_U32_HIGH_LOW_BYTE(read_request->Api);
  pRR->APILowWordHighByte = _PN_U32_LOW_HIGH_BYTE(read_request->Api);
  pRR->APILowWordLowByte = _PN_U32_LOW_LOW_BYTE(read_request->Api);

  pRR->SlotNumberHighByte = _PN_U16_HIGH_BYTE(read_request->SlotNumber);
  pRR->SlotNumberLowByte = _PN_U16_LOW_BYTE(read_request->SlotNumber);
  pRR->SubSlotNumberHighByte = _PN_U16_HIGH_BYTE(read_request->SubslotNumber);
  pRR->SubSlotNumberLowByte = _PN_U16_LOW_BYTE(read_request->SubslotNumber);
  pRR->IndexHighByte = _PN_U16_HIGH_BYTE(read_request->Index);
  pRR->IndexLowByte = _PN_U16_LOW_BYTE(read_request->Index);
  pRR->LengthHighByte = _PN_U16_HIGH_BYTE(read_request->Length);
  pRR->LengthLowByte = _PN_U16_LOW_BYTE(read_request->Length);
}

void pack_write_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes, unsigned short device_ref,
                    pwr_sClass_PnWriteReq* wr_req)
{
  unsigned offset = 0u;

  T_PNAK_SERVICE_DESCRIPTION* service_desc;
  T_PN_SERVICE_WRITE_REQ* pWR;
  unsigned char* pData;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[offset];

  service_desc->DeviceRef = device_ref;
  service_desc->Instance = PN_CONTROLLER;
  service_desc->Service = PN_SERVICE_WRITE;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;

  /* Calculate length of service */

  service_desc->DataLength = sizeof(T_PN_SERVICE_WRITE_REQ) + wr_req->Length;

  pWR = (T_PN_SERVICE_WRITE_REQ*)(service_desc + 1);

  pWR->VersionHighByte = 1;
  pWR->VersionLowByte = 0;
  pWR->APIHighWordHighByte = _PN_U32_HIGH_HIGH_BYTE(wr_req->Api);
  pWR->APIHighWordLowByte = _PN_U32_HIGH_LOW_BYTE(wr_req->Api);
  pWR->APILowWordHighByte = _PN_U32_LOW_HIGH_BYTE(wr_req->Api);
  pWR->APILowWordLowByte = _PN_U32_LOW_LOW_BYTE(wr_req->Api);

  pWR->SlotNumberHighByte = _PN_U16_HIGH_BYTE(wr_req->SlotNumber);
  pWR->SlotNumberLowByte = _PN_U16_LOW_BYTE(wr_req->SlotNumber);
  pWR->SubSlotNumberHighByte = _PN_U16_HIGH_BYTE(wr_req->SubslotNumber);
  pWR->SubSlotNumberLowByte = _PN_U16_LOW_BYTE(wr_req->SubslotNumber);
  pWR->IndexHighByte = _PN_U16_HIGH_BYTE(wr_req->Index);
  pWR->IndexLowByte = _PN_U16_LOW_BYTE(wr_req->Index);
  pWR->LengthHighByte = _PN_U16_HIGH_BYTE(wr_req->Length);
  pWR->LengthLowByte = _PN_U16_LOW_BYTE(wr_req->Length);

  pData = (unsigned char*)(pWR + 1);

  memcpy(pData, wr_req->Data, wr_req->Length);
}

void pack_get_los_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes)
{
  unsigned offset = 0u;

  T_PNAK_SERVICE_DESCRIPTION* service_desc;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[offset];

  service_desc->DeviceRef = PN_DEVICE_REFERENCE_THIS_STATION;
  service_desc->Instance = PN_SUPERVISOR;
  service_desc->Service = PN_SERVICE_GET_LIST_OF_STATION;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;

  /* Calculate length of service */

  service_desc->DataLength = sizeof(T_PN_SERVICE_GET_LIST_OF_STATION_REQ);
}

void pack_get_alarm_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes, unsigned short ref, unsigned short device_ref)
{
  unsigned offset = 0u;

  T_PNAK_SERVICE_DESCRIPTION* service_desc;
  T_PN_SERVICE_GET_ALARM_REQ* pGAR;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[offset];

  service_desc->DeviceRef = device_ref;
  service_desc->Instance = PN;
  service_desc->Service = PN_SERVICE_GET_ALARM;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;

  /* Calculate length of service */

  service_desc->DataLength = sizeof(T_PN_SERVICE_GET_ALARM_REQ);

  pGAR = (T_PN_SERVICE_GET_ALARM_REQ*)(service_desc + 1);

  pGAR->AlarmRefHighByte = _PN_U16_HIGH_BYTE(ref);
  pGAR->AlarmRefLowByte = _PN_U16_LOW_BYTE(ref);
}

void pack_alarm_ack_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes, unsigned short ref, unsigned short prio,
                        unsigned short device_ref)
{
  unsigned offset = 0u;

  T_PNAK_SERVICE_DESCRIPTION* service_desc;
  T_PN_SERVICE_ALARM_ACK_REQ* pAAR;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[offset];

  service_desc->DeviceRef = device_ref;
  service_desc->Instance = PN;
  service_desc->Service = PN_SERVICE_ALARM_ACK;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;

  /* Calculate length of service */

  service_desc->DataLength = sizeof(T_PN_SERVICE_ALARM_ACK_REQ);

  pAAR = (T_PN_SERVICE_ALARM_ACK_REQ*)(service_desc + 1);

  pAAR->AlarmRefHighByte = _PN_U16_HIGH_BYTE(ref);
  pAAR->AlarmRefLowByte = _PN_U16_LOW_BYTE(ref);
  pAAR->AlarmPriority = _PN_U16_LOW_BYTE(prio);
}

void pack_download_req(T_PNAK_SERVICE_REQ_RES* ServiceReqRes, std::shared_ptr<ProfinetDevice> pn_device)
{
  // Detail codes page 142 PNAK Manual (For when Code == 1)
  T_PNAK_SERVICE_DESCRIPTION* service_desc;

  unsigned short device_ref = pn_device->m_rt_device_ref;
  unsigned short num_iocrs = 0;
  unsigned short num_apis = 0;
  unsigned short num_modules = 0;
  unsigned short num_submodules = 0;
  unsigned short num_datarecords = 0;
  unsigned short data_record_length = 0;

  char* pData;

  unsigned short no_items;
  unsigned short ii, length;
  std::map<int, PnApiData> api_map;

  static unsigned short phase = 1;

  memset(ServiceReqRes, 0, sizeof(T_PNAK_SERVICE_REQ_RES));
  ServiceReqRes->NumberEntries = 1;
  ServiceReqRes->ServiceEntry[0].ServiceOffset = 0;

  service_desc = (T_PNAK_SERVICE_DESCRIPTION*)&ServiceReqRes->ServiceChannel[0u];

  service_desc->DeviceRef = device_ref;
  //  service_desc->DeviceRef  = PN_DEVICE_REFERENCE_THIS_STATION;
  service_desc->Instance = PN; // PN_CONTROLLER
  service_desc->Service = PN_SERVICE_DOWNLOAD;
  service_desc->Primitive = PNAK_SERVICE_REQ;
  service_desc->ClientId = 0;
  service_desc->InvokeId = 0;

  /* Calculate length of service */

  // Calculate number of IOCR's
  // num_iocrs = xml_dev_data->iocr_data.size();
  num_iocrs = pn_device->m_IOCR_map.size();

  /* Calculate the rest */
  // for (std::vector<GsdmlSlotData*>::iterator mod_it = xml_dev_data->slot_data.begin();
  //      mod_it != xml_dev_data->slot_data.end(); mod_it++)
  for (auto const& slot : pn_device->m_slot_list)
  {
    // Skip empty slots
    if (slot.m_module_ID == "")
      continue;

    for (auto const& subslot : slot.m_subslot_map)
    // for (std::vector<GsdmlSubslotData*>::iterator sub_it = (*mod_it)->subslot_data.begin();
    //      sub_it != (*mod_it)->subslot_data.end(); sub_it++)
    {
      // Count submodules
      num_submodules++;

      // Count number of APIs we encounter and populate a map with indexes using
      // that API
      unsigned int api = subslot.second.m_api;
      if (api_map.find(api) == api_map.end())
      {
        printf("Found new API\n");
        api_map.emplace(api, api);
        num_apis++;
      }
      api_map[api].module_index.emplace(num_modules);

      // Count data records and record total length
      for (auto const& data_record : subslot.second.m_data_record_map)
      // for (std::vector<GsdmlDataRecord*>::iterator drec_it = (*sub_it)->data_record.begin();
      //      drec_it != (*sub_it)->data_record.end(); drec_it++)
      {
        num_datarecords++;
        data_record_length += data_record.second.m_data_length;
      }
    }
    // Count modules
    num_modules++;
  }

  // printf("Number of submodules for this slave: %d\n", num_submodules);
  // printf("Data record size for slave: %d\n", data_record_length);
  // printf("num_iocrs: %d\n", num_iocrs);
  // printf("num_apis: %d\n", num_apis);
  // printf("num_modules: %d\n", num_modules);
  // printf("num_submodules: %d\n", num_submodules);
  // printf("num_datarecords: %d\n", num_datarecords);
  // printf("num_data_record_length: %d\n", data_record_length);

  // printf("sizeof DOWNLOAD_REQ: %d\n", sizeof(T_PN_SERVICE_DOWNLOAD_REQ));
  // printf("sizeof PN_IOCR: %d\n", sizeof(T_PN_IOCR));
  // printf("sizeof T_PN_API: %d\n", sizeof(T_PN_API));
  // printf("sizeof T_PN_MODULE: %d\n", sizeof(T_PN_MODULE));
  // printf("sizeof T_PN_SUBMODULE: %d\n", sizeof(T_PN_SUBMODULE));
  // printf("sizeof T_PN_DATA_RECORD: %d\n", sizeof(T_PN_DATA_RECORD));
  // printf("sizeof T_PN_REFERENCE: %d\n", sizeof(T_PN_REFERENCE));

  pData = (char*)(service_desc + 1);

  /* Fill data in download request */

  T_PN_SERVICE_DOWNLOAD_REQ* pSDR = (T_PN_SERVICE_DOWNLOAD_REQ*)pData;

  unsigned char high_high_byte;
  unsigned char high_low_byte;
  unsigned char low_high_byte;
  unsigned char low_low_byte;
  // unsigned char high_byte;
  // unsigned char low_byte;
  unsigned long ar_property;
  unsigned short high_word;
  unsigned short low_word;
  // unsigned short sub_prop;
  T_PN_IOCR* pIOCR;
  T_PN_REFERENCE* pAPIReference;
  T_PN_REFERENCE* pModuleReference;
  T_PN_MODULE* pModule;
  T_PN_SUBMODULE* pSubModule;
  T_PN_REFERENCE* pDataRecordReference;
  T_PN_DATA_RECORD* pDataRecord;

  if (device_ref == 1)
  {
    printf("sizeof download-struct: %d\n", sizeof(T_PN_SERVICE_DOWNLOAD_REQ));
    printf("sizeof IOCR-struct: %d\n", sizeof(T_PN_IOCR));
    printf("sizeof API-struct: %d\n", sizeof(T_PN_API));
    printf("sizeof MODULE-struct: %d\n", sizeof(T_PN_MODULE));
    printf("sizeof SUBMODULE-struct: %d\n", sizeof(T_PN_SUBMODULE));
    printf("sizeof DATARECORD-struct: %d\n", sizeof(T_PN_DATA_RECORD));
    printf("sizeof REFERENCE-struct: %d\n", sizeof(T_PN_REFERENCE));
  }

  no_items = sscanf(pn_device->m_NetworkSettings.m_subnet_mask.c_str(), "%hhi.%hhi.%hhi.%hhi",
                    &high_high_byte, &high_low_byte, &low_high_byte, &low_low_byte);

  if (no_items == 4)
  {
    pSDR->SubnetMaskHighWordHighByte = high_high_byte;
    pSDR->SubnetMaskHighWordLowByte = high_low_byte;
    pSDR->SubnetMaskLowWordHighByte = low_high_byte;
    pSDR->SubnetMaskLowWordLowByte = low_low_byte;
  }

  no_items = sscanf(pn_device->m_NetworkSettings.m_ip_address.c_str(), "%hhi.%hhi.%hhi.%hhi", &high_high_byte,
                    &high_low_byte, &low_high_byte, &low_low_byte);

  if (no_items == 4)
  {
    pSDR->IpAddressHighWordHighByte = high_high_byte;
    pSDR->IpAddressHighWordLowByte = high_low_byte;
    pSDR->IpAddressLowWordHighByte = low_high_byte;
    pSDR->IpAddressLowWordLowByte = low_low_byte;
  }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-security"
snprintf(pSDR->DeviceName, PN_MAX_DEVICE_NAME_LENGTH, pn_device->m_NetworkSettings.m_device_name.c_str());
#pragma GCC diagnostic pop
  
  

  if (device_ref == PN_DEVICE_REFERENCE_THIS_STATION)
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-security"
    snprintf(pSDR->InterfaceName, PN_MAX_INTERFACE_NAME_LENGTH, pn_device->m_rt_interface_name.c_str());
#pragma GCC diagnostic pop
    
    // pSDR->Flag = PN_SERVICE_DOWNLOAD_FLAG_ACTIVATE;
    // PN_SERVICE_DOWNLOAD_FLAG_FULL_APPLICATION_IDENT_SUPPORT
    // PN_SERVICE_DOWNLOAD_FLAG_DISABLE_DCP_HELLO
    // PN_SERVICE_DOWNLOAD_FLAG_CERTIFICATION_ACTIVE
    // pSDR->Flag = PN_SERVICE_DOWNLOAD_FLAG_AUTO_CONTROL_RES;

    ar_property = 0;
    pSDR->InstanceLowByte = 0;
  }
  else
  {
    pSDR->DefaultRouterHighWordHighByte = high_high_byte;
    pSDR->DefaultRouterHighWordLowByte = high_low_byte;
    pSDR->DefaultRouterLowWordHighByte = low_high_byte;
    pSDR->DefaultRouterLowWordLowByte = low_low_byte;

    pSDR->Flag = PN_SERVICE_DOWNLOAD_FLAG_ACTIVATE;

    // ar_property = PROFINET_AR_PROPERTY_STATE_PRIMARY |
    //               PROFINET_AR_PROPERTY_PARAMETER_SERVER_CM |
    //               PROFINET_AR_PROPERTY_STARTUP_MODE_ADVANCED;

    // TODO Check if advanced startup and act accordingly
    ar_property = PROFINET_AR_PROPERTY_STATE_PRIMARY | PROFINET_AR_PROPERTY_PARAMETER_SERVER_CM;

    if (pn_device->m_IOCR_map.at(PROFINET_IO_CR_TYPE_INPUT).m_startup_mode == "Advanced")
    {
      ar_property |= PROFINET_AR_PROPERTY_STARTUP_MODE_ADVANCED;
    }
    else
    {
      ar_property |= PROFINET_AR_PROPERTY_STARTUP_MODE_LEGACY;
    }

    pSDR->AdditionalFlag = 0;
    if (pn_device->m_NetworkSettings.m_skip_ip_assignment)
      pSDR->AdditionalFlag |= PN_SERVICE_DOWNLOAD_ADD_FLAG_SKIP_IP_ASSIGNMENT;

    if (pn_device->m_IOCR_map.at(PROFINET_IO_CR_TYPE_INPUT).m_rt_class == "RT_CLASS_3")
      pSDR->AdditionalFlag |= PN_SERVICE_DOWNLOAD_ADD_FLAG_ENABLE_IRT;

    pSDR->InstanceHighByte = _PN_U16_HIGH_BYTE(pn_device->m_instance);
    pSDR->InstanceLowByte = _PN_U16_LOW_BYTE(pn_device->m_instance);
  }

  // TODO Check into what this is...manual says "Should be 1.0...."
  no_items =
      sscanf(pn_device->m_rt_version.c_str(), "%hhi.%hhi", &pSDR->VersionHighByte, &pSDR->VersionLowByte);

  high_word = _PN_U32_HIGH_WORD(ar_property);
  low_word = _PN_U32_LOW_WORD(ar_property);

  pSDR->ARPropertiesHighWordHighByte = _PN_U16_HIGH_BYTE(high_word);
  pSDR->ARPropertiesHighWordLowByte = _PN_U16_LOW_BYTE(high_word);
  pSDR->ARPropertiesLowWordHighByte = _PN_U16_HIGH_BYTE(low_word);
  pSDR->ARPropertiesLowWordLowByte = _PN_U16_LOW_BYTE(low_word);

  pSDR->DeviceIdHighByte = _PN_U16_HIGH_BYTE(pn_device->m_device_id);
  pSDR->DeviceIdLowByte = _PN_U16_LOW_BYTE(pn_device->m_device_id);
  pSDR->VendorIdHighByte = _PN_U16_HIGH_BYTE(pn_device->m_vendor_id);
  pSDR->VendorIdLowByte = _PN_U16_LOW_BYTE(pn_device->m_vendor_id);

  pSDR->NumberOfIOCRHighByte = _PN_U16_HIGH_BYTE(num_iocrs);
  pSDR->NumberOfIOCRLowByte = _PN_U16_LOW_BYTE(num_iocrs);
  pSDR->NumberOfAPIsHighByte = _PN_U16_HIGH_BYTE(num_apis);
  pSDR->NumberOfAPIsLowByte = _PN_U16_LOW_BYTE(num_apis);
  pSDR->NumberOfModulesHighByte = _PN_U16_HIGH_BYTE(num_modules);
  pSDR->NumberOfModulesLowByte = _PN_U16_LOW_BYTE(num_modules);
  pSDR->NumberOfDataRecordsHighByte = _PN_U16_HIGH_BYTE(num_datarecords);
  pSDR->NumberOfDataRecordsLowByte = _PN_U16_LOW_BYTE(num_datarecords);

  // TODO Check if some of this should be exposed as configuration options...
  pSDR->AlarmCRBlock.VersionHighByte = 1;
  pSDR->AlarmCRBlock.VersionLowByte = 0;
  pSDR->AlarmCRBlock.RTATimeoutFactorHighByte = 0;
  pSDR->AlarmCRBlock.RTATimeoutFactorLowByte = 1;
  pSDR->AlarmCRBlock.RTARetryHighByte = 0;
  pSDR->AlarmCRBlock.RTARetryLowByte = 3;
  pSDR->AlarmCRBlock.PropertiesHighWordHighByte = 0;
  pSDR->AlarmCRBlock.PropertiesHighWordLowByte = 0;
  pSDR->AlarmCRBlock.PropertiesLowWordHighByte = 0;
  pSDR->AlarmCRBlock.PropertiesLowWordLowByte = 0;
  pSDR->AlarmCRBlock.MaxAlarmLengthHighByte = 0;
  pSDR->AlarmCRBlock.MaxAlarmLengthLowByte = 200;
  pSDR->AlarmCRBlock.TagHeaderHighHighByte = 0xC0;
  pSDR->AlarmCRBlock.TagHeaderHighLowByte = 0;
  pSDR->AlarmCRBlock.TagHeaderLowHighByte = 0xA0;
  pSDR->AlarmCRBlock.TagHeaderLowLowByte = 0;

  length = sizeof(T_PN_SERVICE_DOWNLOAD_REQ);

  /* Fill the IOCRS's */

  pIOCR = (T_PN_IOCR*)(pSDR + 1);

  for (auto& iocr : pn_device->m_IOCR_map)
  {
    length += sizeof(T_PN_IOCR);

    /* Fill data for IOCR */
    pIOCR->VersionHighByte = pSDR->VersionHighByte;
    pIOCR->VersionLowByte = pSDR->VersionLowByte;
    pIOCR->TypeHighByte = _PN_U16_HIGH_BYTE(iocr.first);
    pIOCR->TypeLowByte = _PN_U16_LOW_BYTE(iocr.first);

    if (iocr.second.m_rt_class == "RT_CLASS_3")
      iocr.second.m_rt_properties |= PROFINET_IO_CR_RT_CLASS3;
    else if (iocr.second.m_rt_class == "RT_CLASS_2")
      iocr.second.m_rt_properties |= PROFINET_IO_CR_RT_CLASS2;
    else
      iocr.second.m_rt_properties |=
          PROFINET_IO_CR_RT_CLASS2; // RT_CLASS_2 even if device says CLASS_1. Things
                                    // stop working when we use CLASS_1 even if a device says it want
                                    // CLASS_1...

    pIOCR->PropertiesHighWordHighByte = _PN_U32_HIGH_HIGH_BYTE(iocr.second.m_rt_properties);
    pIOCR->PropertiesHighWordLowByte = _PN_U32_HIGH_LOW_BYTE(iocr.second.m_rt_properties);
    pIOCR->PropertiesLowWordHighByte = _PN_U32_LOW_HIGH_BYTE(iocr.second.m_rt_properties);
    pIOCR->PropertiesLowWordLowByte = _PN_U32_LOW_LOW_BYTE(iocr.second.m_rt_properties);
    pIOCR->SendClockFactorHighByte = _PN_U16_HIGH_BYTE(iocr.second.m_send_clock_factor);
    pIOCR->SendClockFactorLowByte = _PN_U16_LOW_BYTE(iocr.second.m_send_clock_factor);

    if (iocr.second.m_reduction_ratio < 1)
    {
      iocr.second.m_reduction_ratio = 1;
    }
    pIOCR->ReductionRatioHighByte = _PN_U16_HIGH_BYTE(iocr.second.m_reduction_ratio);
    pIOCR->ReductionRatioLowByte = _PN_U16_LOW_BYTE(iocr.second.m_reduction_ratio);

    // The configurator only allows to specify one value for phase so the same
    // phase is used for all IOCR's on this device But we keep the ability to
    // specify a unique phase value for each IOCR.
    phase = iocr.second.m_phase;
    pIOCR->PhaseHighByte = _PN_U16_HIGH_BYTE(phase);
    pIOCR->PhaseLowByte = _PN_U16_LOW_BYTE(phase);

    pIOCR->SequenceHighByte = 0; // Not supported (By stack) yet, set to 0
    pIOCR->SequenceLowByte = 0;  // Not supported (By stack) yet, set to 0
    pIOCR->WatchdogFactorHighByte = 0;
    pIOCR->WatchdogFactorLowByte = 10;
    pIOCR->DataHoldFactorHighByte = 0;
    pIOCR->DataHoldFactorLowByte = 10;
    pIOCR->FrameSendOffsetHighWordHighByte =
        0xFF; // Not supported yet (By stack), set to as fast as possible (0xFFFFFFFF)
    pIOCR->FrameSendOffsetHighWordLowByte = 0xFF;
    pIOCR->FrameSendOffsetLowWordHighByte = 0xFF;
    pIOCR->FrameSendOffsetLowWordLowByte = 0xFF;
    pIOCR->TagHeaderHighByte = 0xC0; // High and low byte of the VLAN tag header (ID and priority).
    pIOCR->TagHeaderLowByte = 0;
    pIOCR->MulticastAddr.HighAndVersionHighByte = 0; // Not supported (By stack) yet set to 0
    pIOCR->MulticastAddr.HighAndVersionLowByte = 0;  // Not supported (By stack) yet set to 0
    pIOCR->MulticastAddr.MidHighByte = 0;            // Not supported (By stack) yet set to 0
    pIOCR->MulticastAddr.MidLowByte = 0;             // Not supported (By stack) yet set to 0
    pIOCR->MulticastAddr.LowHighByte = 0;            // Not supported (By stack) yet set to 0
    pIOCR->MulticastAddr.LowLowByte = 0;             // Not supported (By stack) yet set to 0
    pIOCR->NumberOfAPIsHighByte = _PN_U16_HIGH_BYTE(num_apis);
    pIOCR->NumberOfAPIsLowByte = _PN_U16_LOW_BYTE(num_apis);

    /* Fill references to API */

    pAPIReference = (T_PN_REFERENCE*)(pIOCR + 1);
    // printf("api_map.size(): %d\n", (int)api_map.size());

    for (const auto& cApi : api_map)
    {
      // printf("Adding reference to API %d for this IOCR %d\n", cApi.second.api, cApi.first);
      length += sizeof(T_PN_REFERENCE);
      pAPIReference->ReferenceHighByte = _PN_U16_HIGH_BYTE(cApi.second.api);
      pAPIReference->ReferenceLowByte = _PN_U16_LOW_BYTE(cApi.second.api);
      pAPIReference++;
    }

    pIOCR = (T_PN_IOCR*)pAPIReference;
  }

  /* Fill the API's */

  T_PN_API* pAPI = (T_PN_API*)pIOCR;

  for (const auto& cApi : api_map)
  {
    length += sizeof(T_PN_API);
    /* Fill data for API */
    // printf("cApi.second.api: %d\n", cApi.second.api);
    // printf("cApi.second.module_index.size(): %d\n", (int)cApi.second.module_index.size());
    pAPI->APIHighWordHighByte = _PN_U32_HIGH_HIGH_BYTE(cApi.second.api);
    pAPI->APIHighWordLowByte = _PN_U32_HIGH_LOW_BYTE(cApi.second.api);
    pAPI->APILowWordHighByte = _PN_U32_LOW_HIGH_BYTE(cApi.second.api);
    pAPI->APILowWordLowByte = _PN_U32_LOW_LOW_BYTE(cApi.second.api);

    pAPI->NumberOfModulesHighByte = _PN_U16_HIGH_BYTE(cApi.second.module_index.size());
    pAPI->NumberOfModulesLowByte = _PN_U16_LOW_BYTE(cApi.second.module_index.size()); // Blir 7?

    // printf("number of modules (%d) for api %d\n", pAPI->NumberOfModulesLowByte, cApi.second.api);

    /* Fill references to Modules */

    pModuleReference = (T_PN_REFERENCE*)(pAPI + 1);

    for (unsigned int index : cApi.second.module_index)
    {
      //printf("Adding reference to module %d for API %d\n", index, cApi.second.api);
      length += sizeof(T_PN_REFERENCE);
      pModuleReference->ReferenceHighByte = _PN_U16_HIGH_BYTE(index);
      pModuleReference->ReferenceLowByte = _PN_U16_LOW_BYTE(index);
      pModuleReference++;
    }

    pAPI = (T_PN_API*)pModuleReference;
  }

  /* Fill the MODULE's */

  pModule = (T_PN_MODULE*)pAPI;

  for (auto& slot : pn_device->m_slot_list)
  {
    // Skip empty slot
    if (slot.m_module_ID == "")
      continue;

    length += sizeof(T_PN_MODULE);
    /* Fill data for MODULE */
    pModule->VersionHighByte = pSDR->VersionHighByte;
    pModule->VersionLowByte = pSDR->VersionLowByte;
    pModule->SlotNumberHighByte = _PN_U16_HIGH_BYTE(slot.m_slot_number);
    pModule->SlotNumberLowByte = _PN_U16_LOW_BYTE(slot.m_slot_number);
    pModule->IdentNumberHighWordHighByte = _PN_U32_HIGH_HIGH_BYTE(slot.m_module_ident_number);
    pModule->IdentNumberHighWordLowByte = _PN_U32_HIGH_LOW_BYTE(slot.m_module_ident_number);
    pModule->IdentNumberLowWordHighByte = _PN_U32_LOW_HIGH_BYTE(slot.m_module_ident_number);
    pModule->IdentNumberLowWordLowByte = _PN_U32_LOW_LOW_BYTE(slot.m_module_ident_number);
    pModule->PropertiesHighByte = 0;
    pModule->PropertiesLowByte = 0;
    pModule->NumberOfSubmodulesHighByte = _PN_U16_HIGH_BYTE(slot.m_subslot_map.size());
    pModule->NumberOfSubmodulesLowByte = _PN_U16_LOW_BYTE(slot.m_subslot_map.size());
    /* Fill the SUBMODULE's */

    pSubModule = (T_PN_SUBMODULE*)(pModule + 1);

    for (auto& subslot : slot.m_subslot_map)
    // for (jj = 0; jj < xml_dev_data->slot_data[ii]->subslot_data.size(); jj++)
    {
      length += sizeof(T_PN_SUBMODULE);
      /* Fill data for the submodule */

      pSubModule->SubSlotNumberHighByte = _PN_U16_HIGH_BYTE(subslot.second.m_subslot_number);
      pSubModule->SubSlotNumberLowByte = _PN_U16_LOW_BYTE(subslot.second.m_subslot_number);
      pSubModule->IdentNumberHighWordHighByte =
          _PN_U32_HIGH_HIGH_BYTE(subslot.second.m_submodule_ident_number);
      pSubModule->IdentNumberHighWordLowByte = _PN_U32_HIGH_LOW_BYTE(subslot.second.m_submodule_ident_number);
      pSubModule->IdentNumberLowWordHighByte = _PN_U32_LOW_HIGH_BYTE(subslot.second.m_submodule_ident_number);
      pSubModule->IdentNumberLowWordLowByte = _PN_U32_LOW_LOW_BYTE(subslot.second.m_submodule_ident_number);
      pSubModule->PropertiesHighByte = _PN_U16_HIGH_BYTE(subslot.second.m_rt_io_submodule_type);
      pSubModule->PropertiesLowByte = _PN_U16_LOW_BYTE(subslot.second.m_rt_io_submodule_type);
      pSubModule->InputDataLengthHighByte = _PN_U16_HIGH_BYTE(subslot.second.m_io_input_length);
      pSubModule->InputDataLengthLowByte = _PN_U16_LOW_BYTE(subslot.second.m_io_input_length);
      pSubModule->OutputDataLengthHighByte = _PN_U16_HIGH_BYTE(subslot.second.m_io_output_length);
      pSubModule->OutputDataLengthLowByte = _PN_U16_LOW_BYTE(subslot.second.m_io_output_length);
      pSubModule->ConsumerStatusLength = 1; // Fixed by Profinet-spec
      pSubModule->ProviderStatusLength = 1;
      pSubModule->NumberOfDataRecordsHighByte = _PN_U16_HIGH_BYTE(subslot.second.m_data_record_map.size());
      pSubModule->NumberOfDataRecordsLowByte = _PN_U16_LOW_BYTE(subslot.second.m_data_record_map.size());

      /* Add number of datarecords */

      pDataRecordReference = (T_PN_REFERENCE*)(pSubModule + 1);

      for (int ref_index = 0; ref_index < subslot.second.m_data_record_map.size(); ref_index++)
      {
        length += sizeof(T_PN_REFERENCE);
        pDataRecordReference->ReferenceHighByte = _PN_U16_HIGH_BYTE(ref_index);
        pDataRecordReference->ReferenceLowByte = _PN_U16_LOW_BYTE(ref_index);
        pDataRecordReference++;
      }

      pSubModule = (T_PN_SUBMODULE*)pDataRecordReference;
    }

    pModule = (T_PN_MODULE*)pSubModule;
  }

  /* Fill the DATA_RECORD's */

  pDataRecord = (T_PN_DATA_RECORD*)pModule;

  for (auto& slot : pn_device->m_slot_list)
  // for (ii = 0; ii < num_modules; ii++)
  {
    // Skip empty slot
    if (slot.m_module_ID == "")
      continue;

    for (auto& subslot : slot.m_subslot_map)
    // for (jj = 0; jj < xml_dev_data->slot_data[ii]->subslot_data.size(); jj++)
    {
      for (auto& data_record : subslot.second.m_data_record_map)
      // for (kk = 0; kk < xml_dev_data->slot_data[ii]->subslot_data[jj]->data_record.size(); kk++)
      {
        length += sizeof(T_PN_DATA_RECORD) + data_record.second.m_data_length;
        // printf("Fill data records slot (%d), subslot(%d): %d \n", ii, jj, kk);
        pDataRecord->VersionHighByte = pSDR->VersionHighByte;
        pDataRecord->VersionLowByte = pSDR->VersionLowByte;
        pDataRecord->SequenceHighByte = _PN_U16_HIGH_BYTE(data_record.second.m_transfer_sequence);
        pDataRecord->SequenceLowByte = _PN_U16_LOW_BYTE(data_record.second.m_transfer_sequence);
        pDataRecord->APIHighWordHighByte = _PN_U32_HIGH_HIGH_BYTE(subslot.second.m_api);
        pDataRecord->APIHighWordLowByte = _PN_U32_HIGH_LOW_BYTE(subslot.second.m_api);
        pDataRecord->APILowWordHighByte = _PN_U32_LOW_HIGH_BYTE(subslot.second.m_api);
        pDataRecord->APILowWordLowByte = _PN_U32_LOW_LOW_BYTE(subslot.second.m_api);
        pDataRecord->IndexHighByte = _PN_U16_HIGH_BYTE(data_record.second.m_index);
        pDataRecord->IndexLowByte = _PN_U16_LOW_BYTE(data_record.second.m_index);
        pDataRecord->LengthHighByte = _PN_U16_HIGH_BYTE(data_record.second.m_data_length);
        pDataRecord->LengthLowByte = _PN_U16_LOW_BYTE(data_record.second.m_data_length);

        pData = (char*)(pDataRecord + 1);
        memcpy(pData, data_record.second.m_data, data_record.second.m_data_length);
        pData += data_record.second.m_data_length;

        pDataRecord = (T_PN_DATA_RECORD*)pData;
      }
    }
  }

  service_desc->DataLength = length;

  if (device_ref != 0)
  {

    pData = (char*)(pSDR);
    printf("Download of device: %s\n", pn_device->m_NetworkSettings.m_device_name.c_str());
    printf("Total datalength %d\n\n", length);
    for (ii = 0; ii < length; ii++)
    {
      if (ii % 16 == 0)
        printf("\n");
      printf("%02hhX ", pData[ii]);
    }
    printf("\n");
    printf("\n");
  }
}

// los = List Of Station (T_PN_SERVICE_GET_LIST_OF_STATION_CON)
int unpack_get_los_con(T_PNAK_SERVICE_DESCRIPTION* pSdb, io_sAgentLocal* local)
{
  if (pSdb->Result == PNAK_RESULT_POS)
  {
    T_PN_SERVICE_GET_LIST_OF_STATION_CON* pGetLOSCon;
    T_PN_DEVICE_INFO* pDeviceInfo;
    std::shared_ptr<ProfinetDevice> pn_device;

    PN_U16 NumberDevices;
    unsigned short ii, name_length;

    pGetLOSCon = (T_PN_SERVICE_GET_LIST_OF_STATION_CON*)(pSdb + 1);
    pDeviceInfo = (T_PN_DEVICE_INFO*)(pGetLOSCon + 1);

    NumberDevices =
        _HIGH_LOW_BYTES_TO_PN_U16(pGetLOSCon->NumberOfDevicesHighByte, pGetLOSCon->NumberOfDevicesLowByte);

    /* Find configured device */
    if (NumberDevices == 0)
      printf("0\r\n");

    for (ii = 0; ii < NumberDevices; ii++)
    {
      pn_device = std::make_shared<ProfinetDevice>();

      pn_device->m_rt_ipaddress[3] = pDeviceInfo->Ip.AddressHighWordHighByte;
      pn_device->m_rt_ipaddress[2] = pDeviceInfo->Ip.AddressHighWordLowByte;
      pn_device->m_rt_ipaddress[1] = pDeviceInfo->Ip.AddressLowWordHighByte;
      pn_device->m_rt_ipaddress[0] = pDeviceInfo->Ip.AddressLowWordLowByte;
      pn_device->m_rt_macaddress[5] = pDeviceInfo->MacAddress.HighAndVersionHighByte;
      pn_device->m_rt_macaddress[4] = pDeviceInfo->MacAddress.HighAndVersionLowByte;
      pn_device->m_rt_macaddress[3] = pDeviceInfo->MacAddress.MidHighByte;
      pn_device->m_rt_macaddress[2] = pDeviceInfo->MacAddress.MidLowByte;
      pn_device->m_rt_macaddress[1] = pDeviceInfo->MacAddress.LowHighByte;
      pn_device->m_rt_macaddress[0] = pDeviceInfo->MacAddress.LowLowByte;

      pn_device->m_device_id = _HIGH_LOW_BYTES_TO_PN_U16(pDeviceInfo->Property.DeviceIdHighByte,
                                                         pDeviceInfo->Property.DeviceIdLowByte);
      pn_device->m_vendor_id = _HIGH_LOW_BYTES_TO_PN_U16(pDeviceInfo->Property.VendorIdHighByte,
                                                         pDeviceInfo->Property.VendorIdLowByte);

      name_length = _HIGH_LOW_BYTES_TO_PN_U16(pDeviceInfo->DeviceNameLengthHighByte,
                                              pDeviceInfo->DeviceNameLengthLowByte);

      // printf("no: %d            mac: %hhx:%hhx:%hhx:%hhx:%hhx:%hhx\r\n", NumberDevices,
      //        pDeviceInfo->MacAddress.HighAndVersionHighByte, pDeviceInfo->MacAddress.HighAndVersionLowByte,
      //        pDeviceInfo->MacAddress.MidHighByte, pDeviceInfo->MacAddress.MidLowByte,
      //        pDeviceInfo->MacAddress.LowHighByte, pDeviceInfo->MacAddress.LowLowByte);

      pDeviceInfo++;
      pn_device->m_NetworkSettings.m_device_name = std::string((char*)pDeviceInfo, name_length);
      local->device_list.push_back(pn_device);
      
      pDeviceInfo = (T_PN_DEVICE_INFO*)((unsigned char*)pDeviceInfo + name_length);
    }
    return PNAK_OK;
  }
  else if (pSdb->Result == PNAK_RESULT_NEG)
  {
    T_PN_SERVICE_ERROR_CON* pErrorCon = (T_PN_SERVICE_ERROR_CON*)(pSdb + 1);

    printf("channel %d: get_los.con [-] (%d)\r\n"
           "            code       : %d (0x%02x)\r\n"
           "            detail     : %d (0x%02x)\r\n"
           "            add. detail: %d (0x%02x)\r\n"
           "            area       : %d (0x%02x)\r\n",
           0, pSdb->DeviceRef, pErrorCon->Code, pErrorCon->Code, pErrorCon->Detail, pErrorCon->Detail,
           pErrorCon->AdditionalDetail, pErrorCon->AdditionalDetail, pErrorCon->AreaCode,
           pErrorCon->AreaCode);
  }

  return -1;
}

int unpack_read_con(T_PNAK_SERVICE_DESCRIPTION* pSdb, io_sAgentLocal* local)
{
  int i;
  io_sAgent* ap = local->args.ap;
  io_sRack* slave_list;
  pwr_sClass_PnDevice* sp = NULL;
  // std::shared_ptr<ProfinetDevice> pn_dev;
  pwr_tUInt32 saved_counter;
  unsigned short device_ref = pSdb->DeviceRef;

  if (ap)
  {
    // Find device in agent rack. Start iterating on 1 since 0 is our "station".
    // 1 is the first device in device_data vector
    for (slave_list = ap->racklist, i = 1; slave_list != NULL; slave_list = slave_list->next, i++)
    {
      // Do we have a match
      if (local->device_list[i]->m_rt_device_ref == device_ref)
      {
        sp = (pwr_sClass_PnDevice*)slave_list->op;
        // pn_dev = local->device_list[i];
        saved_counter = sp->ReadReq.response.counter;
        memset(&sp->ReadReq.response, 0, sizeof(pwr_sClass_PnReadCon));
        sp->ReadReq.response.counter = saved_counter;
        break;
      }
    }

    // Something is weird, we didn't find a corresponding slave...
    if (!sp)
    {
      errh_Warning("PROFINET: No device found for device reference %d", device_ref);
      return PNAK_OK;
    }
  }
  else
  {
    errh_Warning("PROFINET: No valid agent pointer while unpacking read con "
                 "for device %d",
                 device_ref);
    return PNAK_OK; // If we have no valid agent pointer just....return....
  }

  // Regardless of result, reset the read session and increase counter
  sp->ReadReq.status = pwr_ePnDeviceReadWriteState_Ready;
  sp->ReadReq.response.counter++;

  pwr_sClass_PnReadCon* read_con = &sp->ReadReq.response;

  if (pSdb->Result == PNAK_RESULT_POS)
  {
    T_PN_SERVICE_READ_CON* pReadRes = (T_PN_SERVICE_READ_CON*)(pSdb + 1);

    read_con->result = pwr_ePnReadWriteResultEnum_OK;
    read_con->API = _HIGH_LOW_BYTES_TO_PN_U32(pReadRes->APIHighWordHighByte, pReadRes->APIHighWordLowByte,
                                              pReadRes->APILowWordHighByte, pReadRes->APILowWordLowByte);
    read_con->SlotNumber =
        _HIGH_LOW_BYTES_TO_PN_U16(pReadRes->SlotNumberHighByte, pReadRes->SlotNumberLowByte);
    read_con->SubslotNumber =
        _HIGH_LOW_BYTES_TO_PN_U16(pReadRes->SubSlotNumberHighByte, pReadRes->SubSlotNumberLowByte);
    read_con->Index = _HIGH_LOW_BYTES_TO_PN_U16(pReadRes->IndexHighByte, pReadRes->IndexLowByte);
    read_con->Length = _HIGH_LOW_BYTES_TO_PN_U16(pReadRes->LengthHighByte, pReadRes->LengthLowByte);

    unsigned char* data = (unsigned char*)++pReadRes;
    if (read_con->Length > 0)
    {
      memcpy(read_con->Data, data, read_con->Length);
    }

    return PNAK_OK;
  }
  else if (pSdb->Result == PNAK_RESULT_NEG)
  {
    T_PN_SERVICE_ERROR_CON* pErrorCon = (T_PN_SERVICE_ERROR_CON*)(pSdb + 1);
    read_con->result = pwr_ePnReadWriteResultEnum_ERROR;

    pwr_sClass_PnErrorCon* error_con = &read_con->error;

    error_con->Code = pErrorCon->Code;
    if (error_con->Code == PN_SERVICE_ERROR_CODE_LOCAL)
    {
      error_con->DetailLocal = pErrorCon->Detail; // Explains local errors
    }
    else if (error_con->Code == PN_SERVICE_ERROR_CODE_STACK)
    {
      error_con->DetailStack = pErrorCon->Detail; // Explains stack errors
    }
    error_con->Detail = pErrorCon->Detail;
    error_con->AdditionalDetail = pErrorCon->AdditionalDetail;
    error_con->AreaCode = pErrorCon->AreaCode;
  }

  return -1;
}

int unpack_write_con(T_PNAK_SERVICE_DESCRIPTION* pSdb, io_sAgentLocal* local)
{
  int i;
  io_sAgent* ap = local->args.ap;
  io_sRack* slave_list;
  pwr_sClass_PnDevice* sp;
  // std::shared_ptr<ProfinetDevice> pn_dev;
  pwr_tUInt32 saved_counter;
  unsigned short device_ref = pSdb->DeviceRef;

  if (ap)
  {
    // Find device in agent rack. Start iterating on 1 since 0 is our "station".
    // 1 is the first device in device_data vector
    for (slave_list = ap->racklist, i = 1; slave_list != NULL; slave_list = slave_list->next, i++)
    {
      // Do we have a match
      if (local->device_list[i]->m_rt_device_ref == device_ref)
      {
        sp = (pwr_sClass_PnDevice*)slave_list->op;
        // pn_dev = local->device_list[i];
        saved_counter = sp->WriteReq.response.counter;
        memset(&sp->WriteReq.response, 0, sizeof(pwr_sClass_PnWriteCon));
        sp->WriteReq.response.counter = saved_counter;
        break;
      }
    }

    // Something is weird, we didn't find a corresponding slave...
    if (!sp)
    {
      errh_Warning("PROFINET: No device found for device reference %d", device_ref);
      return PNAK_OK;
    }
  }
  else
  {
    errh_Warning("PROFINET: No valid agent pointer while unpacking write con "
                 "for device %d",
                 device_ref);
    return PNAK_OK; // If we have no valid agent pointer just....return....
  }

  // Regardless of result, reset the read session and increase counter
  sp->WriteReq.status = pwr_ePnDeviceReadWriteState_Ready;
  sp->WriteReq.response.counter++;

  pwr_sClass_PnWriteCon* write_con = &sp->WriteReq.response;

  if (pSdb->Result == PNAK_RESULT_POS)
  {
    write_con->result = pwr_ePnReadWriteResultEnum_OK;

    // Yepp, that's all. There's no more data except for 2 dummy bytes for the
    // compiler in this confirmation :)

    return PNAK_OK;
  }
  else if (pSdb->Result == PNAK_RESULT_NEG)
  {
    T_PN_SERVICE_ERROR_CON* pErrorCon = (T_PN_SERVICE_ERROR_CON*)(pSdb + 1);
    write_con->result = pwr_ePnReadWriteResultEnum_ERROR;

    pwr_sClass_PnErrorCon* error_con = &write_con->error;

    error_con->Code = pErrorCon->Code;
    if (error_con->Code == PN_SERVICE_ERROR_CODE_LOCAL)
    {
      error_con->DetailLocal = pErrorCon->Detail; // Explains local errors
    }
    else if (error_con->Code == PN_SERVICE_ERROR_CODE_STACK)
    {
      error_con->DetailStack = pErrorCon->Detail; // Explains stack errors
    }
    error_con->Detail = pErrorCon->Detail;
    error_con->AdditionalDetail = pErrorCon->AdditionalDetail;
    error_con->AreaCode = pErrorCon->AreaCode;
  }

  return -1;
}

int unpack_get_alarm_con(T_PNAK_SERVICE_DESCRIPTION* pSdb, io_sAgentLocal* local, io_sAgent* ap)
{
  if (pSdb->Result == PNAK_RESULT_POS)
  {
    T_PN_SERVICE_GET_ALARM_CON* pGAC;

    unsigned short alarm_reference;
    unsigned short alarm_prio;
    unsigned short remaining_alarms;
    unsigned short alarm_type;
    unsigned int alarm_api;
    unsigned int slot_number;
    unsigned int subslot_number;
    unsigned int module_ident_number;
    unsigned int submodule_ident_number;
    unsigned short alarm_specifier;
    unsigned short data_length;
    union data
    {
      unsigned char* raw_data;
      struct
      {
        pwr_tUInt16 UserStructureIdentifier;
        pwr_tUInt16 ChannelNumber;
        pwr_tUInt16 ChannelProperties;
        pwr_tUInt16 ChannelErrorType;
        pwr_tUInt16 ExtChannelErrorType;
        pwr_tUInt32 ExtChannelAddValue;
      } * pn_data;
    } data;

    unsigned short ii, jj;

    std::shared_ptr<ProfinetDevice> pn_device;
    // std::vector<ProfinetChannelDiag>
    // std::vector<GsdmlChannelDiag*> channel_diag_vector;
    std::unordered_map<uint, ProfinetChannelDiag>* device_channel_diag_map;

    pGAC = (T_PN_SERVICE_GET_ALARM_CON*)(pSdb + 1);

    alarm_reference = _HIGH_LOW_BYTES_TO_PN_U16(pGAC->AlarmRefHighByte, pGAC->AlarmRefLowByte);
    alarm_prio = pGAC->AlarmPriority;
    remaining_alarms = pGAC->RemainingAlarms;
    alarm_type = _HIGH_LOW_BYTES_TO_PN_U16(pGAC->AlarmTypeHighByte, pGAC->AlarmTypeLowByte);
    alarm_api = _HIGH_LOW_BYTES_TO_PN_U32(pGAC->APIHighWordHighByte, pGAC->APIHighWordLowByte,
                                          pGAC->APILowWordHighByte, pGAC->APILowWordLowByte);
    slot_number = _HIGH_LOW_BYTES_TO_PN_U16(pGAC->SlotNumberHighByte, pGAC->SlotNumberLowByte);
    subslot_number = _HIGH_LOW_BYTES_TO_PN_U16(pGAC->SubSlotNumberHighByte, pGAC->SubSlotNumberLowByte);
    module_ident_number = _HIGH_LOW_BYTES_TO_PN_U32(
        pGAC->ModuleIdentNumberHighWordHighByte, pGAC->ModuleIdentNumberHighWordLowByte,
        pGAC->ModuleIdentNumberLowWordHighByte, pGAC->ModuleIdentNumberLowWordLowByte);
    submodule_ident_number = _HIGH_LOW_BYTES_TO_PN_U32(
        pGAC->SubmoduleIdentNumberHighWordHighByte, pGAC->SubmoduleIdentNumberHighWordLowByte,
        pGAC->SubmoduleIdentNumberLowWordHighByte, pGAC->SubmoduleIdentNumberLowWordLowByte);
    alarm_specifier = _HIGH_LOW_BYTES_TO_PN_U16(pGAC->SpecifierHighByte, pGAC->SpecifierLowByte);
    data_length = _HIGH_LOW_BYTES_TO_PN_U16(pGAC->LengthHighByte, pGAC->LengthLowByte);
    data.raw_data = (unsigned char*)(pGAC + 1);

    /* Find the device */

    for (ii = 0; ii < local->device_list.size(); ii++)
    {
      if (local->device_list[ii]->m_rt_alarm_ref == alarm_reference)
      {
        pn_device = local->device_list[ii];
        device_channel_diag_map = &local->device_list[ii]->m_channel_diag_map;
        // local->device_list[ii]->m_channel_diag_map

        // channel_diag_vector = local->device_list[ii]->channel_diag;

        pn_device->m_rt_alarm_data.alarm_type = alarm_type;
        pn_device->m_rt_alarm_data.alarm_prio = alarm_prio;
        pn_device->m_rt_alarm_data.rem_alarms = remaining_alarms;
        pn_device->m_rt_alarm_data.slot_number = slot_number;
        pn_device->m_rt_alarm_data.sub_slot_number = subslot_number;
        pn_device->m_rt_alarm_data.module_ident_number = module_ident_number;
        pn_device->m_rt_alarm_data.submodule_ident_number = submodule_ident_number;
        pn_device->m_rt_alarm_data.alarm_spec = alarm_specifier;
        pn_device->m_rt_alarm_data.data_length = data_length;
        pn_device->m_rt_alarm_data.data = data.raw_data;

        break;
      }
    }

    if (ap)
    {
      /* Find corresponding device */
      io_sRack* slave_list;
      for (slave_list = ap->racklist, jj = 0; (slave_list != NULL) && jj < ii - 1;
           slave_list = slave_list->next, jj++)
      {
      }
      if (slave_list)
      {
        pwr_sClass_PnDevice* dev;
        pwr_sClass_PnAlarm* alarm;
        dev = (pwr_sClass_PnDevice*)slave_list->op;
        pwr_tObjid dev_objid = slave_list->Objid;

        int index = dev->AlarmBuffer.IndexNext++;
        if (dev->AlarmBuffer.IndexNext >= dev->AlarmBuffer.BufferSize)
          dev->AlarmBuffer.IndexNext = 0;

        alarm = &dev->AlarmBuffer.Alarms[index];

        gdh_SetTimeDL(&alarm->Timestamp, (pwr_tTime*)0);
        alarm->AlarmReference = alarm_reference;
        alarm->Prio = alarm_prio;
        alarm->RemainingAlarms = remaining_alarms;
        alarm->Type = alarm_type;
        alarm->API = alarm_api;
        alarm->SlotNumber = slot_number;
        alarm->SubslotNumber = subslot_number;
        alarm->ModuleIdentNumber = module_ident_number;
        alarm->SubmoduleIdentNumber = submodule_ident_number;
        alarm->Specifier = alarm_specifier;
        alarm->Length = data_length;
        if (data_length > 0)
        {
          memcpy(alarm->Data, data.raw_data, MIN(data_length, sizeof(alarm->Data)));
        }

        // Check if we should log or generate an alaram.
        // Low priority alarms goes as INFO
        // High priority alarms goes as WARNINGS

        io_sCard* card_list;
        pwr_sClass_PnModule* module = NULL;
        int selected_actions = 0;

        // SlotNumber 0 indicates that the device itself generated the alarm
        if (alarm->SlotNumber == 0)
        {
          selected_actions = dev->AlarmActionSelect;
        }
        else
        {
          // Find the module to check what action to take
          for (card_list = slave_list->cardlist; card_list != NULL; card_list = card_list->next)
          {
            module = (pwr_sClass_PnModule*)card_list->op;

            if (module->Slot != alarm->SlotNumber)
              continue;

            // Check what actions to take
            if (module->AlarmActionSelect)
            {
              if (module->AlarmActionSelect & pwr_mPnModuleAlarmActionMask_INHERIT)
              {
                selected_actions = dev->AlarmActionSelect;
              }
              if (module->AlarmActionSelect & pwr_mPnModuleAlarmActionMask_ALARM)
              {
                selected_actions |= pwr_mPnDeviceAlarmActionMask_ALARM;
              }
              if (module->AlarmActionSelect & pwr_mPnModuleAlarmActionMask_PROVIEW_LOG)
              {
                selected_actions |= pwr_mPnDeviceAlarmActionMask_PROVIEW_LOG;
              }
            }
          }
        }

        // Do we need to take action at all?
        if (selected_actions)
        {
          pwr_tOName dev_name; // The name/path of the device that generated
                               // the alarm
          char data_str[250];  // If we have a data payload available we store it in hex format as a string
          pwr_tString80 event_text = "\0";
          pwr_tString256 event_more_text = "\0";

          gdh_ObjidToName(dev_objid, dev_name, sizeof(dev_name), cdh_mName_pathStrict);

          // Pretty print the data in hex
          for (int dlength = 0; dlength < data_length; dlength++)
            sprintf(&data_str[dlength * 2], "%02X", *(data.raw_data + dlength));

          // Generate the messages
          if ((alarm->Type & PROFINET_ALARM_DIAGNOSIS_APPEARS) && data_length > 0)
          {
            // Generate null terminated messages (snprintf will always add '\0' even if strings are truncated)
            // Default is just an informal text and the data
            snprintf(event_more_text, sizeof(event_more_text), "Data: %s", data_str);
            snprintf(event_text, sizeof(event_text), "PROFINET: Diagnostics from Slot: %d, Subslot: %d",
                     alarm->SlotNumber, alarm->SubslotNumber);

            // for (GsdmlChannelDiag* channel_error_type : channel_diag_vector)
            // {

            // TODO check host endianess

            // Check if we have an error description stored...
            ushort error_type = bswap_16(data.pn_data->ChannelErrorType);
            if (device_channel_diag_map->count(error_type))
            {
              // We found a diagnostic string for this error type. Replace the generic alarm text.
              snprintf(event_text, sizeof(event_text), "PROFINET: %s",
                       device_channel_diag_map->at(error_type).m_name.c_str());
              snprintf(event_more_text, sizeof(event_more_text), "%s",
                       device_channel_diag_map->at(error_type).m_help.c_str());

              // Do we have any extended error types?
              ushort ext_error_type = bswap_16(data.pn_data->ExtChannelErrorType);
              if (device_channel_diag_map->at(error_type).m_ext_channel_diag_map.count(ext_error_type))
              {
                // Replace the alarm with the extended information instead
                snprintf(event_text, sizeof(event_text), "PROFINET: %s",
                         device_channel_diag_map->at(error_type)
                             .m_ext_channel_diag_map.at(ext_error_type)
                             .m_name.c_str());
                snprintf(event_more_text, sizeof(event_more_text), "%s",
                         device_channel_diag_map->at(error_type)
                             .m_ext_channel_diag_map.at(ext_error_type)
                             .m_help.c_str());
              }
            }
            // if (channel_error_type->error_type == bswap_16(data.pn_data->ChannelErrorType))
            // {
            //   // We found a diagnostic string for this error type. Replace the generic alarm text.
            //   snprintf(event_text, sizeof(event_text), "PROFINET: %s", channel_error_type->name);
            //   snprintf(event_more_text, sizeof(event_more_text), "%s", channel_error_type->help);

            //   // Do we have any extended error types?
            //   for (GsdmlExtChannelDiag* ext_channel_error_type : channel_error_type->ext_channel_diag)
            //   {
            //     if (ext_channel_error_type->error_type == bswap_16(data.pn_data->ExtChannelErrorType))
            //     {
            //       // Replace the alarm with the extended information instead
            //       snprintf(event_text, sizeof(event_text), "PROFINET: %s", ext_channel_error_type->name);
            //       snprintf(event_more_text, sizeof(event_more_text), "%s", ext_channel_error_type->help);
            //     }
            //   }
            // }
            //}
          }
          else if (alarm->Prio == pwr_ePnAlarmPrioEnum_High)
          {
            // Default high prio
            snprintf(event_text, sizeof(event_text),
                     "PROFINET High Priority Alarm. Slot: %d, Subslot: %d, "
                     "type: %d",
                     alarm->SlotNumber, alarm->SubslotNumber, alarm->Type);
          }
          else if (alarm->Prio == pwr_ePnAlarmPrioEnum_Low)
          {
            // Default low prio
            snprintf(event_text, sizeof(event_text),
                     "PROFINET Low Priority Alarm. Slot: %d, Subslot: %d, "
                     "type: %d",
                     alarm->SlotNumber, alarm->SubslotNumber, alarm->Type);
          }

          // Take actions
          if (selected_actions & pwr_mPnDeviceAlarmActionMask_ALARM)
          {
            mh_sApplMessage alarm_msg;
            pwr_tStatus alarm_sts;
            pwr_tUInt32 m_id; // Our message ID. Not used as of this writing but
                              // can be used to return an alarm state sent

            memset(&alarm_msg, 0, sizeof(alarm_msg));

            // Fill out the alarm message!
            alarm_msg.Object = dev_objid;
            alarm_msg.EventFlags = (mh_mEventFlags)(mh_mEventFlags_Bell | mh_mEventFlags_Ack |
                                                    mh_mEventFlags_Return | mh_mEventFlags_Returned);
            alarm_msg.EventTime = alarm->Timestamp;
            strncpy(alarm_msg.EventName, dev_name, sizeof(pwr_tString80));
            alarm_msg.EventType = mh_eEvent_Alarm;
            strcpy(alarm_msg.EventText, event_text);
            strcpy(alarm_msg.EventMoreText, event_more_text);
            // Set the alarm priority and default message if no data in alarm
            if (alarm->Prio == pwr_ePnAlarmPrioEnum_High)
            {
              alarm_msg.EventPrio = mh_eEventPrio_B;
            }
            else
            {
              alarm_msg.EventPrio = mh_eEventPrio_C;
            }

            alarm_sts = mh_ApplMessage(&m_id, &alarm_msg);
            if (EVEN(alarm_sts))
            {
              errh_Error("PROFINET: Error sending alarm");
              return alarm_sts;
            }
          }

          // Now check if we are to log anything
          if (selected_actions & pwr_mPnDeviceAlarmActionMask_PROVIEW_LOG)
          {
            if (alarm->Prio == pwr_ePnAlarmPrioEnum_Low)
            {
              errh_Warning("PROFINET: %s - %s", event_text, event_more_text);
            }
            else
            {
              errh_Error("PROFINET: %s - %s", event_text, event_more_text);
            }
          }
        }
      }
    }

    return PNAK_OK;
  }
  else if (pSdb->Result == PNAK_RESULT_NEG)
  {
    T_PN_SERVICE_ERROR_CON* pErrorCon = (T_PN_SERVICE_ERROR_CON*)(pSdb + 1);

    printf("channel %d: get_los.con [-] (%d)\r\n"
           "            code       : %d (0x%02x)\r\n"
           "            detail     : %d (0x%02x)\r\n"
           "            add. detail: %d (0x%02x)\r\n"
           "            area       : %d (0x%02x)\r\n",
           0, pSdb->DeviceRef, pErrorCon->Code, pErrorCon->Code, pErrorCon->Detail, pErrorCon->Detail,
           pErrorCon->AdditionalDetail, pErrorCon->AdditionalDetail, pErrorCon->AreaCode,
           pErrorCon->AreaCode);
  }

  return -1;
}
int unpack_get_device_state_con(T_PNAK_SERVICE_DESCRIPTION* pSdb, io_sAgentLocal* local, io_sAgent* ap)
{
  if (pSdb->Result == PNAK_RESULT_POS)
  {
    T_PN_SERVICE_GET_DEVICE_STATE_CON* pGDSC;
    T_PN_DIFF_MODULE* pDiffModule;

    // PN_U16 no_diff_modules;
    PN_U16 diff_mod_index;
    unsigned short device_ref, ii, jj;

    std::shared_ptr<ProfinetDevice> pn_device;
    unsigned short save_first = TRUE;
    unsigned short err_slot_number = 0;
    unsigned short err_module_state = 0;
    unsigned short phys_ident_number = 0;
    unsigned short dev_ind;

    device_ref = pSdb->DeviceRef;

    /* Find configured device */

    for (ii = 0; ii < local->device_list.size(); ii++)
    {
      if (local->device_list[ii]->m_rt_device_ref == device_ref)
      {
        pn_device = local->device_list[ii];
        break;
      }
    }

    if (ii == local->device_list.size())
      return -1; // ERR_NODEV_FOUND;

    dev_ind = ii;

    pGDSC = (T_PN_SERVICE_GET_DEVICE_STATE_CON*)(pSdb + 1);
    pDiffModule = (T_PN_DIFF_MODULE*)(pGDSC + 1);
    pn_device->m_rt_number_of_diff_modules =
        _HIGH_LOW_BYTES_TO_PN_U16(pGDSC->NumberOfDiffModulesHighByte, pGDSC->NumberOfDiffModulesLowByte);
    pn_device->m_rt_device_state = _HIGH_LOW_BYTES_TO_PN_U16(pGDSC->StateHighByte, pGDSC->StateLowByte);

    //    printf("No diff modules: %d \r\n", no_diff_modules);

    for (diff_mod_index = 0u; diff_mod_index < pn_device->m_rt_number_of_diff_modules; diff_mod_index++)
    {
      T_PN_DIFF_MODULE_API* pDiffModuleAPI = (T_PN_DIFF_MODULE_API*)(pDiffModule + 1);
      PN_U16 no_apis;
      PN_U16 api_ind;

      no_apis =
          _HIGH_LOW_BYTES_TO_PN_U16(pDiffModule->NumberOfAPIsHighByte, pDiffModule->NumberOfAPIsLowByte);

      for (api_ind = 0u; api_ind < no_apis; api_ind++)
      {
        T_PN_DIFF_MODULE_SLOT* pModuleSlot = (T_PN_DIFF_MODULE_SLOT*)(pDiffModuleAPI + 1);

        PN_U16 no_slots;
        PN_U16 slot_ind;

        no_slots = _HIGH_LOW_BYTES_TO_PN_U16(pDiffModuleAPI->NumberOfModulesHighByte,
                                             pDiffModuleAPI->NumberOfModulesLowByte);

        for (slot_ind = 0u; slot_ind < no_slots; slot_ind++)
        {
          T_PN_DIFF_MODULE_SUBSLOT* pModuleSubSlot = (T_PN_DIFF_MODULE_SUBSLOT*)(pModuleSlot + 1);

          PN_U16 no_subslots;
          PN_U16 subslot_ind;

          // PnModuleData* module_data = NULL;

          no_subslots = _HIGH_LOW_BYTES_TO_PN_U16(pModuleSlot->NumberOfSubmodulesHighByte,
                                                  pModuleSlot->NumberOfSubmodulesLowByte);

          for (auto& slot : pn_device->m_slot_list)
          // for (ii = 0; ii < device->module_data.size(); ii++)
          {

            // module_data = device->module_data[ii];

            if (slot.m_slot_number ==
                _HIGH_LOW_BYTES_TO_PN_U16(pModuleSlot->SlotNumberHighByte, pModuleSlot->SlotNumberLowByte))
            {
              slot.m_rt_state =
                  _HIGH_LOW_BYTES_TO_PN_U16(pModuleSlot->StateHighByte, pModuleSlot->StateLowByte);
              slot.m_rt_phys_ident_number = _HIGH_LOW_BYTES_TO_PN_U32(
                  pModuleSlot->IdentNumberHighWordHighByte, pModuleSlot->IdentNumberHighWordLowByte,
                  pModuleSlot->IdentNumberLowWordHighByte, pModuleSlot->IdentNumberLowWordLowByte);
              //	      printf("  Slot no: %d, State: %d \r\n",
              // module_data->slot_number, module_data->state);
              if (save_first)
              {
                err_slot_number = slot.m_slot_number;
                err_module_state = slot.m_rt_state;
                phys_ident_number = slot.m_rt_phys_ident_number;
                save_first = FALSE;
              }
              break;
            }

            for (subslot_ind = 0; subslot_ind < no_subslots; subslot_ind++)
            {
              // PnSubmoduleData* submodule_data;

              for (auto& subslot : slot.m_subslot_map)
              // for (jj = 0; jj < module_data->submodule_data.size(); jj++)
              {
                // submodule_data = module_data->submodule_data[jj];
                if (subslot.second.m_subslot_number ==
                    _HIGH_LOW_BYTES_TO_PN_U16(pModuleSubSlot->SubSlotNumberHighByte,
                                              pModuleSubSlot->SubSlotNumberLowByte))
                {
                  subslot.second.m_rt_state =
                      _HIGH_LOW_BYTES_TO_PN_U16(pModuleSubSlot->StateHighByte, pModuleSubSlot->StateLowByte);
                  subslot.second.m_rt_phys_ident_number = _HIGH_LOW_BYTES_TO_PN_U32(
                      pModuleSubSlot->IdentNumberHighWordHighByte, pModuleSubSlot->IdentNumberHighWordLowByte,
                      pModuleSubSlot->IdentNumberLowWordHighByte, pModuleSubSlot->IdentNumberLowWordLowByte);

                  //		    printf("    SubSlot no: %d, State: %d \r\n",
                  // submodule_data->subslot_number, submodule_data->state);
                }
              }

              pModuleSubSlot++;
            }
          }
          pModuleSlot = (T_PN_DIFF_MODULE_SLOT*)pModuleSubSlot;
        }
        pDiffModuleAPI = (T_PN_DIFF_MODULE_API*)pModuleSlot;
      }
      pDiffModule = (T_PN_DIFF_MODULE*)pDiffModuleAPI;
    }

    if (ap)
    {
      /* Find corresponding device */
      io_sRack* slave_list;
      for (slave_list = ap->racklist, jj = 0; (slave_list != NULL) && jj < dev_ind - 1;
           slave_list = slave_list->next, jj++)
      {
      }
      if (slave_list)
      {
        pwr_sClass_PnDevice* dev;
        dev = (pwr_sClass_PnDevice*)slave_list->op;
        dev->NoDiffModules = pn_device->m_rt_number_of_diff_modules;
        if (pn_device->m_rt_device_state == PNAK_DEVICE_STATE_CONNECTED)
          dev->Status = PB__NORMAL;
        else
          dev->Status = PB__NOCONN;
        if (!save_first)
        {
          dev->ErrSlotNumber = err_slot_number;
          dev->ErrModuleState = err_module_state;
          dev->PhysIdentNumber = phys_ident_number;
        }
        else
        {
          dev->ErrSlotNumber = 0;
          dev->ErrModuleState = 0;
          dev->PhysIdentNumber = 0;
        }
      }
    }

    return PNAK_OK;
  }
  else if (pSdb->Result == PNAK_RESULT_NEG)
  {
    T_PN_SERVICE_ERROR_CON* pErrorCon = (T_PN_SERVICE_ERROR_CON*)(pSdb + 1);

    printf("channel %d: get_device_state.con [-] (%d)\r\n"
           "            code       : %d (0x%02x)\r\n"
           "            detail     : %d (0x%02x)\r\n"
           "            add. detail: %d (0x%02x)\r\n"
           "            area       : %d (0x%02x)\r\n",
           0, pSdb->DeviceRef, pErrorCon->Code, pErrorCon->Code, pErrorCon->Detail, pErrorCon->Detail,
           pErrorCon->AdditionalDetail, pErrorCon->AdditionalDetail, pErrorCon->AreaCode,
           pErrorCon->AreaCode);
  }

  return -1;
}

int unpack_download_con(T_PNAK_SERVICE_DESCRIPTION* pSdb, io_sAgentLocal* local)
{
  if (pSdb->Result == PNAK_RESULT_POS)
  {
    T_PN_SERVICE_DOWNLOAD_CON* pDownloadCon;
    T_PN_IOCR_INFO* pIOCRInfo;

    PN_U16 NumberIOCRs;
    PN_U16 IOCRIndex;
    unsigned short device_ref, ii;

    // std::shared_ptr<PnDeviceData> device;
    std::shared_ptr<ProfinetDevice> pn_device;

    device_ref = pSdb->DeviceRef;

    /* Find configured device */

    for (ii = 0; ii < local->device_list.size(); ii++)
    {
      if (local->device_list[ii]->m_rt_device_ref == device_ref)
      {
        pn_device = local->device_list[ii];
        break;
      }
    }

    if (ii == local->device_list.size())
    {
      printf("No dev found!\n");
      return -1; // ERR_NODEV_FOUND;
    }

    pDownloadCon = (T_PN_SERVICE_DOWNLOAD_CON*)(pSdb + 1);
    pIOCRInfo = (T_PN_IOCR_INFO*)(pDownloadCon + 1);
    NumberIOCRs =
        _HIGH_LOW_BYTES_TO_PN_U16(pDownloadCon->NumberOfIOCRHighByte, pDownloadCon->NumberOfIOCRLowByte);

    pn_device->m_rt_alarm_ref =
        _HIGH_LOW_BYTES_TO_PN_U16(pDownloadCon->AlarmRefHighByte, pDownloadCon->AlarmRefLowByte);

    for (IOCRIndex = 0u; IOCRIndex < NumberIOCRs; IOCRIndex++)
    {
      T_PN_API_INFO* pAPIInfo = (T_PN_API_INFO*)(pIOCRInfo + 1);
      PN_U16 NumberAPIs;
      PN_U16 APIIndex;
      // PnIOCRData* iocr_data = NULL;

      unsigned short type;

      type = _HIGH_LOW_BYTES_TO_PN_U16(pIOCRInfo->TypeHighByte, pIOCRInfo->TypeLowByte);

      // for (ii = 0; ii < pn_device->iocr_data.size(); ii++)
      // {
      // for (auto& iocr : pn_device->m_IOCR_map)
      // {
      //   if (pn_device->iocr_data[ii]->type == type)
      //   {
      //     iocr_data = device->iocr_data[ii];
      //     break;
      //   }
      // }

      // if (ii == device->iocr_data.size())
      // {
      //   /* This iocr is not found, log something and continue */

      //   printf("iocr not found %d \n", type);
      //   continue;
      // }

      if (!pn_device->m_IOCR_map.count(type))
      {
        continue;
      }

      pn_device->m_IOCR_map.at(type);
      // iocr_data->type = _HIGH_LOW_BYTES_TO_PN_U16(pIOCRInfo->TypeHighByte, pIOCRInfo->TypeLowByte);
      pn_device->m_IOCR_map.at(type).m_rt_identifier =
          _HIGH_LOW_BYTES_TO_PN_U16(pIOCRInfo->IOCRIdentifierHighByte, pIOCRInfo->IOCRIdentifierLowByte);
      pn_device->m_IOCR_map.at(type).m_rt_io_data_length =
          _HIGH_LOW_BYTES_TO_PN_U16(pIOCRInfo->IODataLengthHighByte, pIOCRInfo->IODataLengthLowByte);
      pn_device->m_IOCR_map.at(type).m_rt_io_data =
          (unsigned char*)calloc(1, pn_device->m_IOCR_map.at(type).m_rt_io_data_length);
      //      printf("            iocr (0x%04x) 0x%04x %d\r\n",
      // 	     _HIGH_LOW_BYTES_TO_PN_U16 (pIOCRInfo->TypeHighByte,
      // pIOCRInfo->TypeLowByte),
      // 	     _HIGH_LOW_BYTES_TO_PN_U16
      // (pIOCRInfo->IOCRIdentifierHighByte, pIOCRInfo->IOCRIdentifierLowByte),
      // 	     _HIGH_LOW_BYTES_TO_PN_U16 (pIOCRInfo->IODataLengthHighByte,
      // pIOCRInfo->IODataLengthLowByte));

      NumberAPIs = _HIGH_LOW_BYTES_TO_PN_U16(pIOCRInfo->NumberOfAPIsHighByte, pIOCRInfo->NumberOfAPIsLowByte);

      for (APIIndex = 0u; APIIndex < NumberAPIs; APIIndex++)
      {
        T_PN_DATA_INFO* pDataInfo = (T_PN_DATA_INFO*)(pAPIInfo + 1);

        PN_U16 NumberIODatas;
        PN_U16 IODataIndex;

        //	printf("              api 0x%04x%04x\r\n"
        //	       "                data\r\n",
        //	       _HIGH_LOW_BYTES_TO_PN_U16 (pAPIInfo->APIHighWordHighByte,
        // pAPIInfo->APIHighWordLowByte),
        //	       _HIGH_LOW_BYTES_TO_PN_U16 (pAPIInfo->APILowWordHighByte,
        // pAPIInfo->APILowWordLowByte));
        //

        NumberIODatas =
            _HIGH_LOW_BYTES_TO_PN_U16(pAPIInfo->NumberOfIODataHighByte, pAPIInfo->NumberOfIODataLowByte);

        for (IODataIndex = 0u; IODataIndex < NumberIODatas; IODataIndex++)
        {
          //	  printf("                  slot: %d subslot: %d offset:
          //%d\r\n",
          //		 _HIGH_LOW_BYTES_TO_PN_U16
          //(pDataInfo->SlotNumberHighByte,
          // pDataInfo->SlotNumberLowByte),
          //		 _HIGH_LOW_BYTES_TO_PN_U16
          //(pDataInfo->SubSlotNumberHighByte, pDataInfo->SubSlotNumberLowByte),
          //		 _HIGH_LOW_BYTES_TO_PN_U16 (pDataInfo->OffsetHighByte,
          // pDataInfo->OffsetLowByte));

          for (auto& slot : pn_device->m_slot_list)
          // for (ii = 0; ii < device->module_data.size(); ii++)
          {
            // PnModuleData* module_data;

            // module_data = device->module_data[ii];

            if (slot.m_slot_number ==
                _HIGH_LOW_BYTES_TO_PN_U16(pDataInfo->SlotNumberHighByte, pDataInfo->SlotNumberLowByte))
            {
              for (auto& subslot : slot.m_subslot_map)
              // for (jj = 0; jj < module_data->submodule_data.size(); jj++)
              {
                // PnSubmoduleData* submodule_data;

                // submodule_data = module_data->submodule_data[jj];
                if (subslot.second.m_subslot_number ==
                    _HIGH_LOW_BYTES_TO_PN_U16(pDataInfo->SubSlotNumberHighByte,
                                              pDataInfo->SubSlotNumberLowByte))
                {
                  if (PROFINET_IO_CR_TYPE_INPUT == type)
                  {
                    subslot.second.m_rt_offset_io_in =
                        _HIGH_LOW_BYTES_TO_PN_U16(pDataInfo->OffsetHighByte, pDataInfo->OffsetLowByte);
                  }
                  else
                  {
                    subslot.second.m_rt_offset_io_out =
                        _HIGH_LOW_BYTES_TO_PN_U16(pDataInfo->OffsetHighByte, pDataInfo->OffsetLowByte);
                  }
                }
              }
            }
          }
          pDataInfo++;
        }

        //	printf ("                status\r\n");
        NumberIODatas =
            _HIGH_LOW_BYTES_TO_PN_U16(pAPIInfo->NumberOfIOStatusHighByte, pAPIInfo->NumberOfIOStatusLowByte);

        for (IODataIndex = 0u; IODataIndex < NumberIODatas; IODataIndex++)
        {
          //	  printf("                  slot: %d subslot: %d offset:
          //%d\r\n",
          //		 _HIGH_LOW_BYTES_TO_PN_U16
          //(pDataInfo->SlotNumberHighByte,
          // pDataInfo->SlotNumberLowByte),
          //		 _HIGH_LOW_BYTES_TO_PN_U16
          //(pDataInfo->SubSlotNumberHighByte, pDataInfo->SubSlotNumberLowByte),
          //		 _HIGH_LOW_BYTES_TO_PN_U16 (pDataInfo->OffsetHighByte,
          // pDataInfo->OffsetLowByte));

          for (auto& slot : pn_device->m_slot_list)
          // for (ii = 0; ii < device->module_data.size(); ii++)
          {
            // PnModuleData* module_data;

            // module_data = device->module_data[ii];

            if (slot.m_slot_number ==
                _HIGH_LOW_BYTES_TO_PN_U16(pDataInfo->SlotNumberHighByte, pDataInfo->SlotNumberLowByte))
            {
              for (auto& subslot : slot.m_subslot_map)
              // for (jj = 0; jj < module_data->submodule_data.size(); jj++)
              {
                // PnSubmoduleData* submodule_data;

                // submodule_data = module_data->submodule_data[jj];
                if (subslot.second.m_subslot_number ==
                    _HIGH_LOW_BYTES_TO_PN_U16(pDataInfo->SubSlotNumberHighByte,
                                              pDataInfo->SubSlotNumberLowByte))
                {
                  if (PROFINET_IO_CR_TYPE_INPUT == type)
                  {
                    subslot.second.m_rt_offset_status_in =
                        _HIGH_LOW_BYTES_TO_PN_U16(pDataInfo->OffsetHighByte, pDataInfo->OffsetLowByte);
                  }
                  else
                  {
                    subslot.second.m_rt_offset_status_out =
                        _HIGH_LOW_BYTES_TO_PN_U16(pDataInfo->OffsetHighByte, pDataInfo->OffsetLowByte);
                  }
                }
              }
            }
          }
          pDataInfo++;
        }

        pAPIInfo = (T_PN_API_INFO*)pDataInfo;
      }

      pIOCRInfo = (T_PN_IOCR_INFO*)pAPIInfo;
    }

    return PNAK_OK;
  }
  else if (pSdb->Result == PNAK_RESULT_NEG)
  {

    T_PN_SERVICE_ERROR_CON* pErrorCon = (T_PN_SERVICE_ERROR_CON*)(pSdb + 1);

    printf("channel %d: download.con [-] (%d)\r\n"
           "            code       : %d (0x%02x)\r\n"
           "            detail     : %d (0x%02x)\r\n"
           "            add. detail: %d (0x%02x)\r\n"
           "            area       : %d (0x%02x)\r\n",
           0, pSdb->DeviceRef, pErrorCon->Code, pErrorCon->Code, pErrorCon->Detail, pErrorCon->Detail,
           pErrorCon->AdditionalDetail, pErrorCon->AdditionalDetail, pErrorCon->AreaCode,
           pErrorCon->AreaCode);
  }

  return -1;
}

int handle_service_con(io_sAgentLocal* local, io_sAgent* ap)
{
  int sts;
  unsigned short ii;

  memset(&local->service_con, 0, sizeof(T_PNAK_SERVICE_CON));
  sts = pnak_get_service_con(0, &local->service_con);

  if (sts == PNAK_NOTIFICATION_RECEIVED)
  {
    for (ii = 0; ii < local->service_con.NumberEntries; ii++)
    {
      T_PNAK_SERVICE_DESCRIPTION* pSdb;
      unsigned int offset;

      offset = local->service_con.ServiceEntry[ii].ServiceOffset;
      pSdb = (T_PNAK_SERVICE_DESCRIPTION*)&local->service_con.ServiceChannel[offset];

      if ((pSdb->Instance == PN) || (pSdb->Instance == PN_CONTROLLER))
      {
        switch (pSdb->Service)
        {
        case PN_SERVICE_DOWNLOAD_EXTENDED:
        // printf("EXTENDED DOWNLOAD!\n");
        case PN_SERVICE_DOWNLOAD:
        {
          // printf("unpack_download_con\n");
          sts = unpack_download_con(pSdb, local);
          break;
        }

        case PN_SERVICE_SET_IDENTIFICATION:
        {
          break;
        }
        case PN_SERVICE_READ:
        {
          // printf("Read response!\n");
          sts = unpack_read_con(pSdb, local);
          break;
        }

        case PN_SERVICE_WRITE_MULTIPLE:
        // printf("WRITE MULTIPLE!\n");
        case PN_SERVICE_WRITE:
        {
          // printf("unpack_write_con\n");
          sts = unpack_write_con(pSdb, local);
          break;
        }

        case PN_SERVICE_GET_ALARM:
        {
          sts = unpack_get_alarm_con(pSdb, local, ap);
          break;
        }

        case PN_SERVICE_GET_DEVICE_STATE:
        {
          sts = unpack_get_device_state_con(pSdb, local, ap);
          break;
        }
        case PN_SERVICE_ALARM_ACK:
        {
          break;
        }

        default:
        {
          printf("channel %d: unhandled service confirmation [0x%x]\r\n", 0, pSdb->Service);
        }
        }
      }
      else if (pSdb->Instance ==
               PN_SUPERVISOR) // We can never be supervisor as it stands today?
                              // TODO Maybe we should implement it? PnViewer uses SUPERVISOR services
      {
        switch (pSdb->Service)
        {
        case PN_SERVICE_GET_LIST_OF_STATION:
        {
          sts = unpack_get_los_con(pSdb, local);
          break;
        }

        case PN_SERVICE_SET_IDENTIFICATION:
        case PN_SERVICE_SET_IP_SETTINGS:
        case PN_SERVICE_SET_DEVICE_NAME:
        {
          if (pSdb->Result == PNAK_RESULT_NEG)
          {
            T_PN_SERVICE_ERROR_CON* pErrorCon = (T_PN_SERVICE_ERROR_CON*)(pSdb + 1);

            printf("channel %d: get_los.con [-] (%d)\r\n"
                   "            code       : %d (0x%02x)\r\n"
                   "            detail     : %d (0x%02x)\r\n"
                   "            add. detail: %d (0x%02x)\r\n"
                   "            area       : %d (0x%02x)\r\n",
                   0, pSdb->DeviceRef, pErrorCon->Code, pErrorCon->Code, pErrorCon->Detail, pErrorCon->Detail,
                   pErrorCon->AdditionalDetail, pErrorCon->AdditionalDetail, pErrorCon->AreaCode,
                   pErrorCon->AreaCode);
          }
          break;
        }

        default:
        {
          printf("channel %d: unhandled service confirmation [0x%x]\r\n", 0, pSdb->Service);
        }
        }
      }
    }
  }

  return sts;
}

int wait_service_con(io_sAgentLocal* local, io_sAgent* ap)
{
  T_PNAK_WAIT_OBJECT wait_object;
  int sts;

  wait_object = PNAK_WAIT_OBJECT_SERVICE_CON;
  // wait_object = PNAK_WAIT_OBJECTS_SERVICE;

  sts = pnak_wait_for_multiple_objects(0, &wait_object, PNAK_INFINITE_TIMEOUT);

  if (sts == PNAK_OK)
  {
    sts = handle_service_con(local, ap);
  }

  return sts;
}

void handle_exception(io_sAgentLocal* local) { return; }

void handle_state_changed(io_sAgentLocal* local)
{
  printf("State changed!\n");
  return;
}

void handle_device_state_changed(io_sAgentLocal* local, io_sAgent* ap)
{
  int sts;
  unsigned short ii, jj;
  T_PNAK_EVENT_DEVICE_STATE dev_state;

  // printf("device State changed!\n");
  sts = pnak_get_device_state_ind(0, &dev_state);

  if (sts == PNAK_NOTIFICATION_RECEIVED)
  {
    /* Check state for all devices */

    for (ii = 1; ii < local->device_list.size(); ii++)
    {
      //      printf("Dev_ref %d, State, %d \r\n", ii, dev_state.State[ii]);

      //  for (ii = 0; ii < 1; ii++) {
      if (dev_state.State[ii] != local->device_list[ii]->m_rt_device_state)
      {
        local->device_list[ii]->m_rt_device_state = dev_state.State[ii];

        if (ap)
        {
          /* Find corresponding device */
          io_sRack* slave_list;
          for (slave_list = ap->racklist, jj = 0; (slave_list != NULL) && jj < ii - 1;
               slave_list = slave_list->next, jj++)
          {
          }
          if (slave_list)
          {
            pwr_sClass_PnDevice* dev;
            dev = (pwr_sClass_PnDevice*)slave_list->op;
            dev->State = dev_state.State[ii];

            if (dev->State == PNAK_DEVICE_STATE_CONNECTED)
              dev->Status = PB__NORMAL;
            else
              dev->Status = PB__NOCONN;

            errh_Info("PROFINET: New device state, dev: %s, state: %d", slave_list->Name, dev->State);
          }
        }

        if (dev_state.State[ii] == PNAK_DEVICE_STATE_CONNECTED)
        {
          pack_get_device_state_req(&local->service_req_res, local->device_list[ii]->m_rt_device_ref);

          sts = pnak_send_service_req_res(0, &local->service_req_res);

          if (sts == PNAK_OK)
          {
            sts = wait_service_con(local, ap);
          }
        }
      }
    }
  }

  return;
}

void handle_alarm_indication(io_sAgentLocal* local, io_sAgent* ap)
{
  T_PNAK_EVENT_ALARM pAlarm;
  int sts;
  unsigned short ii, index, bit_no;

  sts = pnak_get_alarm_ind(0, &pAlarm);

  if (sts == PNAK_NOTIFICATION_RECEIVED)
  {
    for (ii = 0; ii < local->device_list.size(); ii++)
    {
      index = ii / 8;
      bit_no = ii % 8;
      if (pAlarm.DeviceReference[index] & (1 << bit_no))
      {
        // printf("New alarm for device: %d\r\n", ii);

        pack_get_alarm_req(&local->service_req_res, local->device_list[ii]->m_rt_alarm_ref,
                           local->device_list[ii]->m_rt_device_ref);

        sts = pnak_send_service_req_res(0, &local->service_req_res);

        if (sts == PNAK_OK)
        {
          sts = wait_service_con(local, ap);
          if (sts == PNAK_OK)
          {
            pack_alarm_ack_req(&local->service_req_res, local->device_list[ii]->m_rt_alarm_ref,
                               local->device_list[ii]->m_rt_alarm_data.alarm_prio,
                               local->device_list[ii]->m_rt_device_ref);

            sts = pnak_send_service_req_res(0, &local->service_req_res);

            if (sts == PNAK_OK)
            {
              sts = wait_service_con(local, ap);
            }
          }
        }

        break;
      }
    }
  }
}

int connect_alarm()
{
  static int alarm_connected = 0;
  int sts;
  mh_eEvent AbortEventType = mh_eEvent_Alarm;
  mh_eEventPrio AbortEventPrio = mh_eEventPrio_A;
  pwr_tUInt32 NoOfActMessages;

  if (alarm_connected)
    /* We are already connected */
    return 1;

  sts = mh_ApplConnect(pwr_cNObjid, (mh_mApplFlags)0, "AbortEventName", AbortEventType, AbortEventPrio,
                       (mh_mEventFlags)(mh_mEventFlags_Bell | mh_mEventFlags_Ack | mh_mEventFlags_Return),
                       "AbortEventText", &NoOfActMessages);
  if (EVEN(sts))
    return sts;

  alarm_connected = 1;
  return 1;
}

/* Supervision thread */

void* handle_events(void* ptr)
{
  agent_args* args;
  io_sAgentLocal* local;
  io_sAgent* ap;
  T_PNAK_WAIT_OBJECT wait_object;
  int sts;

  // Connect to alarm handling
  sts = connect_alarm();
  if EVEN (sts)
    errh_Warning("PROFINET: Unable to initialize alarm queue. Alarms from this "
                 "service won't work...");

  pwr_sClass_PnControllerSoftingPNAK* op;
  io_sPnRackLocal* r_local;

  char fname[196];
  char hname[40];
  char* env;

  // std::vector<ProfinetRuntimeData*> xml_dev_data_vect;
  ProfinetRuntimeData* xml_dev_data;
  // PnDeviceData* pn_dev_data;
  // PnDeviceData* pn_controller_data;
  //  PnIOCRData* pn_iocr_data;
  //  PnModuleData* pn_slot_data;
  //  PnSubmoduleData* pn_subslot_data;
  unsigned short ii, offset_inputs, offset_outputs;
  // unsigned short num_modules = 0;
  int s;

  struct ifreq ifr = {};

  io_sRack* slave_list;

  args = (agent_args*)ptr;
  local = (io_sAgentLocal*)args->local;
  ap = args->ap;

  //  count=0;

  pthread_mutex_lock(&local->mutex);

  op = (pwr_sClass_PnControllerSoftingPNAK*)ap->op;

  /* Initialize interface */

  errh_Info("PROFINET: Initializing interface for controller %s", ap->Name);

  /* Add master as a device */

  // ProfinetRuntimeData controller_data;
  // controller_data.reset_to_default();

  // std::shared_ptr<ProfinetDevice> pn_controller(controller_data.m_PnDevice);
  // std::shared_ptr<ProfinetDevice> pn_controller = controller_data.m_PnDevice;
  auto pn_controller = std::make_shared<ProfinetDevice>();
  /* Get configs for device */

  gethostname(hname, 40);

  s = socket(AF_INET, SOCK_DGRAM, 0);
  strncpy(ifr.ifr_name, op->EthernetDevice, sizeof(ifr.ifr_name));
  if (ioctl(s, SIOCGIFADDR, &ifr) >= 0)
  {
    pn_controller->m_NetworkSettings.m_ip_address = inet_ntoa(((struct sockaddr_in*)&ifr.ifr_addr)->sin_addr);
    // strcpy(controller_data->ip_address,
    //        inet_ntoa(((struct sockaddr_in*)&ifr.ifr_addr)->sin_addr));
  }
  if (ioctl(s, SIOCGIFNETMASK, &ifr) >= 0)
  {
    pn_controller->m_NetworkSettings.m_subnet_mask =
        inet_ntoa(((struct sockaddr_in*)&ifr.ifr_netmask)->sin_addr);
    // strcpy(controller_data->subnet_mask,
    //        inet_ntoa(((struct sockaddr_in*)&ifr.ifr_netmask)->sin_addr));
  }

  sscanf(pn_controller->m_NetworkSettings.m_ip_address.c_str(), "%hhu.%hhu.%hhu.%hhu",
         &pn_controller->m_rt_ipaddress[3], &pn_controller->m_rt_ipaddress[2],
         &pn_controller->m_rt_ipaddress[1], &pn_controller->m_rt_ipaddress[0]);
  sscanf(pn_controller->m_NetworkSettings.m_subnet_mask.c_str(), "%hhu.%hhu.%hhu.%hhu",
         &pn_controller->m_rt_subnetmask[3], &pn_controller->m_rt_subnetmask[2],
         &pn_controller->m_rt_subnetmask[1], &pn_controller->m_rt_subnetmask[0]);

  pn_controller->m_NetworkSettings.m_device_name = hname;
  // strcpy(controller_data->device_name, hname);
  pn_controller->m_rt_device_ref = PN_DEVICE_REFERENCE_THIS_STATION;

  // controller_data->device_num = PN_DEVICE_REFERENCE_THIS_STATION;
  // strcpy(controller_data->device_text, op->EthernetDevice);
  pn_controller->m_rt_interface_name = std::string(op->EthernetDevice);
  pn_controller->m_vendor_id = 279; // Softing vendor id
  pn_controller->m_device_id = 0;
  pn_controller->m_rt_version = "1.0";
  // controller_data->vendor_id = 279; // Softing vendor id
  // controller_data->device_id = 0;
  // strcpy(controller_data->version, "1.0");
  // controller_data->byte_order = 0;

  local->device_list.push_back(pn_controller);

  env = getenv("pwrp_load");

  /* Iterate over the slaves. and read our runtime configuration for each slave.
   */
  for (slave_list = ap->racklist, ii = 1; slave_list != NULL; slave_list = slave_list->next, ii++)
  {
    // xml_dev_data = new GsdmlDeviceData; // Allt som str i pwr_pn-xml-filen fr
    // resp. device
    xml_dev_data = new ProfinetRuntimeData;
    xml_dev_data->reset_to_default();
    // xml_dev_data->m_PnDevice->m_pn_local_runtime_data.reset(new PnDeviceData);
    //  pn_dev_data = new PnDeviceData; // Data som hr till profinet-konfigen

    sprintf(fname, "%s/pwr_pn_%s.xml", env, cdh_ObjidToFnString(NULL, slave_list->Objid));

    xml_dev_data->read_pwr_pn_xml(fname, "");
    // TODO Why dont we check for errors...
    // xml_dev_data->read(fname);
    // xml_dev_data_vect.push_back(xml_dev_data);

    // pn_dev_data->device_ref = ii + 1;
    std::shared_ptr<ProfinetDevice> pn_device = xml_dev_data->m_PnDevice;
    pn_device->m_rt_device_ref = ii;

    // for (int iocr_type = PROFINET_IO_CR_TYPE_INPUT; iocr_type <= PROFINET_IO_CR_TYPE_OUTPUT; iocr_type++)
    // {
    //   PnIOCRData* pn_iocr_data = new PnIOCRData;
    //   pn_iocr_data->type = iocr_type;
    //   pn_device->m_pn_local_runtime_data->iocr_data.push_back(pn_iocr_data);
    // }

    /* Loop through all devices in our gsdml data and filter out submodules.
      Also add all found devices and their submodules to the local data using
      the PnXXXXXXX classes */
    // for (auto const& slot : pn_device->m_slot_list)
    // {
    //   // Do we have anything in this slot?
    //   if (slot.m_module_ID != "")
    //   {
    //     PnModuleData* pn_slot_data = new PnModuleData;
    //     pn_slot_data->slot_number = slot.m_slot_number;
    //     pn_slot_data->ident_number = slot.m_module_ident_number;
    //     pn_device->m_pn_local_runtime_data->module_data.push_back(pn_slot_data);

    //     // Iterate over the submodules
    //     for (auto const& subslot : slot.m_subslot_map)
    //     {
    //       PnSubmoduleData* pn_submodule_data = new PnSubmoduleData;
    //       pn_submodule_data->subslot_number = subslot.second.m_subslot_number;
    //       pn_submodule_data->ident_number = subslot.second.m_submodule_ident_number;
    //       pn_submodule_data->api = subslot.second.m_api;
    //       pn_submodule_data->io_in_data_length = subslot.second.m_io_input_length;
    //       pn_submodule_data->io_out_data_length = subslot.second.m_io_output_length;
    //       pn_submodule_data->type = subslot.second.m_rt_io_submodule_type;
    //       pn_slot_data->submodule_data.push_back(pn_submodule_data);
    //     }
    //   }
    // }
    //   for (std::vector<GsdmlSlotData*>::iterator mod_it =
    //            xml_dev_data->slot_data.begin();
    //        mod_it != xml_dev_data->slot_data.end();)
    //   {
    //     // Do we have anything in this slot?
    //     if ((*mod_it)->module_enum_number != 0 ||
    //         (*mod_it)->module_ident_number != 0)
    //     {
    //       pn_slot_data = new PnModuleData;
    //       pn_slot_data->slot_number = (*mod_it)->slot_number;
    //       pn_slot_data->ident_number = (*mod_it)->module_ident_number;
    //       pn_dev_data->module_data.push_back(pn_slot_data);

    //       // Now check all submodules of this slot
    //       for (std::vector<GsdmlSubslotData*>::iterator sub_it =
    //                (*mod_it)->subslot_data.begin();
    //            sub_it != (*mod_it)->subslot_data.end();)
    //       {
    //         // Remove submodules > 0x7FFF
    //         if ((*sub_it)->subslot_number > 0x7FFF)
    //         {
    //           sub_it = (*mod_it)->subslot_data.erase(sub_it);
    //           continue;
    //         }

    //         pn_subslot_data = new PnSubmoduleData;
    //         pn_subslot_data->subslot_number = (*sub_it)->subslot_number;
    //         pn_subslot_data->ident_number = (*sub_it)->submodule_ident_number;
    //         pn_subslot_data->api = (*sub_it)->api;

    //         // Check input types of the submodule in question
    //         if ((*sub_it)->io_input_length > 0)
    //         {
    //           pn_subslot_data->io_in_data_length = (*sub_it)->io_input_length;
    //           pn_subslot_data->type = PROFINET_IO_SUBMODULE_TYPE_INPUT;
    //         }

    //         if ((*sub_it)->io_output_length > 0)
    //         {
    //           pn_subslot_data->io_out_data_length = (*sub_it)->io_output_length;
    //           pn_subslot_data->type |= PROFINET_IO_SUBMODULE_TYPE_OUTPUT;
    //         }

    //         if ((*sub_it)->io_output_length > 0 && (*sub_it)->io_input_length > 0)
    //         {
    //           pn_subslot_data->type |=
    //               PROFINET_IO_SUBMODULE_TYPE_INPUT_AND_OUTPUT;
    //         }

    //         pn_dev_data->module_data.back()->submodule_data.push_back(
    //             pn_subslot_data);
    //         sub_it++;
    //       }
    //     }
    //     else
    //     {
    //       mod_it = xml_dev_data->slot_data.erase(mod_it);
    //       continue;
    //     }
    //     mod_it++;
    //   }
    //   local->device_data.push_back(pn_dev_data);
    // }

    local->device_list.push_back(pn_device);
  }

  /* Start profistack */

  sts = pnak_start_profistack(0, PNAK_CONTROLLER_MODE);

  if (sts != PNAK_OK)
  {
    op->Status = PB__INITFAIL;
    errh_Error("PROFINET: Start of stack returned with error code: %d", sts);
    //    return IO__ERRINIDEVICE;
  }

  /* Download configuration for all devices */

  // for (ii = 0; ii < local->device_list.size(); ii++)
  for (auto& pn_device : local->device_list)
  {
    pack_download_req(&local->service_req_res, pn_device);

    sts = pnak_send_service_req_res(0, &local->service_req_res);

    if (sts == PNAK_OK)
    {
      sts = wait_service_con(local, ap);

      if (sts == PNAK_OK)
      {
        /* Loop through devices and calculate offset for io */
        // for (jj = 0; jj < local->device_data[ii]->iocr_data.size(); jj++)
        // for (int iocr = 0; iocr < 2; iocr++)
        for (auto& iocr : pn_device->m_IOCR_map)
        {
          offset_inputs = 0;
          offset_outputs = 0;

          // type = local->device_data[ii]->iocr_data[jj]->type;
          for (auto& module_data : pn_device->m_slot_list)
          // for (kk = 0; kk < local->device_data[ii]->module_data.size(); kk++)
          {
            for (auto& submodule_data : module_data.m_subslot_map)
            // for (ll = 0; ll < local->device_data[ii]->module_data[kk]->submodule_data.size(); ll++)
            {
              if (iocr.first == PROFINET_IO_CR_TYPE_INPUT &&
                  (submodule_data.second.m_rt_io_submodule_type == PROFINET_IO_SUBMODULE_TYPE_INPUT ||
                   submodule_data.second.m_rt_io_submodule_type ==
                       PROFINET_IO_SUBMODULE_TYPE_INPUT_AND_OUTPUT))
              {

                submodule_data.second.m_rt_offset_clean_io_in = offset_inputs;
                offset_inputs += submodule_data.second.m_io_input_length;
              }
              else if (iocr.first == PROFINET_IO_CR_TYPE_OUTPUT &&
                       (submodule_data.second.m_rt_io_submodule_type == PROFINET_IO_SUBMODULE_TYPE_OUTPUT ||
                        submodule_data.second.m_rt_io_submodule_type ==
                            PROFINET_IO_SUBMODULE_TYPE_INPUT_AND_OUTPUT))
              {
                submodule_data.second.m_rt_offset_clean_io_out = offset_outputs;
                offset_outputs += submodule_data.second.m_io_output_length;
              }
              // PnSubmoduleData* submodule;
              // submodule = local->device_data[ii]->module_data[kk]->submodule_data[ll];
              // if ((type == PROFINET_IO_CR_TYPE_INPUT) &&
              //     ((submodule->type == PROFINET_IO_SUBMODULE_TYPE_INPUT) ||
              //      (submodule->type == PROFINET_IO_SUBMODULE_TYPE_INPUT_AND_OUTPUT)))
              // {
              //   submodule->offset_clean_io_in = offset_inputs;
              //   offset_inputs += submodule->io_in_data_length;
              // }
              // else if ((type == PROFINET_IO_CR_TYPE_OUTPUT) &&
              //          ((submodule->type == PROFINET_IO_SUBMODULE_TYPE_OUTPUT) ||
              //           (submodule->type == PROFINET_IO_SUBMODULE_TYPE_INPUT_AND_OUTPUT)))
              // {
              //   submodule->offset_clean_io_out = offset_outputs;
              //   offset_outputs += submodule->io_out_data_length;
              // }
            }
          }
          iocr.second.m_rt_clean_io_data = (unsigned char*)calloc(1, offset_inputs + offset_outputs);
          // local->device_data[ii]->iocr_data[jj]->clean_io_data =
          //     (unsigned char*)calloc(1, offset_inputs + offset_outputs);
          iocr.second.m_rt_clean_io_data_length = offset_inputs + offset_outputs;
          // local->device_data[ii]->iocr_data[jj]->clean_io_data_length = offset_inputs + offset_outputs;
        }
      }
      else
      {
        printf("Failed to download conf (sts: %d)\n", sts);
        errh_Error("PROFINET: Download of device configuration failed for: %s",
                   pn_device->m_NetworkSettings.m_device_name.c_str());
        /* Setup a dummy i/o area. Depending on exisiting channels this area
         * needs to exist */
        for (auto& iocr : pn_device->m_IOCR_map)
        {
          iocr.second.m_rt_clean_io_data = (unsigned char*)calloc(1, PROFINET_IO_DATA_MAX_LENGTH);
        }
        // for (jj = 0; jj < local->device_data[ii]->iocr_data.size(); jj++)
        // {
        //   local->device_data[ii]->iocr_data[jj]->clean_io_data =
        //       (unsigned char*)calloc(1, PROFINET_IO_DATA_MAX_LENGTH);
        // }
      }
    }
  }

  /* Loop trough devices and set up i/o */
  int device_index = 1;
  for (slave_list = ap->racklist; slave_list != NULL; slave_list = slave_list->next, device_index++)
  {
    slave_list->Local = (unsigned char*)calloc(1, sizeof(io_sPnRackLocal));
    r_local = (io_sPnRackLocal*)slave_list->Local;

    // std::shared_ptr<PnDeviceData> pn_device_data =
    // local->device_list[device_index]->m_pn_local_runtime_data;
    std::shared_ptr<ProfinetDevice> pn_device = local->device_list[device_index];
    for (auto& iocr : pn_device->m_IOCR_map)
    {
      if (iocr.first == PROFINET_IO_CR_TYPE_INPUT)
      {
        r_local->bytes_of_input = iocr.second.m_rt_clean_io_data_length;
        r_local->inputs = iocr.second.m_rt_clean_io_data;
      }
      else if (iocr.first == PROFINET_IO_CR_TYPE_OUTPUT)
      {
        r_local->bytes_of_output = iocr.second.m_rt_clean_io_data_length;
        r_local->outputs = iocr.second.m_rt_clean_io_data;
      }
    }

    // for (jj = 0; jj < local->device_data[ii + 1]->iocr_data.size(); jj++)
    // {
    //   if (local->device_data[ii + 1]->iocr_data[jj]->type == PROFINET_IO_CR_TYPE_INPUT)
    //   {
    //     r_local->bytes_of_input = local->device_data[ii + 1]->iocr_data[jj]->clean_io_data_length;
    //     r_local->inputs = local->device_data[ii + 1]->iocr_data[jj]->clean_io_data;
    //   }
    //   else if (local->device_data[ii + 1]->iocr_data[jj]->type == PROFINET_IO_CR_TYPE_OUTPUT)
    //   {
    //     r_local->bytes_of_output = local->device_data[ii + 1]->iocr_data[jj]->clean_io_data_length;
    //     r_local->outputs = local->device_data[ii + 1]->iocr_data[jj]->clean_io_data;
    //   }
    // }
  }

  /* Set identification */

  pack_set_identification_req(&local->service_req_res);

  sts = pnak_send_service_req_res(0, &local->service_req_res);

  if (sts == PNAK_OK)
  {
    sts = wait_service_con(local, ap);
  }

  /* Set mode online */

  T_PNAK_EVENT_SET_MODE pMode;

  pMode.Mode = PNAK_MODE_ONLINE;

  sts = pnak_set_mode(0, &pMode);

  if (sts != PNAK_OK)
  {
    op->Status = PB__INITFAIL;
    errh_Error("PROFINET: Unable to go online, error code: %d", sts);
    //    return IO__ERRINIDEVICE;
  }

  //  T_PNAK_WAIT_OBJECT           wait_object;

  wait_object = PNAK_WAIT_OBJECT_STATE_CHANGED;

  sts = pnak_wait_for_multiple_objects(0, &wait_object, PNAK_INFINITE_TIMEOUT);

  if (sts == PNAK_OK)
  {
    T_PNAK_EVENT_STATE pState;

    sts = pnak_get_state(0, &pState);

    if (pState.Mode != PNAK_MODE_ONLINE)
    {
      if (sts != PNAK_OK)
      {
        op->Status = PB__INITFAIL;
        errh_Error("PROFINET: Unable to set state online, error code: %d", sts);
        //	return IO__ERRINIDEVICE;
      }
    }
  }

  /* Activate the devices */

  T_PNAK_EVENT_SET_DEVICE_STATE set_dev_state;
  unsigned short index, bit_no;

  memset(&set_dev_state, 0, sizeof(set_dev_state));

  for (int device = 0; device < local->device_list.size(); device++)
  {
    index = device / 8;
    bit_no = device % 8;
    set_dev_state.ActivateDeviceReference[index] |= (1 << bit_no);
  }

  sts = pnak_set_device_state(0, &set_dev_state);

  if (sts != PNAK_OK)
  {
    op->Status = PB__INITFAIL;
    errh_Error("PROFINET: Unable to activate devices, error code: %d", sts);
    //    return IO__ERRINIDEVICE;
  }

  /* Check state for all devices */

  for (int device = 1; device < local->device_list.size(); device++)
  {
    //  for (ii = 0; ii < 1; ii++) {
    pack_get_device_state_req(&local->service_req_res, local->device_list[device]->m_rt_device_ref);

    sts = pnak_send_service_req_res(0, &local->service_req_res);

    if (sts == PNAK_OK)
    {
      sts = wait_service_con(local, ap);
    }
  }

  pthread_cond_signal(&local->cond);
  pthread_mutex_unlock(&local->mutex);

  /* Do until we close the channel and break out */
  while (1)
  {
    /* Other states available:
      PNAK_WAIT_OBJECT_ETHERNET_STATE_CHANGED
      PNAK_WAIT_OBJECT_INTERRUPTED
      PNAK_WAIT_OBJECTS_EVENT_IND
      PNAK_WAIT_OBJECTS_OTHER
      PNAK_WAIT_OBJECT_SERVICE_CON
    */

    wait_object = PNAK_WAIT_OBJECTS_ALL &
                  ~(PNAK_WAIT_OBJECT_PROVIDER_DATA_UPDATED | PNAK_WAIT_OBJECT_CONSUMER_DATA_CHANGED);

    sts = pnak_wait_for_multiple_objects(0, &wait_object, PNAK_INFINITE_TIMEOUT);

    if (sts == PNAK_OK)
    {
      if (wait_object & PNAK_WAIT_OBJECT_CHANNEL_CLOSED)
      {
        errh_Info("PROFINET: Stack received channel closed event!");

        // Iterate through all devices and propagate stopped state to all
        // children
        if (ap)
        {
          ((pwr_sClass_PnControllerSoftingPNAK*)ap->op)->Status = PB__STOPPED;
          io_sRack* device;
          io_sCard* module;
          pwr_sClass_PnDevice* dev;
          pwr_sClass_PnModule* mod;
          for (device = ap->racklist; device != NULL; device = device->next)
          {
            dev = (pwr_sClass_PnDevice*)device->op;
            dev->Status = PB__STOPPED;
            for (module = device->cardlist; module != NULL; module = module->next)
            {
              mod = (pwr_sClass_PnModule*)module->op;
              mod->Status = PB__STOPPED;
            }
          }
        }
        break;
      }

      else if (wait_object & PNAK_WAIT_OBJECT_EXCEPTION)
      {
        handle_exception(local);
      }

      else if (wait_object & PNAK_WAIT_OBJECT_STATE_CHANGED)
      {
        handle_state_changed(local);
      }

      else if (wait_object & PNAK_WAIT_OBJECT_DEVICE_STATE_CHANGED)
      {
        handle_device_state_changed(local, ap);
      }

      else if (wait_object & PNAK_WAIT_OBJECT_ALARM)
      {
        handle_alarm_indication(local, ap);
      }

      else if (wait_object & PNAK_WAIT_OBJECT_SERVICE_CON)
      {
        // printf("service_con!\n");
        sts = handle_service_con(local, ap);
      }
      else if (wait_object & PNAK_WAIT_OBJECT_SERVICE_REQ_RES_HANDLED)
      {
        std::cout << "Request/Response handled!" << std::endl;
      }
      else
        printf("Unknown service: %d\n", wait_object);
    }
    else
    {
      errh_Fatal("PROFINET: Fatal exception occured. Stopping PROFINET!");
      pnak_stop_stack(0);
    }
  }
  pnak_term();
  return 0;
}
