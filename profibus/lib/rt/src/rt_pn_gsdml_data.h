/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build  function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef rt_pn_gsdml_data_h
#define rt_pn_gsdml_data_h

/* cow_pn_gsdml_data.h -- Profinet configurator data file. */

#include <vector>
#include <unordered_map>
#include <memory>
#include <map>
#include <iostream>

#include "co_xml_parser.h"
#include "co_pugixml.hpp"

#define RUNTIME_PARSER_STRING_MAX_LENGTH sizeof(pwr_tString256)
#define DAP_SLOT 0
#define SUBMODULE_INTERFACE 32768
#define SUBMODULE_PORT_1 32769
#define SUBMODULE_PORT_2 32770

// New parser class
class ProfinetDataRecord
{
public:
  ProfinetDataRecord() = default;
  ProfinetDataRecord(pugi::xml_node&&);
  ProfinetDataRecord(ProfinetDataRecord&&);
  ProfinetDataRecord(ProfinetDataRecord const&) = default;  
  ~ProfinetDataRecord();
  //ProfinetDataRecord& operator=(ProfinetDataRecord const&);
  void build(pugi::xml_node&&) const;
  
  unsigned char* m_data;
  unsigned int m_data_length;
  unsigned short m_index;
  unsigned short m_transfer_sequence;
};
class GsdmlDataRecord
{
public:
  GsdmlDataRecord()
      : record_idx(0), data(0), data_reversed_endianess(0), data_length(0),
        index(0), transfer_sequence(0)
  {
  }

  unsigned int record_idx;
  unsigned char* data;
  unsigned char* data_reversed_endianess;
  unsigned int data_length;
  unsigned short index;
  unsigned short transfer_sequence;

  ~GsdmlDataRecord()
  {
    if (data)
      free(data);
    if (data_reversed_endianess)
      free(data_reversed_endianess);
  }
  GsdmlDataRecord(const GsdmlDataRecord& x);

  int print(std::ofstream& fp, bool reverse_endianess);
};

class ProfinetIOCR
{
public:
  ProfinetIOCR() = default;
  ProfinetIOCR(pugi::xml_node&&);
  ProfinetIOCR(ProfinetIOCR&&) = default;
  ProfinetIOCR(ProfinetIOCR const&) = delete;
  ~ProfinetIOCR() = default;
  void build(pugi::xml_node&&) const;
  
  unsigned short m_send_clock_factor;
  unsigned short m_reduction_ratio;
  unsigned int m_phase; // TODO Initialize to 1 ???
  unsigned int m_api; // Check with the spec what to do with submodule items specifying a specific API...
  std::string m_rt_class;
  std::string m_startup_mode;
};
class GsdmlIOCRData
{
public:
  GsdmlIOCRData()
      : type(0), properties(0), send_clock_factor(0), phase(0), api(0)
  {
  }

  unsigned short type;
  unsigned int properties;
  unsigned short send_clock_factor;
  unsigned short reduction_ratio;
  unsigned int phase;
  unsigned int api;

  int print(std::ofstream& fp);
};

class ProfinetSubslot
{
public:
  ProfinetSubslot() = default;
  ProfinetSubslot(pugi::xml_node&&);
  ProfinetSubslot(ProfinetSubslot&&) = default;
  ProfinetSubslot(ProfinetSubslot const&);    
  ~ProfinetSubslot() = default;
  void build(pugi::xml_node&&) const;
  void reset();

  // Attributes
  unsigned int m_subslot_number; // This is more or less fixed and is not affected by a reset  
  unsigned int m_submodule_ident_number;    
  unsigned int m_io_input_length;
  unsigned int m_io_output_length;
  std::string m_submodule_ID;

  // Elements  
  std::map<uint, ProfinetDataRecord> m_data_record_map; // Indexed on the actual Index attribute of the ParameterRecordDataItem
};

class GsdmlSubslotData
{
public:
  GsdmlSubslotData()
      : subslot_number(0), subslot_idx(0), submodule_enum_number(0),
        submodule_ident_number(0), api(0), io_input_length(0),
        io_output_length(0)
  {
  }

  std::vector<GsdmlDataRecord*> data_record;
  unsigned int subslot_number;
  unsigned int subslot_idx;
  unsigned int submodule_enum_number;
  unsigned int submodule_ident_number;
  unsigned int api;
  unsigned int io_input_length;
  unsigned int io_output_length;

  ~GsdmlSubslotData()
  {
    for (unsigned int i = 0; i < data_record.size(); i++)
      delete data_record[i];
  }
  GsdmlSubslotData(const GsdmlSubslotData& x)
      : subslot_number(x.subslot_number), subslot_idx(x.subslot_idx)
  {
    for (unsigned int i = 0; i < x.data_record.size(); i++)
    {
      data_record.push_back(new GsdmlDataRecord(*x.data_record[i]));
    }
  }
  int print(std::ofstream& fp, bool reverse_endianess);
};

class ProfinetSlot
{
public:
  ProfinetSlot() = default;
  ProfinetSlot(pugi::xml_node&&);
  ProfinetSlot(ProfinetSlot&&) = default;
  ProfinetSlot(ProfinetSlot const&) = delete;
  ProfinetSlot& operator=(const ProfinetSlot &);
  ~ProfinetSlot() = default;
  void build(pugi::xml_node&&) const;

  unsigned int m_module_ident_number;
  pwr_tCid m_module_class;  
  std::string m_module_ID; // This is unique even across the same ident number
  unsigned int m_slot_number;
  unsigned int m_api; // TODO Check if this is on device level even....  
  std::map<uint, ProfinetSubslot> m_subslot_map;  

  // Non saved members
  pwr_tOid m_module_oid; // Meta, never saved. Only used as temporary storage for oids when creating modules/channels
  bool m_is_modified; // Meta, never save. Indicates wether or not this slot had it's module updated before applyig/saving...
};


class GsdmlSlotData
{
public:
  GsdmlSlotData()
      : module_enum_number(0), dap_fixed_slot(0), module_class(0),
        module_oid(pwr_cNOid), slot_number(0), slot_idx(0)
  {
    module_text[0] = 0;
  }
  unsigned int module_enum_number;
  unsigned int module_ident_number;

  unsigned int dap_fixed_slot;
  pwr_tCid module_class;
  pwr_tOid module_oid;
  char module_text[160];
  unsigned int slot_number;

  unsigned int slot_idx;
  std::vector<GsdmlSubslotData*> subslot_data;

  ~GsdmlSlotData()
  {
    for (unsigned int i = 0; i < subslot_data.size(); i++)
      delete subslot_data[i];
  }
  void slot_reset()
  {
    for (unsigned int i = 0; i < subslot_data.size(); i++)
      delete subslot_data[i];
    subslot_data.clear();
  }
  GsdmlSlotData(const GsdmlSlotData& x)
      : module_enum_number(x.module_enum_number), module_class(x.module_class),
        module_oid(pwr_cNObjid), slot_number(x.slot_number),
        slot_idx(x.slot_idx)
  {
    for (unsigned int i = 0; i < x.subslot_data.size(); i++)
    {
      subslot_data.push_back(new GsdmlSubslotData(*x.subslot_data[i]));
    }
  }
  int print(std::ofstream& fp, bool reverse_endianess);
};
class ProfinetExtChannelDiag
{
public:
  ProfinetExtChannelDiag() = default;
  ProfinetExtChannelDiag(pugi::xml_node&&);
  ProfinetExtChannelDiag(ProfinetExtChannelDiag&&) = default;
  ProfinetExtChannelDiag(ProfinetExtChannelDiag const&) = delete;
  ~ProfinetExtChannelDiag() = default;
  void build(pugi::xml_node&&, uint p_error_type) const;

  // Attributes
  // ErrorType is implicitly stored as the index in the diagnostics maps
  std::string m_name;
  std::string m_help;
};

class GsdmlExtChannelDiag
{
public:
  GsdmlExtChannelDiag();
  unsigned short error_type;
  char name[200];
  char help[4096];
  // std::vector<GsdmlExtChannelAddValueDataItem*> data_item; TODO Do we want this extra level of diagnostic information available?

  int print(std::ofstream& fp);
};

class ProfinetChannelDiag
{
public:
  ProfinetChannelDiag() = default;
  ProfinetChannelDiag(pugi::xml_node&&);
  ProfinetChannelDiag(ProfinetChannelDiag&&) = default;
  ProfinetChannelDiag(ProfinetChannelDiag const&) = delete;
  ~ProfinetChannelDiag() = default;
  void build(pugi::xml_node&&, uint p_error_type) const;

  // Attributes
  // ErrorType is implicitly stored as the index in the diagnostics maps
  std::string m_name;
  std::string m_help;

  // Elements
  std::unordered_map<uint, ProfinetExtChannelDiag> m_ext_channel_diag_map;
};

class GsdmlChannelDiag
{
public:
  GsdmlChannelDiag();
  unsigned short error_type;
  char name[200];
  char help[4096]; // We need a large buffer for most of the help text in the
                   // diagnostics...
  std::vector<GsdmlExtChannelDiag*> ext_channel_diag;

  int print(std::ofstream& fp);
};

class ProfinetNetworkSettings
{
public:
  ProfinetNetworkSettings() = default;
  ProfinetNetworkSettings(pugi::xml_node&&);
  ProfinetNetworkSettings(ProfinetNetworkSettings&&) = default;
  ProfinetNetworkSettings(ProfinetNetworkSettings const&) = delete;
  ~ProfinetNetworkSettings() = default;
  void build(pugi::xml_node&&) const;
  
  std::string m_device_name;
  std::string m_ip_address;
  std::string m_subnet_mask;
  std::string m_mac_address;
  bool m_skip_ip_assignment;
};

class ProfinetDevice
{
public:
  ProfinetDevice() = default;
  ProfinetDevice(pugi::xml_node&&);
  ProfinetDevice(ProfinetDevice&&) = default;
  ProfinetDevice(ProfinetDevice const&) = delete;
  ~ProfinetDevice() = default;
  void build(pugi::xml_node&&) const;

  // Attributes
  std::string m_gsdml_source_file;  
  std::string m_moduleinfo_name; // ModuleInfo->Name in the GSDML  
  std::string m_DAP_ID; // DAP ID to map what DAP to use from the GSDML
  unsigned short m_vendor_id; // Part of DeviceIdentity
  unsigned short m_device_id; // Part of DeviceIdentity  

  // Elements
  ProfinetNetworkSettings m_NetworkSettings;  
  std::vector<ProfinetSlot> m_slot_list;
  ProfinetIOCR m_IOCR;
  std::unordered_map<uint, ProfinetChannelDiag> m_channel_diag_map;  
};

class ProfinetRuntimeData
{
public:
  ProfinetRuntimeData() = default;
  ProfinetRuntimeData(ProfinetRuntimeData&&) = default;
  ProfinetRuntimeData(ProfinetRuntimeData const&) = delete;
  ~ProfinetRuntimeData() = default;
  int read_pwr_pn_xml(std::string const& p_filename, std::string const& p_gsdml_file);
  void reset_to_default();  
  bool save() const;

  std::shared_ptr<ProfinetDevice> m_PnDevice;

  bool m_file_missing; // This will be set to true if the file was missing while reading the pwr_pn data.
  bool m_gsdml_mismatch; // This will be set to true if the GSDML used is different from the one used to create the pwr_pn data.

  std::string m_pwr_pn_filename; // We keep a reference to the filename here. No need to pass it around...

  // Misc
  static ProfinetSlot* m_paste_slotdata;

  // TODO Do we need this?
  // int m_byte_order;
  // int m_read_data_is_native_ordered;
  // unsigned short m_instance; TODO Needed??
};

class GsdmlDeviceData
{
public:
  GsdmlDeviceData()
      : device_num(0), skip_ip_assignment(0), vendor_id(0), device_id(0),
        byte_order(0), read_data_is_native_ordered(1), instance(0)
  {
    device_name[0] = 0;
    ip_address[0] = 0;
    subnet_mask[0] = 0;
    mac_address[0] = 0;
    device_text[0] = 0;
    version[0] = 0;
    gsdmlfile[0] = 0;
  }
  char device_name[80];
  char ip_address[20];
  char subnet_mask[20];
  char mac_address[20];
  int device_num;
  int skip_ip_assignment;
  char device_text[160];
  unsigned short vendor_id;
  unsigned short device_id;
  char version[20];
  int byte_order;
  int read_data_is_native_ordered;
  unsigned short instance;
  pwr_tFileName gsdmlfile;
  std::vector<GsdmlSlotData*> slot_data;
  std::vector<GsdmlIOCRData*> iocr_data;
  static GsdmlSlotData* paste_slotdata;
  std::vector<GsdmlChannelDiag*> channel_diag;

  ~GsdmlDeviceData()
  {
    device_reset();
    channel_diag_reset();
  }
  void device_reset()
  {
    for (unsigned int i = 0; i < slot_data.size(); i++)
      delete slot_data[i];
    slot_data.clear();
    for (unsigned int i = 0; i < iocr_data.size(); i++)
      delete iocr_data[i];
    iocr_data.clear();
  }
  void channel_diag_reset()
  {
    for (unsigned int i = 0; i < channel_diag.size(); i++)
      delete channel_diag[i];
    channel_diag.clear();
  }
  int print(const char* filename);
  int read(const char* filename, int new_filename = 0);
  int copy_slot(unsigned int slot_idx);
  int cut_slot(unsigned int slot_idx);
  int paste_slot(unsigned int slot_idx);
  int modify_value(const char* attr, const char* value);
  int get_value(const char* attr, char* buf, int bufsize);
};

class GsdmlDataReader : public co_xml_interpreter
{
public:
  GsdmlDataReader(GsdmlDeviceData* d) : data(d), new_filename(0) {}
  int tag(const char* name);
  int metatag(const char* name);
  int tag_end(const char* name);
  int metatag_end(const char* name);
  int tag_value(const char* value);
  int tag_attribute(const char* name, const char* value);

  int tag_name_to_id(const char* name, unsigned int* id);

  unsigned int current_tag;
  GsdmlDeviceData* data;
  int new_filename;
};

#endif
