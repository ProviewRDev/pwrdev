/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build  function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef rt_pn_gsdml_data_h
#define rt_pn_gsdml_data_h

/* cow_pn_gsdml_data.h -- Profinet configurator data file. */

#include <vector>
#include <unordered_map>
#include <memory>
#include <map>
#include <iostream>

#include "pwr.h"
#include "co_pugixml.hpp"
#include "rt_profinet.h"

#define RUNTIME_PARSER_STRING_MAX_LENGTH sizeof(pwr_tString256)
#define DAP_DEFAULT_SLOT 0
#define SUBMODULE_INTERFACE 32768
#define SUBMODULE_PORT_1 32769
#define SUBMODULE_PORT_2 32770

// New parser class
class ProfinetDataRecord
{
public:
  ProfinetDataRecord() = default;
  ProfinetDataRecord(pugi::xml_node&&);
  ProfinetDataRecord(ProfinetDataRecord&&);
  ProfinetDataRecord(ProfinetDataRecord const&) = default;
  ~ProfinetDataRecord();
  void build(pugi::xml_node&&) const;

  unsigned char* m_data;
  unsigned int m_data_length;
  unsigned short m_index;
  unsigned short m_transfer_sequence;
};

class ProfinetAPI
{
public:
  ProfinetAPI() = default;
  ProfinetAPI(pugi::xml_node&&);
  ProfinetAPI(ProfinetAPI&&) = default;
  ProfinetAPI(ProfinetAPI const&) = default;
  ProfinetAPI& operator=(ProfinetAPI&) = default;
  ~ProfinetAPI() = default;
  void build(pugi::xml_node&&) const;

  uint m_profile_id;
  uint m_index;
  std::vector<uint> m_module_ref;
};

class ProfinetIOCR
{
public:
  ProfinetIOCR() = default;
  ProfinetIOCR(pugi::xml_node&& p_IOCR, pugi::xml_node&& p_APIs);
  ProfinetIOCR(ProfinetIOCR&&) = default;
  ProfinetIOCR(ProfinetIOCR const&) = default;
  ProfinetIOCR& operator=(ProfinetIOCR&) = default;
  ~ProfinetIOCR() = default;
  void build(pugi::xml_node&&, uint type) const;

  unsigned short m_send_clock_factor;
  unsigned short m_reduction_ratio;
  unsigned int m_phase;            // Phase can not be greater than reduction ratio and must be > 0.
  std::map<uint, uint> m_api_refs; // <api, api-index-reference>
  std::string m_rt_class;
  std::string m_startup_mode;

  // Stack Runtime specifics
  unsigned short m_rt_identifier;
  unsigned short m_rt_io_data_length;
  unsigned char* m_rt_io_data;
  unsigned short m_rt_clean_io_data_length;
  unsigned char* m_rt_clean_io_data;
  uint m_rt_properties = 0;
};

class ProfinetSubslot
{
public:
  ProfinetSubslot() = default;
  ProfinetSubslot(pugi::xml_node&&);
  ProfinetSubslot(ProfinetSubslot&&) = default;
  ProfinetSubslot(ProfinetSubslot const&);
  ~ProfinetSubslot() = default;
  void build(pugi::xml_node&&) const;
  void reset();

  // Attributes
  unsigned int m_subslot_number; // This is more or less fixed and is not affected by a reset
  unsigned int m_submodule_ident_number;
  unsigned int m_io_input_length;
  unsigned int m_io_output_length;
  unsigned int m_api = PROFINET_DEFAULT_API; // Will default to 0.
  std::string m_submodule_ID;

  // Elements
  std::map<ushort, ProfinetDataRecord>
      m_data_record_map; // Indexed on the actual Index attribute of the ParameterRecordDataItem

  // Runtime specifics
  ushort m_rt_io_submodule_type;
  ushort m_rt_state {0};
  uint m_rt_phys_ident_number {0};

  ushort m_rt_offset_io_in;
  ushort m_rt_offset_clean_io_in;
  ushort m_rt_offset_io_out;
  ushort m_rt_offset_clean_io_out;
  ushort m_rt_offset_status_in;
  ushort m_rt_offset_status_out;
};

class ProfinetSlot
{
public:
  ProfinetSlot() = default;
  ProfinetSlot(pugi::xml_node&&);
  ProfinetSlot(ProfinetSlot&&) = default;
  ProfinetSlot(ProfinetSlot const&) = default;
  ProfinetSlot& operator=(const ProfinetSlot&);
  ~ProfinetSlot() = default;
  void build(pugi::xml_node&&) const;

  unsigned int m_module_ident_number;
  pwr_tCid m_module_class;
  std::string m_module_ID; // This is unique even across the same ident number
  unsigned int m_slot_number;
  std::map<uint, ProfinetSubslot> m_subslot_map;

  // Non saved members
  pwr_tOid m_module_oid; // Meta, never saved. Only used as temporary storage for oids when creating
                         // modules/channels
  bool m_is_modified;    // Meta, never save. Indicates wether or not this slot had it's module updated before
                         // applyig/saving...
  bool m_is_dap = false;

  // Runtime
  ushort m_rt_state {0};
  uint m_rt_phys_ident_number {0};
};

class ProfinetExtChannelDiag
{
public:
  ProfinetExtChannelDiag() = default;
  ProfinetExtChannelDiag(pugi::xml_node&&);
  ProfinetExtChannelDiag(ProfinetExtChannelDiag&&) = default;
  ProfinetExtChannelDiag(ProfinetExtChannelDiag const&) = default;
  ~ProfinetExtChannelDiag() = default;
  void build(pugi::xml_node&&, uint p_error_type) const;

  // Attributes
  // ErrorType is implicitly stored as the index in the diagnostics maps
  std::string m_name;
  std::string m_help;
};

class ProfinetChannelDiag
{
public:
  ProfinetChannelDiag() = default;
  ProfinetChannelDiag(pugi::xml_node&&);
  ProfinetChannelDiag(ProfinetChannelDiag&&) = default;
  ProfinetChannelDiag(ProfinetChannelDiag const&) = default;
  ~ProfinetChannelDiag() = default;
  void build(pugi::xml_node&&, uint p_error_type) const;

  // Attributes
  // ErrorType is implicitly stored as the index in the diagnostics maps
  std::string m_name;
  std::string m_help;

  // Elements
  std::unordered_map<uint, ProfinetExtChannelDiag> m_ext_channel_diag_map;
};

class ProfinetUnitDiagTypeRef
{
public:
  ProfinetUnitDiagTypeRef() = default;
  ProfinetUnitDiagTypeRef(pugi::xml_node&&);
  ProfinetUnitDiagTypeRef(ProfinetUnitDiagTypeRef&&) = default;
  ProfinetUnitDiagTypeRef(ProfinetUnitDiagTypeRef const&) = default;
  ~ProfinetUnitDiagTypeRef() = default;
  void build(pugi::xml_node&&, uint p_byte_offset) const;

  // Attributes    
  //ushort m_data_type;
  std::string m_text;  
};

class ProfinetUnitDiagType
{
public:
  ProfinetUnitDiagType() = default;
  ProfinetUnitDiagType(pugi::xml_node&&);
  ProfinetUnitDiagType(ProfinetUnitDiagType&&) = default;
  ProfinetUnitDiagType(ProfinetUnitDiagType const&) = default;
  ~ProfinetUnitDiagType() = default;
  void build(pugi::xml_node&&, uint p_user_structure_identifier) const;

  // Attributes  
  std::string m_name;
  std::string m_help;

  // Elements
  // <Ref ByteOffset="1" DataType="Unsigned8" DefaultValue="0" TextId="Missing server module" ValueItemTarget="hidden" />
  // <ByteOffset, ProfinetUnitDiagTypeRef>
  std::unordered_map<uint, ProfinetUnitDiagTypeRef> m_ref_map;
};

class ProfinetNetworkSettings
{
public:
  ProfinetNetworkSettings() = default;
  ProfinetNetworkSettings(pugi::xml_node&&);
  ProfinetNetworkSettings(ProfinetNetworkSettings&&) = default;
  ProfinetNetworkSettings(ProfinetNetworkSettings const&) = default;
  ~ProfinetNetworkSettings() = default;
  void build(pugi::xml_node&&) const;

  std::string m_device_name;
  std::string m_ip_address;
  std::string m_subnet_mask;
  std::string m_mac_address;
  bool m_skip_ip_assignment;
};

class ProfinetDevice
{
  typedef struct _PN_Alarm_Data
  {
    unsigned short alarm_type;
    unsigned short alarm_prio;
    unsigned short rem_alarms;
    unsigned int slot_number;
    unsigned int sub_slot_number;
    unsigned int module_ident_number;
    unsigned int submodule_ident_number;
    unsigned short alarm_spec;
    unsigned short data_length;
    unsigned char* data;
  } PN_Alarm_Data;

public:
  ProfinetDevice() = default;
  ProfinetDevice(pugi::xml_node&&);
  ProfinetDevice(ProfinetDevice&&) = default;
  ProfinetDevice(ProfinetDevice const&) = default;
  ~ProfinetDevice() = default;
  void build(pugi::xml_node&&) const;

  // Attributes
  std::string m_gsdml_source_file;
  std::string m_moduleinfo_name; // ModuleInfo->Name in the GSDML
  std::string m_DAP_ID;          // DAP ID to map what DAP to use from the GSDML
  unsigned short m_vendor_id;    // Part of DeviceIdentity
  unsigned short m_device_id;    // Part of DeviceIdentity
  unsigned int
      m_instance; // Used to make out the ObjectUUID for DCERPC together with vendor ID and device ID.

  // Elements
  ProfinetNetworkSettings m_NetworkSettings;
  std::vector<ProfinetSlot> m_slot_list;
  std::map<uint, ProfinetAPI> m_API_map;   // <api, ProfinetAPI>
  std::map<uint, ProfinetIOCR> m_IOCR_map; // <iocr type, ProfinetIOCR>
  std::unordered_map<uint, ProfinetChannelDiag> m_channel_diag_map; // <ErrorType, xxxxxxxxxxxxxxxxxxx>
  std::unordered_map<uint, ProfinetUnitDiagType> m_unit_diag_type_map; // <UserStructureIdentifier, xxxxxxxxxxxxxxxxxx>

  // Runtime specifics
  unsigned short m_rt_device_state;
  unsigned short m_rt_device_ref;
  unsigned short m_rt_alarm_ref;
  PN_Alarm_Data m_rt_alarm_data;
  ushort m_rt_number_of_diff_modules;

  unsigned char m_rt_ipaddress[4];
  unsigned char m_rt_subnetmask[4];
  unsigned char m_rt_macaddress[6];
  std::string m_rt_interface_name;  // Used by the controller. Ignored by other devices...
  std::string m_rt_version = "1.0"; // Who knows? According to manual set this to "1.0"
};

class ProfinetRuntimeData
{
public:
  ProfinetRuntimeData() = default;
  ProfinetRuntimeData(ProfinetRuntimeData&&) = default;
  ProfinetRuntimeData(ProfinetRuntimeData const&) = delete;
  ~ProfinetRuntimeData() = default;
  int read_pwr_pn_xml(std::string const& p_filename, std::string const& p_gsdml_file);
  void reset_to_default();
  bool save() const;

  std::shared_ptr<ProfinetDevice> m_PnDevice;

  bool m_file_missing;   // This will be set to true if the file was missing while reading the pwr_pn data.
  bool m_gsdml_mismatch; // This will be set to true if the GSDML used is different from the one used to
                         // create the pwr_pn data.

  std::string m_pwr_pn_filename; // We keep a reference to the filename here. No need to pass it around...

  // Misc for configurator
  static ProfinetSlot* m_paste_slotdata;
};

#endif
