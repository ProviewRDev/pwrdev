/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* cow_pn_gsdml_data.cpp -- Profinet configurator data file */

#include <stdlib.h>
#include <memory>
#include <iostream>
#include <sstream>
#include <iomanip>

#include "co_dcli.h"
#include "co_string.h"

#include "rt_pb_msg.h"
#include "rt_pn_gsdml_data.h"

#include "pwr_baseclasses.h"

typedef enum
{
  gsdmldata_eTag_,
  gsdmldata_eTag_PnDevice,
  gsdmldata_eTag_NetworkSettings,
  gsdmldata_eTag_Slot,
  gsdmldata_eTag_Subslot,
  gsdmldata_eTag_DataRecord,
  gsdmldata_eTag_IOCR,
  gsdmldata_eTag_ChannelDiag,
  gsdmldata_eTag_ExtChannelDiag,
  gsdmldata_eTag__
} gsdmldata_eTag;

GsdmlSlotData* GsdmlDeviceData::paste_slotdata = 0;

GsdmlExtChannelDiag::GsdmlExtChannelDiag() : error_type(0)
{
  memset(name, 0, sizeof(name));
  memset(help, 0, sizeof(help));
}

GsdmlChannelDiag::GsdmlChannelDiag() : error_type(0)
{
  memset(name, 0, sizeof(name));
  memset(help, 0, sizeof(help));
}

int GsdmlExtChannelDiag::print(std::ofstream& fp) {
  fp << "           <ExtChannelDiag ErrorType=\"" << error_type << "\"\n"
     << "             Name=\"" << name << "\"\n"
     << "             Help=\"" << help << "\" />\n";

  return 1;
}

int GsdmlChannelDiag::print(std::ofstream& fp)
{
  fp << "      <ChannelDiag ErrorType=\"" << error_type << "\"\n"
     << "         Name=\"" << name << "\"\n"
     << "         Help=\"" << help << "\">\n";

  for (auto& ecd : ext_channel_diag)
    ecd->print(fp);

  fp << "      </ChannelDiag>\n";
  return 1;
}

GsdmlDataRecord::GsdmlDataRecord(const GsdmlDataRecord& x)
    : record_idx(x.record_idx), data(x.data), data_length(x.data_length),
      index(x.index), transfer_sequence(x.transfer_sequence)
{
  if (data)
  {
    data = (unsigned char*)malloc(data_length);
    memcpy(data, x.data, data_length);
  }
}

int GsdmlDataRecord::print(std::ofstream& fp, bool reverse_endianess)
{
  char str[1024];
  unsigned char* data;

  // If we have allocated memory for reversed endianess we come from the pn
  // configurator otherwise we use the data as is. The method SetIoDeviceData
  // for instance reads the raw data and then recreates the pn configuration
  // file.
  if (data_reversed_endianess)
  {
    data = (reverse_endianess ? this->data_reversed_endianess : this->data);
  }
  else
  {
    data = this->data;
  }

  co_xml_parser::data_to_ostring(data, data_length, str, sizeof(str));

  fp << "      <DataRecord Index=\"" << index << "\"\n"
     << "         TransferSequence=\"" << transfer_sequence << "\"\n"
     << "         DataLength=\"" << data_length << "\"\n"
     << "         Data=\"" << str << "\" />\n";

  return 1;
}

int GsdmlSubslotData::print(std::ofstream& fp, bool reverse_endianess)
{
  fp << "    <Subslot SubslotNumber=\"" << subslot_number << "\"\n"
     << "       SubmoduleEnumNumber=\"" << submodule_enum_number << "\"\n"
     << "       SubmoduleIdentNumber=\"" << submodule_ident_number << "\"\n"
     << "       API=\"" << api << "\"\n"
     << "       IOInputLength=\"" << io_input_length << "\"\n"
     << "       IOOutputLength=\"" << io_output_length << "\" >\n";

  for (unsigned int i = 0; i < data_record.size(); i++)
  {
    data_record[i]->print(fp, reverse_endianess);
  }

  fp << "    </Subslot>\n";
  return 1;
}

int GsdmlSlotData::print(std::ofstream& fp, bool reverse_endianess)
{
  fp << "  <Slot ModuleEnumNumber=\"" << module_enum_number << "\"\n"
     << "        ModuleIdentNumber=\"" << module_ident_number << "\"\n"
     << "        ModuleClass=\"" << module_class << "\"\n"
     << "        ModuleText=\"" << module_text << "\"\n"
     << "        SlotNumber=\"" << slot_number << "\"\n"
     << "        DapFixedInSlot=\"" << dap_fixed_slot << "\" >\n";

  for (unsigned int i = 0; i < subslot_data.size(); i++)
  {
    subslot_data[i]->print(fp, reverse_endianess);
  }

  fp << "  </Slot>\n";
  return 1;
}

int GsdmlIOCRData::print(std::ofstream& fp)
{
  fp << "  <IOCR Type=\"" << type << "\"\n"
     << "    Properties=\"" << properties << "\"\n"
     << "    SendClockFactor=\"" << send_clock_factor << "\"\n"
     << "    ReductionRatio=\"" << reduction_ratio << "\"\n"
     << "    Phase=\"" << phase << "\"\n"
     << "    API=\"" << api << "\" />\n";

  return 1;
}

int GsdmlDeviceData::print(const char* filename)
{
  pwr_tFileName fname;
  std::ofstream fp;
  char* gsdmlfile_p;
  bool reverse_endianess = false;

  // Print name of gsdmlfile, not path
  if ((gsdmlfile_p = strrchr(gsdmlfile, '/')))
    gsdmlfile_p++;
  else
    gsdmlfile_p = gsdmlfile;

  dcli_translate_filename(fname, filename);

  fp.open(fname);

  fp << "<PnDevice GsdmlFile=\"" << gsdmlfile_p << "\"\n"
     << "  DeviceNumber=\"" << device_num << "\"\n"
     << "  DeviceText=\"" << device_text << "\"\n"
     << "  VendorId=\"" << vendor_id << "\"\n"
     << "  DeviceId=\"" << device_id << "\"\n"
     << "  Version=\"" << version << "\"\n"
     << "  ByteOrder=\"" << byte_order << "\"\n"
     << "  Instance=\"" << instance << "\">\n"
     << "  <NetworkSettings \n"
     << "    DeviceName=\"" << device_name << "\"\n"
     << "    IP_Address=\"" << ip_address << "\"\n"
     << "    SubnetMask=\"" << subnet_mask << "\"\n"
     << "    MAC_Address=\"" << mac_address << "\"\n"
     << "    Skip_IP_Assignment=\"" << skip_ip_assignment << "\" />\n";

// Save in accordance to the chosen endianess
#if (pwr_dHost_byteOrder == pwr_dLittleEndian)
  if (byte_order == pwr_eByteOrderingEnum_LittleEndian)
  {
    reverse_endianess = false;
  }
  else
  {
    // We use the data saved as the reversed endianess
    reverse_endianess = true;
  }
#elif (pwr_dHost_byteOrder == pwr_dBigEndian)
  if (byte_order == pwr_eByteOrderingEnum_LittleEndian)
  {
    reverse_endianess = true;
  }
  else
  {
    reverse_endianess = false;
  }
#endif

  for (unsigned int i = 0; i < slot_data.size(); i++)
  {
    slot_data[i]->print(fp, reverse_endianess);
  }
  for (unsigned int i = 0; i < iocr_data.size(); i++)
  {
    iocr_data[i]->print(fp);
  }
  for (unsigned int i = 0; i < channel_diag.size(); i++)
  {
    channel_diag[i]->print(fp);
  }

  fp << "</PnDevice>\n";

  fp.close();

  return PB__SUCCESS;
}

ProfinetExtChannelDiag::ProfinetExtChannelDiag(pugi::xml_node&& p_ExtChannelDiag)
  : m_name(p_ExtChannelDiag.attribute("Name").as_string()),
    m_help(p_ExtChannelDiag.attribute("Help").as_string())
{
  // strncpy(m_name, p_ExtChannelDiag.attribute("Name").as_string(), sizeof(pwr_tString256)); // No null-termination if size > 256
  // strncpy(m_help, p_ExtChannelDiag.attribute("Help").as_string(), sizeof(pwr_tString256)); // No null-termination if size > 256
}

void ProfinetExtChannelDiag::build(pugi::xml_node&& p_ext_channel_diag, uint p_error_type) const
{
  // Attributes
  p_ext_channel_diag.append_attribute("ErrorType").set_value(p_error_type);
  p_ext_channel_diag.append_attribute("Name").set_value(m_name.c_str());
  p_ext_channel_diag.append_attribute("Help").set_value(m_help.c_str());
}

ProfinetChannelDiag::ProfinetChannelDiag(pugi::xml_node&& p_ChannelDiag)
  : m_name(p_ChannelDiag.attribute("Name").as_string()),
    m_help(p_ChannelDiag.attribute("Help").as_string())  
{
  // strncpy(m_name, p_ChannelDiag.attribute("Name").as_string(), sizeof(pwr_tString256)); // No null-termination if size > 256
  // strncpy(m_help, p_ChannelDiag.attribute("Help").as_string(), sizeof(pwr_tString256)); // No null-termination if size > 256

  for (pugi::xml_node& ext_channel_diag : p_ChannelDiag.children("ExtChannelDiag"))
  {
    m_ext_channel_diag_map.emplace(ext_channel_diag.attribute("ErrorType").as_uint(), std::move(ProfinetExtChannelDiag(std::move(ext_channel_diag))));
  }
}

void ProfinetChannelDiag::build(pugi::xml_node&& p_channel_diag, uint p_error_type) const
{
  // Attributes
  p_channel_diag.append_attribute("ErrorType").set_value(p_error_type);
  p_channel_diag.append_attribute("Name").set_value(m_name.c_str());
  p_channel_diag.append_attribute("Help").set_value(m_help.c_str());

  for (auto const& ext_channel_diag : m_ext_channel_diag_map)
  {
    ext_channel_diag.second.build(p_channel_diag.append_child("ExtChannelDiag"), ext_channel_diag.first);    
  } 
}

ProfinetIOCR::ProfinetIOCR(pugi::xml_node&& p_IOCR)
  : //m_type(p_IOCR.attribute("Type").as_uint()),
    //m_properties(p_IOCR.attribute("Properties").as_uint()),
    m_send_clock_factor(p_IOCR.attribute("SendClockFactor").as_uint()),
    m_reduction_ratio(p_IOCR.attribute("ReductionRatio").as_uint()),
    m_phase(p_IOCR.attribute("Phase").as_uint()),
    m_api(p_IOCR.attribute("API").as_uint()),
    m_rt_class(p_IOCR.attribute("RT_CLASS").as_string()),
    m_startup_mode(p_IOCR.attribute("StartupMode").as_string())
{

}

void ProfinetIOCR::build(pugi::xml_node&& p_iocr) const
{
  // Attributes
  //p_iocr.append_attribute("Type").set_value(m_type);
  //p_iocr.append_attribute("Properties").set_value(m_properties);
  p_iocr.append_attribute("SendClockFactor").set_value(m_send_clock_factor);
  p_iocr.append_attribute("ReductionRatio").set_value(m_reduction_ratio);
  p_iocr.append_attribute("Phase").set_value(m_phase);
  p_iocr.append_attribute("API").set_value(m_api);
  p_iocr.append_attribute("RT_CLASS").set_value(m_rt_class.c_str());
  p_iocr.append_attribute("StartupMode").set_value(m_startup_mode.c_str());
}

ProfinetDataRecord::ProfinetDataRecord(pugi::xml_node&& p_DataRecord)
  : //m_record_idx(0),
  m_data_length(p_DataRecord.attribute("DataLength").as_uint()),
  m_index(p_DataRecord.attribute("Index").as_uint()),
  m_transfer_sequence(p_DataRecord.attribute("TransferSequence").as_uint())
{
  m_data = new unsigned char[m_data_length]();
  
  // Lets parse it...
  std::istringstream buf(p_DataRecord.attribute("Data").as_string(),
                         std::ios_base::in);
    
// #if (pwr_dHost_byteOrder == pwr_dLittleEndian)  
//   size_t offset = m_data_length - 1;
// #endif       

  std::string value;
  unsigned int byte; // We need this to be a uint
  size_t pos = 0;
  while (getline(buf, value, ','))
  {
    std::istringstream val(value, std::ios_base::in);
    val.seekg(2); // Skip the 0x part
    val >> std::hex >> byte;

  //#if (pwr_dHost_byteOrder == pwr_dLittleEndian)
  //  *(m_data + offset - pos++) = (unsigned char)byte;    
  //#else
    *(m_data + pos++) = (unsigned char)byte;    
  //#endif
  }
}

ProfinetDataRecord::ProfinetDataRecord(ProfinetDataRecord&& o)
  : //m_record_idx(0),
    m_data(o.m_data),
    m_data_length(o.m_data_length),
    m_index(o.m_index),
    m_transfer_sequence(o.m_transfer_sequence)
{
  o.m_data = nullptr;
}

void ProfinetDataRecord::build(pugi::xml_node&& p_data_record) const
{
   // Attributes
  p_data_record.append_attribute("Index").set_value(m_index);
  p_data_record.append_attribute("TransferSequence").set_value(m_transfer_sequence);
  p_data_record.append_attribute("DataLength").set_value(m_data_length);
  
  std::ostringstream buf(std::ios_base::out);
  size_t offset = 0;  
// #if (pwr_dHost_byteOrder == pwr_dLittleEndian)
//   offset = m_data_length - 1;
// #endif

  for (size_t pos = 0; pos < m_data_length; pos++)
  {    
  // #if (pwr_dHost_byteOrder == pwr_dLittleEndian)
  //   buf << "0x" << std::hex << std::setfill('0') << std::setw(2) << std::right << +(*(m_data + offset - pos));
  // #else
    buf << "0x" << std::hex << std::setfill('0') << std::setw(2) << std::right << +(*(m_data + offset + pos));
  //#endif
    if (pos != (m_data_length - 1)) buf << ",";    
  }

  p_data_record.append_attribute("Data").set_value(buf.str().c_str());
}

ProfinetDataRecord::~ProfinetDataRecord()
{
  if (m_data)
  {
    delete[] m_data;
    m_data = nullptr;
  }  
}

ProfinetSubslot::ProfinetSubslot(pugi::xml_node&& p_Subslot)
  : m_subslot_number(p_Subslot.attribute("SubslotNumber").as_uint()),
   // m_subslot_idx(0), // Used in the configurator
   // m_submodule_enum_number(p_Subslot.attribute("SubmoduleEnumNumber").as_uint()),
    m_submodule_ident_number(p_Subslot.attribute("SubmoduleIdentNumber").as_uint()),
    m_io_input_length(p_Subslot.attribute("IOInputLength").as_uint()),
    m_io_output_length(p_Subslot.attribute("IOOutputLength").as_uint()),
    m_submodule_ID(p_Subslot.attribute("ID").as_string())
{
  for (pugi::xml_node& data_record : p_Subslot.children("DataRecord"))
  {
    //m_data_record_list.push_back(std::move(ProfinetDataRecord(std::move(data_record))));
    uint index = data_record.attribute("Index").as_uint();    
    m_data_record_map.emplace(index, ProfinetDataRecord(std::move(data_record)));
  }
}

// ProfinetSubslot& ProfinetSubslot::operator=(ProfinetSubslot const& other)
// {
//   if (this == &other)
//     return *this;

//   return *this;
// }

void ProfinetSubslot::build(pugi::xml_node&& p_subslot) const
{
  // Attributes
  p_subslot.append_attribute("SubslotNumber").set_value(m_subslot_number);
  //p_subslot.append_attribute("SubmoduleEnumNumber").set_value(m_submodule_enum_number);
  p_subslot.append_attribute("SubmoduleIdentNumber").set_value(m_submodule_ident_number);
  p_subslot.append_attribute("IOInputLength").set_value(m_io_input_length);
  p_subslot.append_attribute("IOOutputLength").set_value(m_io_output_length);
  p_subslot.append_attribute("ID").set_value(m_submodule_ID.c_str());

  // DataRecords
  for (auto const& datarecord : m_data_record_map)
  {
    datarecord.second.build(p_subslot.append_child("DataRecord"));
  }
  
}

ProfinetSlot::ProfinetSlot(pugi::xml_node&& p_Slot)
  : //m_module_enum_number(p_Slot.attribute("ModuleEnumNumber").as_uint()),
    m_module_ident_number(p_Slot.attribute("ModuleIdentNumber").as_uint()),
    //m_dap_fixed_slot(p_Slot.attribute("DapFixedInSlot").as_uint()),
    m_module_class(p_Slot.attribute("ModuleClass").as_uint()),
    //m_module_text(p_Slot.attribute("ModuleText").as_string()),    
    m_module_ID(p_Slot.attribute("ModuleID").as_string()),
    m_slot_number(p_Slot.attribute("SlotNumber").as_uint())
{
  //strncpy(m_module_text, p_Slot.attribute("ModuleText").as_string(), sizeof(pwr_tString256));

  for (pugi::xml_node& subslot : p_Slot.children("Subslot"))
  {
    uint subslot_number = subslot.attribute("SubslotNumber").as_uint();    
    //m_subslot_list.push_back(ProfinetSubslot(std::move(subslot)));
    m_subslot_map.emplace(subslot_number, ProfinetSubslot(std::move(subslot)));
  }
}

// ProfinetSlot& ProfinetSlot::operator=(ProfinetSlot const& other)
// {
//   if (this == &other)
//     return *this;

//   m_module_ident_number = other.m_module_ident_number;
//   m_module_oid = other.m_module_oid;
//   m_slot_number = other.m_slot_number;
  
//   return *this;
// }

void ProfinetSlot::build(pugi::xml_node&& p_slot) const
{
  // Attributes
  //p_slot.append_attribute("ModuleEnumNumber").set_value(m_module_enum_number);
  p_slot.append_attribute("ModuleIdentNumber").set_value(m_module_ident_number);
  p_slot.append_attribute("ModuleClass").set_value(m_module_class);
  //p_slot.append_attribute("ModuleText").set_value(m_module_text);
  p_slot.append_attribute("ModuleID").set_value(m_module_ID.c_str());
  p_slot.append_attribute("SlotNumber").set_value(m_slot_number);
  //p_slot.append_attribute("DapFixedInSlot").set_value(m_dap_fixed_slot);

  // Subslots
  for (auto const& subslot : m_subslot_map)
  {
    subslot.second.build(p_slot.append_child("Subslot"));
  }
}

ProfinetNetworkSettings::ProfinetNetworkSettings(pugi::xml_node&& p_PnNetworkSettings)
  : m_device_name(p_PnNetworkSettings.attribute("DeviceName").as_string()),
    m_ip_address(p_PnNetworkSettings.attribute("IP_Address").as_string()),
    m_subnet_mask(p_PnNetworkSettings.attribute("SubnetMask").as_string()),
    m_mac_address(p_PnNetworkSettings.attribute("MAC_Address").as_string()),
    m_skip_ip_assignment(p_PnNetworkSettings.attribute("Skip_IP_Assignment").as_bool())
{
  // strncpy(m_device_name, p_PnNetworkSettings.attribute("DeviceName").as_string(), sizeof(pwr_tString256));
  // strncpy(m_ip_address, p_PnNetworkSettings.attribute("IP_Address").as_string(), sizeof(pwr_tString256));
  // strncpy(m_subnet_mask, p_PnNetworkSettings.attribute("SubnetMask").as_string(), sizeof(pwr_tString256));
  // strncpy(m_mac_address, p_PnNetworkSettings.attribute("MAC_Address").as_string(), sizeof(pwr_tString256));
}

void ProfinetNetworkSettings::build(pugi::xml_node&& p_network_settings) const
{
  p_network_settings.append_attribute("DeviceName").set_value(m_device_name.c_str());
  p_network_settings.append_attribute("IP_Address").set_value(m_ip_address.c_str());
  p_network_settings.append_attribute("SubnetMask").set_value(m_subnet_mask.c_str());
  p_network_settings.append_attribute("MAC_Address").set_value(m_mac_address.c_str());
  p_network_settings.append_attribute("Skip_IP_Assignment").set_value(static_cast<bool>(m_skip_ip_assignment));
}

ProfinetDevice::ProfinetDevice(pugi::xml_node&& p_pn_device)
  : m_gsdml_source_file(p_pn_device.attribute("GSDML_Source").as_string()),
    //m_pn_runtime_conf_file(p_pn_device.attribute("GsdmlFile").as_string()),
    //m_device_num(p_pn_device.attribute("DeviceNumber").as_uint()),    
    //m_device_text(p_pn_device.attribute("DeviceText").as_string()),
    m_DAP_ID(p_pn_device.attribute("DAP_ID").as_string()),
    m_vendor_id(p_pn_device.attribute("VendorId").as_uint()),
    m_device_id(p_pn_device.attribute("DeviceId").as_uint()),
    //m_version(p_pn_device.attribute("Version").as_string()), // TODO Why is this important???    It referes to the profile revision in the profile body of the GSDML. Maybe we should save the PNIO version of the DAP instead?
    m_NetworkSettings(p_pn_device.child("NetworkSettings")),
    m_IOCR(p_pn_device.child("IOCR"))
{
  //strncpy(m_pn_runtime_conf_file, p_pn_device.attribute("GsdmlFile").as_string(), sizeof(pwr_tString256));
  //strncpy(m_device_text, p_pn_device.attribute("DeviceText").as_string(), sizeof(pwr_tString256));
  //strncpy(m_DAP_ID, p_pn_device.attribute("DAP_ID").as_string(), sizeof(pwr_tString256));

  for (pugi::xml_node& slot : p_pn_device.children("Slot"))
  {
    m_slot_list.push_back(ProfinetSlot(std::move(slot)));
  }

  // for (pugi::xml_node& iocr : p_pn_device.children("IOCR"))
  // {
  //   m_iocr_list.push_back(ProfinetIOCR(std::move(iocr)));
  // }

  for (pugi::xml_node& channel_diag : p_pn_device.child("Diagnostics").children("ChannelDiag"))
  {
    m_channel_diag_map.emplace(channel_diag.attribute("ErrorType").as_uint(), std::move(ProfinetChannelDiag(std::move(channel_diag))));
  }
}

void ProfinetDevice::build(pugi::xml_node&& p_pn_device) const
{
  p_pn_device.append_attribute("GSDML_Source").set_value(m_gsdml_source_file.c_str());
  //p_pn_device.append_attribute("DeviceNumber").set_value(m_device_num);
  //p_pn_device.append_attribute("DeviceText").set_value(m_device_text);
  p_pn_device.append_attribute("DAP_ID").set_value(m_DAP_ID.c_str());
  p_pn_device.append_attribute("VendorId").set_value(m_vendor_id);
  p_pn_device.append_attribute("DeviceId").set_value(m_device_id);
  //p_pn_device.append_attribute("Version").set_value(m_version.c_str());

  m_NetworkSettings.build(p_pn_device.append_child("NetworkSettings"));

  for (auto const& slot : m_slot_list)
  {
    slot.build(p_pn_device.append_child("Slot"));
  }

  m_IOCR.build(p_pn_device.append_child("IOCR"));

  // Diagnostics section
  pugi::xml_node diagnostics = p_pn_device.append_child("Diagnostics");
  for (auto const& channel_diag : m_channel_diag_map)
  {
    channel_diag.second.build(diagnostics.append_child("ChannelDiag"), channel_diag.first);    
  }
} 

void ProfinetRuntimeData::reset_to_default()
{
  m_PnDevice.reset(new ProfinetDevice());
  //m_PnDevice->m_iocr_list.push_back(ProfinetIOCR());
  //m_PnDevice->m_iocr_list.push_back(ProfinetIOCR());
}

int ProfinetRuntimeData::read_pwr_pn_xml(std::string const& p_filename, std::string const& p_gsdml_file)
{
  pugi::xml_document doc;
  pugi::xml_parse_result result = doc.load_file(p_filename.c_str());

  m_pwr_pn_filename = p_filename;

  if (result.status != pugi::status_ok)
  {
    // Construct a minimal default "zeroed" device
    reset_to_default();

    m_file_missing = true;
    return PB__GSDMLFILE;
  }

  // All good start parsing...
  m_PnDevice.reset(new ProfinetDevice(doc.select_node("/PnDevice").node()));

  /* 
    Check if GSDML files still match...
    One might have changed to a newer or older (though this is discouraged!) GSDML file. Newer GSDML files
    should be backwards compatible. So it should be safe. But we do let the user know of this and take action
    accordingly. The calling function will then, depending on the user choice pass in the parameter "ignore_mismatch".
  */
  std::string gsdml_file = doc.select_node("/PnDevice").node().attribute("GSDML_Source").as_string();
  if (gsdml_file != p_gsdml_file)
  {
    m_gsdml_mismatch = true;
    return PB__GSDMLFILEMISMATCH;
  }

  return PB__SUCCESS;
}

bool ProfinetRuntimeData::save() const
{
  pugi::xml_document doc;

  m_PnDevice->build(doc.append_child("PnDevice"));

  return doc.save_file(m_pwr_pn_filename.c_str());
}

int GsdmlDeviceData::read(const char* filename, int new_filename)
{  
  int sts;
  GsdmlDataReader* reader = new GsdmlDataReader(this);
  co_xml_parser* xml_parser = new co_xml_parser(reader);

  reader->new_filename = new_filename;
  sts = xml_parser->read(filename);
  delete xml_parser;
  delete reader;

  return sts;
}

int GsdmlDeviceData::copy_slot(unsigned int slot_idx)
{
  if (slot_idx >= slot_data.size())
    return 0;

  if (paste_slotdata)
    delete paste_slotdata;

  paste_slotdata = new GsdmlSlotData(*slot_data[slot_idx]);
  return PB__SUCCESS;
}

int GsdmlDeviceData::cut_slot(unsigned int slot_idx)
{
  if (slot_idx >= slot_data.size())
    return 0;

  unsigned int tmp_slot_idx;
  unsigned int tmp_slot_number;
  unsigned int prev_slot_idx = slot_data[slot_idx]->slot_idx;
  unsigned int prev_slot_number = slot_data[slot_idx]->slot_number;

  delete slot_data[slot_idx];

  for (unsigned int i = slot_idx; i < slot_data.size() - 1; i++)
  {
    tmp_slot_idx = slot_data[i + 1]->slot_idx;
    tmp_slot_number = slot_data[i + 1]->slot_number;

    slot_data[i] = slot_data[i + 1];

    slot_data[i]->slot_idx = prev_slot_idx;
    slot_data[i]->slot_number = prev_slot_number;
    prev_slot_idx = tmp_slot_idx;
    prev_slot_number = tmp_slot_number;
  }
  slot_data[slot_data.size() - 1] = new GsdmlSlotData();
  slot_data[slot_data.size() - 1]->slot_idx = prev_slot_idx;
  slot_data[slot_data.size() - 1]->slot_number = prev_slot_number;
  return PB__SUCCESS;
}

int GsdmlDeviceData::paste_slot(unsigned int slot_idx)
{
  if (slot_idx >= slot_data.size())
    return 0;

  if (!paste_slotdata)
    return 0;

  unsigned int tmp_slot_idx;
  unsigned int tmp_slot_number;
  unsigned int prev_slot_idx = slot_data[slot_data.size() - 1]->slot_idx;
  unsigned int prev_slot_number = slot_data[slot_data.size() - 1]->slot_number;

  delete slot_data[slot_data.size() - 1];

  for (unsigned int i = slot_data.size() - 1; i > slot_idx; i--)
  {
    tmp_slot_idx = slot_data[i - 1]->slot_idx;
    tmp_slot_number = slot_data[i - 1]->slot_number;

    slot_data[i] = slot_data[i - 1];

    slot_data[i]->slot_idx = prev_slot_idx;
    slot_data[i]->slot_number = prev_slot_number;
    prev_slot_idx = tmp_slot_idx;
    prev_slot_number = tmp_slot_number;
  }
  slot_data[slot_idx] = new GsdmlSlotData(*paste_slotdata);
  slot_data[slot_idx]->slot_idx = prev_slot_idx;
  slot_data[slot_idx]->slot_number = prev_slot_number;
  return PB__SUCCESS;
}

int GsdmlDeviceData::modify_value(const char* attr, const char* value)
{
  char attrvect[10][80];
  int num;
  int ival, num2;

  num = dcli_parse(attr, "-", "", (char*)attrvect,
                   sizeof(attrvect) / sizeof(attrvect[0]), sizeof(attrvect[0]),
                   0);

  if (streq(attrvect[0], "NetworkSettings"))
  {
    if (num < 2)
      return 0;
    if (streq(attrvect[1], "DeviceName"))
      strncpy(device_name, value, sizeof(device_name));
    else if (streq(attrvect[1], "IP Address"))
      strncpy(ip_address, value, sizeof(ip_address));
    else if (streq(attrvect[1], "Subnet Mask"))
      strncpy(subnet_mask, value, sizeof(subnet_mask));
    else if (streq(attrvect[1], "MAC Address"))
      strncpy(mac_address, value, sizeof(mac_address));
    else if (streq(attrvect[1], "SendClock"))
    {
      num2 = sscanf(value, "%d", &ival);
      if (num2 != 1)
        return 0;
      for (unsigned int i = 0; i < iocr_data.size(); i++)
        iocr_data[i]->send_clock_factor = ival;
    }
    else if (streq(attrvect[1], "ReductionRatio"))
    {
      num2 = sscanf(value, "%d", &ival);
      if (num2 != 1)
        return 0;
      for (unsigned int i = 0; i < iocr_data.size(); i++)
        iocr_data[i]->reduction_ratio = ival;
    }
    else if (streq(attrvect[1], "Phase"))
    {
      num2 = sscanf(value, "%d", &ival);
      if (num2 != 1)
        return 0;
      for (unsigned int i = 0; i < iocr_data.size(); i++)
        iocr_data[i]->phase = ival;
    }
    else if (streq(attrvect[1], "API"))
    {
      num2 = sscanf(value, "%d", &ival);
      if (num2 != 1)
        return 0;
      for (unsigned int i = 0; i < iocr_data.size(); i++)
        iocr_data[i]->api = ival;
    }
    else
      return 0;
  }
  else
    return 0;
  return 1;
}

int GsdmlDeviceData::get_value(const char* attr, char* buf, int bufsize)
{
  char attrvect[10][80];
  int num;

  num = dcli_parse(attr, "-", "", (char*)attrvect,
                   sizeof(attrvect) / sizeof(attrvect[0]), sizeof(attrvect[0]),
                   0);

  if (streq(attrvect[0], "NetworkSettings"))
  {
    if (num < 2)
      return 0;
    if (streq(attrvect[1], "DeviceName"))
      strncpy(buf, device_name, bufsize);
    else if (streq(attrvect[1], "IP Address"))
      strncpy(buf, ip_address, bufsize);
    else if (streq(attrvect[1], "Subnet Mask"))
      strncpy(buf, subnet_mask, bufsize);
    else if (streq(attrvect[1], "MAC Address"))
      strncpy(buf, mac_address, bufsize);
    else if (streq(attrvect[1], "SendClock"))
      snprintf(buf, bufsize, "%d", iocr_data[0]->send_clock_factor);
    else if (streq(attrvect[1], "ReductionRatio"))
      snprintf(buf, bufsize, "%d", iocr_data[0]->reduction_ratio);
    else if (streq(attrvect[1], "Phase"))
      snprintf(buf, bufsize, "%d", iocr_data[0]->phase);
    else if (streq(attrvect[1], "API"))
      snprintf(buf, bufsize, "%d", iocr_data[0]->api);
    else
      return 0;
  }
  else
    return 0;
  return 1;
}

int GsdmlDataReader::tag_name_to_id(const char* name, unsigned int* id)
{
  if (streq(name, "PnDevice"))
    *id = gsdmldata_eTag_PnDevice;
  else if (streq(name, "NetworkSettings"))
    *id = gsdmldata_eTag_NetworkSettings;
  else if (streq(name, "Slot"))
    *id = gsdmldata_eTag_Slot;
  else if (streq(name, "Subslot"))
    *id = gsdmldata_eTag_Subslot;
  else if (streq(name, "DataRecord"))
    *id = gsdmldata_eTag_DataRecord;
  else if (streq(name, "IOCR"))
    *id = gsdmldata_eTag_IOCR;
  else if (streq(name, "ChannelDiag"))
    *id = gsdmldata_eTag_ChannelDiag;
  else if (streq(name, "ExtChannelDiag"))
    *id = gsdmldata_eTag_ExtChannelDiag;
  else
    return 0;

  return 1;
}

int GsdmlDataReader::tag(const char* name)
{
  if (tag_name_to_id(name, &current_tag))
    tag_stack_push(current_tag);
  else
  {
    printf("XML-Parser: Unknown tag: %s\n", name);
    return 0;
  }

  switch (current_tag)
  {
  case gsdmldata_eTag_Slot:
  {
    GsdmlSlotData* sd = new GsdmlSlotData();

    data->slot_data.push_back(sd);
    object_stack_push(sd, current_tag);
    break;
  }
  case gsdmldata_eTag_Subslot:
  {
    GsdmlSlotData* sd = (GsdmlSlotData*)get_object_stack(gsdmldata_eTag_Slot);
    if (!sd)
    {
      printf("XML-Parser: Subslot outside slot");
      break;
    }

    GsdmlSubslotData* ssd = new GsdmlSubslotData();

    sd->subslot_data.push_back(ssd);
    object_stack_push(ssd, current_tag);
    break;
  }
  case gsdmldata_eTag_DataRecord:
  {
    GsdmlSubslotData* ssd =
        (GsdmlSubslotData*)get_object_stack(gsdmldata_eTag_Subslot);
    if (!ssd)
    {
      printf("XML-Parser: RecordData outside subslot\n");
      break;
    }

    GsdmlDataRecord* dr = new GsdmlDataRecord();

    ssd->data_record.push_back(dr);
    object_stack_push(dr, current_tag);
    break;
  }
  case gsdmldata_eTag_IOCR:
  {
    GsdmlIOCRData* iod = new GsdmlIOCRData();

    data->iocr_data.push_back(iod);
    object_stack_push(iod, current_tag);
    break;
  }
  case gsdmldata_eTag_ChannelDiag:
  {
    GsdmlChannelDiag* cd = new GsdmlChannelDiag();

    data->channel_diag.push_back(cd);
    object_stack_push(cd, current_tag);
    break;
  }
  case gsdmldata_eTag_ExtChannelDiag:
  {
    GsdmlChannelDiag* cd = (GsdmlChannelDiag*)get_object_stack(gsdmldata_eTag_ChannelDiag);
    if (!cd)
    {
      printf("XML-Parser: ExtChannelDiag outside ChannelDiag\n");
      break;
    }
    GsdmlExtChannelDiag* ecd = new GsdmlExtChannelDiag();

    cd->ext_channel_diag.push_back(ecd);    
    object_stack_push(ecd, current_tag);
    break;
  }
  default:;
  }

  return 1;
}
int GsdmlDataReader::metatag(const char* name) { return 1; }
int GsdmlDataReader::tag_end(const char* name)
{
  unsigned int id;

  if (tag_name_to_id(name, &id))
    tag_stack_pull(id);
  else
  {
    printf("XML-Parser: Tag/EndTag mismach: %s\n", name);
    return 0;
  }

  switch (id)
  {
  case gsdmldata_eTag_Slot:
    object_stack_pull(id);
    break;
  case gsdmldata_eTag_Subslot:
    object_stack_pull(id);
    break;
  case gsdmldata_eTag_DataRecord:
    object_stack_pull(id);
    break;
  case gsdmldata_eTag_IOCR:
    object_stack_pull(id);
    break;
  case gsdmldata_eTag_ExtChannelDiag:
    object_stack_pull(id);
    break;
  default:;
  }
  return 1;
}
int GsdmlDataReader::metatag_end(const char* name) { return 1; }
int GsdmlDataReader::tag_value(const char* name) { return 1; }
int GsdmlDataReader::tag_attribute(const char* name, const char* value)
{
  switch (current_tag)
  {
  case gsdmldata_eTag_PnDevice:
    if (streq(name, "GsdmlFile"))
    {
      if (!streq(data->gsdmlfile, ""))
      {
        // Check that the GSDML file is not changed
        char* gsdmlfile_p;

        // Print name of gsdmlfile, not path
        if ((gsdmlfile_p = strrchr(data->gsdmlfile, '/')))
          gsdmlfile_p++;
        else
          gsdmlfile_p = data->gsdmlfile;

        if (!streq(value, gsdmlfile_p) && !new_filename)
          return PB__GSDMLFILEMISMATCH;
      }
      else
        strncpy(data->gsdmlfile, value, sizeof(data->gsdmlfile));
    }
    else if (streq(name, "DeviceText"))
      strncpy(data->device_text, value, sizeof(data->device_text));
    else if (streq(name, "DeviceNumber"))
      sscanf(value, "%d", &data->device_num);
    else if (streq(name, "VendorId"))
      sscanf(value, "%hu", &data->vendor_id);
    else if (streq(name, "DeviceId"))
      sscanf(value, "%hu", &data->device_id);
    else if (streq(name, "Version"))
      strncpy(data->version, value, sizeof(data->version));
    else if (streq(name, "ByteOrder"))
      sscanf(value, "%d", &data->byte_order);
    else if (streq(name, "Instance"))
      sscanf(value, "%hu", &data->instance);
    break;
  case gsdmldata_eTag_NetworkSettings:
    if (streq(name, "DeviceName"))
      strncpy(data->device_name, value, sizeof(data->device_name));
    else if (streq(name, "IP_Address"))
      strncpy(data->ip_address, value, sizeof(data->ip_address));
    else if (streq(name, "SubnetMask"))
      strncpy(data->subnet_mask, value, sizeof(data->subnet_mask));
    else if (streq(name, "MAC_Address"))
      strncpy(data->mac_address, value, sizeof(data->mac_address));
    else if (streq(name, "Skip_IP_Assignment"))
      sscanf(value, "%d", &data->skip_ip_assignment);
    break;
  case gsdmldata_eTag_Slot:
  {
    GsdmlSlotData* sd = (GsdmlSlotData*)get_object_stack(current_tag);

    if (streq(name, "ModuleEnumNumber"))
      sscanf(value, "%d", &sd->module_enum_number);
    else if (streq(name, "ModuleIdentNumber"))
      sscanf(value, "%u", &sd->module_ident_number);
    else if (streq(name, "ModuleClass"))
      sscanf(value, "%u", &sd->module_class);
    else if (streq(name, "ModuleText"))
      strncpy(sd->module_text, value, sizeof(sd->module_text));
    else if (streq(name, "SlotNumber"))
      sscanf(value, "%u", &sd->slot_number);
    else if (streq(name, "DapFixedInSlot"))
      sscanf(value, "%u", &sd->dap_fixed_slot);
    break;
  }
  case gsdmldata_eTag_Subslot:
  {
    GsdmlSubslotData* sd = (GsdmlSubslotData*)get_object_stack(current_tag);

    if (streq(name, "SubslotNumber"))
      sscanf(value, "%u", &sd->subslot_number);
    else if (streq(name, "SubmoduleIdentNumber"))
      sscanf(value, "%u", &sd->submodule_ident_number);
    else if (streq(name, "API"))
      sscanf(value, "%u", &sd->api);
    else if (streq(name, "SubmoduleEnumNumber"))
      sscanf(value, "%d", &sd->submodule_enum_number);
    else if (streq(name, "IOInputLength"))
      sscanf(value, "%u", &sd->io_input_length);
    else if (streq(name, "IOOutputLength"))
      sscanf(value, "%u", &sd->io_output_length);
    break;
  }
  case gsdmldata_eTag_DataRecord:
  {
    GsdmlDataRecord* dr = (GsdmlDataRecord*)get_object_stack(current_tag);

    if (streq(name, "DataLength"))
      sscanf(value, "%u", &dr->data_length);
    else if (streq(name, "Index"))
      sscanf(value, "%hu", &dr->index);
    else if (streq(name, "TransferSequence"))
      sscanf(value, "%hu", &dr->transfer_sequence);
    else if (streq(name, "Data"))
    {
      int len;
      co_xml_parser::ostring_to_data(&dr->data, value, dr->data_length, &len);
    }
    break;
  }
  case gsdmldata_eTag_IOCR:
  {
    GsdmlIOCRData* iod = (GsdmlIOCRData*)get_object_stack(current_tag);

    if (streq(name, "Type"))
      sscanf(value, "%hu", &iod->type);
    else if (streq(name, "Properties"))
      sscanf(value, "%u", &iod->properties);
    else if (streq(name, "SendClockFactor"))
      sscanf(value, "%hu", &iod->send_clock_factor);
    else if (streq(name, "ReductionRatio"))
      sscanf(value, "%hu", &iod->reduction_ratio);
    else if (streq(name, "Phase"))
      sscanf(value, "%u", &iod->phase);
    else if (streq(name, "API"))
      sscanf(value, "%u", &iod->api);
    break;
  }
  case gsdmldata_eTag_ChannelDiag:
  {
    GsdmlChannelDiag* cd = (GsdmlChannelDiag*)get_object_stack(current_tag);

    if (streq(name, "ErrorType"))
      sscanf(value, "%hu", &cd->error_type);
    else if (streq(name, "Name"))
      strncpy(cd->name, value, sizeof(cd->name));
    else if (streq(name, "Help"))
      strncpy(cd->help, value, sizeof(cd->help));
    break;
  }
  case gsdmldata_eTag_ExtChannelDiag:
  {
    GsdmlExtChannelDiag* ecd = (GsdmlExtChannelDiag*)get_object_stack(current_tag);

    if (streq(name, "ErrorType"))
      sscanf(value, "%hu", &ecd->error_type);
    else if (streq(name, "Name"))
      strncpy(ecd->name, value, sizeof(ecd->name));
    else if (streq(name, "Help"))
      strncpy(ecd->help, value, sizeof(ecd->help));
    break;
  }
  default:;
  }
  return 1;
}
