/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2022 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* cow_pn_gsdml_data.cpp -- Profinet configurator data file */

#include <stdlib.h>
#include <memory>
#include <iostream>
#include <sstream>
#include <iomanip>

#include "co_dcli.h"
#include "co_string.h"

#include "rt_pb_msg.h"
#include "rt_pn_gsdml_data.h"

#include "pwr_baseclasses.h"

ProfinetExtChannelDiag::ProfinetExtChannelDiag(pugi::xml_node&& p_ExtChannelDiag)
    : m_name(p_ExtChannelDiag.attribute("Name").as_string()),
      m_help(p_ExtChannelDiag.attribute("Help").as_string())
{
}

void ProfinetExtChannelDiag::build(pugi::xml_node&& p_ext_channel_diag, uint p_error_type) const
{
  // Attributes
  p_ext_channel_diag.append_attribute("ErrorType").set_value(p_error_type);
  p_ext_channel_diag.append_attribute("Name").set_value(m_name.c_str());
  p_ext_channel_diag.append_attribute("Help").set_value(m_help.c_str());
}

ProfinetChannelDiag::ProfinetChannelDiag(pugi::xml_node&& p_ChannelDiag)
    : m_name(p_ChannelDiag.attribute("Name").as_string()), m_help(p_ChannelDiag.attribute("Help").as_string())
{
  for (pugi::xml_node& ext_channel_diag : p_ChannelDiag.children("ExtChannelDiag"))
  {
    m_ext_channel_diag_map.emplace(ext_channel_diag.attribute("ErrorType").as_uint(),
                                   std::move(ProfinetExtChannelDiag(std::move(ext_channel_diag))));
  }
}

void ProfinetChannelDiag::build(pugi::xml_node&& p_channel_diag, uint p_error_type) const
{
  // Attributes
  p_channel_diag.append_attribute("ErrorType").set_value(p_error_type);
  p_channel_diag.append_attribute("Name").set_value(m_name.c_str());
  p_channel_diag.append_attribute("Help").set_value(m_help.c_str());

  for (auto const& ext_channel_diag : m_ext_channel_diag_map)
  {
    ext_channel_diag.second.build(p_channel_diag.append_child("ExtChannelDiag"), ext_channel_diag.first);
  }
}

ProfinetIOCR::ProfinetIOCR(pugi::xml_node&& p_IOCR)
    : m_send_clock_factor(p_IOCR.attribute("SendClockFactor").as_uint()),
      m_reduction_ratio(p_IOCR.attribute("ReductionRatio").as_uint()),
      m_phase(p_IOCR.attribute("Phase").as_uint()), m_api(p_IOCR.attribute("API").as_uint()),
      m_rt_class(p_IOCR.attribute("RT_CLASS").as_string()),
      m_startup_mode(p_IOCR.attribute("StartupMode").as_string())
{
}

void ProfinetIOCR::build(pugi::xml_node&& p_iocr, uint type) const
{
  // Attributes
  p_iocr.append_attribute("Type").set_value(type);
  p_iocr.append_attribute("SendClockFactor").set_value(m_send_clock_factor);
  p_iocr.append_attribute("ReductionRatio").set_value(m_reduction_ratio);
  p_iocr.append_attribute("Phase").set_value(m_phase);
  p_iocr.append_attribute("API").set_value(m_api);
  p_iocr.append_attribute("RT_CLASS").set_value(m_rt_class.c_str());
  p_iocr.append_attribute("StartupMode").set_value(m_startup_mode.c_str());
}

ProfinetDataRecord::ProfinetDataRecord(pugi::xml_node&& p_DataRecord)
    : m_data_length(p_DataRecord.attribute("DataLength").as_uint()),
      m_index(p_DataRecord.attribute("Index").as_uint()),
      m_transfer_sequence(p_DataRecord.attribute("TransferSequence").as_uint())
{
  m_data = new unsigned char[m_data_length]();

  // Lets parse it...
  std::istringstream buf(p_DataRecord.attribute("Data").as_string(), std::ios_base::in);

  std::string value;
  unsigned int byte; // We need this to be a uint
  size_t pos = 0;
  while (getline(buf, value, ','))
  {
    std::istringstream val(value, std::ios_base::in);
    val.seekg(2); // Skip the 0x part
    val >> std::hex >> byte;
    *(m_data + pos++) = (unsigned char)byte;
  }
}

ProfinetDataRecord::ProfinetDataRecord(ProfinetDataRecord&& o)
    : m_data(o.m_data), m_data_length(o.m_data_length), m_index(o.m_index),
      m_transfer_sequence(o.m_transfer_sequence)
{
  o.m_data = nullptr;
}

void ProfinetDataRecord::build(pugi::xml_node&& p_data_record) const
{
  // Attributes
  p_data_record.append_attribute("Index").set_value(m_index);
  p_data_record.append_attribute("TransferSequence").set_value(m_transfer_sequence);
  p_data_record.append_attribute("DataLength").set_value(m_data_length);

  std::ostringstream buf(std::ios_base::out);
  size_t offset = 0;

  for (size_t pos = 0; pos < m_data_length; pos++)
  {
    buf << "0x" << std::hex << std::setfill('0') << std::setw(2) << std::right << +(*(m_data + offset + pos));
    if (pos != (m_data_length - 1))
      buf << ",";
  }

  p_data_record.append_attribute("Data").set_value(buf.str().c_str());
}

ProfinetDataRecord::~ProfinetDataRecord()
{
  if (m_data)
  {
    delete[] m_data;
    m_data = nullptr;
  }
}

ProfinetSubslot::ProfinetSubslot(pugi::xml_node&& p_Subslot)
    : m_subslot_number(p_Subslot.attribute("SubslotNumber").as_uint()),
      m_submodule_ident_number(p_Subslot.attribute("SubmoduleIdentNumber").as_uint()),
      m_io_input_length(p_Subslot.attribute("IOInputLength").as_uint()),
      m_io_output_length(p_Subslot.attribute("IOOutputLength").as_uint()),
      m_api(p_Subslot.attribute("API").as_uint()), m_submodule_ID(p_Subslot.attribute("ID").as_string()),
      m_rt_io_submodule_type(PROFINET_IO_SUBMODULE_TYPE_NO_INPUT_NO_OUTPUT)
{
  for (pugi::xml_node& data_record : p_Subslot.children("DataRecord"))
  {
    uint index = data_record.attribute("Index").as_uint();
    m_data_record_map.emplace(index, ProfinetDataRecord(std::move(data_record)));
  }

  // Set submodule input type for this subslot. We only need this in the constructor and
  // we don't need to bother updating this since we only need this data in the runtime where it is read from
  // the file only once
  if (m_io_input_length > 0)
  {
    m_rt_io_submodule_type = PROFINET_IO_SUBMODULE_TYPE_INPUT;
  }

  if (m_io_output_length > 0)
  {
    m_rt_io_submodule_type |= PROFINET_IO_SUBMODULE_TYPE_OUTPUT;
  }
}

ProfinetSubslot::ProfinetSubslot(ProfinetSubslot const& other)
{
  // Deep copy record data otherwise we will be modifying the same data references when we start copy slots
  for (auto const& data_record : other.m_data_record_map)
  {
    m_data_record_map[data_record.first].m_data = new unsigned char[data_record.second.m_data_length]();
    memcpy(m_data_record_map[data_record.first].m_data, data_record.second.m_data,
           data_record.second.m_data_length);

    m_data_record_map[data_record.first].m_data_length = data_record.second.m_data_length;
    m_data_record_map[data_record.first].m_index = data_record.second.m_index;
    m_data_record_map[data_record.first].m_transfer_sequence = data_record.second.m_transfer_sequence;
  }

  m_io_input_length = other.m_io_input_length;
  m_io_output_length = other.m_io_output_length;
  m_submodule_ID = other.m_submodule_ID;
  m_submodule_ident_number = other.m_submodule_ident_number;
  m_subslot_number = other.m_subslot_number;
  m_api = other.m_api;

  // We can safely ignore "Runtime specific" member variables since we don't be copy construct these classes
  // in the runtime
}

void ProfinetSubslot::build(pugi::xml_node&& p_subslot) const
{
  // Attributes
  p_subslot.append_attribute("SubslotNumber").set_value(m_subslot_number);
  p_subslot.append_attribute("SubmoduleIdentNumber").set_value(m_submodule_ident_number);
  p_subslot.append_attribute("IOInputLength").set_value(m_io_input_length);
  p_subslot.append_attribute("IOOutputLength").set_value(m_io_output_length);
  p_subslot.append_attribute("ID").set_value(m_submodule_ID.c_str());
  p_subslot.append_attribute("API").set_value(m_api);

  // DataRecords
  for (auto const& datarecord : m_data_record_map)
  {
    datarecord.second.build(p_subslot.append_child("DataRecord"));
  }
}

void ProfinetSubslot::reset()
{
  m_submodule_ident_number = 0;
  m_data_record_map.clear();
  m_io_input_length = 0;
  m_io_output_length = 0;
}

ProfinetSlot::ProfinetSlot(pugi::xml_node&& p_Slot)
    : m_module_ident_number(p_Slot.attribute("ModuleIdentNumber").as_uint()),
      m_module_class(p_Slot.attribute("ModuleClass").as_uint()),
      m_module_ID(p_Slot.attribute("ModuleID").as_string()),
      m_slot_number(p_Slot.attribute("SlotNumber").as_uint()), m_module_oid(pwr_cNOid), m_is_modified(false)
{
  for (pugi::xml_node& subslot : p_Slot.children("Subslot"))
  {
    uint subslot_number = subslot.attribute("SubslotNumber").as_uint();
    m_subslot_map.emplace(subslot_number, ProfinetSubslot(std::move(subslot)));
  }
}

ProfinetSlot& ProfinetSlot::operator=(ProfinetSlot const& other)
{
  if (this == &other)
    return *this;

  m_is_modified = true;
  m_module_class = other.m_module_class;
  m_module_ID = other.m_module_ID;
  m_module_ident_number = other.m_module_ident_number;
  m_module_oid = other.m_module_oid; // Not really used in the configurator
  // Ignore slot_number since it should stay unchanged...

  m_subslot_map = other.m_subslot_map;

  return *this;
}

void ProfinetSlot::build(pugi::xml_node&& p_slot) const
{
  // Attributes
  p_slot.append_attribute("ModuleIdentNumber").set_value(m_module_ident_number);
  p_slot.append_attribute("ModuleClass").set_value(m_module_class);
  p_slot.append_attribute("ModuleID").set_value(m_module_ID.c_str());
  p_slot.append_attribute("SlotNumber").set_value(m_slot_number);

  // Subslots
  for (auto const& subslot : m_subslot_map)
  {
    subslot.second.build(p_slot.append_child("Subslot"));
  }
}

ProfinetNetworkSettings::ProfinetNetworkSettings(pugi::xml_node&& p_PnNetworkSettings)
    : m_device_name(p_PnNetworkSettings.attribute("DeviceName").as_string()),
      m_ip_address(p_PnNetworkSettings.attribute("IP_Address").as_string()),
      m_subnet_mask(p_PnNetworkSettings.attribute("SubnetMask").as_string()),
      m_mac_address(p_PnNetworkSettings.attribute("MAC_Address").as_string()),
      m_skip_ip_assignment(p_PnNetworkSettings.attribute("Skip_IP_Assignment").as_bool())
{
}

void ProfinetNetworkSettings::build(pugi::xml_node&& p_network_settings) const
{
  p_network_settings.append_attribute("DeviceName").set_value(m_device_name.c_str());
  p_network_settings.append_attribute("IP_Address").set_value(m_ip_address.c_str());
  p_network_settings.append_attribute("SubnetMask").set_value(m_subnet_mask.c_str());
  p_network_settings.append_attribute("MAC_Address").set_value(m_mac_address.c_str());
  p_network_settings.append_attribute("Skip_IP_Assignment")
      .set_value(static_cast<bool>(m_skip_ip_assignment));
}

ProfinetDevice::ProfinetDevice(pugi::xml_node&& p_pn_device)
    : m_gsdml_source_file(p_pn_device.attribute("GSDML_Source").as_string()),
      m_moduleinfo_name(p_pn_device.attribute("ModuleInfoName").as_string()),
      m_DAP_ID(p_pn_device.attribute("DAP_ID").as_string()),
      m_vendor_id(p_pn_device.attribute("VendorId").as_uint()),
      m_device_id(p_pn_device.attribute("DeviceId").as_uint()),
      m_instance(p_pn_device.attribute("Instance").as_uint()),
      // m_version(p_pn_device.attribute("Version").as_string()), // TODO Why is this important???    It
      // referes to the profile revision in the profile body of the GSDML. Maybe we should save the PNIO
      // version of the DAP instead?
      m_NetworkSettings(p_pn_device.child("NetworkSettings"))
{
  for (pugi::xml_node& iocr : p_pn_device.child("IOCRs").children("IOCR"))
  {
    m_IOCR_map.emplace(iocr.attribute("Type").as_uint(), std::move(ProfinetIOCR(std::move(iocr))));
  }

  for (pugi::xml_node& slot : p_pn_device.children("Slot"))
  {
    m_slot_list.push_back(ProfinetSlot(std::move(slot)));
  }

  for (pugi::xml_node& channel_diag : p_pn_device.child("Diagnostics").children("ChannelDiag"))
  {
    m_channel_diag_map.emplace(channel_diag.attribute("ErrorType").as_uint(),
                               std::move(ProfinetChannelDiag(std::move(channel_diag))));
  }
}

void ProfinetDevice::build(pugi::xml_node&& p_pn_device) const
{
  p_pn_device.append_attribute("GSDML_Source").set_value(m_gsdml_source_file.c_str());
  p_pn_device.append_attribute("ModuleInfoName").set_value(m_moduleinfo_name.c_str());
  p_pn_device.append_attribute("DAP_ID").set_value(m_DAP_ID.c_str());
  p_pn_device.append_attribute("VendorId").set_value(m_vendor_id);
  p_pn_device.append_attribute("DeviceId").set_value(m_device_id);
  p_pn_device.append_attribute("Instance").set_value(m_instance);

  m_NetworkSettings.build(p_pn_device.append_child("NetworkSettings"));

  for (auto const& slot : m_slot_list)
  {
    slot.build(p_pn_device.append_child("Slot"));
  }

  // IOCR Section
  pugi::xml_node iocrs = p_pn_device.append_child("IOCRs");
  for (auto const& iocr : m_IOCR_map)
  {
    iocr.second.build(iocrs.append_child("IOCR"), iocr.first);
  }

  // Diagnostics section
  pugi::xml_node diagnostics = p_pn_device.append_child("Diagnostics");
  for (auto const& channel_diag : m_channel_diag_map)
  {
    channel_diag.second.build(diagnostics.append_child("ChannelDiag"), channel_diag.first);
  }
}

void ProfinetRuntimeData::reset_to_default() { m_PnDevice.reset(new ProfinetDevice()); }

int ProfinetRuntimeData::read_pwr_pn_xml(std::string const& p_filename, std::string const& p_gsdml_file)
{
  pugi::xml_document doc;
  pugi::xml_parse_result result = doc.load_file(p_filename.c_str());

  m_pwr_pn_filename = p_filename;

  if (result.status != pugi::status_ok)
  {
    // Construct a minimal default "zeroed" device
    reset_to_default();

    m_file_missing = true;
    return PB__GSDMLFILE;
  }

  // All good start parsing...
  m_PnDevice.reset(new ProfinetDevice(doc.select_node("/PnDevice").node()));

  /*
    Check if GSDML files still match...
    One might have changed to a newer or older (though this is discouraged!) GSDML file. Newer GSDML files
    should be backwards compatible. So it should be safe. But we do let the user know of this and take action
    accordingly. The calling function will then, depending on the user choice pass in the parameter
    "ignore_mismatch".
  */
  std::string gsdml_file = doc.select_node("/PnDevice").node().attribute("GSDML_Source").as_string();
  if (gsdml_file != p_gsdml_file)
  {
    m_gsdml_mismatch = true;
    return PB__GSDMLFILEMISMATCH;
  }

  return PB__SUCCESS;
}

bool ProfinetRuntimeData::save() const
{
  pugi::xml_document doc;

  m_PnDevice->build(doc.append_child("PnDevice"));

  return doc.save_file(m_pwr_pn_filename.c_str());
}