/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2025 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* pn_viewer_pnak.cpp -- Profinet viewer PNAK interface */

#ifdef PWRE_CONF_PNAK

#include <unistd.h>

#include <arpa/inet.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include "co_error.h"
#include "pn_viewer_pnak.h"

#include "pwr_profibusclasses.h"
#include "rt_pn_iface.h"

PnViewerPNAK::PnViewerPNAK(pwr_tStatus* sts, const char* interface_name)
{
  int s;
  struct ifreq ifr = {};
  std::shared_ptr<ProfinetDevice> pn_device;
  //  PnDeviceData* pn_dev_data;
  T_PNAK_EVENT_SET_MODE pMode;
  T_PNAK_WAIT_OBJECT wait_object;

  /* Init PNAK */

  m_local = new io_sAgentLocal;
  pnak_init();
  *sts = pnak_start_profistack(0, PNAK_SUPERVISOR_MODE);

  if (*sts != PNAK_OK)
  {
    printf("Starting profistack returned with error code\n");
    exit(0);
  }

  /* Get configs for device */

  s = socket(AF_INET, SOCK_DGRAM, 0);
  strncpy(ifr.ifr_name, interface_name, sizeof(ifr.ifr_name));
  if (ioctl(s, SIOCGIFADDR, &ifr) >= 0)
  {
    m_controller.m_NetworkSettings.m_ip_address =
        std::string(inet_ntoa(((struct sockaddr_in*)&ifr.ifr_addr)->sin_addr));
    // strcpy(dev_data.ip_address, inet_ntoa(((struct sockaddr_in*)&ifr.ifr_addr)->sin_addr));
  }
  if (ioctl(s, SIOCGIFNETMASK, &ifr) >= 0)
  {
    m_controller.m_NetworkSettings.m_subnet_mask =
        std::string(inet_ntoa(((struct sockaddr_in*)&ifr.ifr_netmask)->sin_addr));
    // strcpy(dev_data.subnet_mask, inet_ntoa(((struct sockaddr_in*)&ifr.ifr_netmask)->sin_addr));
  }

  sscanf(m_controller.m_NetworkSettings.m_ip_address.c_str(), "%hhu.%hhu.%hhu.%hhu",
         &m_controller.m_rt_ipaddress[3], &m_controller.m_rt_ipaddress[2], &m_controller.m_rt_ipaddress[1],
         &m_controller.m_rt_ipaddress[0]);
  sscanf(m_controller.m_NetworkSettings.m_subnet_mask.c_str(), "%hhu.%hhu.%hhu.%hhu",
         &m_controller.m_rt_subnetmask[3], &m_controller.m_rt_subnetmask[2], &m_controller.m_rt_subnetmask[1],
         &m_controller.m_rt_subnetmask[0]);

  m_controller.m_NetworkSettings.m_device_name = std::string("dumle");
  // strcpy(dev_data.device_name, "dumle");
  m_controller.m_rt_device_ref = PN_DEVICE_REFERENCE_THIS_STATION;
  // dev_data.device_num = PN_DEVICE_REFERENCE_THIS_STATION;
  m_controller.m_rt_interface_name = std::string(interface_name);
  // strcpy(dev_data.device_text, interface_name);
  m_controller.m_vendor_id = 279; // Softing vendor id
  // dev_data.vendor_id = 279; // Softing vendor id
  m_controller.m_device_id = 0;
  // dev_data.device_id = 0;

  // strcpy(dev_data.version, "1.0");
  m_controller.m_rt_version = std::string("1.0");
  // dev_data.byte_order = 0;

  // pn_dev_data = new PnDeviceData;

  pn_device.reset(new ProfinetDevice(m_controller));
  // pn_dev_data->device_ref = PN_DEVICE_REFERENCE_THIS_STATION;
  m_local->device_list.push_back(pn_device);

  /* Download config */

  pack_download_req(&m_local->service_req_res, pn_device);

  *sts = pnak_send_service_req_res(0, &m_local->service_req_res);

  if (*sts == PNAK_OK)
  {
    *sts = wait_service_con(m_local, 0);

    if (*sts != PNAK_OK)
    {
      /* Loop through devices and calculate offset for io */
    }
  }

  /* Set identification */

  pack_set_identification_req(&m_local->service_req_res);

  *sts = pnak_send_service_req_res(0, &m_local->service_req_res);

  if (*sts == PNAK_OK)
  {
    *sts = wait_service_con(m_local, 0);
  }

  pMode.Mode = PNAK_MODE_ONLINE;

  *sts = pnak_set_mode(0, &pMode);

  wait_object = PNAK_WAIT_OBJECT_STATE_CHANGED;

  *sts = pnak_wait_for_multiple_objects(0, &wait_object, PNAK_INFINITE_TIMEOUT);

  if (*sts != PNAK_OK)
  {
    printf("Setting state failed, sts: %d\r\n", *sts);
    return;
  }

  *sts = 1;
}

PnViewerPNAK::~PnViewerPNAK()
{
  // Close PNAK
}

void PnViewerPNAK::fetch_devices(std::vector<PnDevice>& dev_vect)
{
  PnDevice device;
  int sts;

  while (1)
  {
    // for (ii = 0; ii < m_local->dev_info.size(); ii++)
    // {
    //   delete m_local->dev_info[ii];
    // }

    // m_local->dev_info.clear();

    m_local->device_list.clear(); // Memory will be released automatically

    pack_get_los_req(&m_local->service_req_res);

    sts = pnak_send_service_req_res(0, &m_local->service_req_res);

    if (sts == PNAK_OK)
    {
      sts = wait_service_con(m_local, 0);
      if (sts == PNAK_OK)
      {
        // TODO Did we put the controller on pos 0 now? since we removed the m_local ref variables ipaddress
        // and so on. debug this...
        if (m_local->device_list.size() > 0)
        {
          for (auto& pn_device : m_local->device_list)
          // for (ii = 0; ii < m_local->dev_info.size(); ii++)
          {
            device.ipaddress[0] = pn_device->m_rt_ipaddress[0];
            device.ipaddress[1] = pn_device->m_rt_ipaddress[1];
            device.ipaddress[2] = pn_device->m_rt_ipaddress[2];
            device.ipaddress[3] = pn_device->m_rt_ipaddress[3];
            device.macaddress[0] = pn_device->m_rt_macaddress[0];
            device.macaddress[1] = pn_device->m_rt_macaddress[1];
            device.macaddress[2] = pn_device->m_rt_macaddress[2];
            device.macaddress[3] = pn_device->m_rt_macaddress[3];
            device.macaddress[4] = pn_device->m_rt_macaddress[4];
            device.macaddress[5] = pn_device->m_rt_macaddress[5];
            strncpy(device.devname, pn_device->m_NetworkSettings.m_device_name.c_str(),
                    sizeof(device.devname));
            device.vendorid = pn_device->m_vendor_id;
            device.deviceid = pn_device->m_device_id;
            dev_vect.push_back(device);
          }
          break;
        }
        else
          continue;
      }
    }
  }

  /*  pMode.Mode = PNAK_MODE_OFFLINE;

  sts = pnak_set_mode(0, &pMode);

  wait_object = PNAK_WAIT_OBJECT_STATE_CHANGED;

  sts = pnak_wait_for_multiple_objects(0, &wait_object, PNAK_INFINITE_TIMEOUT);

  if (sts != PNAK_OK) {
  printf("Setting state failed, sts: %d\r\n", sts);
  return;
  } */

  // if ( ...error... ) throw co_error_str( "Somethings is wrong...");
}

void PnViewerPNAK::set_device_properties(unsigned char* macaddress, unsigned char* ipaddress, char* devname)
{
  PnDevice device;
  int sts;
  ProfinetDevice pn_device;
  // PnDeviceInfo dev_info;

  /* Set name and ip-address of device */

  pn_device.m_rt_ipaddress[0] = ipaddress[0];
  pn_device.m_rt_ipaddress[1] = ipaddress[1];
  pn_device.m_rt_ipaddress[2] = ipaddress[2];
  pn_device.m_rt_ipaddress[3] = ipaddress[3];
  pn_device.m_rt_subnetmask[0] = m_controller.m_rt_subnetmask[0];
  pn_device.m_rt_subnetmask[1] = m_controller.m_rt_subnetmask[1];
  pn_device.m_rt_subnetmask[2] = m_controller.m_rt_subnetmask[2];
  pn_device.m_rt_subnetmask[3] = m_controller.m_rt_subnetmask[3];
  pn_device.m_rt_macaddress[0] = macaddress[0];
  pn_device.m_rt_macaddress[1] = macaddress[1];
  pn_device.m_rt_macaddress[2] = macaddress[2];
  pn_device.m_rt_macaddress[3] = macaddress[3];
  pn_device.m_rt_macaddress[4] = macaddress[4];
  pn_device.m_rt_macaddress[5] = macaddress[5];
  pn_device.m_NetworkSettings.m_device_name = std::string(devname);
  // strncpy(pn_device.m_NetworkSettings.m_device_name, devname, sizeof(dev_info.devname));

  pack_set_device_name_req(&m_local->service_req_res, &pn_device);
  sts = pnak_send_service_req_res(0, &m_local->service_req_res);

  if (sts == PNAK_OK)
  {
    sts = wait_service_con(m_local, 0);
  }

  sleep(3);

  pack_set_ip_settings_req(&m_local->service_req_res, &pn_device);
  sts = pnak_send_service_req_res(0, &m_local->service_req_res);

  if (sts == PNAK_OK)
  {
    sts = wait_service_con(m_local, 0);
  }
}

#endif
