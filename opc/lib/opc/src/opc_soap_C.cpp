/* opc_soap_C.cpp
   Generated by gSOAP 2.7.9d from opc_msg.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "opc_soap_H.h"

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wregister"

SOAP_SOURCE_STAMP("@(#) opc_soap_C.cpp ver 2.7.9d 2007-03-30 08:43:57 GMT")

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap* soap)
{
  if (soap->header)
    soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap* soap)
{
  if (soap->header) {
    soap->part = SOAP_IN_HEADER;
    soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
    soap->part = SOAP_END_HEADER;
  }
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap* soap)
{
  soap->part = SOAP_IN_HEADER;
  soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
  soap->part = SOAP_END_HEADER;
  return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap* soap)
{
  if (!soap->fault) {
    soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
    soap_default_SOAP_ENV__Fault(soap, soap->fault);
  }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Code) {
    soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
    soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
  }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason) {
    soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
    soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
  }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap* soap)
{
  soap_fault(soap);
  if (soap->fault)
    soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap* soap)
{
  if (soap->fault)
    return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap* soap)
{
  return (soap->fault
             = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL))
      == NULL;
}

SOAP_FMAC3 const char** SOAP_FMAC4 soap_faultcode(struct soap* soap)
{
  soap_fault(soap);
  if (soap->version == 2)
    return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
  return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char** SOAP_FMAC4 soap_faultsubcode(struct soap* soap)
{
  soap_fault(soap);
  if (soap->version == 2) {
    if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode) {
      soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode
          = soap_new_SOAP_ENV__Code(soap, -1);
      soap_default_SOAP_ENV__Code(
          soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
    }
    return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode
        ->SOAP_ENV__Value;
  }
  return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char** SOAP_FMAC4 soap_faultstring(struct soap* soap)
{
  soap_fault(soap);
  if (soap->version == 2)
    return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
  return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char** SOAP_FMAC4 soap_faultdetail(struct soap* soap)
{
  soap_fault(soap);
  if (soap->version == 1) {
    if (!soap->fault->detail) {
      soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(
          soap, sizeof(struct SOAP_ENV__Detail));
      soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
    }
    return (const char**)&soap->fault->detail->__any;
  }
  if (!soap->fault->SOAP_ENV__Detail) {
    soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
    soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
  }
  return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap* soap)
{
  int t;
  for (;;)
    if (!soap_getelement(soap, &t))
      if (soap->error || soap_ignore_element(soap))
        break;
  if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
    soap->error = SOAP_OK;
  return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void* SOAP_FMAC4 soap_getelement(struct soap* soap, int* type)
{
  if (soap_peek_element(soap))
    return NULL;
  if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
    *type = soap_lookup_type(soap, soap->href);
  switch (*type) {
  case SOAP_TYPE_byte:
    return soap_in_byte(soap, NULL, NULL, "xsd:byte");
  case SOAP_TYPE_short:
    return soap_in_short(soap, NULL, NULL, "xsd:short");
  case SOAP_TYPE_int:
    return soap_in_int(soap, NULL, NULL, "xsd:int");
  case SOAP_TYPE_LONG64:
    return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
  case SOAP_TYPE_float:
    return soap_in_float(soap, NULL, NULL, "xsd:float");
  case SOAP_TYPE_double:
    return soap_in_double(soap, NULL, NULL, "xsd:double");
  case SOAP_TYPE_unsignedByte:
    return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
  case SOAP_TYPE_unsignedShort:
    return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
  case SOAP_TYPE_unsignedInt:
    return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
  case SOAP_TYPE_unsignedLONG64:
    return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
  case SOAP_TYPE_s0__browseFilter:
    return soap_in_s0__browseFilter(soap, NULL, NULL, "s0:browseFilter");
  case SOAP_TYPE_s0__limitBits:
    return soap_in_s0__limitBits(soap, NULL, NULL, "s0:limitBits");
  case SOAP_TYPE_s0__qualityBits:
    return soap_in_s0__qualityBits(soap, NULL, NULL, "s0:qualityBits");
  case SOAP_TYPE_s0__interfaceVersion:
    return soap_in_s0__interfaceVersion(
        soap, NULL, NULL, "s0:interfaceVersion");
  case SOAP_TYPE_s0__serverState:
    return soap_in_s0__serverState(soap, NULL, NULL, "s0:serverState");
  case SOAP_TYPE_bool:
    return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
  case SOAP_TYPE_s0__browseFilter_:
    return soap_in_s0__browseFilter_(soap, NULL, NULL, "s0:browseFilter");
  case SOAP_TYPE_s0__limitBits_:
    return soap_in_s0__limitBits_(soap, NULL, NULL, "s0:limitBits");
  case SOAP_TYPE_s0__qualityBits_:
    return soap_in_s0__qualityBits_(soap, NULL, NULL, "s0:qualityBits");
  case SOAP_TYPE_s0__interfaceVersion_:
    return soap_in_s0__interfaceVersion_(
        soap, NULL, NULL, "s0:interfaceVersion");
  case SOAP_TYPE_s0__serverState_:
    return soap_in_s0__serverState_(soap, NULL, NULL, "s0:serverState");
  case SOAP_TYPE_s0__PropertyReplyList:
    return soap_in_s0__PropertyReplyList(
        soap, NULL, NULL, "s0:PropertyReplyList");
  case SOAP_TYPE_s0__ItemIdentifier:
    return soap_in_s0__ItemIdentifier(soap, NULL, NULL, "s0:ItemIdentifier");
  case SOAP_TYPE_s0__ItemProperty:
    return soap_in_s0__ItemProperty(soap, NULL, NULL, "s0:ItemProperty");
  case SOAP_TYPE_s0__BrowseElement:
    return soap_in_s0__BrowseElement(soap, NULL, NULL, "s0:BrowseElement");
  case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
    return soap_in_s0__SubscribePolledRefreshReplyItemList(
        soap, NULL, NULL, "s0:SubscribePolledRefreshReplyItemList");
  case SOAP_TYPE_s0__SubscribeItemValue:
    return soap_in_s0__SubscribeItemValue(
        soap, NULL, NULL, "s0:SubscribeItemValue");
  case SOAP_TYPE_s0__SubscribeReplyItemList:
    return soap_in_s0__SubscribeReplyItemList(
        soap, NULL, NULL, "s0:SubscribeReplyItemList");
  case SOAP_TYPE_s0__SubscribeRequestItem:
    return soap_in_s0__SubscribeRequestItem(
        soap, NULL, NULL, "s0:SubscribeRequestItem");
  case SOAP_TYPE_s0__SubscribeRequestItemList:
    return soap_in_s0__SubscribeRequestItemList(
        soap, NULL, NULL, "s0:SubscribeRequestItemList");
  case SOAP_TYPE_s0__WriteRequestItemList:
    return soap_in_s0__WriteRequestItemList(
        soap, NULL, NULL, "s0:WriteRequestItemList");
  case SOAP_TYPE_s0__ArrayOfShort:
    return soap_in_s0__ArrayOfShort(soap, NULL, NULL, "s0:ArrayOfShort");
  case SOAP_TYPE_s0__ArrayOfByte:
    return soap_in_s0__ArrayOfByte(soap, NULL, NULL, "s0:ArrayOfByte");
  case SOAP_TYPE_s0__ArrayOfDecimal:
    return soap_in_s0__ArrayOfDecimal(soap, NULL, NULL, "s0:ArrayOfDecimal");
  case SOAP_TYPE_s0__ArrayOfAnyType:
    return soap_in_s0__ArrayOfAnyType(soap, NULL, NULL, "s0:ArrayOfAnyType");
  case SOAP_TYPE_s0__ArrayOfDateTime:
    return soap_in_s0__ArrayOfDateTime(soap, NULL, NULL, "s0:ArrayOfDateTime");
  case SOAP_TYPE_s0__ArrayOfString:
    return soap_in_s0__ArrayOfString(soap, NULL, NULL, "s0:ArrayOfString");
  case SOAP_TYPE_s0__ArrayOfBoolean:
    return soap_in_s0__ArrayOfBoolean(soap, NULL, NULL, "s0:ArrayOfBoolean");
  case SOAP_TYPE_s0__ArrayOfUnsignedShort:
    return soap_in_s0__ArrayOfUnsignedShort(
        soap, NULL, NULL, "s0:ArrayOfUnsignedShort");
  case SOAP_TYPE_s0__ArrayOfDouble:
    return soap_in_s0__ArrayOfDouble(soap, NULL, NULL, "s0:ArrayOfDouble");
  case SOAP_TYPE_s0__ArrayOfUnsignedLong:
    return soap_in_s0__ArrayOfUnsignedLong(
        soap, NULL, NULL, "s0:ArrayOfUnsignedLong");
  case SOAP_TYPE_s0__ArrayOfLong:
    return soap_in_s0__ArrayOfLong(soap, NULL, NULL, "s0:ArrayOfLong");
  case SOAP_TYPE_s0__ArrayOfUnsignedInt:
    return soap_in_s0__ArrayOfUnsignedInt(
        soap, NULL, NULL, "s0:ArrayOfUnsignedInt");
  case SOAP_TYPE_s0__ArrayOfInt:
    return soap_in_s0__ArrayOfInt(soap, NULL, NULL, "s0:ArrayOfInt");
  case SOAP_TYPE_s0__ArrayOfFloat:
    return soap_in_s0__ArrayOfFloat(soap, NULL, NULL, "s0:ArrayOfFloat");
  case SOAP_TYPE_s0__OPCError:
    return soap_in_s0__OPCError(soap, NULL, NULL, "s0:OPCError");
  case SOAP_TYPE_s0__OPCQuality:
    return soap_in_s0__OPCQuality(soap, NULL, NULL, "s0:OPCQuality");
  case SOAP_TYPE_s0__Value:
    return soap_in_s0__Value(soap, NULL, NULL, "s0:Value");
  case SOAP_TYPE_s0__ItemValue:
    return soap_in_s0__ItemValue(soap, NULL, NULL, "s0:ItemValue");
  case SOAP_TYPE_s0__ReplyItemList:
    return soap_in_s0__ReplyItemList(soap, NULL, NULL, "s0:ReplyItemList");
  case SOAP_TYPE_s0__ReadRequestItem:
    return soap_in_s0__ReadRequestItem(soap, NULL, NULL, "s0:ReadRequestItem");
  case SOAP_TYPE_s0__ReadRequestItemList:
    return soap_in_s0__ReadRequestItemList(
        soap, NULL, NULL, "s0:ReadRequestItemList");
  case SOAP_TYPE_s0__RequestOptions:
    return soap_in_s0__RequestOptions(soap, NULL, NULL, "s0:RequestOptions");
  case SOAP_TYPE_s0__ServerStatus:
    return soap_in_s0__ServerStatus(soap, NULL, NULL, "s0:ServerStatus");
  case SOAP_TYPE_s0__ReplyBase:
    return soap_in_s0__ReplyBase(soap, NULL, NULL, "s0:ReplyBase");
  case SOAP_TYPE_xsd__unsignedShort:
    return soap_in_xsd__unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
  case SOAP_TYPE_xsd__unsignedLong:
    return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
  case SOAP_TYPE_xsd__unsignedInt:
    return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
  case SOAP_TYPE_xsd__unsignedByte:
    return soap_in_xsd__unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
  case SOAP_TYPE_xsd__string:
    return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
  case SOAP_TYPE_xsd__short:
    return soap_in_xsd__short(soap, NULL, NULL, "xsd:short");
  case SOAP_TYPE_xsd__long:
    return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
  case SOAP_TYPE_xsd__int:
    return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
  case SOAP_TYPE_xsd__float:
    return soap_in_xsd__float(soap, NULL, NULL, "xsd:float");
  case SOAP_TYPE_xsd__double:
    return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
  case SOAP_TYPE_xsd__decimal_:
    return soap_in_xsd__decimal_(soap, NULL, NULL, "xsd:decimal");
  case SOAP_TYPE_xsd__decimal:
    return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
  case SOAP_TYPE_xsd__duration:
    return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
  case SOAP_TYPE_xsd__dateTime:
    return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
  case SOAP_TYPE_xsd__byte:
    return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
  case SOAP_TYPE_xsd__boolean:
    return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
  case SOAP_TYPE_xsd__QName_:
    return soap_in_xsd__QName_(soap, NULL, NULL, "xsd:QName");
  case SOAP_TYPE_xsd__QName:
    return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
  case SOAP_TYPE_std__string:
    return soap_in_std__string(soap, NULL, NULL, "xsd:string");
  case SOAP_TYPE_xsd__anyType:
    return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
  case SOAP_TYPE_PointerTo_s0__GetPropertiesResponse:
    return soap_in_PointerTo_s0__GetPropertiesResponse(
        soap, NULL, NULL, "s0:GetPropertiesResponse");
  case SOAP_TYPE_PointerTo_s0__GetProperties:
    return soap_in_PointerTo_s0__GetProperties(
        soap, NULL, NULL, "s0:GetProperties");
  case SOAP_TYPE_PointerTo_s0__BrowseResponse:
    return soap_in_PointerTo_s0__BrowseResponse(
        soap, NULL, NULL, "s0:BrowseResponse");
  case SOAP_TYPE_PointerTo_s0__Browse:
    return soap_in_PointerTo_s0__Browse(soap, NULL, NULL, "s0:Browse");
  case SOAP_TYPE_PointerTo_s0__SubscriptionCancelResponse:
    return soap_in_PointerTo_s0__SubscriptionCancelResponse(
        soap, NULL, NULL, "s0:SubscriptionCancelResponse");
  case SOAP_TYPE_PointerTo_s0__SubscriptionCancel:
    return soap_in_PointerTo_s0__SubscriptionCancel(
        soap, NULL, NULL, "s0:SubscriptionCancel");
  case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefreshResponse:
    return soap_in_PointerTo_s0__SubscriptionPolledRefreshResponse(
        soap, NULL, NULL, "s0:SubscriptionPolledRefreshResponse");
  case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefresh:
    return soap_in_PointerTo_s0__SubscriptionPolledRefresh(
        soap, NULL, NULL, "s0:SubscriptionPolledRefresh");
  case SOAP_TYPE_PointerTo_s0__SubscribeResponse:
    return soap_in_PointerTo_s0__SubscribeResponse(
        soap, NULL, NULL, "s0:SubscribeResponse");
  case SOAP_TYPE_PointerTo_s0__Subscribe:
    return soap_in_PointerTo_s0__Subscribe(soap, NULL, NULL, "s0:Subscribe");
  case SOAP_TYPE_PointerTo_s0__WriteResponse:
    return soap_in_PointerTo_s0__WriteResponse(
        soap, NULL, NULL, "s0:WriteResponse");
  case SOAP_TYPE_PointerTo_s0__Write:
    return soap_in_PointerTo_s0__Write(soap, NULL, NULL, "s0:Write");
  case SOAP_TYPE_PointerTo_s0__ReadResponse:
    return soap_in_PointerTo_s0__ReadResponse(
        soap, NULL, NULL, "s0:ReadResponse");
  case SOAP_TYPE_PointerTo_s0__Read:
    return soap_in_PointerTo_s0__Read(soap, NULL, NULL, "s0:Read");
  case SOAP_TYPE_PointerTo_s0__GetStatusResponse:
    return soap_in_PointerTo_s0__GetStatusResponse(
        soap, NULL, NULL, "s0:GetStatusResponse");
  case SOAP_TYPE_PointerTo_s0__GetStatus:
    return soap_in_PointerTo_s0__GetStatus(soap, NULL, NULL, "s0:GetStatus");
  case SOAP_TYPE_PointerTos0__PropertyReplyList:
    return soap_in_PointerTos0__PropertyReplyList(
        soap, NULL, NULL, "s0:PropertyReplyList");
  case SOAP_TYPE_PointerTos0__ItemIdentifier:
    return soap_in_PointerTos0__ItemIdentifier(
        soap, NULL, NULL, "s0:ItemIdentifier");
  case SOAP_TYPE_PointerTos0__BrowseElement:
    return soap_in_PointerTos0__BrowseElement(
        soap, NULL, NULL, "s0:BrowseElement");
  case SOAP_TYPE_PointerTos0__browseFilter:
    return soap_in_PointerTos0__browseFilter(
        soap, NULL, NULL, "s0:browseFilter");
  case SOAP_TYPE_PointerTos0__SubscribePolledRefreshReplyItemList:
    return soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(
        soap, NULL, NULL, "s0:SubscribePolledRefreshReplyItemList");
  case SOAP_TYPE_PointerTos0__SubscribeReplyItemList:
    return soap_in_PointerTos0__SubscribeReplyItemList(
        soap, NULL, NULL, "s0:SubscribeReplyItemList");
  case SOAP_TYPE_PointerTos0__SubscribeRequestItemList:
    return soap_in_PointerTos0__SubscribeRequestItemList(
        soap, NULL, NULL, "s0:SubscribeRequestItemList");
  case SOAP_TYPE_PointerTos0__WriteRequestItemList:
    return soap_in_PointerTos0__WriteRequestItemList(
        soap, NULL, NULL, "s0:WriteRequestItemList");
  case SOAP_TYPE_PointerTos0__OPCError:
    return soap_in_PointerTos0__OPCError(soap, NULL, NULL, "s0:OPCError");
  case SOAP_TYPE_PointerTos0__ReplyItemList:
    return soap_in_PointerTos0__ReplyItemList(
        soap, NULL, NULL, "s0:ReplyItemList");
  case SOAP_TYPE_PointerTos0__ReadRequestItemList:
    return soap_in_PointerTos0__ReadRequestItemList(
        soap, NULL, NULL, "s0:ReadRequestItemList");
  case SOAP_TYPE_PointerTos0__RequestOptions:
    return soap_in_PointerTos0__RequestOptions(
        soap, NULL, NULL, "s0:RequestOptions");
  case SOAP_TYPE_PointerTos0__ServerStatus:
    return soap_in_PointerTos0__ServerStatus(
        soap, NULL, NULL, "s0:ServerStatus");
  case SOAP_TYPE_PointerTos0__ReplyBase:
    return soap_in_PointerTos0__ReplyBase(soap, NULL, NULL, "s0:ReplyBase");
  case SOAP_TYPE_PointerTos0__ItemProperty:
    return soap_in_PointerTos0__ItemProperty(
        soap, NULL, NULL, "s0:ItemProperty");
  case SOAP_TYPE_PointerTos0__SubscribeItemValue:
    return soap_in_PointerTos0__SubscribeItemValue(
        soap, NULL, NULL, "s0:SubscribeItemValue");
  case SOAP_TYPE_PointerTofloat:
    return soap_in_PointerTofloat(soap, NULL, NULL, "xsd:float");
  case SOAP_TYPE_PointerTos0__SubscribeRequestItem:
    return soap_in_PointerTos0__SubscribeRequestItem(
        soap, NULL, NULL, "s0:SubscribeRequestItem");
  case SOAP_TYPE_PointerTounsignedShort:
    return soap_in_PointerTounsignedShort(
        soap, NULL, NULL, "xsd:unsignedShort");
  case SOAP_TYPE_PointerTos0__limitBits:
    return soap_in_PointerTos0__limitBits(soap, NULL, NULL, "s0:limitBits");
  case SOAP_TYPE_PointerTos0__qualityBits:
    return soap_in_PointerTos0__qualityBits(soap, NULL, NULL, "s0:qualityBits");
  case SOAP_TYPE_PointerTos0__OPCQuality:
    return soap_in_PointerTos0__OPCQuality(soap, NULL, NULL, "s0:OPCQuality");
  case SOAP_TYPE_PointerToxsd__anyType:
    return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
  case SOAP_TYPE_PointerTos0__ItemValue:
    return soap_in_PointerTos0__ItemValue(soap, NULL, NULL, "s0:ItemValue");
  case SOAP_TYPE_PointerToint:
    return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
  case SOAP_TYPE_PointerToxsd__QName:
    return soap_in_PointerToxsd__QName(soap, NULL, NULL, "xsd:QName");
  case SOAP_TYPE_PointerTos0__ReadRequestItem:
    return soap_in_PointerTos0__ReadRequestItem(
        soap, NULL, NULL, "s0:ReadRequestItem");
  case SOAP_TYPE_PointerTobool:
    return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
  case SOAP_TYPE_PointerTostd__string:
    return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
  case SOAP_TYPE_string: {
    char** s;
    s = soap_in_string(soap, NULL, NULL, "xsd:string");
    return s ? *s : NULL;
  }
  default: {
    const char* t = soap->type;
    if (!*t)
      t = soap->tag;
    if (!soap_match_tag(soap, t, "xsd:byte")) {
      *type = SOAP_TYPE_byte;
      return soap_in_byte(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:short")) {
      *type = SOAP_TYPE_short;
      return soap_in_short(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:int")) {
      *type = SOAP_TYPE_int;
      return soap_in_int(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:long")) {
      *type = SOAP_TYPE_LONG64;
      return soap_in_LONG64(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:float")) {
      *type = SOAP_TYPE_float;
      return soap_in_float(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:double")) {
      *type = SOAP_TYPE_double;
      return soap_in_double(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedByte")) {
      *type = SOAP_TYPE_unsignedByte;
      return soap_in_unsignedByte(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedShort")) {
      *type = SOAP_TYPE_unsignedShort;
      return soap_in_unsignedShort(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedInt")) {
      *type = SOAP_TYPE_unsignedInt;
      return soap_in_unsignedInt(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedLong")) {
      *type = SOAP_TYPE_unsignedLONG64;
      return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:browseFilter")) {
      *type = SOAP_TYPE_s0__browseFilter;
      return soap_in_s0__browseFilter(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:limitBits")) {
      *type = SOAP_TYPE_s0__limitBits;
      return soap_in_s0__limitBits(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:qualityBits")) {
      *type = SOAP_TYPE_s0__qualityBits;
      return soap_in_s0__qualityBits(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:interfaceVersion")) {
      *type = SOAP_TYPE_s0__interfaceVersion;
      return soap_in_s0__interfaceVersion(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:serverState")) {
      *type = SOAP_TYPE_s0__serverState;
      return soap_in_s0__serverState(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:boolean")) {
      *type = SOAP_TYPE_bool;
      return soap_in_bool(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:browseFilter")) {
      *type = SOAP_TYPE_s0__browseFilter_;
      return soap_in_s0__browseFilter_(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:limitBits")) {
      *type = SOAP_TYPE_s0__limitBits_;
      return soap_in_s0__limitBits_(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:qualityBits")) {
      *type = SOAP_TYPE_s0__qualityBits_;
      return soap_in_s0__qualityBits_(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:interfaceVersion")) {
      *type = SOAP_TYPE_s0__interfaceVersion_;
      return soap_in_s0__interfaceVersion_(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:serverState")) {
      *type = SOAP_TYPE_s0__serverState_;
      return soap_in_s0__serverState_(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:PropertyReplyList")) {
      *type = SOAP_TYPE_s0__PropertyReplyList;
      return soap_in_s0__PropertyReplyList(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ItemIdentifier")) {
      *type = SOAP_TYPE_s0__ItemIdentifier;
      return soap_in_s0__ItemIdentifier(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ItemProperty")) {
      *type = SOAP_TYPE_s0__ItemProperty;
      return soap_in_s0__ItemProperty(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:BrowseElement")) {
      *type = SOAP_TYPE_s0__BrowseElement;
      return soap_in_s0__BrowseElement(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscribePolledRefreshReplyItemList")) {
      *type = SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList;
      return soap_in_s0__SubscribePolledRefreshReplyItemList(
          soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscribeItemValue")) {
      *type = SOAP_TYPE_s0__SubscribeItemValue;
      return soap_in_s0__SubscribeItemValue(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscribeReplyItemList")) {
      *type = SOAP_TYPE_s0__SubscribeReplyItemList;
      return soap_in_s0__SubscribeReplyItemList(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscribeRequestItem")) {
      *type = SOAP_TYPE_s0__SubscribeRequestItem;
      return soap_in_s0__SubscribeRequestItem(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscribeRequestItemList")) {
      *type = SOAP_TYPE_s0__SubscribeRequestItemList;
      return soap_in_s0__SubscribeRequestItemList(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:WriteRequestItemList")) {
      *type = SOAP_TYPE_s0__WriteRequestItemList;
      return soap_in_s0__WriteRequestItemList(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfShort")) {
      *type = SOAP_TYPE_s0__ArrayOfShort;
      return soap_in_s0__ArrayOfShort(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfByte")) {
      *type = SOAP_TYPE_s0__ArrayOfByte;
      return soap_in_s0__ArrayOfByte(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfDecimal")) {
      *type = SOAP_TYPE_s0__ArrayOfDecimal;
      return soap_in_s0__ArrayOfDecimal(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfAnyType")) {
      *type = SOAP_TYPE_s0__ArrayOfAnyType;
      return soap_in_s0__ArrayOfAnyType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfDateTime")) {
      *type = SOAP_TYPE_s0__ArrayOfDateTime;
      return soap_in_s0__ArrayOfDateTime(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfString")) {
      *type = SOAP_TYPE_s0__ArrayOfString;
      return soap_in_s0__ArrayOfString(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfBoolean")) {
      *type = SOAP_TYPE_s0__ArrayOfBoolean;
      return soap_in_s0__ArrayOfBoolean(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfUnsignedShort")) {
      *type = SOAP_TYPE_s0__ArrayOfUnsignedShort;
      return soap_in_s0__ArrayOfUnsignedShort(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfDouble")) {
      *type = SOAP_TYPE_s0__ArrayOfDouble;
      return soap_in_s0__ArrayOfDouble(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfUnsignedLong")) {
      *type = SOAP_TYPE_s0__ArrayOfUnsignedLong;
      return soap_in_s0__ArrayOfUnsignedLong(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfLong")) {
      *type = SOAP_TYPE_s0__ArrayOfLong;
      return soap_in_s0__ArrayOfLong(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfUnsignedInt")) {
      *type = SOAP_TYPE_s0__ArrayOfUnsignedInt;
      return soap_in_s0__ArrayOfUnsignedInt(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfInt")) {
      *type = SOAP_TYPE_s0__ArrayOfInt;
      return soap_in_s0__ArrayOfInt(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ArrayOfFloat")) {
      *type = SOAP_TYPE_s0__ArrayOfFloat;
      return soap_in_s0__ArrayOfFloat(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:OPCError")) {
      *type = SOAP_TYPE_s0__OPCError;
      return soap_in_s0__OPCError(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:OPCQuality")) {
      *type = SOAP_TYPE_s0__OPCQuality;
      return soap_in_s0__OPCQuality(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:Value")) {
      *type = SOAP_TYPE_s0__Value;
      return soap_in_s0__Value(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ItemValue")) {
      *type = SOAP_TYPE_s0__ItemValue;
      return soap_in_s0__ItemValue(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ReplyItemList")) {
      *type = SOAP_TYPE_s0__ReplyItemList;
      return soap_in_s0__ReplyItemList(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ReadRequestItem")) {
      *type = SOAP_TYPE_s0__ReadRequestItem;
      return soap_in_s0__ReadRequestItem(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ReadRequestItemList")) {
      *type = SOAP_TYPE_s0__ReadRequestItemList;
      return soap_in_s0__ReadRequestItemList(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:RequestOptions")) {
      *type = SOAP_TYPE_s0__RequestOptions;
      return soap_in_s0__RequestOptions(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ServerStatus")) {
      *type = SOAP_TYPE_s0__ServerStatus;
      return soap_in_s0__ServerStatus(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ReplyBase")) {
      *type = SOAP_TYPE_s0__ReplyBase;
      return soap_in_s0__ReplyBase(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedShort")) {
      *type = SOAP_TYPE_xsd__unsignedShort;
      return soap_in_xsd__unsignedShort(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedLong")) {
      *type = SOAP_TYPE_xsd__unsignedLong;
      return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedInt")) {
      *type = SOAP_TYPE_xsd__unsignedInt;
      return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedByte")) {
      *type = SOAP_TYPE_xsd__unsignedByte;
      return soap_in_xsd__unsignedByte(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:string")) {
      *type = SOAP_TYPE_xsd__string;
      return soap_in_xsd__string(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:short")) {
      *type = SOAP_TYPE_xsd__short;
      return soap_in_xsd__short(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:long")) {
      *type = SOAP_TYPE_xsd__long;
      return soap_in_xsd__long(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:int")) {
      *type = SOAP_TYPE_xsd__int;
      return soap_in_xsd__int(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:float")) {
      *type = SOAP_TYPE_xsd__float;
      return soap_in_xsd__float(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:double")) {
      *type = SOAP_TYPE_xsd__double;
      return soap_in_xsd__double(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:decimal")) {
      *type = SOAP_TYPE_xsd__decimal_;
      return soap_in_xsd__decimal_(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:decimal")) {
      *type = SOAP_TYPE_xsd__decimal;
      return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:duration")) {
      *type = SOAP_TYPE_xsd__duration;
      return soap_in_xsd__duration(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:dateTime")) {
      *type = SOAP_TYPE_xsd__dateTime;
      return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:byte")) {
      *type = SOAP_TYPE_xsd__byte;
      return soap_in_xsd__byte(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:boolean")) {
      *type = SOAP_TYPE_xsd__boolean;
      return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:QName")) {
      *type = SOAP_TYPE_xsd__QName_;
      return soap_in_xsd__QName_(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:QName")) {
      *type = SOAP_TYPE_xsd__QName;
      return soap_in_xsd__QName(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:string")) {
      *type = SOAP_TYPE_std__string;
      return soap_in_std__string(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:anyType")) {
      *type = SOAP_TYPE_xsd__anyType;
      return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:string")) {
      char** s;
      *type = SOAP_TYPE_string;
      s = soap_in_string(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    t = soap->tag;
    if (!soap_match_tag(soap, t, "s0:GetPropertiesResponse")) {
      *type = SOAP_TYPE__s0__GetPropertiesResponse;
      return soap_in__s0__GetPropertiesResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:GetProperties")) {
      *type = SOAP_TYPE__s0__GetProperties;
      return soap_in__s0__GetProperties(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:BrowseResponse")) {
      *type = SOAP_TYPE__s0__BrowseResponse;
      return soap_in__s0__BrowseResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:Browse")) {
      *type = SOAP_TYPE__s0__Browse;
      return soap_in__s0__Browse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscriptionCancelResponse")) {
      *type = SOAP_TYPE__s0__SubscriptionCancelResponse;
      return soap_in__s0__SubscriptionCancelResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscriptionCancel")) {
      *type = SOAP_TYPE__s0__SubscriptionCancel;
      return soap_in__s0__SubscriptionCancel(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscriptionPolledRefreshResponse")) {
      *type = SOAP_TYPE__s0__SubscriptionPolledRefreshResponse;
      return soap_in__s0__SubscriptionPolledRefreshResponse(
          soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscriptionPolledRefresh")) {
      *type = SOAP_TYPE__s0__SubscriptionPolledRefresh;
      return soap_in__s0__SubscriptionPolledRefresh(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:SubscribeResponse")) {
      *type = SOAP_TYPE__s0__SubscribeResponse;
      return soap_in__s0__SubscribeResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:Subscribe")) {
      *type = SOAP_TYPE__s0__Subscribe;
      return soap_in__s0__Subscribe(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:WriteResponse")) {
      *type = SOAP_TYPE__s0__WriteResponse;
      return soap_in__s0__WriteResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:Write")) {
      *type = SOAP_TYPE__s0__Write;
      return soap_in__s0__Write(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:ReadResponse")) {
      *type = SOAP_TYPE__s0__ReadResponse;
      return soap_in__s0__ReadResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:Read")) {
      *type = SOAP_TYPE__s0__Read;
      return soap_in__s0__Read(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:GetStatusResponse")) {
      *type = SOAP_TYPE__s0__GetStatusResponse;
      return soap_in__s0__GetStatusResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "s0:GetStatus")) {
      *type = SOAP_TYPE__s0__GetStatus;
      return soap_in__s0__GetStatus(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:QName")) {
      char** s;
      *type = SOAP_TYPE__QName;
      s = soap_in__QName(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
  }
  }
  soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap* soap)
{
  if (!soap_peek_element(soap)) {
    int t;
    if (soap->mustUnderstand && !soap->other)
      return soap->error = SOAP_MUSTUNDERSTAND;
    if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER)
        || !soap_match_tag(soap, soap->tag, "SOAP-ENV:")) {
      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
      return soap->error = SOAP_TAG_MISMATCH;
    }
    if (!*soap->id || !soap_getelement(soap, &t)) {
      soap->peeked = 0;
      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n",
                       soap->tag, soap->level, soap->body));
      if (soap->fignore)
        soap->error = soap->fignore(soap, soap->tag);
      else
        soap->error = SOAP_OK;
      DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(
                       fdebug, "IGNORING element '%s'\n", soap->tag));
      if (!soap->error && soap->body) {
        soap->level++;
        while (!soap_ignore_element(soap))
          ;
        if (soap->error == SOAP_NO_TAG)
          soap->error = soap_element_end_in(soap, NULL);
      }
    }
  }
  return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap* soap)
{
  int i;
  struct soap_plist* pp;
  if (soap->version == 1 && soap->encodingStyle
      && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
    for (i = 0; i < SOAP_PTRHASH; i++)
      for (pp = soap->pht[i]; pp; pp = pp->next)
        if (pp->mark1 == 2 || pp->mark2 == 2)
          if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
            return soap->error;
  return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(
    struct soap* soap, const void* ptr, const char* tag, int id, int type)
{
  switch (type) {
  case SOAP_TYPE_byte:
    return soap_out_byte(soap, tag, id, (const char*)ptr, "xsd:byte");
  case SOAP_TYPE_short:
    return soap_out_short(soap, tag, id, (const short*)ptr, "xsd:short");
  case SOAP_TYPE_int:
    return soap_out_int(soap, tag, id, (const int*)ptr, "xsd:int");
  case SOAP_TYPE_LONG64:
    return soap_out_LONG64(soap, tag, id, (const LONG64*)ptr, "xsd:long");
  case SOAP_TYPE_float:
    return soap_out_float(soap, tag, id, (const float*)ptr, "xsd:float");
  case SOAP_TYPE_double:
    return soap_out_double(soap, tag, id, (const double*)ptr, "xsd:double");
  case SOAP_TYPE_unsignedByte:
    return soap_out_unsignedByte(
        soap, tag, id, (const unsigned char*)ptr, "xsd:unsignedByte");
  case SOAP_TYPE_unsignedShort:
    return soap_out_unsignedShort(
        soap, tag, id, (const unsigned short*)ptr, "xsd:unsignedShort");
  case SOAP_TYPE_unsignedInt:
    return soap_out_unsignedInt(
        soap, tag, id, (const unsigned int*)ptr, "xsd:unsignedInt");
  case SOAP_TYPE_unsignedLONG64:
    return soap_out_unsignedLONG64(
        soap, tag, id, (const ULONG64*)ptr, "xsd:unsignedLong");
  case SOAP_TYPE_s0__browseFilter:
    return soap_out_s0__browseFilter(
        soap, tag, id, (const enum s0__browseFilter*)ptr, "s0:browseFilter");
  case SOAP_TYPE_s0__limitBits:
    return soap_out_s0__limitBits(
        soap, tag, id, (const enum s0__limitBits*)ptr, "s0:limitBits");
  case SOAP_TYPE_s0__qualityBits:
    return soap_out_s0__qualityBits(
        soap, tag, id, (const enum s0__qualityBits*)ptr, "s0:qualityBits");
  case SOAP_TYPE_s0__interfaceVersion:
    return soap_out_s0__interfaceVersion(soap, tag, id,
        (const enum s0__interfaceVersion*)ptr, "s0:interfaceVersion");
  case SOAP_TYPE_s0__serverState:
    return soap_out_s0__serverState(
        soap, tag, id, (const enum s0__serverState*)ptr, "s0:serverState");
  case SOAP_TYPE_bool:
    return soap_out_bool(soap, tag, id, (const bool*)ptr, "xsd:boolean");
  case SOAP_TYPE_s0__browseFilter_:
    return ((s0__browseFilter_*)ptr)
        ->soap_out(soap, tag, id, "s0:browseFilter");
  case SOAP_TYPE_s0__limitBits_:
    return ((s0__limitBits_*)ptr)->soap_out(soap, tag, id, "s0:limitBits");
  case SOAP_TYPE_s0__qualityBits_:
    return ((s0__qualityBits_*)ptr)->soap_out(soap, tag, id, "s0:qualityBits");
  case SOAP_TYPE_s0__interfaceVersion_:
    return ((s0__interfaceVersion_*)ptr)
        ->soap_out(soap, tag, id, "s0:interfaceVersion");
  case SOAP_TYPE_s0__serverState_:
    return ((s0__serverState_*)ptr)->soap_out(soap, tag, id, "s0:serverState");
  case SOAP_TYPE__s0__GetPropertiesResponse:
    return ((_s0__GetPropertiesResponse*)ptr)
        ->soap_out(soap, "s0:GetPropertiesResponse", id, NULL);
  case SOAP_TYPE__s0__GetProperties:
    return ((_s0__GetProperties*)ptr)
        ->soap_out(soap, "s0:GetProperties", id, NULL);
  case SOAP_TYPE__s0__BrowseResponse:
    return ((_s0__BrowseResponse*)ptr)
        ->soap_out(soap, "s0:BrowseResponse", id, NULL);
  case SOAP_TYPE__s0__Browse:
    return ((_s0__Browse*)ptr)->soap_out(soap, "s0:Browse", id, NULL);
  case SOAP_TYPE__s0__SubscriptionCancelResponse:
    return ((_s0__SubscriptionCancelResponse*)ptr)
        ->soap_out(soap, "s0:SubscriptionCancelResponse", id, NULL);
  case SOAP_TYPE__s0__SubscriptionCancel:
    return ((_s0__SubscriptionCancel*)ptr)
        ->soap_out(soap, "s0:SubscriptionCancel", id, NULL);
  case SOAP_TYPE__s0__SubscriptionPolledRefreshResponse:
    return ((_s0__SubscriptionPolledRefreshResponse*)ptr)
        ->soap_out(soap, "s0:SubscriptionPolledRefreshResponse", id, NULL);
  case SOAP_TYPE__s0__SubscriptionPolledRefresh:
    return ((_s0__SubscriptionPolledRefresh*)ptr)
        ->soap_out(soap, "s0:SubscriptionPolledRefresh", id, NULL);
  case SOAP_TYPE__s0__SubscribeResponse:
    return ((_s0__SubscribeResponse*)ptr)
        ->soap_out(soap, "s0:SubscribeResponse", id, NULL);
  case SOAP_TYPE__s0__Subscribe:
    return ((_s0__Subscribe*)ptr)->soap_out(soap, "s0:Subscribe", id, NULL);
  case SOAP_TYPE__s0__WriteResponse:
    return ((_s0__WriteResponse*)ptr)
        ->soap_out(soap, "s0:WriteResponse", id, NULL);
  case SOAP_TYPE__s0__Write:
    return ((_s0__Write*)ptr)->soap_out(soap, "s0:Write", id, NULL);
  case SOAP_TYPE__s0__ReadResponse:
    return ((_s0__ReadResponse*)ptr)
        ->soap_out(soap, "s0:ReadResponse", id, NULL);
  case SOAP_TYPE__s0__Read:
    return ((_s0__Read*)ptr)->soap_out(soap, "s0:Read", id, NULL);
  case SOAP_TYPE__s0__GetStatusResponse:
    return ((_s0__GetStatusResponse*)ptr)
        ->soap_out(soap, "s0:GetStatusResponse", id, NULL);
  case SOAP_TYPE__s0__GetStatus:
    return ((_s0__GetStatus*)ptr)->soap_out(soap, "s0:GetStatus", id, NULL);
  case SOAP_TYPE_s0__PropertyReplyList:
    return ((s0__PropertyReplyList*)ptr)
        ->soap_out(soap, tag, id, "s0:PropertyReplyList");
  case SOAP_TYPE_s0__ItemIdentifier:
    return ((s0__ItemIdentifier*)ptr)
        ->soap_out(soap, tag, id, "s0:ItemIdentifier");
  case SOAP_TYPE_s0__ItemProperty:
    return ((s0__ItemProperty*)ptr)->soap_out(soap, tag, id, "s0:ItemProperty");
  case SOAP_TYPE_s0__BrowseElement:
    return ((s0__BrowseElement*)ptr)
        ->soap_out(soap, tag, id, "s0:BrowseElement");
  case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
    return ((s0__SubscribePolledRefreshReplyItemList*)ptr)
        ->soap_out(soap, tag, id, "s0:SubscribePolledRefreshReplyItemList");
  case SOAP_TYPE_s0__SubscribeItemValue:
    return ((s0__SubscribeItemValue*)ptr)
        ->soap_out(soap, tag, id, "s0:SubscribeItemValue");
  case SOAP_TYPE_s0__SubscribeReplyItemList:
    return ((s0__SubscribeReplyItemList*)ptr)
        ->soap_out(soap, tag, id, "s0:SubscribeReplyItemList");
  case SOAP_TYPE_s0__SubscribeRequestItem:
    return ((s0__SubscribeRequestItem*)ptr)
        ->soap_out(soap, tag, id, "s0:SubscribeRequestItem");
  case SOAP_TYPE_s0__SubscribeRequestItemList:
    return ((s0__SubscribeRequestItemList*)ptr)
        ->soap_out(soap, tag, id, "s0:SubscribeRequestItemList");
  case SOAP_TYPE_s0__WriteRequestItemList:
    return ((s0__WriteRequestItemList*)ptr)
        ->soap_out(soap, tag, id, "s0:WriteRequestItemList");
  case SOAP_TYPE_s0__ArrayOfShort:
    return ((s0__ArrayOfShort*)ptr)->soap_out(soap, tag, id, "s0:ArrayOfShort");
  case SOAP_TYPE_s0__ArrayOfByte:
    return ((s0__ArrayOfByte*)ptr)->soap_out(soap, tag, id, "s0:ArrayOfByte");
  case SOAP_TYPE_s0__ArrayOfDecimal:
    return ((s0__ArrayOfDecimal*)ptr)
        ->soap_out(soap, tag, id, "s0:ArrayOfDecimal");
  case SOAP_TYPE_s0__ArrayOfAnyType:
    return ((s0__ArrayOfAnyType*)ptr)
        ->soap_out(soap, tag, id, "s0:ArrayOfAnyType");
  case SOAP_TYPE_s0__ArrayOfDateTime:
    return ((s0__ArrayOfDateTime*)ptr)
        ->soap_out(soap, tag, id, "s0:ArrayOfDateTime");
  case SOAP_TYPE_s0__ArrayOfString:
    return ((s0__ArrayOfString*)ptr)
        ->soap_out(soap, tag, id, "s0:ArrayOfString");
  case SOAP_TYPE_s0__ArrayOfBoolean:
    return ((s0__ArrayOfBoolean*)ptr)
        ->soap_out(soap, tag, id, "s0:ArrayOfBoolean");
  case SOAP_TYPE_s0__ArrayOfUnsignedShort:
    return ((s0__ArrayOfUnsignedShort*)ptr)
        ->soap_out(soap, tag, id, "s0:ArrayOfUnsignedShort");
  case SOAP_TYPE_s0__ArrayOfDouble:
    return ((s0__ArrayOfDouble*)ptr)
        ->soap_out(soap, tag, id, "s0:ArrayOfDouble");
  case SOAP_TYPE_s0__ArrayOfUnsignedLong:
    return ((s0__ArrayOfUnsignedLong*)ptr)
        ->soap_out(soap, tag, id, "s0:ArrayOfUnsignedLong");
  case SOAP_TYPE_s0__ArrayOfLong:
    return ((s0__ArrayOfLong*)ptr)->soap_out(soap, tag, id, "s0:ArrayOfLong");
  case SOAP_TYPE_s0__ArrayOfUnsignedInt:
    return ((s0__ArrayOfUnsignedInt*)ptr)
        ->soap_out(soap, tag, id, "s0:ArrayOfUnsignedInt");
  case SOAP_TYPE_s0__ArrayOfInt:
    return ((s0__ArrayOfInt*)ptr)->soap_out(soap, tag, id, "s0:ArrayOfInt");
  case SOAP_TYPE_s0__ArrayOfFloat:
    return ((s0__ArrayOfFloat*)ptr)->soap_out(soap, tag, id, "s0:ArrayOfFloat");
  case SOAP_TYPE_s0__OPCError:
    return ((s0__OPCError*)ptr)->soap_out(soap, tag, id, "s0:OPCError");
  case SOAP_TYPE_s0__OPCQuality:
    return ((s0__OPCQuality*)ptr)->soap_out(soap, tag, id, "s0:OPCQuality");
  case SOAP_TYPE_s0__Value:
    return ((s0__Value*)ptr)->soap_out(soap, tag, id, "s0:Value");
  case SOAP_TYPE_s0__ItemValue:
    return ((s0__ItemValue*)ptr)->soap_out(soap, tag, id, "s0:ItemValue");
  case SOAP_TYPE_s0__ReplyItemList:
    return ((s0__ReplyItemList*)ptr)
        ->soap_out(soap, tag, id, "s0:ReplyItemList");
  case SOAP_TYPE_s0__ReadRequestItem:
    return ((s0__ReadRequestItem*)ptr)
        ->soap_out(soap, tag, id, "s0:ReadRequestItem");
  case SOAP_TYPE_s0__ReadRequestItemList:
    return ((s0__ReadRequestItemList*)ptr)
        ->soap_out(soap, tag, id, "s0:ReadRequestItemList");
  case SOAP_TYPE_s0__RequestOptions:
    return ((s0__RequestOptions*)ptr)
        ->soap_out(soap, tag, id, "s0:RequestOptions");
  case SOAP_TYPE_s0__ServerStatus:
    return ((s0__ServerStatus*)ptr)->soap_out(soap, tag, id, "s0:ServerStatus");
  case SOAP_TYPE_s0__ReplyBase:
    return ((s0__ReplyBase*)ptr)->soap_out(soap, tag, id, "s0:ReplyBase");
  case SOAP_TYPE_xsd__unsignedShort:
    return ((xsd__unsignedShort*)ptr)
        ->soap_out(soap, tag, id, "xsd:unsignedShort");
  case SOAP_TYPE_xsd__unsignedLong:
    return ((xsd__unsignedLong*)ptr)
        ->soap_out(soap, tag, id, "xsd:unsignedLong");
  case SOAP_TYPE_xsd__unsignedInt:
    return ((xsd__unsignedInt*)ptr)->soap_out(soap, tag, id, "xsd:unsignedInt");
  case SOAP_TYPE_xsd__unsignedByte:
    return ((xsd__unsignedByte*)ptr)
        ->soap_out(soap, tag, id, "xsd:unsignedByte");
  case SOAP_TYPE_xsd__string:
    return ((xsd__string*)ptr)->soap_out(soap, tag, id, "xsd:string");
  case SOAP_TYPE_xsd__short:
    return ((xsd__short*)ptr)->soap_out(soap, tag, id, "xsd:short");
  case SOAP_TYPE_xsd__long:
    return ((xsd__long*)ptr)->soap_out(soap, tag, id, "xsd:long");
  case SOAP_TYPE_xsd__int:
    return ((xsd__int*)ptr)->soap_out(soap, tag, id, "xsd:int");
  case SOAP_TYPE_xsd__float:
    return ((xsd__float*)ptr)->soap_out(soap, tag, id, "xsd:float");
  case SOAP_TYPE_xsd__double:
    return ((xsd__double*)ptr)->soap_out(soap, tag, id, "xsd:double");
  case SOAP_TYPE_xsd__decimal_:
    return ((xsd__decimal_*)ptr)->soap_out(soap, tag, id, "xsd:decimal");
  case SOAP_TYPE_xsd__decimal:
    return soap_out_xsd__decimal(
        soap, tag, id, (const std::string*)ptr, "xsd:decimal");
  case SOAP_TYPE_xsd__duration:
    return ((xsd__duration*)ptr)->soap_out(soap, tag, id, "xsd:duration");
  case SOAP_TYPE_xsd__dateTime:
    return ((xsd__dateTime*)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
  case SOAP_TYPE_xsd__byte:
    return ((xsd__byte*)ptr)->soap_out(soap, tag, id, "xsd:byte");
  case SOAP_TYPE_xsd__boolean:
    return ((xsd__boolean*)ptr)->soap_out(soap, tag, id, "xsd:boolean");
  case SOAP_TYPE_xsd__QName_:
    return ((xsd__QName_*)ptr)->soap_out(soap, tag, id, "xsd:QName");
  case SOAP_TYPE_xsd__QName:
    return soap_out_xsd__QName(
        soap, tag, id, (const std::string*)ptr, "xsd:QName");
  case SOAP_TYPE_std__string:
    return soap_out_std__string(
        soap, tag, id, (const std::string*)ptr, "xsd:string");
  case SOAP_TYPE_xsd__anyType:
    return ((xsd__anyType*)ptr)->soap_out(soap, tag, id, "xsd:anyType");
  case SOAP_TYPE_PointerTo_s0__GetPropertiesResponse:
    return soap_out_PointerTo_s0__GetPropertiesResponse(soap, tag, id,
        (_s0__GetPropertiesResponse * const*)ptr, "s0:GetPropertiesResponse");
  case SOAP_TYPE_PointerTo_s0__GetProperties:
    return soap_out_PointerTo_s0__GetProperties(
        soap, tag, id, (_s0__GetProperties * const*)ptr, "s0:GetProperties");
  case SOAP_TYPE_PointerTo_s0__BrowseResponse:
    return soap_out_PointerTo_s0__BrowseResponse(
        soap, tag, id, (_s0__BrowseResponse * const*)ptr, "s0:BrowseResponse");
  case SOAP_TYPE_PointerTo_s0__Browse:
    return soap_out_PointerTo_s0__Browse(
        soap, tag, id, (_s0__Browse * const*)ptr, "s0:Browse");
  case SOAP_TYPE_PointerTo_s0__SubscriptionCancelResponse:
    return soap_out_PointerTo_s0__SubscriptionCancelResponse(soap, tag, id,
        (_s0__SubscriptionCancelResponse * const*)ptr,
        "s0:SubscriptionCancelResponse");
  case SOAP_TYPE_PointerTo_s0__SubscriptionCancel:
    return soap_out_PointerTo_s0__SubscriptionCancel(soap, tag, id,
        (_s0__SubscriptionCancel * const*)ptr, "s0:SubscriptionCancel");
  case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefreshResponse:
    return soap_out_PointerTo_s0__SubscriptionPolledRefreshResponse(soap, tag,
        id, (_s0__SubscriptionPolledRefreshResponse * const*)ptr,
        "s0:SubscriptionPolledRefreshResponse");
  case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefresh:
    return soap_out_PointerTo_s0__SubscriptionPolledRefresh(soap, tag, id,
        (_s0__SubscriptionPolledRefresh * const*)ptr,
        "s0:SubscriptionPolledRefresh");
  case SOAP_TYPE_PointerTo_s0__SubscribeResponse:
    return soap_out_PointerTo_s0__SubscribeResponse(soap, tag, id,
        (_s0__SubscribeResponse * const*)ptr, "s0:SubscribeResponse");
  case SOAP_TYPE_PointerTo_s0__Subscribe:
    return soap_out_PointerTo_s0__Subscribe(
        soap, tag, id, (_s0__Subscribe * const*)ptr, "s0:Subscribe");
  case SOAP_TYPE_PointerTo_s0__WriteResponse:
    return soap_out_PointerTo_s0__WriteResponse(
        soap, tag, id, (_s0__WriteResponse * const*)ptr, "s0:WriteResponse");
  case SOAP_TYPE_PointerTo_s0__Write:
    return soap_out_PointerTo_s0__Write(
        soap, tag, id, (_s0__Write * const*)ptr, "s0:Write");
  case SOAP_TYPE_PointerTo_s0__ReadResponse:
    return soap_out_PointerTo_s0__ReadResponse(
        soap, tag, id, (_s0__ReadResponse * const*)ptr, "s0:ReadResponse");
  case SOAP_TYPE_PointerTo_s0__Read:
    return soap_out_PointerTo_s0__Read(
        soap, tag, id, (_s0__Read * const*)ptr, "s0:Read");
  case SOAP_TYPE_PointerTo_s0__GetStatusResponse:
    return soap_out_PointerTo_s0__GetStatusResponse(soap, tag, id,
        (_s0__GetStatusResponse * const*)ptr, "s0:GetStatusResponse");
  case SOAP_TYPE_PointerTo_s0__GetStatus:
    return soap_out_PointerTo_s0__GetStatus(
        soap, tag, id, (_s0__GetStatus * const*)ptr, "s0:GetStatus");
  case SOAP_TYPE_PointerTos0__PropertyReplyList:
    return soap_out_PointerTos0__PropertyReplyList(soap, tag, id,
        (s0__PropertyReplyList * const*)ptr, "s0:PropertyReplyList");
  case SOAP_TYPE_PointerTos0__ItemIdentifier:
    return soap_out_PointerTos0__ItemIdentifier(
        soap, tag, id, (s0__ItemIdentifier * const*)ptr, "s0:ItemIdentifier");
  case SOAP_TYPE_PointerTos0__BrowseElement:
    return soap_out_PointerTos0__BrowseElement(
        soap, tag, id, (s0__BrowseElement * const*)ptr, "s0:BrowseElement");
  case SOAP_TYPE_PointerTos0__browseFilter:
    return soap_out_PointerTos0__browseFilter(
        soap, tag, id, (enum s0__browseFilter * const*)ptr, "s0:browseFilter");
  case SOAP_TYPE_PointerTos0__SubscribePolledRefreshReplyItemList:
    return soap_out_PointerTos0__SubscribePolledRefreshReplyItemList(soap, tag,
        id, (s0__SubscribePolledRefreshReplyItemList * const*)ptr,
        "s0:SubscribePolledRefreshReplyItemList");
  case SOAP_TYPE_PointerTos0__SubscribeReplyItemList:
    return soap_out_PointerTos0__SubscribeReplyItemList(soap, tag, id,
        (s0__SubscribeReplyItemList * const*)ptr, "s0:SubscribeReplyItemList");
  case SOAP_TYPE_PointerTos0__SubscribeRequestItemList:
    return soap_out_PointerTos0__SubscribeRequestItemList(soap, tag, id,
        (s0__SubscribeRequestItemList * const*)ptr,
        "s0:SubscribeRequestItemList");
  case SOAP_TYPE_PointerTos0__WriteRequestItemList:
    return soap_out_PointerTos0__WriteRequestItemList(soap, tag, id,
        (s0__WriteRequestItemList * const*)ptr, "s0:WriteRequestItemList");
  case SOAP_TYPE_PointerTos0__OPCError:
    return soap_out_PointerTos0__OPCError(
        soap, tag, id, (s0__OPCError * const*)ptr, "s0:OPCError");
  case SOAP_TYPE_PointerTos0__ReplyItemList:
    return soap_out_PointerTos0__ReplyItemList(
        soap, tag, id, (s0__ReplyItemList * const*)ptr, "s0:ReplyItemList");
  case SOAP_TYPE_PointerTos0__ReadRequestItemList:
    return soap_out_PointerTos0__ReadRequestItemList(soap, tag, id,
        (s0__ReadRequestItemList * const*)ptr, "s0:ReadRequestItemList");
  case SOAP_TYPE_PointerTos0__RequestOptions:
    return soap_out_PointerTos0__RequestOptions(
        soap, tag, id, (s0__RequestOptions * const*)ptr, "s0:RequestOptions");
  case SOAP_TYPE_PointerTos0__ServerStatus:
    return soap_out_PointerTos0__ServerStatus(
        soap, tag, id, (s0__ServerStatus * const*)ptr, "s0:ServerStatus");
  case SOAP_TYPE_PointerTos0__ReplyBase:
    return soap_out_PointerTos0__ReplyBase(
        soap, tag, id, (s0__ReplyBase * const*)ptr, "s0:ReplyBase");
  case SOAP_TYPE_PointerTos0__ItemProperty:
    return soap_out_PointerTos0__ItemProperty(
        soap, tag, id, (s0__ItemProperty * const*)ptr, "s0:ItemProperty");
  case SOAP_TYPE_PointerTos0__SubscribeItemValue:
    return soap_out_PointerTos0__SubscribeItemValue(soap, tag, id,
        (s0__SubscribeItemValue * const*)ptr, "s0:SubscribeItemValue");
  case SOAP_TYPE_PointerTofloat:
    return soap_out_PointerTofloat(
        soap, tag, id, (float* const*)ptr, "xsd:float");
  case SOAP_TYPE_PointerTos0__SubscribeRequestItem:
    return soap_out_PointerTos0__SubscribeRequestItem(soap, tag, id,
        (s0__SubscribeRequestItem * const*)ptr, "s0:SubscribeRequestItem");
  case SOAP_TYPE_PointerTounsignedShort:
    return soap_out_PointerTounsignedShort(
        soap, tag, id, (unsigned short* const*)ptr, "xsd:unsignedShort");
  case SOAP_TYPE_PointerTos0__limitBits:
    return soap_out_PointerTos0__limitBits(
        soap, tag, id, (enum s0__limitBits * const*)ptr, "s0:limitBits");
  case SOAP_TYPE_PointerTos0__qualityBits:
    return soap_out_PointerTos0__qualityBits(
        soap, tag, id, (enum s0__qualityBits * const*)ptr, "s0:qualityBits");
  case SOAP_TYPE_PointerTos0__OPCQuality:
    return soap_out_PointerTos0__OPCQuality(
        soap, tag, id, (s0__OPCQuality * const*)ptr, "s0:OPCQuality");
  case SOAP_TYPE_PointerToxsd__anyType:
    return soap_out_PointerToxsd__anyType(
        soap, tag, id, (xsd__anyType * const*)ptr, "xsd:anyType");
  case SOAP_TYPE_PointerTos0__ItemValue:
    return soap_out_PointerTos0__ItemValue(
        soap, tag, id, (s0__ItemValue * const*)ptr, "s0:ItemValue");
  case SOAP_TYPE_PointerToint:
    return soap_out_PointerToint(soap, tag, id, (int* const*)ptr, "xsd:int");
  case SOAP_TYPE_PointerToxsd__QName:
    return soap_out_PointerToxsd__QName(
        soap, tag, id, (std::string * const*)ptr, "xsd:QName");
  case SOAP_TYPE_PointerTos0__ReadRequestItem:
    return soap_out_PointerTos0__ReadRequestItem(
        soap, tag, id, (s0__ReadRequestItem * const*)ptr, "s0:ReadRequestItem");
  case SOAP_TYPE_PointerTobool:
    return soap_out_PointerTobool(
        soap, tag, id, (bool* const*)ptr, "xsd:boolean");
  case SOAP_TYPE_PointerTostd__string:
    return soap_out_PointerTostd__string(
        soap, tag, id, (std::string * const*)ptr, "xsd:string");
  case SOAP_TYPE__QName:
    return soap_out_string(soap, "xsd:QName", id, (char**)&ptr, NULL);
  case SOAP_TYPE_string:
    return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
  }
  return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(
    struct soap* soap, const void* ptr, int type)
{
  (void)soap;
  (void)ptr;
  (void)type; /* appease -Wall -Werror */
  switch (type) {
  case SOAP_TYPE_s0__browseFilter_:
    ((s0__browseFilter_*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__limitBits_:
    ((s0__limitBits_*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__qualityBits_:
    ((s0__qualityBits_*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__interfaceVersion_:
    ((s0__interfaceVersion_*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__serverState_:
    ((s0__serverState_*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__GetPropertiesResponse:
    ((_s0__GetPropertiesResponse*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__GetProperties:
    ((_s0__GetProperties*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__BrowseResponse:
    ((_s0__BrowseResponse*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__Browse:
    ((_s0__Browse*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__SubscriptionCancelResponse:
    ((_s0__SubscriptionCancelResponse*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__SubscriptionCancel:
    ((_s0__SubscriptionCancel*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__SubscriptionPolledRefreshResponse:
    ((_s0__SubscriptionPolledRefreshResponse*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__SubscriptionPolledRefresh:
    ((_s0__SubscriptionPolledRefresh*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__SubscribeResponse:
    ((_s0__SubscribeResponse*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__Subscribe:
    ((_s0__Subscribe*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__WriteResponse:
    ((_s0__WriteResponse*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__Write:
    ((_s0__Write*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__ReadResponse:
    ((_s0__ReadResponse*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__Read:
    ((_s0__Read*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__GetStatusResponse:
    ((_s0__GetStatusResponse*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE__s0__GetStatus:
    ((_s0__GetStatus*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__PropertyReplyList:
    ((s0__PropertyReplyList*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ItemIdentifier:
    ((s0__ItemIdentifier*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ItemProperty:
    ((s0__ItemProperty*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__BrowseElement:
    ((s0__BrowseElement*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
    ((s0__SubscribePolledRefreshReplyItemList*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__SubscribeItemValue:
    ((s0__SubscribeItemValue*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__SubscribeReplyItemList:
    ((s0__SubscribeReplyItemList*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__SubscribeRequestItem:
    ((s0__SubscribeRequestItem*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__SubscribeRequestItemList:
    ((s0__SubscribeRequestItemList*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__WriteRequestItemList:
    ((s0__WriteRequestItemList*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfShort:
    ((s0__ArrayOfShort*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfByte:
    ((s0__ArrayOfByte*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfDecimal:
    ((s0__ArrayOfDecimal*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfAnyType:
    ((s0__ArrayOfAnyType*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfDateTime:
    ((s0__ArrayOfDateTime*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfString:
    ((s0__ArrayOfString*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfBoolean:
    ((s0__ArrayOfBoolean*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfUnsignedShort:
    ((s0__ArrayOfUnsignedShort*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfDouble:
    ((s0__ArrayOfDouble*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfUnsignedLong:
    ((s0__ArrayOfUnsignedLong*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfLong:
    ((s0__ArrayOfLong*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfUnsignedInt:
    ((s0__ArrayOfUnsignedInt*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfInt:
    ((s0__ArrayOfInt*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ArrayOfFloat:
    ((s0__ArrayOfFloat*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__OPCError:
    ((s0__OPCError*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__OPCQuality:
    ((s0__OPCQuality*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__Value:
    ((s0__Value*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ItemValue:
    ((s0__ItemValue*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ReplyItemList:
    ((s0__ReplyItemList*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ReadRequestItem:
    ((s0__ReadRequestItem*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ReadRequestItemList:
    ((s0__ReadRequestItemList*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__RequestOptions:
    ((s0__RequestOptions*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ServerStatus:
    ((s0__ServerStatus*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_s0__ReplyBase:
    ((s0__ReplyBase*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__unsignedShort:
    ((xsd__unsignedShort*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__unsignedLong:
    ((xsd__unsignedLong*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__unsignedInt:
    ((xsd__unsignedInt*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__unsignedByte:
    ((xsd__unsignedByte*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__string:
    ((xsd__string*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__short:
    ((xsd__short*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__long:
    ((xsd__long*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__int:
    ((xsd__int*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__float:
    ((xsd__float*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__double:
    ((xsd__double*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__decimal_:
    ((xsd__decimal_*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__decimal:
    soap_serialize_xsd__decimal(soap, (const std::string*)ptr);
    break;
  case SOAP_TYPE_xsd__duration:
    ((xsd__duration*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__dateTime:
    ((xsd__dateTime*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__byte:
    ((xsd__byte*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__boolean:
    ((xsd__boolean*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__QName_:
    ((xsd__QName_*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE_xsd__QName:
    soap_serialize_xsd__QName(soap, (const std::string*)ptr);
    break;
  case SOAP_TYPE_std__string:
    soap_serialize_std__string(soap, (const std::string*)ptr);
    break;
  case SOAP_TYPE_xsd__anyType:
    ((xsd__anyType*)ptr)->soap_serialize(soap);
    break;
  case SOAP_TYPE___s0__GetProperties:
    soap_serialize___s0__GetProperties(
        soap, (const struct __s0__GetProperties*)ptr);
    break;
  case SOAP_TYPE___s0__Browse:
    soap_serialize___s0__Browse(soap, (const struct __s0__Browse*)ptr);
    break;
  case SOAP_TYPE___s0__SubscriptionCancel:
    soap_serialize___s0__SubscriptionCancel(
        soap, (const struct __s0__SubscriptionCancel*)ptr);
    break;
  case SOAP_TYPE___s0__SubscriptionPolledRefresh:
    soap_serialize___s0__SubscriptionPolledRefresh(
        soap, (const struct __s0__SubscriptionPolledRefresh*)ptr);
    break;
  case SOAP_TYPE___s0__Subscribe:
    soap_serialize___s0__Subscribe(soap, (const struct __s0__Subscribe*)ptr);
    break;
  case SOAP_TYPE___s0__Write:
    soap_serialize___s0__Write(soap, (const struct __s0__Write*)ptr);
    break;
  case SOAP_TYPE___s0__Read:
    soap_serialize___s0__Read(soap, (const struct __s0__Read*)ptr);
    break;
  case SOAP_TYPE___s0__GetStatus:
    soap_serialize___s0__GetStatus(soap, (const struct __s0__GetStatus*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__GetPropertiesResponse:
    soap_serialize_PointerTo_s0__GetPropertiesResponse(
        soap, (_s0__GetPropertiesResponse * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__GetProperties:
    soap_serialize_PointerTo_s0__GetProperties(
        soap, (_s0__GetProperties * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__BrowseResponse:
    soap_serialize_PointerTo_s0__BrowseResponse(
        soap, (_s0__BrowseResponse * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__Browse:
    soap_serialize_PointerTo_s0__Browse(soap, (_s0__Browse * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__SubscriptionCancelResponse:
    soap_serialize_PointerTo_s0__SubscriptionCancelResponse(
        soap, (_s0__SubscriptionCancelResponse * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__SubscriptionCancel:
    soap_serialize_PointerTo_s0__SubscriptionCancel(
        soap, (_s0__SubscriptionCancel * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefreshResponse:
    soap_serialize_PointerTo_s0__SubscriptionPolledRefreshResponse(
        soap, (_s0__SubscriptionPolledRefreshResponse * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefresh:
    soap_serialize_PointerTo_s0__SubscriptionPolledRefresh(
        soap, (_s0__SubscriptionPolledRefresh * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__SubscribeResponse:
    soap_serialize_PointerTo_s0__SubscribeResponse(
        soap, (_s0__SubscribeResponse * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__Subscribe:
    soap_serialize_PointerTo_s0__Subscribe(soap, (_s0__Subscribe * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__WriteResponse:
    soap_serialize_PointerTo_s0__WriteResponse(
        soap, (_s0__WriteResponse * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__Write:
    soap_serialize_PointerTo_s0__Write(soap, (_s0__Write * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__ReadResponse:
    soap_serialize_PointerTo_s0__ReadResponse(
        soap, (_s0__ReadResponse * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__Read:
    soap_serialize_PointerTo_s0__Read(soap, (_s0__Read * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__GetStatusResponse:
    soap_serialize_PointerTo_s0__GetStatusResponse(
        soap, (_s0__GetStatusResponse * const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_s0__GetStatus:
    soap_serialize_PointerTo_s0__GetStatus(soap, (_s0__GetStatus * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__PropertyReplyList:
    soap_serialize_PointerTos0__PropertyReplyList(
        soap, (s0__PropertyReplyList * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__ItemIdentifier:
    soap_serialize_PointerTos0__ItemIdentifier(
        soap, (s0__ItemIdentifier * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__BrowseElement:
    soap_serialize_PointerTos0__BrowseElement(
        soap, (s0__BrowseElement * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__browseFilter:
    soap_serialize_PointerTos0__browseFilter(
        soap, (enum s0__browseFilter * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__SubscribePolledRefreshReplyItemList:
    soap_serialize_PointerTos0__SubscribePolledRefreshReplyItemList(
        soap, (s0__SubscribePolledRefreshReplyItemList * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__SubscribeReplyItemList:
    soap_serialize_PointerTos0__SubscribeReplyItemList(
        soap, (s0__SubscribeReplyItemList * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__SubscribeRequestItemList:
    soap_serialize_PointerTos0__SubscribeRequestItemList(
        soap, (s0__SubscribeRequestItemList * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__WriteRequestItemList:
    soap_serialize_PointerTos0__WriteRequestItemList(
        soap, (s0__WriteRequestItemList * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__OPCError:
    soap_serialize_PointerTos0__OPCError(soap, (s0__OPCError * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__ReplyItemList:
    soap_serialize_PointerTos0__ReplyItemList(
        soap, (s0__ReplyItemList * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__ReadRequestItemList:
    soap_serialize_PointerTos0__ReadRequestItemList(
        soap, (s0__ReadRequestItemList * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__RequestOptions:
    soap_serialize_PointerTos0__RequestOptions(
        soap, (s0__RequestOptions * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__ServerStatus:
    soap_serialize_PointerTos0__ServerStatus(
        soap, (s0__ServerStatus * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__ReplyBase:
    soap_serialize_PointerTos0__ReplyBase(soap, (s0__ReplyBase * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__ItemProperty:
    soap_serialize_PointerTos0__ItemProperty(
        soap, (s0__ItemProperty * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__SubscribeItemValue:
    soap_serialize_PointerTos0__SubscribeItemValue(
        soap, (s0__SubscribeItemValue * const*)ptr);
    break;
  case SOAP_TYPE_PointerTofloat:
    soap_serialize_PointerTofloat(soap, (float* const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__SubscribeRequestItem:
    soap_serialize_PointerTos0__SubscribeRequestItem(
        soap, (s0__SubscribeRequestItem * const*)ptr);
    break;
  case SOAP_TYPE_PointerTounsignedShort:
    soap_serialize_PointerTounsignedShort(soap, (unsigned short* const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__limitBits:
    soap_serialize_PointerTos0__limitBits(
        soap, (enum s0__limitBits * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__qualityBits:
    soap_serialize_PointerTos0__qualityBits(
        soap, (enum s0__qualityBits * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__OPCQuality:
    soap_serialize_PointerTos0__OPCQuality(soap, (s0__OPCQuality * const*)ptr);
    break;
  case SOAP_TYPE_PointerToxsd__anyType:
    soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__ItemValue:
    soap_serialize_PointerTos0__ItemValue(soap, (s0__ItemValue * const*)ptr);
    break;
  case SOAP_TYPE_PointerToint:
    soap_serialize_PointerToint(soap, (int* const*)ptr);
    break;
  case SOAP_TYPE_PointerToxsd__QName:
    soap_serialize_PointerToxsd__QName(soap, (std::string * const*)ptr);
    break;
  case SOAP_TYPE_PointerTos0__ReadRequestItem:
    soap_serialize_PointerTos0__ReadRequestItem(
        soap, (s0__ReadRequestItem * const*)ptr);
    break;
  case SOAP_TYPE_PointerTobool:
    soap_serialize_PointerTobool(soap, (bool* const*)ptr);
    break;
  case SOAP_TYPE_PointerTostd__string:
    soap_serialize_PointerTostd__string(soap, (std::string * const*)ptr);
    break;
  case SOAP_TYPE__QName:
    soap_serialize_string(soap, (char**)&ptr);
    break;
  case SOAP_TYPE_string:
    soap_serialize_string(soap, (char**)&ptr);
    break;
  }
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void* SOAP_FMAC4 soap_instantiate(struct soap* soap, int t,
    const char* type, const char* arrayType, size_t* n)
{
  switch (t) {
  case SOAP_TYPE_xsd__anyType:
    return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__string:
    return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__QName_:
    return (void*)soap_instantiate_xsd__QName_(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__boolean:
    return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__byte:
    return (void*)soap_instantiate_xsd__byte(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__dateTime:
    return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__duration:
    return (void*)soap_instantiate_xsd__duration(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__decimal_:
    return (void*)soap_instantiate_xsd__decimal_(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__double:
    return (void*)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__float:
    return (void*)soap_instantiate_xsd__float(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__int:
    return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__long:
    return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__short:
    return (void*)soap_instantiate_xsd__short(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__string:
    return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__unsignedByte:
    return (void*)soap_instantiate_xsd__unsignedByte(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__unsignedInt:
    return (void*)soap_instantiate_xsd__unsignedInt(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__unsignedLong:
    return (void*)soap_instantiate_xsd__unsignedLong(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__unsignedShort:
    return (void*)soap_instantiate_xsd__unsignedShort(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__serverState_:
    return (void*)soap_instantiate_s0__serverState_(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__interfaceVersion_:
    return (void*)soap_instantiate_s0__interfaceVersion_(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__qualityBits_:
    return (void*)soap_instantiate_s0__qualityBits_(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__limitBits_:
    return (void*)soap_instantiate_s0__limitBits_(soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__browseFilter_:
    return (void*)soap_instantiate_s0__browseFilter_(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ReplyBase:
    return (void*)soap_instantiate_s0__ReplyBase(soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ServerStatus:
    return (void*)soap_instantiate_s0__ServerStatus(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__RequestOptions:
    return (void*)soap_instantiate_s0__RequestOptions(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ReadRequestItemList:
    return (void*)soap_instantiate_s0__ReadRequestItemList(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ReadRequestItem:
    return (void*)soap_instantiate_s0__ReadRequestItem(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ReplyItemList:
    return (void*)soap_instantiate_s0__ReplyItemList(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ItemValue:
    return (void*)soap_instantiate_s0__ItemValue(soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__Value:
    return (void*)soap_instantiate_s0__Value(soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__OPCQuality:
    return (void*)soap_instantiate_s0__OPCQuality(soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__OPCError:
    return (void*)soap_instantiate_s0__OPCError(soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfFloat:
    return (void*)soap_instantiate_s0__ArrayOfFloat(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfInt:
    return (void*)soap_instantiate_s0__ArrayOfInt(soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfUnsignedInt:
    return (void*)soap_instantiate_s0__ArrayOfUnsignedInt(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfLong:
    return (void*)soap_instantiate_s0__ArrayOfLong(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfUnsignedLong:
    return (void*)soap_instantiate_s0__ArrayOfUnsignedLong(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfDouble:
    return (void*)soap_instantiate_s0__ArrayOfDouble(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfUnsignedShort:
    return (void*)soap_instantiate_s0__ArrayOfUnsignedShort(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfBoolean:
    return (void*)soap_instantiate_s0__ArrayOfBoolean(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfString:
    return (void*)soap_instantiate_s0__ArrayOfString(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfDateTime:
    return (void*)soap_instantiate_s0__ArrayOfDateTime(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfAnyType:
    return (void*)soap_instantiate_s0__ArrayOfAnyType(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfDecimal:
    return (void*)soap_instantiate_s0__ArrayOfDecimal(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfByte:
    return (void*)soap_instantiate_s0__ArrayOfByte(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ArrayOfShort:
    return (void*)soap_instantiate_s0__ArrayOfShort(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__WriteRequestItemList:
    return (void*)soap_instantiate_s0__WriteRequestItemList(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__SubscribeRequestItemList:
    return (void*)soap_instantiate_s0__SubscribeRequestItemList(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__SubscribeRequestItem:
    return (void*)soap_instantiate_s0__SubscribeRequestItem(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__SubscribeReplyItemList:
    return (void*)soap_instantiate_s0__SubscribeReplyItemList(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__SubscribeItemValue:
    return (void*)soap_instantiate_s0__SubscribeItemValue(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
    return (void*)soap_instantiate_s0__SubscribePolledRefreshReplyItemList(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__BrowseElement:
    return (void*)soap_instantiate_s0__BrowseElement(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ItemProperty:
    return (void*)soap_instantiate_s0__ItemProperty(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__ItemIdentifier:
    return (void*)soap_instantiate_s0__ItemIdentifier(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_s0__PropertyReplyList:
    return (void*)soap_instantiate_s0__PropertyReplyList(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__GetStatus:
    return (void*)soap_instantiate__s0__GetStatus(soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__GetStatusResponse:
    return (void*)soap_instantiate__s0__GetStatusResponse(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__Read:
    return (void*)soap_instantiate__s0__Read(soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__ReadResponse:
    return (void*)soap_instantiate__s0__ReadResponse(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__Write:
    return (void*)soap_instantiate__s0__Write(soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__WriteResponse:
    return (void*)soap_instantiate__s0__WriteResponse(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__Subscribe:
    return (void*)soap_instantiate__s0__Subscribe(soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__SubscribeResponse:
    return (void*)soap_instantiate__s0__SubscribeResponse(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__SubscriptionPolledRefresh:
    return (void*)soap_instantiate__s0__SubscriptionPolledRefresh(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__SubscriptionPolledRefreshResponse:
    return (void*)soap_instantiate__s0__SubscriptionPolledRefreshResponse(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__SubscriptionCancel:
    return (void*)soap_instantiate__s0__SubscriptionCancel(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__SubscriptionCancelResponse:
    return (void*)soap_instantiate__s0__SubscriptionCancelResponse(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__Browse:
    return (void*)soap_instantiate__s0__Browse(soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__BrowseResponse:
    return (void*)soap_instantiate__s0__BrowseResponse(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__GetProperties:
    return (void*)soap_instantiate__s0__GetProperties(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE__s0__GetPropertiesResponse:
    return (void*)soap_instantiate__s0__GetPropertiesResponse(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE___s0__GetStatus:
    return (void*)soap_instantiate___s0__GetStatus(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE___s0__Read:
    return (void*)soap_instantiate___s0__Read(soap, -1, type, arrayType, n);
  case SOAP_TYPE___s0__Write:
    return (void*)soap_instantiate___s0__Write(soap, -1, type, arrayType, n);
  case SOAP_TYPE___s0__Subscribe:
    return (void*)soap_instantiate___s0__Subscribe(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE___s0__SubscriptionPolledRefresh:
    return (void*)soap_instantiate___s0__SubscriptionPolledRefresh(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE___s0__SubscriptionCancel:
    return (void*)soap_instantiate___s0__SubscriptionCancel(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE___s0__Browse:
    return (void*)soap_instantiate___s0__Browse(soap, -1, type, arrayType, n);
  case SOAP_TYPE___s0__GetProperties:
    return (void*)soap_instantiate___s0__GetProperties(
        soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Header:
    return (void*)soap_instantiate_SOAP_ENV__Header(
        soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Code:
    return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Detail:
    return (void*)soap_instantiate_SOAP_ENV__Detail(
        soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Reason:
    return (void*)soap_instantiate_SOAP_ENV__Reason(
        soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
  case SOAP_TYPE_SOAP_ENV__Fault:
    return (void*)soap_instantiate_SOAP_ENV__Fault(
        soap, -1, type, arrayType, n);
#endif
  case SOAP_TYPE_xsd__QName:
    return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
  case SOAP_TYPE_xsd__decimal:
    return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList:
    return (void*)
        soap_instantiate_std__vectorTemplateOfPointerTos0__PropertyReplyList(
            soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier:
    return (void*)
        soap_instantiate_std__vectorTemplateOfPointerTos0__ItemIdentifier(
            soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement:
    return (void*)
        soap_instantiate_std__vectorTemplateOfPointerTos0__BrowseElement(
            soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
    return (void*)soap_instantiate_std__vectorTemplateOfxsd__QName(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList:
    return (void*)
        soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
            soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError:
    return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__OPCError(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty:
    return (void*)
        soap_instantiate_std__vectorTemplateOfPointerTos0__ItemProperty(
            soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue:
    return (void*)
        soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
            soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem:
    return (void*)
        soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
            soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfshort:
    return (void*)soap_instantiate_std__vectorTemplateOfshort(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfbyte:
    return (void*)soap_instantiate_std__vectorTemplateOfbyte(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfxsd__decimal:
    return (void*)soap_instantiate_std__vectorTemplateOfxsd__decimal(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOf_XML:
    return (void*)soap_instantiate_std__vectorTemplateOf_XML(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfbool:
    return (void*)soap_instantiate_std__vectorTemplateOfbool(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfunsignedShort:
    return (void*)soap_instantiate_std__vectorTemplateOfunsignedShort(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfdouble:
    return (void*)soap_instantiate_std__vectorTemplateOfdouble(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfunsignedLONG64:
    return (void*)soap_instantiate_std__vectorTemplateOfunsignedLONG64(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfLONG64:
    return (void*)soap_instantiate_std__vectorTemplateOfLONG64(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
    return (void*)soap_instantiate_std__vectorTemplateOfunsignedInt(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfint:
    return (void*)soap_instantiate_std__vectorTemplateOfint(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOffloat:
    return (void*)soap_instantiate_std__vectorTemplateOffloat(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue:
    return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__ItemValue(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem:
    return (void*)
        soap_instantiate_std__vectorTemplateOfPointerTos0__ReadRequestItem(
            soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion:
    return (void*)soap_instantiate_std__vectorTemplateOfs0__interfaceVersion(
        soap, -1, type, arrayType, n);
  case SOAP_TYPE_std__vectorTemplateOfstd__string:
    return (void*)soap_instantiate_std__vectorTemplateOfstd__string(
        soap, -1, type, arrayType, n);
  }
  return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist* p)
{
  switch (p->type) {
  case SOAP_TYPE_xsd__anyType:
    if (p->size < 0)
      delete (xsd__anyType*)p->ptr;
    else
      delete[](xsd__anyType*) p->ptr;
    break;
  case SOAP_TYPE_std__string:
    if (p->size < 0)
      delete (std::string*)p->ptr;
    else
      delete[](std::string*) p->ptr;
    break;
  case SOAP_TYPE_xsd__QName_:
    if (p->size < 0)
      delete (xsd__QName_*)p->ptr;
    else
      delete[](xsd__QName_*) p->ptr;
    break;
  case SOAP_TYPE_xsd__boolean:
    if (p->size < 0)
      delete (xsd__boolean*)p->ptr;
    else
      delete[](xsd__boolean*) p->ptr;
    break;
  case SOAP_TYPE_xsd__byte:
    if (p->size < 0)
      delete (xsd__byte*)p->ptr;
    else
      delete[](xsd__byte*) p->ptr;
    break;
  case SOAP_TYPE_xsd__dateTime:
    if (p->size < 0)
      delete (xsd__dateTime*)p->ptr;
    else
      delete[](xsd__dateTime*) p->ptr;
    break;
  case SOAP_TYPE_xsd__duration:
    if (p->size < 0)
      delete (xsd__duration*)p->ptr;
    else
      delete[](xsd__duration*) p->ptr;
    break;
  case SOAP_TYPE_xsd__decimal_:
    if (p->size < 0)
      delete (xsd__decimal_*)p->ptr;
    else
      delete[](xsd__decimal_*) p->ptr;
    break;
  case SOAP_TYPE_xsd__double:
    if (p->size < 0)
      delete (xsd__double*)p->ptr;
    else
      delete[](xsd__double*) p->ptr;
    break;
  case SOAP_TYPE_xsd__float:
    if (p->size < 0)
      delete (xsd__float*)p->ptr;
    else
      delete[](xsd__float*) p->ptr;
    break;
  case SOAP_TYPE_xsd__int:
    if (p->size < 0)
      delete (xsd__int*)p->ptr;
    else
      delete[](xsd__int*) p->ptr;
    break;
  case SOAP_TYPE_xsd__long:
    if (p->size < 0)
      delete (xsd__long*)p->ptr;
    else
      delete[](xsd__long*) p->ptr;
    break;
  case SOAP_TYPE_xsd__short:
    if (p->size < 0)
      delete (xsd__short*)p->ptr;
    else
      delete[](xsd__short*) p->ptr;
    break;
  case SOAP_TYPE_xsd__string:
    if (p->size < 0)
      delete (xsd__string*)p->ptr;
    else
      delete[](xsd__string*) p->ptr;
    break;
  case SOAP_TYPE_xsd__unsignedByte:
    if (p->size < 0)
      delete (xsd__unsignedByte*)p->ptr;
    else
      delete[](xsd__unsignedByte*) p->ptr;
    break;
  case SOAP_TYPE_xsd__unsignedInt:
    if (p->size < 0)
      delete (xsd__unsignedInt*)p->ptr;
    else
      delete[](xsd__unsignedInt*) p->ptr;
    break;
  case SOAP_TYPE_xsd__unsignedLong:
    if (p->size < 0)
      delete (xsd__unsignedLong*)p->ptr;
    else
      delete[](xsd__unsignedLong*) p->ptr;
    break;
  case SOAP_TYPE_xsd__unsignedShort:
    if (p->size < 0)
      delete (xsd__unsignedShort*)p->ptr;
    else
      delete[](xsd__unsignedShort*) p->ptr;
    break;
  case SOAP_TYPE_s0__serverState_:
    if (p->size < 0)
      delete (s0__serverState_*)p->ptr;
    else
      delete[](s0__serverState_*) p->ptr;
    break;
  case SOAP_TYPE_s0__interfaceVersion_:
    if (p->size < 0)
      delete (s0__interfaceVersion_*)p->ptr;
    else
      delete[](s0__interfaceVersion_*) p->ptr;
    break;
  case SOAP_TYPE_s0__qualityBits_:
    if (p->size < 0)
      delete (s0__qualityBits_*)p->ptr;
    else
      delete[](s0__qualityBits_*) p->ptr;
    break;
  case SOAP_TYPE_s0__limitBits_:
    if (p->size < 0)
      delete (s0__limitBits_*)p->ptr;
    else
      delete[](s0__limitBits_*) p->ptr;
    break;
  case SOAP_TYPE_s0__browseFilter_:
    if (p->size < 0)
      delete (s0__browseFilter_*)p->ptr;
    else
      delete[](s0__browseFilter_*) p->ptr;
    break;
  case SOAP_TYPE_s0__ReplyBase:
    if (p->size < 0)
      delete (s0__ReplyBase*)p->ptr;
    else
      delete[](s0__ReplyBase*) p->ptr;
    break;
  case SOAP_TYPE_s0__ServerStatus:
    if (p->size < 0)
      delete (s0__ServerStatus*)p->ptr;
    else
      delete[](s0__ServerStatus*) p->ptr;
    break;
  case SOAP_TYPE_s0__RequestOptions:
    if (p->size < 0)
      delete (s0__RequestOptions*)p->ptr;
    else
      delete[](s0__RequestOptions*) p->ptr;
    break;
  case SOAP_TYPE_s0__ReadRequestItemList:
    if (p->size < 0)
      delete (s0__ReadRequestItemList*)p->ptr;
    else
      delete[](s0__ReadRequestItemList*) p->ptr;
    break;
  case SOAP_TYPE_s0__ReadRequestItem:
    if (p->size < 0)
      delete (s0__ReadRequestItem*)p->ptr;
    else
      delete[](s0__ReadRequestItem*) p->ptr;
    break;
  case SOAP_TYPE_s0__ReplyItemList:
    if (p->size < 0)
      delete (s0__ReplyItemList*)p->ptr;
    else
      delete[](s0__ReplyItemList*) p->ptr;
    break;
  case SOAP_TYPE_s0__ItemValue:
    if (p->size < 0)
      delete (s0__ItemValue*)p->ptr;
    else
      delete[](s0__ItemValue*) p->ptr;
    break;
  case SOAP_TYPE_s0__Value:
    if (p->size < 0)
      delete (s0__Value*)p->ptr;
    else
      delete[](s0__Value*) p->ptr;
    break;
  case SOAP_TYPE_s0__OPCQuality:
    if (p->size < 0)
      delete (s0__OPCQuality*)p->ptr;
    else
      delete[](s0__OPCQuality*) p->ptr;
    break;
  case SOAP_TYPE_s0__OPCError:
    if (p->size < 0)
      delete (s0__OPCError*)p->ptr;
    else
      delete[](s0__OPCError*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfFloat:
    if (p->size < 0)
      delete (s0__ArrayOfFloat*)p->ptr;
    else
      delete[](s0__ArrayOfFloat*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfInt:
    if (p->size < 0)
      delete (s0__ArrayOfInt*)p->ptr;
    else
      delete[](s0__ArrayOfInt*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfUnsignedInt:
    if (p->size < 0)
      delete (s0__ArrayOfUnsignedInt*)p->ptr;
    else
      delete[](s0__ArrayOfUnsignedInt*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfLong:
    if (p->size < 0)
      delete (s0__ArrayOfLong*)p->ptr;
    else
      delete[](s0__ArrayOfLong*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfUnsignedLong:
    if (p->size < 0)
      delete (s0__ArrayOfUnsignedLong*)p->ptr;
    else
      delete[](s0__ArrayOfUnsignedLong*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfDouble:
    if (p->size < 0)
      delete (s0__ArrayOfDouble*)p->ptr;
    else
      delete[](s0__ArrayOfDouble*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfUnsignedShort:
    if (p->size < 0)
      delete (s0__ArrayOfUnsignedShort*)p->ptr;
    else
      delete[](s0__ArrayOfUnsignedShort*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfBoolean:
    if (p->size < 0)
      delete (s0__ArrayOfBoolean*)p->ptr;
    else
      delete[](s0__ArrayOfBoolean*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfString:
    if (p->size < 0)
      delete (s0__ArrayOfString*)p->ptr;
    else
      delete[](s0__ArrayOfString*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfDateTime:
    if (p->size < 0)
      delete (s0__ArrayOfDateTime*)p->ptr;
    else
      delete[](s0__ArrayOfDateTime*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfAnyType:
    if (p->size < 0)
      delete (s0__ArrayOfAnyType*)p->ptr;
    else
      delete[](s0__ArrayOfAnyType*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfDecimal:
    if (p->size < 0)
      delete (s0__ArrayOfDecimal*)p->ptr;
    else
      delete[](s0__ArrayOfDecimal*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfByte:
    if (p->size < 0)
      delete (s0__ArrayOfByte*)p->ptr;
    else
      delete[](s0__ArrayOfByte*) p->ptr;
    break;
  case SOAP_TYPE_s0__ArrayOfShort:
    if (p->size < 0)
      delete (s0__ArrayOfShort*)p->ptr;
    else
      delete[](s0__ArrayOfShort*) p->ptr;
    break;
  case SOAP_TYPE_s0__WriteRequestItemList:
    if (p->size < 0)
      delete (s0__WriteRequestItemList*)p->ptr;
    else
      delete[](s0__WriteRequestItemList*) p->ptr;
    break;
  case SOAP_TYPE_s0__SubscribeRequestItemList:
    if (p->size < 0)
      delete (s0__SubscribeRequestItemList*)p->ptr;
    else
      delete[](s0__SubscribeRequestItemList*) p->ptr;
    break;
  case SOAP_TYPE_s0__SubscribeRequestItem:
    if (p->size < 0)
      delete (s0__SubscribeRequestItem*)p->ptr;
    else
      delete[](s0__SubscribeRequestItem*) p->ptr;
    break;
  case SOAP_TYPE_s0__SubscribeReplyItemList:
    if (p->size < 0)
      delete (s0__SubscribeReplyItemList*)p->ptr;
    else
      delete[](s0__SubscribeReplyItemList*) p->ptr;
    break;
  case SOAP_TYPE_s0__SubscribeItemValue:
    if (p->size < 0)
      delete (s0__SubscribeItemValue*)p->ptr;
    else
      delete[](s0__SubscribeItemValue*) p->ptr;
    break;
  case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
    if (p->size < 0)
      delete (s0__SubscribePolledRefreshReplyItemList*)p->ptr;
    else
      delete[](s0__SubscribePolledRefreshReplyItemList*) p->ptr;
    break;
  case SOAP_TYPE_s0__BrowseElement:
    if (p->size < 0)
      delete (s0__BrowseElement*)p->ptr;
    else
      delete[](s0__BrowseElement*) p->ptr;
    break;
  case SOAP_TYPE_s0__ItemProperty:
    if (p->size < 0)
      delete (s0__ItemProperty*)p->ptr;
    else
      delete[](s0__ItemProperty*) p->ptr;
    break;
  case SOAP_TYPE_s0__ItemIdentifier:
    if (p->size < 0)
      delete (s0__ItemIdentifier*)p->ptr;
    else
      delete[](s0__ItemIdentifier*) p->ptr;
    break;
  case SOAP_TYPE_s0__PropertyReplyList:
    if (p->size < 0)
      delete (s0__PropertyReplyList*)p->ptr;
    else
      delete[](s0__PropertyReplyList*) p->ptr;
    break;
  case SOAP_TYPE__s0__GetStatus:
    if (p->size < 0)
      delete (_s0__GetStatus*)p->ptr;
    else
      delete[](_s0__GetStatus*) p->ptr;
    break;
  case SOAP_TYPE__s0__GetStatusResponse:
    if (p->size < 0)
      delete (_s0__GetStatusResponse*)p->ptr;
    else
      delete[](_s0__GetStatusResponse*) p->ptr;
    break;
  case SOAP_TYPE__s0__Read:
    if (p->size < 0)
      delete (_s0__Read*)p->ptr;
    else
      delete[](_s0__Read*) p->ptr;
    break;
  case SOAP_TYPE__s0__ReadResponse:
    if (p->size < 0)
      delete (_s0__ReadResponse*)p->ptr;
    else
      delete[](_s0__ReadResponse*) p->ptr;
    break;
  case SOAP_TYPE__s0__Write:
    if (p->size < 0)
      delete (_s0__Write*)p->ptr;
    else
      delete[](_s0__Write*) p->ptr;
    break;
  case SOAP_TYPE__s0__WriteResponse:
    if (p->size < 0)
      delete (_s0__WriteResponse*)p->ptr;
    else
      delete[](_s0__WriteResponse*) p->ptr;
    break;
  case SOAP_TYPE__s0__Subscribe:
    if (p->size < 0)
      delete (_s0__Subscribe*)p->ptr;
    else
      delete[](_s0__Subscribe*) p->ptr;
    break;
  case SOAP_TYPE__s0__SubscribeResponse:
    if (p->size < 0)
      delete (_s0__SubscribeResponse*)p->ptr;
    else
      delete[](_s0__SubscribeResponse*) p->ptr;
    break;
  case SOAP_TYPE__s0__SubscriptionPolledRefresh:
    if (p->size < 0)
      delete (_s0__SubscriptionPolledRefresh*)p->ptr;
    else
      delete[](_s0__SubscriptionPolledRefresh*) p->ptr;
    break;
  case SOAP_TYPE__s0__SubscriptionPolledRefreshResponse:
    if (p->size < 0)
      delete (_s0__SubscriptionPolledRefreshResponse*)p->ptr;
    else
      delete[](_s0__SubscriptionPolledRefreshResponse*) p->ptr;
    break;
  case SOAP_TYPE__s0__SubscriptionCancel:
    if (p->size < 0)
      delete (_s0__SubscriptionCancel*)p->ptr;
    else
      delete[](_s0__SubscriptionCancel*) p->ptr;
    break;
  case SOAP_TYPE__s0__SubscriptionCancelResponse:
    if (p->size < 0)
      delete (_s0__SubscriptionCancelResponse*)p->ptr;
    else
      delete[](_s0__SubscriptionCancelResponse*) p->ptr;
    break;
  case SOAP_TYPE__s0__Browse:
    if (p->size < 0)
      delete (_s0__Browse*)p->ptr;
    else
      delete[](_s0__Browse*) p->ptr;
    break;
  case SOAP_TYPE__s0__BrowseResponse:
    if (p->size < 0)
      delete (_s0__BrowseResponse*)p->ptr;
    else
      delete[](_s0__BrowseResponse*) p->ptr;
    break;
  case SOAP_TYPE__s0__GetProperties:
    if (p->size < 0)
      delete (_s0__GetProperties*)p->ptr;
    else
      delete[](_s0__GetProperties*) p->ptr;
    break;
  case SOAP_TYPE__s0__GetPropertiesResponse:
    if (p->size < 0)
      delete (_s0__GetPropertiesResponse*)p->ptr;
    else
      delete[](_s0__GetPropertiesResponse*) p->ptr;
    break;
  case SOAP_TYPE___s0__GetStatus:
    if (p->size < 0)
      delete (struct __s0__GetStatus*)p->ptr;
    else
      delete[](struct __s0__GetStatus*) p->ptr;
    break;
  case SOAP_TYPE___s0__Read:
    if (p->size < 0)
      delete (struct __s0__Read*)p->ptr;
    else
      delete[](struct __s0__Read*) p->ptr;
    break;
  case SOAP_TYPE___s0__Write:
    if (p->size < 0)
      delete (struct __s0__Write*)p->ptr;
    else
      delete[](struct __s0__Write*) p->ptr;
    break;
  case SOAP_TYPE___s0__Subscribe:
    if (p->size < 0)
      delete (struct __s0__Subscribe*)p->ptr;
    else
      delete[](struct __s0__Subscribe*) p->ptr;
    break;
  case SOAP_TYPE___s0__SubscriptionPolledRefresh:
    if (p->size < 0)
      delete (struct __s0__SubscriptionPolledRefresh*)p->ptr;
    else
      delete[](struct __s0__SubscriptionPolledRefresh*) p->ptr;
    break;
  case SOAP_TYPE___s0__SubscriptionCancel:
    if (p->size < 0)
      delete (struct __s0__SubscriptionCancel*)p->ptr;
    else
      delete[](struct __s0__SubscriptionCancel*) p->ptr;
    break;
  case SOAP_TYPE___s0__Browse:
    if (p->size < 0)
      delete (struct __s0__Browse*)p->ptr;
    else
      delete[](struct __s0__Browse*) p->ptr;
    break;
  case SOAP_TYPE___s0__GetProperties:
    if (p->size < 0)
      delete (struct __s0__GetProperties*)p->ptr;
    else
      delete[](struct __s0__GetProperties*) p->ptr;
    break;
  case SOAP_TYPE_SOAP_ENV__Header:
    if (p->size < 0)
      delete (struct SOAP_ENV__Header*)p->ptr;
    else
      delete[](struct SOAP_ENV__Header*) p->ptr;
    break;
  case SOAP_TYPE_SOAP_ENV__Code:
    if (p->size < 0)
      delete (struct SOAP_ENV__Code*)p->ptr;
    else
      delete[](struct SOAP_ENV__Code*) p->ptr;
    break;
  case SOAP_TYPE_SOAP_ENV__Detail:
    if (p->size < 0)
      delete (struct SOAP_ENV__Detail*)p->ptr;
    else
      delete[](struct SOAP_ENV__Detail*) p->ptr;
    break;
  case SOAP_TYPE_SOAP_ENV__Reason:
    if (p->size < 0)
      delete (struct SOAP_ENV__Reason*)p->ptr;
    else
      delete[](struct SOAP_ENV__Reason*) p->ptr;
    break;
  case SOAP_TYPE_SOAP_ENV__Fault:
    if (p->size < 0)
      delete (struct SOAP_ENV__Fault*)p->ptr;
    else
      delete[](struct SOAP_ENV__Fault*) p->ptr;
    break;
  case SOAP_TYPE_xsd__QName:
    if (p->size < 0)
      delete (std::string*)p->ptr;
    else
      delete[](std::string*) p->ptr;
    break;
  case SOAP_TYPE_xsd__decimal:
    if (p->size < 0)
      delete (std::string*)p->ptr;
    else
      delete[](std::string*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList:
    if (p->size < 0)
      delete (std::vector<s0__PropertyReplyList*>*)p->ptr;
    else
      delete[](std::vector<s0__PropertyReplyList*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier:
    if (p->size < 0)
      delete (std::vector<s0__ItemIdentifier*>*)p->ptr;
    else
      delete[](std::vector<s0__ItemIdentifier*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement:
    if (p->size < 0)
      delete (std::vector<s0__BrowseElement*>*)p->ptr;
    else
      delete[](std::vector<s0__BrowseElement*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
    if (p->size < 0)
      delete (std::vector<std::string>*)p->ptr;
    else
      delete[](std::vector<std::string>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList:
    if (p->size < 0)
      delete (std::vector<s0__SubscribePolledRefreshReplyItemList*>*)p->ptr;
    else
      delete[](std::vector<s0__SubscribePolledRefreshReplyItemList*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError:
    if (p->size < 0)
      delete (std::vector<s0__OPCError*>*)p->ptr;
    else
      delete[](std::vector<s0__OPCError*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty:
    if (p->size < 0)
      delete (std::vector<s0__ItemProperty*>*)p->ptr;
    else
      delete[](std::vector<s0__ItemProperty*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue:
    if (p->size < 0)
      delete (std::vector<s0__SubscribeItemValue*>*)p->ptr;
    else
      delete[](std::vector<s0__SubscribeItemValue*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem:
    if (p->size < 0)
      delete (std::vector<s0__SubscribeRequestItem*>*)p->ptr;
    else
      delete[](std::vector<s0__SubscribeRequestItem*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfshort:
    if (p->size < 0)
      delete (std::vector<short>*)p->ptr;
    else
      delete[](std::vector<short>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfbyte:
    if (p->size < 0)
      delete (std::vector<char>*)p->ptr;
    else
      delete[](std::vector<char>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfxsd__decimal:
    if (p->size < 0)
      delete (std::vector<std::string>*)p->ptr;
    else
      delete[](std::vector<std::string>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOf_XML:
    if (p->size < 0)
      delete (std::vector<char*>*)p->ptr;
    else
      delete[](std::vector<char*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfbool:
    if (p->size < 0)
      delete (std::vector<bool>*)p->ptr;
    else
      delete[](std::vector<bool>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfunsignedShort:
    if (p->size < 0)
      delete (std::vector<unsigned short>*)p->ptr;
    else
      delete[](std::vector<unsigned short>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfdouble:
    if (p->size < 0)
      delete (std::vector<double>*)p->ptr;
    else
      delete[](std::vector<double>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfunsignedLONG64:
    if (p->size < 0)
      delete (std::vector<ULONG64>*)p->ptr;
    else
      delete[](std::vector<ULONG64>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfLONG64:
    if (p->size < 0)
      delete (std::vector<LONG64>*)p->ptr;
    else
      delete[](std::vector<LONG64>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
    if (p->size < 0)
      delete (std::vector<unsigned int>*)p->ptr;
    else
      delete[](std::vector<unsigned int>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfint:
    if (p->size < 0)
      delete (std::vector<int>*)p->ptr;
    else
      delete[](std::vector<int>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOffloat:
    if (p->size < 0)
      delete (std::vector<float>*)p->ptr;
    else
      delete[](std::vector<float>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue:
    if (p->size < 0)
      delete (std::vector<s0__ItemValue*>*)p->ptr;
    else
      delete[](std::vector<s0__ItemValue*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem:
    if (p->size < 0)
      delete (std::vector<s0__ReadRequestItem*>*)p->ptr;
    else
      delete[](std::vector<s0__ReadRequestItem*>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion:
    if (p->size < 0)
      delete (std::vector<enum s0__interfaceVersion>*)p->ptr;
    else
      delete[](std::vector<enum s0__interfaceVersion>*) p->ptr;
    break;
  case SOAP_TYPE_std__vectorTemplateOfstd__string:
    if (p->size < 0)
      delete (std::vector<std::string>*)p->ptr;
    else
      delete[](std::vector<std::string>*) p->ptr;
    break;
  default:
    return SOAP_ERR;
  }
  return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap* soap,
    const char* id, void* p, int t, size_t n, const char* type,
    const char* arrayType)
{
  return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap* soap,
    const char* href, void* p, size_t len, int st, int tt, size_t n,
    unsigned int k)
{
  return soap_id_forward(
      soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  switch (tt) {
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__PropertyReplyList*>*)p)[len]
        = *(s0__PropertyReplyList**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__ItemIdentifier*>*)p)[len] = *(s0__ItemIdentifier**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__BrowseElement*>*)p)[len] = *(s0__BrowseElement**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<std::string>*)p)[len] = *(std::string*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__SubscribePolledRefreshReplyItemList*>*)p)[len]
        = *(s0__SubscribePolledRefreshReplyItemList**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__OPCError*>*)p)[len] = *(s0__OPCError**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__ItemProperty*>*)p)[len] = *(s0__ItemProperty**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__SubscribeItemValue*>*)p)[len]
        = *(s0__SubscribeItemValue**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__SubscribeRequestItem*>*)p)[len]
        = *(s0__SubscribeRequestItem**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfshort:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<short>*)p)[len] = *(short*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfbyte:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<char>*)p)[len] = *(char*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfxsd__decimal:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<std::string>*)p)[len] = *(std::string*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOf_XML:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<char*>*)p)[len] = *(char**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfbool:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<bool>*)p)[len] = *(bool*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfunsignedShort:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<unsigned short>*)p)[len] = *(unsigned short*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfdouble:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<double>*)p)[len] = *(double*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfunsignedLONG64:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<ULONG64>*)p)[len] = *(ULONG64*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfLONG64:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<LONG64>*)p)[len] = *(LONG64*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<unsigned int>*)p)[len] = *(unsigned int*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfint:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<int>*)p)[len] = *(int*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOffloat:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<float>*)p)[len] = *(float*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__ItemValue*>*)p)[len] = *(s0__ItemValue**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<s0__ReadRequestItem*>*)p)[len] = *(s0__ReadRequestItem**)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<enum s0__interfaceVersion>*)p)[len]
        = *(enum s0__interfaceVersion*)q;
    break;
  case SOAP_TYPE_std__vectorTemplateOfstd__string:
    DBGLOG(TEST,
        SOAP_MESSAGE(fdebug,
            "Container insert type=%d in %d location=%p object=%p len=%lu\n",
            st, tt, p, q, (unsigned long)len));
    (*(std::vector<std::string>*)p)[len] = *(std::string*)q;
    break;
  default:
    DBGLOG(
        TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
  }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap* soap, char* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
  *a = SOAP_DEFAULT_byte;
#else
  *a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(
    struct soap* soap, const char* a, const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
  if (soap_out_byte(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(
    struct soap* soap, const char* tag, int id, const char* a, const char* type)
{
  return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char* SOAP_FMAC4 soap_get_byte(
    struct soap* soap, char* p, const char* tag, const char* type)
{
  if ((p = soap_in_byte(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 char* SOAP_FMAC4 soap_in_byte(
    struct soap* soap, const char* tag, char* a, const char* type)
{
  return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap* soap, short* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
  *a = SOAP_DEFAULT_short;
#else
  *a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(
    struct soap* soap, const short* a, const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
  if (soap_out_short(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap* soap, const char* tag,
    int id, const short* a, const char* type)
{
  return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short* SOAP_FMAC4 soap_get_short(
    struct soap* soap, short* p, const char* tag, const char* type)
{
  if ((p = soap_in_short(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 short* SOAP_FMAC4 soap_in_short(
    struct soap* soap, const char* tag, short* a, const char* type)
{
  return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap* soap, int* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
  *a = SOAP_DEFAULT_int;
#else
  *a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(
    struct soap* soap, const int* a, const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
  if (soap_out_int(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(
    struct soap* soap, const char* tag, int id, const int* a, const char* type)
{
  return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int* SOAP_FMAC4 soap_get_int(
    struct soap* soap, int* p, const char* tag, const char* type)
{
  if ((p = soap_in_int(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 int* SOAP_FMAC4 soap_in_int(
    struct soap* soap, const char* tag, int* a, const char* type)
{
  return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap* soap, LONG64* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
  *a = SOAP_DEFAULT_LONG64;
#else
  *a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(
    struct soap* soap, const LONG64* a, const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
  if (soap_out_LONG64(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap* soap, const char* tag,
    int id, const LONG64* a, const char* type)
{
  return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64* SOAP_FMAC4 soap_get_LONG64(
    struct soap* soap, LONG64* p, const char* tag, const char* type)
{
  if ((p = soap_in_LONG64(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 LONG64* SOAP_FMAC4 soap_in_LONG64(
    struct soap* soap, const char* tag, LONG64* a, const char* type)
{
  return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap* soap, float* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
  *a = SOAP_DEFAULT_float;
#else
  *a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(
    struct soap* soap, const float* a, const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
  if (soap_out_float(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap* soap, const char* tag,
    int id, const float* a, const char* type)
{
  return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float* SOAP_FMAC4 soap_get_float(
    struct soap* soap, float* p, const char* tag, const char* type)
{
  if ((p = soap_in_float(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 float* SOAP_FMAC4 soap_in_float(
    struct soap* soap, const char* tag, float* a, const char* type)
{
  return soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap* soap, double* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
  *a = SOAP_DEFAULT_double;
#else
  *a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(
    struct soap* soap, const double* a, const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
  if (soap_out_double(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap* soap, const char* tag,
    int id, const double* a, const char* type)
{
  return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double* SOAP_FMAC4 soap_get_double(
    struct soap* soap, double* p, const char* tag, const char* type)
{
  if ((p = soap_in_double(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 double* SOAP_FMAC4 soap_in_double(
    struct soap* soap, const char* tag, double* a, const char* type)
{
  return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(
    struct soap* soap, unsigned char* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
  *a = SOAP_DEFAULT_unsignedByte;
#else
  *a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap* soap,
    const unsigned char* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
  if (soap_out_unsignedByte(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap* soap,
    const char* tag, int id, const unsigned char* a, const char* type)
{
  return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char* SOAP_FMAC4 soap_get_unsignedByte(
    struct soap* soap, unsigned char* p, const char* tag, const char* type)
{
  if ((p = soap_in_unsignedByte(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 unsigned char* SOAP_FMAC4 soap_in_unsignedByte(
    struct soap* soap, const char* tag, unsigned char* a, const char* type)
{
  return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(
    struct soap* soap, unsigned short* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedShort
  *a = SOAP_DEFAULT_unsignedShort;
#else
  *a = (unsigned short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap* soap,
    const unsigned short* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
  if (soap_out_unsignedShort(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap* soap,
    const char* tag, int id, const unsigned short* a, const char* type)
{
  return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short* SOAP_FMAC4 soap_get_unsignedShort(
    struct soap* soap, unsigned short* p, const char* tag, const char* type)
{
  if ((p = soap_in_unsignedShort(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 unsigned short* SOAP_FMAC4 soap_in_unsignedShort(
    struct soap* soap, const char* tag, unsigned short* a, const char* type)
{
  return soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(
    struct soap* soap, unsigned int* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
  *a = SOAP_DEFAULT_unsignedInt;
#else
  *a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(
    struct soap* soap, const unsigned int* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
  if (soap_out_unsignedInt(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap* soap,
    const char* tag, int id, const unsigned int* a, const char* type)
{
  return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int* SOAP_FMAC4 soap_get_unsignedInt(
    struct soap* soap, unsigned int* p, const char* tag, const char* type)
{
  if ((p = soap_in_unsignedInt(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 unsigned int* SOAP_FMAC4 soap_in_unsignedInt(
    struct soap* soap, const char* tag, unsigned int* a, const char* type)
{
  return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(
    struct soap* soap, ULONG64* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
  *a = SOAP_DEFAULT_unsignedLONG64;
#else
  *a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(
    struct soap* soap, const ULONG64* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
  if (soap_out_unsignedLONG64(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap* soap,
    const char* tag, int id, const ULONG64* a, const char* type)
{
  return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64* SOAP_FMAC4 soap_get_unsignedLONG64(
    struct soap* soap, ULONG64* p, const char* tag, const char* type)
{
  if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 ULONG64* SOAP_FMAC4 soap_in_unsignedLONG64(
    struct soap* soap, const char* tag, ULONG64* a, const char* type)
{
  return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__browseFilter(
    struct soap* soap, enum s0__browseFilter* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__browseFilter
  *a = SOAP_DEFAULT_s0__browseFilter;
#else
  *a = (enum s0__browseFilter)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__browseFilter(struct soap* soap,
    const enum s0__browseFilter* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__browseFilter);
  if (soap_out_s0__browseFilter(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__browseFilter[]
    = { { (long)s0__browseFilter__all, "all" },
        { (long)s0__browseFilter__branch, "branch" },
        { (long)s0__browseFilter__item, "item" }, { 0, NULL } };

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__browseFilter2s(
    struct soap* soap, enum s0__browseFilter n)
{
  const char* s = soap_code_str(soap_codes_s0__browseFilter, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__browseFilter(struct soap* soap,
    const char* tag, int id, const enum s0__browseFilter* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__browseFilter), type);
  soap_send(soap, soap_s0__browseFilter2s(soap, *a));
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__browseFilter* SOAP_FMAC4 soap_get_s0__browseFilter(
    struct soap* soap, enum s0__browseFilter* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__browseFilter(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__browseFilter(
    struct soap* soap, const char* s, enum s0__browseFilter* a)
{
  const struct soap_code_map* map;
  if (!s)
    return SOAP_OK;
  map = soap_code(soap_codes_s0__browseFilter, s);
  if (map)
    *a = (enum s0__browseFilter)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n)
        || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
      return soap->error = SOAP_TYPE;
    *a = (enum s0__browseFilter)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum s0__browseFilter* SOAP_FMAC4 soap_in_s0__browseFilter(
    struct soap* soap, const char* tag, enum s0__browseFilter* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum s0__browseFilter*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__browseFilter, sizeof(enum s0__browseFilter), 0, NULL, NULL,
      NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2s0__browseFilter(soap, soap_value(soap), a)
        || soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (enum s0__browseFilter*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__browseFilter, 0, sizeof(enum s0__browseFilter), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__limitBits(
    struct soap* soap, enum s0__limitBits* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__limitBits
  *a = SOAP_DEFAULT_s0__limitBits;
#else
  *a = (enum s0__limitBits)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__limitBits(struct soap* soap,
    const enum s0__limitBits* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__limitBits);
  if (soap_out_s0__limitBits(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__limitBits[]
    = { { (long)s0__limitBits__none, "none" },
        { (long)s0__limitBits__low, "low" },
        { (long)s0__limitBits__high, "high" },
        { (long)s0__limitBits__constant, "constant" }, { 0, NULL } };

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__limitBits2s(
    struct soap* soap, enum s0__limitBits n)
{
  const char* s = soap_code_str(soap_codes_s0__limitBits, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__limitBits(struct soap* soap,
    const char* tag, int id, const enum s0__limitBits* a, const char* type)
{
  soap_element_begin_out(
      soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__limitBits), type);
  soap_send(soap, soap_s0__limitBits2s(soap, *a));
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__limitBits* SOAP_FMAC4 soap_get_s0__limitBits(
    struct soap* soap, enum s0__limitBits* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__limitBits(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__limitBits(
    struct soap* soap, const char* s, enum s0__limitBits* a)
{
  const struct soap_code_map* map;
  if (!s)
    return SOAP_OK;
  map = soap_code(soap_codes_s0__limitBits, s);
  if (map)
    *a = (enum s0__limitBits)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n)
        || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
      return soap->error = SOAP_TYPE;
    *a = (enum s0__limitBits)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum s0__limitBits* SOAP_FMAC4 soap_in_s0__limitBits(
    struct soap* soap, const char* tag, enum s0__limitBits* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum s0__limitBits*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__limitBits, sizeof(enum s0__limitBits), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2s0__limitBits(soap, soap_value(soap), a)
        || soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (enum s0__limitBits*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__limitBits, 0, sizeof(enum s0__limitBits), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__qualityBits(
    struct soap* soap, enum s0__qualityBits* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__qualityBits
  *a = SOAP_DEFAULT_s0__qualityBits;
#else
  *a = (enum s0__qualityBits)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__qualityBits(struct soap* soap,
    const enum s0__qualityBits* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__qualityBits);
  if (soap_out_s0__qualityBits(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__qualityBits[] = {
  { (long)s0__qualityBits__bad, "bad" },
  { (long)s0__qualityBits__badConfigurationError, "badConfigurationError" },
  { (long)s0__qualityBits__badNotConnected, "badNotConnected" },
  { (long)s0__qualityBits__badDeviceFailure, "badDeviceFailure" },
  { (long)s0__qualityBits__badSensorFailure, "badSensorFailure" },
  { (long)s0__qualityBits__badLastKnownValue, "badLastKnownValue" },
  { (long)s0__qualityBits__badCommFailure, "badCommFailure" },
  { (long)s0__qualityBits__badOutOfService, "badOutOfService" },
  { (long)s0__qualityBits__badWaitingForInitialData,
      "badWaitingForInitialData" },
  { (long)s0__qualityBits__uncertain, "uncertain" },
  { (long)s0__qualityBits__uncertainLastUsableValue,
      "uncertainLastUsableValue" },
  { (long)s0__qualityBits__uncertainSensorNotAccurate,
      "uncertainSensorNotAccurate" },
  { (long)s0__qualityBits__uncertainEUExceeded, "uncertainEUExceeded" },
  { (long)s0__qualityBits__uncertainSubNormal, "uncertainSubNormal" },
  { (long)s0__qualityBits__good, "good" },
  { (long)s0__qualityBits__goodLocalOverride, "goodLocalOverride" }, { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__qualityBits2s(
    struct soap* soap, enum s0__qualityBits n)
{
  const char* s = soap_code_str(soap_codes_s0__qualityBits, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__qualityBits(struct soap* soap,
    const char* tag, int id, const enum s0__qualityBits* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__qualityBits), type);
  soap_send(soap, soap_s0__qualityBits2s(soap, *a));
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__qualityBits* SOAP_FMAC4 soap_get_s0__qualityBits(
    struct soap* soap, enum s0__qualityBits* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__qualityBits(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__qualityBits(
    struct soap* soap, const char* s, enum s0__qualityBits* a)
{
  const struct soap_code_map* map;
  if (!s)
    return SOAP_OK;
  map = soap_code(soap_codes_s0__qualityBits, s);
  if (map)
    *a = (enum s0__qualityBits)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n)
        || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 15)))
      return soap->error = SOAP_TYPE;
    *a = (enum s0__qualityBits)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum s0__qualityBits* SOAP_FMAC4 soap_in_s0__qualityBits(
    struct soap* soap, const char* tag, enum s0__qualityBits* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum s0__qualityBits*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__qualityBits, sizeof(enum s0__qualityBits), 0, NULL, NULL,
      NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2s0__qualityBits(soap, soap_value(soap), a)
        || soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (enum s0__qualityBits*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__qualityBits, 0, sizeof(enum s0__qualityBits), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__interfaceVersion(
    struct soap* soap, enum s0__interfaceVersion* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__interfaceVersion
  *a = SOAP_DEFAULT_s0__interfaceVersion;
#else
  *a = (enum s0__interfaceVersion)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__interfaceVersion(struct soap* soap,
    const enum s0__interfaceVersion* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__interfaceVersion);
  if (soap_out_s0__interfaceVersion(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__interfaceVersion[] = {
  { (long)s0__interfaceVersion__XML_USCOREDA_USCOREVersion_USCORE1_USCORE0,
      "XML_DA_Version_1_0" },
  { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__interfaceVersion2s(
    struct soap* soap, enum s0__interfaceVersion n)
{
  const char* s = soap_code_str(soap_codes_s0__interfaceVersion, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__interfaceVersion(struct soap* soap,
    const char* tag, int id, const enum s0__interfaceVersion* a,
    const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__interfaceVersion), type);
  soap_send(soap, soap_s0__interfaceVersion2s(soap, *a));
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__interfaceVersion* SOAP_FMAC4 soap_get_s0__interfaceVersion(
    struct soap* soap, enum s0__interfaceVersion* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__interfaceVersion(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__interfaceVersion(
    struct soap* soap, const char* s, enum s0__interfaceVersion* a)
{
  const struct soap_code_map* map;
  if (!s)
    return SOAP_OK;
  map = soap_code(soap_codes_s0__interfaceVersion, s);
  if (map)
    *a = (enum s0__interfaceVersion)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n)
        || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
      return soap->error = SOAP_TYPE;
    *a = (enum s0__interfaceVersion)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum s0__interfaceVersion* SOAP_FMAC4 soap_in_s0__interfaceVersion(
    struct soap* soap, const char* tag, enum s0__interfaceVersion* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum s0__interfaceVersion*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__interfaceVersion, sizeof(enum s0__interfaceVersion), 0,
      NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2s0__interfaceVersion(soap, soap_value(soap), a)
        || soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (enum s0__interfaceVersion*)soap_id_forward(soap, soap->href, (void*)a,
        0, SOAP_TYPE_s0__interfaceVersion, 0, sizeof(enum s0__interfaceVersion),
        0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__serverState(
    struct soap* soap, enum s0__serverState* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__serverState
  *a = SOAP_DEFAULT_s0__serverState;
#else
  *a = (enum s0__serverState)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__serverState(struct soap* soap,
    const enum s0__serverState* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__serverState);
  if (soap_out_s0__serverState(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__serverState[]
    = { { (long)s0__serverState__running, "running" },
        { (long)s0__serverState__failed, "failed" },
        { (long)s0__serverState__noConfig, "noConfig" },
        { (long)s0__serverState__suspended, "suspended" },
        { (long)s0__serverState__test, "test" },
        { (long)s0__serverState__commFault, "commFault" }, { 0, NULL } };

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__serverState2s(
    struct soap* soap, enum s0__serverState n)
{
  const char* s = soap_code_str(soap_codes_s0__serverState, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__serverState(struct soap* soap,
    const char* tag, int id, const enum s0__serverState* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__serverState), type);
  soap_send(soap, soap_s0__serverState2s(soap, *a));
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__serverState* SOAP_FMAC4 soap_get_s0__serverState(
    struct soap* soap, enum s0__serverState* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__serverState(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__serverState(
    struct soap* soap, const char* s, enum s0__serverState* a)
{
  const struct soap_code_map* map;
  if (!s)
    return SOAP_OK;
  map = soap_code(soap_codes_s0__serverState, s);
  if (map)
    *a = (enum s0__serverState)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n)
        || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
      return soap->error = SOAP_TYPE;
    *a = (enum s0__serverState)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum s0__serverState* SOAP_FMAC4 soap_in_s0__serverState(
    struct soap* soap, const char* tag, enum s0__serverState* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum s0__serverState*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__serverState, sizeof(enum s0__serverState), 0, NULL, NULL,
      NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2s0__serverState(soap, soap_value(soap), a)
        || soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (enum s0__serverState*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__serverState, 0, sizeof(enum s0__serverState), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap* soap, bool* a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
  *a = SOAP_DEFAULT_bool;
#else
  *a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(
    struct soap* soap, const bool* a, const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
  if (soap_out_bool(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[]
    = { { (long)false, "false" }, { (long)true, "true" }, { 0, NULL } };

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap* soap, bool n)
{
  return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(
    struct soap* soap, const char* tag, int id, const bool* a, const char* type)
{
  soap_element_begin_out(
      soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
  soap_send(soap, soap_bool2s(soap, *a));
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool* SOAP_FMAC4 soap_get_bool(
    struct soap* soap, bool* p, const char* tag, const char* type)
{
  if ((p = soap_in_bool(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(
    struct soap* soap, const char* s, bool* a)
{
  const struct soap_code_map* map;
  if (!s)
    return SOAP_OK;
  map = soap_code(soap_codes_bool, s);
  if (map)
    *a = (bool)(map->code != 0);
  else {
    long n;
    if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
      return soap->error = SOAP_TYPE;
    *a = (bool)(n != 0);
  }
  return SOAP_OK;
}

SOAP_FMAC3 bool* SOAP_FMAC4 soap_in_bool(
    struct soap* soap, const char* tag, bool* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  if (*soap->type && soap_match_tag(soap, soap->type, type)
      && soap_match_tag(soap, soap->type, ":boolean")) {
    soap->error = SOAP_TYPE;
    return NULL;
  }
  a = (bool*)soap_id_enter(
      soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2bool(soap, soap_value(soap), a)
        || soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (bool*)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0,
        sizeof(bool), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

void s0__browseFilter_::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_s0__browseFilter(soap, &((s0__browseFilter_*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__browseFilter_::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(
      soap, &((s0__browseFilter_*)this)->__item, SOAP_TYPE_s0__browseFilter);
  /* transient soap skipped */
}

int s0__browseFilter_::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__browseFilter_);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__browseFilter_::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__browseFilter_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__browseFilter_(struct soap* soap,
    const char* tag, int id, const s0__browseFilter_* a, const char* type)
{
  return soap_out_s0__browseFilter(
      soap, tag, id, &(((s0__browseFilter_*)a)->__item), "s0:browseFilter");
}

void* s0__browseFilter_::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__browseFilter_(soap, this, tag, type);
}

SOAP_FMAC3 s0__browseFilter_* SOAP_FMAC4 soap_get_s0__browseFilter_(
    struct soap* soap, s0__browseFilter_* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__browseFilter_(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__browseFilter_::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__browseFilter_(soap, tag, this, type);
}

SOAP_FMAC3 s0__browseFilter_* SOAP_FMAC4 soap_in_s0__browseFilter_(
    struct soap* soap, const char* tag, s0__browseFilter_* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__browseFilter_*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__browseFilter_, sizeof(s0__browseFilter_), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__browseFilter_)
      return (s0__browseFilter_*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_s0__browseFilter(
          soap, tag, &(((s0__browseFilter_*)a)->__item), "s0:browseFilter"))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__browseFilter_* SOAP_FMAC6 soap_new_s0__browseFilter_(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__browseFilter_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__browseFilter_(
    struct soap* soap, s0__browseFilter_* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__browseFilter_* SOAP_FMAC4 soap_instantiate_s0__browseFilter_(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__browseFilter_(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__browseFilter_, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__browseFilter_;
    if (size)
      *size = sizeof(s0__browseFilter_);
    ((s0__browseFilter_*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__browseFilter_[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__browseFilter_);
    for (int i = 0; i < n; i++)
      ((s0__browseFilter_*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__browseFilter_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__browseFilter_(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__browseFilter_ %p -> %p\n", q, p));
  *(s0__browseFilter_*)p = *(s0__browseFilter_*)q;
}
#ifdef __cplusplus
}
#endif

void s0__limitBits_::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_s0__limitBits(soap, &((s0__limitBits_*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__limitBits_::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(
      soap, &((s0__limitBits_*)this)->__item, SOAP_TYPE_s0__limitBits);
  /* transient soap skipped */
}

int s0__limitBits_::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__limitBits_);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__limitBits_::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__limitBits_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__limitBits_(struct soap* soap,
    const char* tag, int id, const s0__limitBits_* a, const char* type)
{
  return soap_out_s0__limitBits(
      soap, tag, id, &(((s0__limitBits_*)a)->__item), "s0:limitBits");
}

void* s0__limitBits_::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__limitBits_(soap, this, tag, type);
}

SOAP_FMAC3 s0__limitBits_* SOAP_FMAC4 soap_get_s0__limitBits_(
    struct soap* soap, s0__limitBits_* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__limitBits_(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__limitBits_::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__limitBits_(soap, tag, this, type);
}

SOAP_FMAC3 s0__limitBits_* SOAP_FMAC4 soap_in_s0__limitBits_(
    struct soap* soap, const char* tag, s0__limitBits_* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__limitBits_*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__limitBits_, sizeof(s0__limitBits_), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__limitBits_)
      return (s0__limitBits_*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_s0__limitBits(
          soap, tag, &(((s0__limitBits_*)a)->__item), "s0:limitBits"))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__limitBits_* SOAP_FMAC6 soap_new_s0__limitBits_(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__limitBits_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__limitBits_(
    struct soap* soap, s0__limitBits_* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__limitBits_* SOAP_FMAC4 soap_instantiate_s0__limitBits_(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__limitBits_(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__limitBits_, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__limitBits_;
    if (size)
      *size = sizeof(s0__limitBits_);
    ((s0__limitBits_*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__limitBits_[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__limitBits_);
    for (int i = 0; i < n; i++)
      ((s0__limitBits_*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__limitBits_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__limitBits_(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__limitBits_ %p -> %p\n", q, p));
  *(s0__limitBits_*)p = *(s0__limitBits_*)q;
}
#ifdef __cplusplus
}
#endif

void s0__qualityBits_::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_s0__qualityBits(soap, &((s0__qualityBits_*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__qualityBits_::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(
      soap, &((s0__qualityBits_*)this)->__item, SOAP_TYPE_s0__qualityBits);
  /* transient soap skipped */
}

int s0__qualityBits_::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__qualityBits_);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__qualityBits_::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__qualityBits_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__qualityBits_(struct soap* soap,
    const char* tag, int id, const s0__qualityBits_* a, const char* type)
{
  return soap_out_s0__qualityBits(
      soap, tag, id, &(((s0__qualityBits_*)a)->__item), "s0:qualityBits");
}

void* s0__qualityBits_::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__qualityBits_(soap, this, tag, type);
}

SOAP_FMAC3 s0__qualityBits_* SOAP_FMAC4 soap_get_s0__qualityBits_(
    struct soap* soap, s0__qualityBits_* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__qualityBits_(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__qualityBits_::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__qualityBits_(soap, tag, this, type);
}

SOAP_FMAC3 s0__qualityBits_* SOAP_FMAC4 soap_in_s0__qualityBits_(
    struct soap* soap, const char* tag, s0__qualityBits_* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__qualityBits_*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__qualityBits_, sizeof(s0__qualityBits_), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__qualityBits_)
      return (s0__qualityBits_*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_s0__qualityBits(
          soap, tag, &(((s0__qualityBits_*)a)->__item), "s0:qualityBits"))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__qualityBits_* SOAP_FMAC6 soap_new_s0__qualityBits_(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__qualityBits_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__qualityBits_(
    struct soap* soap, s0__qualityBits_* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__qualityBits_* SOAP_FMAC4 soap_instantiate_s0__qualityBits_(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__qualityBits_(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__qualityBits_, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__qualityBits_;
    if (size)
      *size = sizeof(s0__qualityBits_);
    ((s0__qualityBits_*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__qualityBits_[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__qualityBits_);
    for (int i = 0; i < n; i++)
      ((s0__qualityBits_*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__qualityBits_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__qualityBits_(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__qualityBits_ %p -> %p\n", q, p));
  *(s0__qualityBits_*)p = *(s0__qualityBits_*)q;
}
#ifdef __cplusplus
}
#endif

void s0__interfaceVersion_::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_s0__interfaceVersion(
      soap, &((s0__interfaceVersion_*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__interfaceVersion_::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int s0__interfaceVersion_::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__interfaceVersion_);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__interfaceVersion_::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__interfaceVersion_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__interfaceVersion_(struct soap* soap,
    const char* tag, int id, const s0__interfaceVersion_* a, const char* type)
{
  return soap_out_s0__interfaceVersion(soap, tag, id,
      &(((s0__interfaceVersion_*)a)->__item), "s0:interfaceVersion");
}

void* s0__interfaceVersion_::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__interfaceVersion_(soap, this, tag, type);
}

SOAP_FMAC3 s0__interfaceVersion_* SOAP_FMAC4 soap_get_s0__interfaceVersion_(
    struct soap* soap, s0__interfaceVersion_* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__interfaceVersion_(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__interfaceVersion_::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__interfaceVersion_(soap, tag, this, type);
}

SOAP_FMAC3 s0__interfaceVersion_* SOAP_FMAC4 soap_in_s0__interfaceVersion_(
    struct soap* soap, const char* tag, s0__interfaceVersion_* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__interfaceVersion_*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__interfaceVersion_, sizeof(s0__interfaceVersion_),
            soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__interfaceVersion_)
      return (s0__interfaceVersion_*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_s0__interfaceVersion(soap, tag,
          &(((s0__interfaceVersion_*)a)->__item), "s0:interfaceVersion"))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__interfaceVersion_* SOAP_FMAC6 soap_new_s0__interfaceVersion_(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__interfaceVersion_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__interfaceVersion_(
    struct soap* soap, s0__interfaceVersion_* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__interfaceVersion_* SOAP_FMAC4
soap_instantiate_s0__interfaceVersion_(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__interfaceVersion_(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__interfaceVersion_, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__interfaceVersion_;
    if (size)
      *size = sizeof(s0__interfaceVersion_);
    ((s0__interfaceVersion_*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__interfaceVersion_[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__interfaceVersion_);
    for (int i = 0; i < n; i++)
      ((s0__interfaceVersion_*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__interfaceVersion_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__interfaceVersion_(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__interfaceVersion_ %p -> %p\n", q, p));
  *(s0__interfaceVersion_*)p = *(s0__interfaceVersion_*)q;
}
#ifdef __cplusplus
}
#endif

void s0__serverState_::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_s0__serverState(soap, &((s0__serverState_*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__serverState_::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int s0__serverState_::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__serverState_);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__serverState_::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__serverState_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__serverState_(struct soap* soap,
    const char* tag, int id, const s0__serverState_* a, const char* type)
{
  return soap_out_s0__serverState(
      soap, tag, id, &(((s0__serverState_*)a)->__item), "s0:serverState");
}

void* s0__serverState_::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__serverState_(soap, this, tag, type);
}

SOAP_FMAC3 s0__serverState_* SOAP_FMAC4 soap_get_s0__serverState_(
    struct soap* soap, s0__serverState_* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__serverState_(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__serverState_::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__serverState_(soap, tag, this, type);
}

SOAP_FMAC3 s0__serverState_* SOAP_FMAC4 soap_in_s0__serverState_(
    struct soap* soap, const char* tag, s0__serverState_* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__serverState_*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__serverState_, sizeof(s0__serverState_), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__serverState_)
      return (s0__serverState_*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_s0__serverState(
          soap, tag, &(((s0__serverState_*)a)->__item), "s0:serverState"))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__serverState_* SOAP_FMAC6 soap_new_s0__serverState_(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__serverState_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__serverState_(
    struct soap* soap, s0__serverState_* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__serverState_* SOAP_FMAC4 soap_instantiate_s0__serverState_(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__serverState_(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__serverState_, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__serverState_;
    if (size)
      *size = sizeof(s0__serverState_);
    ((s0__serverState_*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__serverState_[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__serverState_);
    for (int i = 0; i < n; i++)
      ((s0__serverState_*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__serverState_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__serverState_(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__serverState_ %p -> %p\n", q, p));
  *(s0__serverState_*)p = *(s0__serverState_*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__GetPropertiesResponse::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__GetPropertiesResponse*)this)->GetPropertiesResult = NULL;
  soap_default_std__vectorTemplateOfPointerTos0__PropertyReplyList(
      soap, &((_s0__GetPropertiesResponse*)this)->PropertyLists);
  soap_default_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__GetPropertiesResponse*)this)->Errors);
  /* transient soap skipped */
}

void _s0__GetPropertiesResponse::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__ReplyBase(
      soap, &((_s0__GetPropertiesResponse*)this)->GetPropertiesResult);
  soap_serialize_std__vectorTemplateOfPointerTos0__PropertyReplyList(
      soap, &((_s0__GetPropertiesResponse*)this)->PropertyLists);
  soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__GetPropertiesResponse*)this)->Errors);
  /* transient soap skipped */
}

int _s0__GetPropertiesResponse::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__GetPropertiesResponse);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__GetPropertiesResponse::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__GetPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__GetPropertiesResponse(struct soap* soap,
    const char* tag, int id, const _s0__GetPropertiesResponse* a,
    const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__GetPropertiesResponse),
      type);
  if (a->GetPropertiesResult)
    soap_element_result(soap, "s0:GetPropertiesResult");
  soap_out_PointerTos0__ReplyBase(soap, "s0:GetPropertiesResult", -1,
      &(((_s0__GetPropertiesResponse*)a)->GetPropertiesResult), "");
  soap_out_std__vectorTemplateOfPointerTos0__PropertyReplyList(soap,
      "s0:PropertyLists", -1,
      &(((_s0__GetPropertiesResponse*)a)->PropertyLists), "");
  soap_out_std__vectorTemplateOfPointerTos0__OPCError(
      soap, "s0:Errors", -1, &(((_s0__GetPropertiesResponse*)a)->Errors), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__GetPropertiesResponse::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__GetPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__GetPropertiesResponse* SOAP_FMAC4
soap_get__s0__GetPropertiesResponse(struct soap* soap,
    _s0__GetPropertiesResponse* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__GetPropertiesResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__GetPropertiesResponse::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__GetPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__GetPropertiesResponse* SOAP_FMAC4
soap_in__s0__GetPropertiesResponse(struct soap* soap, const char* tag,
    _s0__GetPropertiesResponse* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__GetPropertiesResponse*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__GetPropertiesResponse, sizeof(_s0__GetPropertiesResponse),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__GetPropertiesResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__GetPropertiesResponse*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag_GetPropertiesResult1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_GetPropertiesResult1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReplyBase(soap, "s0:GetPropertiesResult",
                &(((_s0__GetPropertiesResponse*)a)->GetPropertiesResult),
                "s0:ReplyBase")) {
          soap_flag_GetPropertiesResult1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__PropertyReplyList(soap,
                "s0:PropertyLists",
                &(((_s0__GetPropertiesResponse*)a)->PropertyLists),
                "s0:PropertyReplyList"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap,
                "s0:Errors", &(((_s0__GetPropertiesResponse*)a)->Errors),
                "s0:OPCError"))
          continue;
      /* transient soap skipped */
      soap_check_result(soap, "s0:GetPropertiesResult");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__GetPropertiesResponse*)soap_id_forward(soap, soap->href, (void*)a,
        0, SOAP_TYPE__s0__GetPropertiesResponse, 0,
        sizeof(_s0__GetPropertiesResponse), 0,
        soap_copy__s0__GetPropertiesResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__GetPropertiesResponse* SOAP_FMAC6
soap_new__s0__GetPropertiesResponse(struct soap* soap, int n)
{
  return soap_instantiate__s0__GetPropertiesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__GetPropertiesResponse(
    struct soap* soap, _s0__GetPropertiesResponse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__GetPropertiesResponse* SOAP_FMAC4
soap_instantiate__s0__GetPropertiesResponse(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate__s0__GetPropertiesResponse(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE__s0__GetPropertiesResponse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__GetPropertiesResponse;
    if (size)
      *size = sizeof(_s0__GetPropertiesResponse);
    ((_s0__GetPropertiesResponse*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__GetPropertiesResponse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__GetPropertiesResponse);
    for (int i = 0; i < n; i++)
      ((_s0__GetPropertiesResponse*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__GetPropertiesResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__GetPropertiesResponse(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying _s0__GetPropertiesResponse %p -> %p\n", q, p));
  *(_s0__GetPropertiesResponse*)p = *(_s0__GetPropertiesResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__GetProperties::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTos0__ItemIdentifier(
      soap, &((_s0__GetProperties*)this)->ItemIDs);
  soap_default_std__vectorTemplateOfxsd__QName(
      soap, &((_s0__GetProperties*)this)->PropertyNames);
  ((_s0__GetProperties*)this)->LocaleID = NULL;
  ((_s0__GetProperties*)this)->ClientRequestHandle = NULL;
  ((_s0__GetProperties*)this)->ItemPath = NULL;
  ((_s0__GetProperties*)this)->ReturnAllProperties = NULL;
  ((_s0__GetProperties*)this)->ReturnPropertyValues = NULL;
  ((_s0__GetProperties*)this)->ReturnErrorText = NULL;
  /* transient soap skipped */
}

void _s0__GetProperties::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTos0__ItemIdentifier(
      soap, &((_s0__GetProperties*)this)->ItemIDs);
  soap_serialize_std__vectorTemplateOfxsd__QName(
      soap, &((_s0__GetProperties*)this)->PropertyNames);
  /* transient soap skipped */
}

int _s0__GetProperties::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__GetProperties);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__GetProperties::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__GetProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__GetProperties(struct soap* soap,
    const char* tag, int id, const _s0__GetProperties* a, const char* type)
{
  if (((_s0__GetProperties*)a)->LocaleID)
    soap_set_attr(
        soap, "LocaleID", ((_s0__GetProperties*)a)->LocaleID->c_str());
  if (((_s0__GetProperties*)a)->ClientRequestHandle)
    soap_set_attr(soap, "ClientRequestHandle",
        ((_s0__GetProperties*)a)->ClientRequestHandle->c_str());
  if (((_s0__GetProperties*)a)->ItemPath)
    soap_set_attr(
        soap, "ItemPath", ((_s0__GetProperties*)a)->ItemPath->c_str());
  if (((_s0__GetProperties*)a)->ReturnAllProperties)
    soap_set_attr(soap, "ReturnAllProperties",
        soap_bool2s(soap, *((_s0__GetProperties*)a)->ReturnAllProperties));
  if (((_s0__GetProperties*)a)->ReturnPropertyValues)
    soap_set_attr(soap, "ReturnPropertyValues",
        soap_bool2s(soap, *((_s0__GetProperties*)a)->ReturnPropertyValues));
  if (((_s0__GetProperties*)a)->ReturnErrorText)
    soap_set_attr(soap, "ReturnErrorText",
        soap_bool2s(soap, *((_s0__GetProperties*)a)->ReturnErrorText));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__GetProperties), type);
  soap_out_std__vectorTemplateOfPointerTos0__ItemIdentifier(
      soap, "s0:ItemIDs", -1, &(((_s0__GetProperties*)a)->ItemIDs), "");
  soap_out_std__vectorTemplateOfxsd__QName(soap, "s0:PropertyNames", -1,
      &(((_s0__GetProperties*)a)->PropertyNames), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__GetProperties::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__GetProperties(soap, this, tag, type);
}

SOAP_FMAC3 _s0__GetProperties* SOAP_FMAC4 soap_get__s0__GetProperties(
    struct soap* soap, _s0__GetProperties* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__GetProperties(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__GetProperties::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__GetProperties(soap, tag, this, type);
}

SOAP_FMAC3 _s0__GetProperties* SOAP_FMAC4 soap_in__s0__GetProperties(
    struct soap* soap, const char* tag, _s0__GetProperties* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__GetProperties*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__GetProperties, sizeof(_s0__GetProperties), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__GetProperties) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__GetProperties*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "LocaleID", 0);
    if (t) {
      if (!(((_s0__GetProperties*)a)->LocaleID
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__GetProperties*)a)->LocaleID = soap_new_std__string(soap, -1);
        ((_s0__GetProperties*)a)->LocaleID->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientRequestHandle", 0);
    if (t) {
      if (!(((_s0__GetProperties*)a)->ClientRequestHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__GetProperties*)a)->ClientRequestHandle
            = soap_new_std__string(soap, -1);
        ((_s0__GetProperties*)a)->ClientRequestHandle->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((_s0__GetProperties*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__GetProperties*)a)->ItemPath = soap_new_std__string(soap, -1);
        ((_s0__GetProperties*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnAllProperties", 0);
    if (t) {
      if (!(((_s0__GetProperties*)a)->ReturnAllProperties
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((_s0__GetProperties*)a)->ReturnAllProperties))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnPropertyValues", 0);
    if (t) {
      if (!(((_s0__GetProperties*)a)->ReturnPropertyValues
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((_s0__GetProperties*)a)->ReturnPropertyValues))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnErrorText", 0);
    if (t) {
      if (!(((_s0__GetProperties*)a)->ReturnErrorText
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((_s0__GetProperties*)a)->ReturnErrorText))
        return NULL;
    }
  };
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__ItemIdentifier(soap,
                "s0:ItemIDs", &(((_s0__GetProperties*)a)->ItemIDs),
                "s0:ItemIdentifier"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfxsd__QName(soap, "s0:PropertyNames",
                &(((_s0__GetProperties*)a)->PropertyNames), "xsd:QName"))
          continue;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__GetProperties*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__GetProperties, 0, sizeof(_s0__GetProperties), 0,
        soap_copy__s0__GetProperties);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__GetProperties* SOAP_FMAC6 soap_new__s0__GetProperties(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__GetProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__GetProperties(
    struct soap* soap, _s0__GetProperties* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__GetProperties* SOAP_FMAC4 soap_instantiate__s0__GetProperties(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate__s0__GetProperties(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE__s0__GetProperties, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__GetProperties;
    if (size)
      *size = sizeof(_s0__GetProperties);
    ((_s0__GetProperties*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__GetProperties[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__GetProperties);
    for (int i = 0; i < n; i++)
      ((_s0__GetProperties*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__GetProperties*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__GetProperties(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying _s0__GetProperties %p -> %p\n", q, p));
  *(_s0__GetProperties*)p = *(_s0__GetProperties*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__BrowseResponse::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__BrowseResponse*)this)->BrowseResult = NULL;
  soap_default_std__vectorTemplateOfPointerTos0__BrowseElement(
      soap, &((_s0__BrowseResponse*)this)->Elements);
  soap_default_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__BrowseResponse*)this)->Errors);
  ((_s0__BrowseResponse*)this)->ContinuationPoint = NULL;
  ((_s0__BrowseResponse*)this)->MoreElements = NULL;
  /* transient soap skipped */
}

void _s0__BrowseResponse::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__ReplyBase(
      soap, &((_s0__BrowseResponse*)this)->BrowseResult);
  soap_serialize_std__vectorTemplateOfPointerTos0__BrowseElement(
      soap, &((_s0__BrowseResponse*)this)->Elements);
  soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__BrowseResponse*)this)->Errors);
  /* transient soap skipped */
}

int _s0__BrowseResponse::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__BrowseResponse);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__BrowseResponse::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__BrowseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__BrowseResponse(struct soap* soap,
    const char* tag, int id, const _s0__BrowseResponse* a, const char* type)
{
  if (((_s0__BrowseResponse*)a)->ContinuationPoint)
    soap_set_attr(soap, "ContinuationPoint",
        ((_s0__BrowseResponse*)a)->ContinuationPoint->c_str());
  if (((_s0__BrowseResponse*)a)->MoreElements)
    soap_set_attr(soap, "MoreElements",
        soap_bool2s(soap, *((_s0__BrowseResponse*)a)->MoreElements));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__BrowseResponse), type);
  if (a->BrowseResult)
    soap_element_result(soap, "s0:BrowseResult");
  soap_out_PointerTos0__ReplyBase(soap, "s0:BrowseResult", -1,
      &(((_s0__BrowseResponse*)a)->BrowseResult), "");
  soap_out_std__vectorTemplateOfPointerTos0__BrowseElement(
      soap, "s0:Elements", -1, &(((_s0__BrowseResponse*)a)->Elements), "");
  soap_out_std__vectorTemplateOfPointerTos0__OPCError(
      soap, "s0:Errors", -1, &(((_s0__BrowseResponse*)a)->Errors), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__BrowseResponse::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__BrowseResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__BrowseResponse* SOAP_FMAC4 soap_get__s0__BrowseResponse(
    struct soap* soap, _s0__BrowseResponse* p, const char* tag,
    const char* type)
{
  if ((p = soap_in__s0__BrowseResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__BrowseResponse::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__BrowseResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__BrowseResponse* SOAP_FMAC4 soap_in__s0__BrowseResponse(
    struct soap* soap, const char* tag, _s0__BrowseResponse* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__BrowseResponse*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__BrowseResponse, sizeof(_s0__BrowseResponse), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__BrowseResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__BrowseResponse*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ContinuationPoint", 0);
    if (t) {
      if (!(((_s0__BrowseResponse*)a)->ContinuationPoint
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__BrowseResponse*)a)->ContinuationPoint
            = soap_new_std__string(soap, -1);
        ((_s0__BrowseResponse*)a)->ContinuationPoint->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "MoreElements", 0);
    if (t) {
      if (!(((_s0__BrowseResponse*)a)->MoreElements
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((_s0__BrowseResponse*)a)->MoreElements))
        return NULL;
    }
  }
  short soap_flag_BrowseResult1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_BrowseResult1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReplyBase(soap, "s0:BrowseResult",
                &(((_s0__BrowseResponse*)a)->BrowseResult), "s0:ReplyBase")) {
          soap_flag_BrowseResult1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__BrowseElement(soap,
                "s0:Elements", &(((_s0__BrowseResponse*)a)->Elements),
                "s0:BrowseElement"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap,
                "s0:Errors", &(((_s0__BrowseResponse*)a)->Errors),
                "s0:OPCError"))
          continue;
      /* transient soap skipped */
      soap_check_result(soap, "s0:BrowseResult");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__BrowseResponse*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__BrowseResponse, 0, sizeof(_s0__BrowseResponse), 0,
        soap_copy__s0__BrowseResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__BrowseResponse* SOAP_FMAC6 soap_new__s0__BrowseResponse(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__BrowseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__BrowseResponse(
    struct soap* soap, _s0__BrowseResponse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__BrowseResponse* SOAP_FMAC4 soap_instantiate__s0__BrowseResponse(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate__s0__BrowseResponse(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE__s0__BrowseResponse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__BrowseResponse;
    if (size)
      *size = sizeof(_s0__BrowseResponse);
    ((_s0__BrowseResponse*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__BrowseResponse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__BrowseResponse);
    for (int i = 0; i < n; i++)
      ((_s0__BrowseResponse*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__BrowseResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__BrowseResponse(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying _s0__BrowseResponse %p -> %p\n", q, p));
  *(_s0__BrowseResponse*)p = *(_s0__BrowseResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__Browse::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfxsd__QName(
      soap, &((_s0__Browse*)this)->PropertyNames);
  ((_s0__Browse*)this)->LocaleID = NULL;
  ((_s0__Browse*)this)->ClientRequestHandle = NULL;
  ((_s0__Browse*)this)->ItemPath = NULL;
  ((_s0__Browse*)this)->ItemName = NULL;
  ((_s0__Browse*)this)->ContinuationPoint = NULL;
  ((_s0__Browse*)this)->MaxElementsReturned = NULL;
  ((_s0__Browse*)this)->BrowseFilter = NULL;
  ((_s0__Browse*)this)->ElementNameFilter = NULL;
  ((_s0__Browse*)this)->VendorFilter = NULL;
  ((_s0__Browse*)this)->ReturnAllProperties = NULL;
  ((_s0__Browse*)this)->ReturnPropertyValues = NULL;
  ((_s0__Browse*)this)->ReturnErrorText = NULL;
  /* transient soap skipped */
}

void _s0__Browse::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfxsd__QName(
      soap, &((_s0__Browse*)this)->PropertyNames);
  /* transient soap skipped */
}

int _s0__Browse::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__Browse);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__Browse::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__Browse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__Browse(struct soap* soap,
    const char* tag, int id, const _s0__Browse* a, const char* type)
{
  if (((_s0__Browse*)a)->LocaleID)
    soap_set_attr(soap, "LocaleID", ((_s0__Browse*)a)->LocaleID->c_str());
  if (((_s0__Browse*)a)->ClientRequestHandle)
    soap_set_attr(soap, "ClientRequestHandle",
        ((_s0__Browse*)a)->ClientRequestHandle->c_str());
  if (((_s0__Browse*)a)->ItemPath)
    soap_set_attr(soap, "ItemPath", ((_s0__Browse*)a)->ItemPath->c_str());
  if (((_s0__Browse*)a)->ItemName)
    soap_set_attr(soap, "ItemName", ((_s0__Browse*)a)->ItemName->c_str());
  if (((_s0__Browse*)a)->ContinuationPoint)
    soap_set_attr(soap, "ContinuationPoint",
        ((_s0__Browse*)a)->ContinuationPoint->c_str());
  if (((_s0__Browse*)a)->MaxElementsReturned)
    soap_set_attr(soap, "MaxElementsReturned",
        soap_int2s(soap, *((_s0__Browse*)a)->MaxElementsReturned));
  if (((_s0__Browse*)a)->BrowseFilter)
    soap_set_attr(soap, "BrowseFilter",
        soap_s0__browseFilter2s(soap, *((_s0__Browse*)a)->BrowseFilter));
  if (((_s0__Browse*)a)->ElementNameFilter)
    soap_set_attr(soap, "ElementNameFilter",
        ((_s0__Browse*)a)->ElementNameFilter->c_str());
  if (((_s0__Browse*)a)->VendorFilter)
    soap_set_attr(
        soap, "VendorFilter", ((_s0__Browse*)a)->VendorFilter->c_str());
  if (((_s0__Browse*)a)->ReturnAllProperties)
    soap_set_attr(soap, "ReturnAllProperties",
        soap_bool2s(soap, *((_s0__Browse*)a)->ReturnAllProperties));
  if (((_s0__Browse*)a)->ReturnPropertyValues)
    soap_set_attr(soap, "ReturnPropertyValues",
        soap_bool2s(soap, *((_s0__Browse*)a)->ReturnPropertyValues));
  if (((_s0__Browse*)a)->ReturnErrorText)
    soap_set_attr(soap, "ReturnErrorText",
        soap_bool2s(soap, *((_s0__Browse*)a)->ReturnErrorText));
  soap_element_begin_out(
      soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__Browse), type);
  soap_out_std__vectorTemplateOfxsd__QName(
      soap, "s0:PropertyNames", -1, &(((_s0__Browse*)a)->PropertyNames), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__Browse::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__Browse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__Browse* SOAP_FMAC4 soap_get__s0__Browse(
    struct soap* soap, _s0__Browse* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__Browse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__Browse::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__Browse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__Browse* SOAP_FMAC4 soap_in__s0__Browse(
    struct soap* soap, const char* tag, _s0__Browse* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__Browse*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__Browse, sizeof(_s0__Browse), soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__Browse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__Browse*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "LocaleID", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->LocaleID
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__Browse*)a)->LocaleID = soap_new_std__string(soap, -1);
        ((_s0__Browse*)a)->LocaleID->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientRequestHandle", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->ClientRequestHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__Browse*)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
        ((_s0__Browse*)a)->ClientRequestHandle->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__Browse*)a)->ItemPath = soap_new_std__string(soap, -1);
        ((_s0__Browse*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemName", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->ItemName
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__Browse*)a)->ItemName = soap_new_std__string(soap, -1);
        ((_s0__Browse*)a)->ItemName->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ContinuationPoint", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->ContinuationPoint
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__Browse*)a)->ContinuationPoint = soap_new_std__string(soap, -1);
        ((_s0__Browse*)a)->ContinuationPoint->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "MaxElementsReturned", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->MaxElementsReturned
              = (int*)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(soap, t, ((_s0__Browse*)a)->MaxElementsReturned))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "BrowseFilter", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->BrowseFilter
              = (enum s0__browseFilter*)soap_malloc(
                  soap, sizeof(enum s0__browseFilter)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2s0__browseFilter(soap, t, ((_s0__Browse*)a)->BrowseFilter))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ElementNameFilter", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->ElementNameFilter
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__Browse*)a)->ElementNameFilter = soap_new_std__string(soap, -1);
        ((_s0__Browse*)a)->ElementNameFilter->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "VendorFilter", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->VendorFilter
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__Browse*)a)->VendorFilter = soap_new_std__string(soap, -1);
        ((_s0__Browse*)a)->VendorFilter->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnAllProperties", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->ReturnAllProperties
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((_s0__Browse*)a)->ReturnAllProperties))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnPropertyValues", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->ReturnPropertyValues
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((_s0__Browse*)a)->ReturnPropertyValues))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnErrorText", 0);
    if (t) {
      if (!(((_s0__Browse*)a)->ReturnErrorText
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((_s0__Browse*)a)->ReturnErrorText))
        return NULL;
    }
  };
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfxsd__QName(soap, "s0:PropertyNames",
                &(((_s0__Browse*)a)->PropertyNames), "xsd:QName"))
          continue;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__Browse*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__Browse, 0, sizeof(_s0__Browse), 0,
        soap_copy__s0__Browse);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__Browse* SOAP_FMAC6 soap_new__s0__Browse(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__Browse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__Browse(
    struct soap* soap, _s0__Browse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__Browse* SOAP_FMAC4 soap_instantiate__s0__Browse(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__Browse(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE__s0__Browse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__Browse;
    if (size)
      *size = sizeof(_s0__Browse);
    ((_s0__Browse*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__Browse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__Browse);
    for (int i = 0; i < n; i++)
      ((_s0__Browse*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__Browse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__Browse(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__Browse %p -> %p\n", q, p));
  *(_s0__Browse*)p = *(_s0__Browse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscriptionCancelResponse::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__SubscriptionCancelResponse*)this)->ClientRequestHandle = NULL;
  /* transient soap skipped */
}

void _s0__SubscriptionCancelResponse::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int _s0__SubscriptionCancelResponse::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(soap, (void*)this, NULL, 0, tag,
      SOAP_TYPE__s0__SubscriptionCancelResponse);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__SubscriptionCancelResponse::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__SubscriptionCancelResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscriptionCancelResponse(
    struct soap* soap, const char* tag, int id,
    const _s0__SubscriptionCancelResponse* a, const char* type)
{
  if (((_s0__SubscriptionCancelResponse*)a)->ClientRequestHandle)
    soap_set_attr(soap, "ClientRequestHandle",
        ((_s0__SubscriptionCancelResponse*)a)->ClientRequestHandle->c_str());
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__SubscriptionCancelResponse),
      type);
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__SubscriptionCancelResponse::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__SubscriptionCancelResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse* SOAP_FMAC4
soap_get__s0__SubscriptionCancelResponse(struct soap* soap,
    _s0__SubscriptionCancelResponse* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__SubscriptionCancelResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__SubscriptionCancelResponse::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__SubscriptionCancelResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse* SOAP_FMAC4
soap_in__s0__SubscriptionCancelResponse(struct soap* soap, const char* tag,
    _s0__SubscriptionCancelResponse* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__SubscriptionCancelResponse*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__SubscriptionCancelResponse,
      sizeof(_s0__SubscriptionCancelResponse), soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__SubscriptionCancelResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__SubscriptionCancelResponse*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientRequestHandle", 0);
    if (t) {
      if (!(((_s0__SubscriptionCancelResponse*)a)->ClientRequestHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__SubscriptionCancelResponse*)a)->ClientRequestHandle
            = soap_new_std__string(soap, -1);
        ((_s0__SubscriptionCancelResponse*)a)->ClientRequestHandle->assign(s);
      }
    }
  };
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__SubscriptionCancelResponse*)soap_id_forward(soap, soap->href,
        (void*)a, 0, SOAP_TYPE__s0__SubscriptionCancelResponse, 0,
        sizeof(_s0__SubscriptionCancelResponse), 0,
        soap_copy__s0__SubscriptionCancelResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__SubscriptionCancelResponse* SOAP_FMAC6
soap_new__s0__SubscriptionCancelResponse(struct soap* soap, int n)
{
  return soap_instantiate__s0__SubscriptionCancelResponse(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscriptionCancelResponse(
    struct soap* soap, _s0__SubscriptionCancelResponse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse* SOAP_FMAC4
soap_instantiate__s0__SubscriptionCancelResponse(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "soap_instantiate__s0__SubscriptionCancelResponse(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE__s0__SubscriptionCancelResponse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__SubscriptionCancelResponse;
    if (size)
      *size = sizeof(_s0__SubscriptionCancelResponse);
    ((_s0__SubscriptionCancelResponse*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__SubscriptionCancelResponse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__SubscriptionCancelResponse);
    for (int i = 0; i < n; i++)
      ((_s0__SubscriptionCancelResponse*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__SubscriptionCancelResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscriptionCancelResponse(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying _s0__SubscriptionCancelResponse %p -> %p\n", q, p));
  *(_s0__SubscriptionCancelResponse*)p = *(_s0__SubscriptionCancelResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscriptionCancel::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__SubscriptionCancel*)this)->ServerSubHandle = NULL;
  ((_s0__SubscriptionCancel*)this)->ClientRequestHandle = NULL;
  /* transient soap skipped */
}

void _s0__SubscriptionCancel::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int _s0__SubscriptionCancel::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__SubscriptionCancel);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__SubscriptionCancel::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__SubscriptionCancel(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscriptionCancel(struct soap* soap,
    const char* tag, int id, const _s0__SubscriptionCancel* a, const char* type)
{
  if (((_s0__SubscriptionCancel*)a)->ServerSubHandle)
    soap_set_attr(soap, "ServerSubHandle",
        ((_s0__SubscriptionCancel*)a)->ServerSubHandle->c_str());
  if (((_s0__SubscriptionCancel*)a)->ClientRequestHandle)
    soap_set_attr(soap, "ClientRequestHandle",
        ((_s0__SubscriptionCancel*)a)->ClientRequestHandle->c_str());
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__SubscriptionCancel), type);
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__SubscriptionCancel::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__SubscriptionCancel(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscriptionCancel* SOAP_FMAC4 soap_get__s0__SubscriptionCancel(
    struct soap* soap, _s0__SubscriptionCancel* p, const char* tag,
    const char* type)
{
  if ((p = soap_in__s0__SubscriptionCancel(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__SubscriptionCancel::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__SubscriptionCancel(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscriptionCancel* SOAP_FMAC4 soap_in__s0__SubscriptionCancel(
    struct soap* soap, const char* tag, _s0__SubscriptionCancel* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__SubscriptionCancel*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__SubscriptionCancel, sizeof(_s0__SubscriptionCancel),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__SubscriptionCancel) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__SubscriptionCancel*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ServerSubHandle", 0);
    if (t) {
      if (!(((_s0__SubscriptionCancel*)a)->ServerSubHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__SubscriptionCancel*)a)->ServerSubHandle
            = soap_new_std__string(soap, -1);
        ((_s0__SubscriptionCancel*)a)->ServerSubHandle->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientRequestHandle", 0);
    if (t) {
      if (!(((_s0__SubscriptionCancel*)a)->ClientRequestHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__SubscriptionCancel*)a)->ClientRequestHandle
            = soap_new_std__string(soap, -1);
        ((_s0__SubscriptionCancel*)a)->ClientRequestHandle->assign(s);
      }
    }
  };
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__SubscriptionCancel*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__SubscriptionCancel, 0, sizeof(_s0__SubscriptionCancel),
        0, soap_copy__s0__SubscriptionCancel);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__SubscriptionCancel* SOAP_FMAC6 soap_new__s0__SubscriptionCancel(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__SubscriptionCancel(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscriptionCancel(
    struct soap* soap, _s0__SubscriptionCancel* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscriptionCancel* SOAP_FMAC4
soap_instantiate__s0__SubscriptionCancel(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate__s0__SubscriptionCancel(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE__s0__SubscriptionCancel, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__SubscriptionCancel;
    if (size)
      *size = sizeof(_s0__SubscriptionCancel);
    ((_s0__SubscriptionCancel*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__SubscriptionCancel[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__SubscriptionCancel);
    for (int i = 0; i < n; i++)
      ((_s0__SubscriptionCancel*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__SubscriptionCancel*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscriptionCancel(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying _s0__SubscriptionCancel %p -> %p\n", q, p));
  *(_s0__SubscriptionCancel*)p = *(_s0__SubscriptionCancel*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscriptionPolledRefreshResponse::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__SubscriptionPolledRefreshResponse*)this)
      ->SubscriptionPolledRefreshResult
      = NULL;
  soap_default_std__vectorTemplateOfstd__string(
      soap, &((_s0__SubscriptionPolledRefreshResponse*)this)
                 ->InvalidServerSubHandles);
  soap_default_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
      soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->RItemList);
  soap_default_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->Errors);
  ((_s0__SubscriptionPolledRefreshResponse*)this)->DataBufferOverflow = NULL;
  /* transient soap skipped */
}

void _s0__SubscriptionPolledRefreshResponse::soap_serialize(
    struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__ReplyBase(
      soap, &((_s0__SubscriptionPolledRefreshResponse*)this)
                 ->SubscriptionPolledRefreshResult);
  soap_serialize_std__vectorTemplateOfstd__string(
      soap, &((_s0__SubscriptionPolledRefreshResponse*)this)
                 ->InvalidServerSubHandles);
  soap_serialize_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
      soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->RItemList);
  soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->Errors);
  /* transient soap skipped */
}

int _s0__SubscriptionPolledRefreshResponse::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(soap, (void*)this, NULL, 0, tag,
      SOAP_TYPE__s0__SubscriptionPolledRefreshResponse);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__SubscriptionPolledRefreshResponse::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__SubscriptionPolledRefreshResponse(
      soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscriptionPolledRefreshResponse(
    struct soap* soap, const char* tag, int id,
    const _s0__SubscriptionPolledRefreshResponse* a, const char* type)
{
  if (((_s0__SubscriptionPolledRefreshResponse*)a)->DataBufferOverflow)
    soap_set_attr(soap, "DataBufferOverflow",
        soap_bool2s(soap,
            *((_s0__SubscriptionPolledRefreshResponse*)a)->DataBufferOverflow));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(
          soap, id, a, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse),
      type);
  if (a->SubscriptionPolledRefreshResult)
    soap_element_result(soap, "s0:SubscriptionPolledRefreshResult");
  soap_out_PointerTos0__ReplyBase(soap, "s0:SubscriptionPolledRefreshResult",
      -1, &(((_s0__SubscriptionPolledRefreshResponse*)a)
                  ->SubscriptionPolledRefreshResult),
      "");
  soap_out_std__vectorTemplateOfstd__string(soap, "s0:InvalidServerSubHandles",
      -1,
      &(((_s0__SubscriptionPolledRefreshResponse*)a)->InvalidServerSubHandles),
      "");
  soap_out_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
      soap, "s0:RItemList", -1,
      &(((_s0__SubscriptionPolledRefreshResponse*)a)->RItemList), "");
  soap_out_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", -1,
      &(((_s0__SubscriptionPolledRefreshResponse*)a)->Errors), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__SubscriptionPolledRefreshResponse::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__SubscriptionPolledRefreshResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse* SOAP_FMAC4
soap_get__s0__SubscriptionPolledRefreshResponse(struct soap* soap,
    _s0__SubscriptionPolledRefreshResponse* p, const char* tag,
    const char* type)
{
  if ((p = soap_in__s0__SubscriptionPolledRefreshResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__SubscriptionPolledRefreshResponse::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__SubscriptionPolledRefreshResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse* SOAP_FMAC4
soap_in__s0__SubscriptionPolledRefreshResponse(struct soap* soap,
    const char* tag, _s0__SubscriptionPolledRefreshResponse* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__SubscriptionPolledRefreshResponse*)soap_class_id_enter(soap,
      soap->id, a, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse,
      sizeof(_s0__SubscriptionPolledRefreshResponse), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__SubscriptionPolledRefreshResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__SubscriptionPolledRefreshResponse*)a->soap_in(
          soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "DataBufferOverflow", 0);
    if (t) {
      if (!(((_s0__SubscriptionPolledRefreshResponse*)a)->DataBufferOverflow
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t,
              ((_s0__SubscriptionPolledRefreshResponse*)a)->DataBufferOverflow))
        return NULL;
    }
  }
  short soap_flag_SubscriptionPolledRefreshResult1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscriptionPolledRefreshResult1
          && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReplyBase(soap,
                "s0:SubscriptionPolledRefreshResult",
                &(((_s0__SubscriptionPolledRefreshResponse*)a)
                        ->SubscriptionPolledRefreshResult),
                "s0:ReplyBase")) {
          soap_flag_SubscriptionPolledRefreshResult1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap,
                "s0:InvalidServerSubHandles",
                &(((_s0__SubscriptionPolledRefreshResponse*)a)
                        ->InvalidServerSubHandles),
                "xsd:string"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
                soap, "s0:RItemList",
                &(((_s0__SubscriptionPolledRefreshResponse*)a)->RItemList),
                "s0:SubscribePolledRefreshReplyItemList"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap,
                "s0:Errors",
                &(((_s0__SubscriptionPolledRefreshResponse*)a)->Errors),
                "s0:OPCError"))
          continue;
      /* transient soap skipped */
      soap_check_result(soap, "s0:SubscriptionPolledRefreshResult");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__SubscriptionPolledRefreshResponse*)soap_id_forward(soap,
        soap->href, (void*)a, 0,
        SOAP_TYPE__s0__SubscriptionPolledRefreshResponse, 0,
        sizeof(_s0__SubscriptionPolledRefreshResponse), 0,
        soap_copy__s0__SubscriptionPolledRefreshResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__SubscriptionPolledRefreshResponse* SOAP_FMAC6
soap_new__s0__SubscriptionPolledRefreshResponse(struct soap* soap, int n)
{
  return soap_instantiate__s0__SubscriptionPolledRefreshResponse(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscriptionPolledRefreshResponse(
    struct soap* soap, _s0__SubscriptionPolledRefreshResponse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse* SOAP_FMAC4
soap_instantiate__s0__SubscriptionPolledRefreshResponse(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate__s0__"
                           "SubscriptionPolledRefreshResponse(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE__s0__SubscriptionPolledRefreshResponse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__SubscriptionPolledRefreshResponse;
    if (size)
      *size = sizeof(_s0__SubscriptionPolledRefreshResponse);
    ((_s0__SubscriptionPolledRefreshResponse*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__SubscriptionPolledRefreshResponse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__SubscriptionPolledRefreshResponse);
    for (int i = 0; i < n; i++)
      ((_s0__SubscriptionPolledRefreshResponse*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__SubscriptionPolledRefreshResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscriptionPolledRefreshResponse(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "Copying _s0__SubscriptionPolledRefreshResponse %p -> %p\n", q, p));
  *(_s0__SubscriptionPolledRefreshResponse*)p
      = *(_s0__SubscriptionPolledRefreshResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscriptionPolledRefresh::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__SubscriptionPolledRefresh*)this)->Options = NULL;
  soap_default_std__vectorTemplateOfstd__string(
      soap, &((_s0__SubscriptionPolledRefresh*)this)->ServerSubHandles);
  ((_s0__SubscriptionPolledRefresh*)this)->HoldTime = NULL;
  ((_s0__SubscriptionPolledRefresh*)this)->WaitTime = NULL;
  ((_s0__SubscriptionPolledRefresh*)this)->ReturnAllItems = NULL;
  /* transient soap skipped */
}

void _s0__SubscriptionPolledRefresh::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__RequestOptions(
      soap, &((_s0__SubscriptionPolledRefresh*)this)->Options);
  soap_serialize_std__vectorTemplateOfstd__string(
      soap, &((_s0__SubscriptionPolledRefresh*)this)->ServerSubHandles);
  /* transient soap skipped */
}

int _s0__SubscriptionPolledRefresh::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(soap, (void*)this, NULL, 0, tag,
      SOAP_TYPE__s0__SubscriptionPolledRefresh);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__SubscriptionPolledRefresh::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__SubscriptionPolledRefresh(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscriptionPolledRefresh(
    struct soap* soap, const char* tag, int id,
    const _s0__SubscriptionPolledRefresh* a, const char* type)
{
  if (((_s0__SubscriptionPolledRefresh*)a)->HoldTime)
    soap_set_attr(soap, "HoldTime",
        ((_s0__SubscriptionPolledRefresh*)a)->HoldTime->c_str());
  if (((_s0__SubscriptionPolledRefresh*)a)->WaitTime)
    soap_set_attr(soap, "WaitTime",
        soap_int2s(soap, *((_s0__SubscriptionPolledRefresh*)a)->WaitTime));
  if (((_s0__SubscriptionPolledRefresh*)a)->ReturnAllItems)
    soap_set_attr(soap, "ReturnAllItems",
        soap_bool2s(
            soap, *((_s0__SubscriptionPolledRefresh*)a)->ReturnAllItems));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__SubscriptionPolledRefresh),
      type);
  soap_out_PointerTos0__RequestOptions(soap, "s0:Options", -1,
      &(((_s0__SubscriptionPolledRefresh*)a)->Options), "");
  soap_out_std__vectorTemplateOfstd__string(soap, "s0:ServerSubHandles", -1,
      &(((_s0__SubscriptionPolledRefresh*)a)->ServerSubHandles), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__SubscriptionPolledRefresh::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__SubscriptionPolledRefresh(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh* SOAP_FMAC4
soap_get__s0__SubscriptionPolledRefresh(struct soap* soap,
    _s0__SubscriptionPolledRefresh* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__SubscriptionPolledRefresh(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__SubscriptionPolledRefresh::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__SubscriptionPolledRefresh(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh* SOAP_FMAC4
soap_in__s0__SubscriptionPolledRefresh(struct soap* soap, const char* tag,
    _s0__SubscriptionPolledRefresh* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__SubscriptionPolledRefresh*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__SubscriptionPolledRefresh,
      sizeof(_s0__SubscriptionPolledRefresh), soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__SubscriptionPolledRefresh) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__SubscriptionPolledRefresh*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "HoldTime", 0);
    if (t) {
      if (!(((_s0__SubscriptionPolledRefresh*)a)->HoldTime
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__SubscriptionPolledRefresh*)a)->HoldTime
            = soap_new_std__string(soap, -1);
        ((_s0__SubscriptionPolledRefresh*)a)->HoldTime->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "WaitTime", 0);
    if (t) {
      if (!(((_s0__SubscriptionPolledRefresh*)a)->WaitTime
              = (int*)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(soap, t, ((_s0__SubscriptionPolledRefresh*)a)->WaitTime))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnAllItems", 0);
    if (t) {
      if (!(((_s0__SubscriptionPolledRefresh*)a)->ReturnAllItems
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(
              soap, t, ((_s0__SubscriptionPolledRefresh*)a)->ReturnAllItems))
        return NULL;
    }
  }
  short soap_flag_Options1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__RequestOptions(soap, "s0:Options",
                &(((_s0__SubscriptionPolledRefresh*)a)->Options),
                "s0:RequestOptions")) {
          soap_flag_Options1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap,
                "s0:ServerSubHandles",
                &(((_s0__SubscriptionPolledRefresh*)a)->ServerSubHandles),
                "xsd:string"))
          continue;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__SubscriptionPolledRefresh*)soap_id_forward(soap, soap->href,
        (void*)a, 0, SOAP_TYPE__s0__SubscriptionPolledRefresh, 0,
        sizeof(_s0__SubscriptionPolledRefresh), 0,
        soap_copy__s0__SubscriptionPolledRefresh);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__SubscriptionPolledRefresh* SOAP_FMAC6
soap_new__s0__SubscriptionPolledRefresh(struct soap* soap, int n)
{
  return soap_instantiate__s0__SubscriptionPolledRefresh(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscriptionPolledRefresh(
    struct soap* soap, _s0__SubscriptionPolledRefresh* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh* SOAP_FMAC4
soap_instantiate__s0__SubscriptionPolledRefresh(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug,
                "soap_instantiate__s0__SubscriptionPolledRefresh(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE__s0__SubscriptionPolledRefresh, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__SubscriptionPolledRefresh;
    if (size)
      *size = sizeof(_s0__SubscriptionPolledRefresh);
    ((_s0__SubscriptionPolledRefresh*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__SubscriptionPolledRefresh[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__SubscriptionPolledRefresh);
    for (int i = 0; i < n; i++)
      ((_s0__SubscriptionPolledRefresh*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__SubscriptionPolledRefresh*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscriptionPolledRefresh(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying _s0__SubscriptionPolledRefresh %p -> %p\n", q, p));
  *(_s0__SubscriptionPolledRefresh*)p = *(_s0__SubscriptionPolledRefresh*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscribeResponse::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__SubscribeResponse*)this)->SubscribeResult = NULL;
  ((_s0__SubscribeResponse*)this)->RItemList = NULL;
  soap_default_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__SubscribeResponse*)this)->Errors);
  ((_s0__SubscribeResponse*)this)->ServerSubHandle = NULL;
  /* transient soap skipped */
}

void _s0__SubscribeResponse::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__ReplyBase(
      soap, &((_s0__SubscribeResponse*)this)->SubscribeResult);
  soap_serialize_PointerTos0__SubscribeReplyItemList(
      soap, &((_s0__SubscribeResponse*)this)->RItemList);
  soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__SubscribeResponse*)this)->Errors);
  /* transient soap skipped */
}

int _s0__SubscribeResponse::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__SubscribeResponse);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__SubscribeResponse::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__SubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscribeResponse(struct soap* soap,
    const char* tag, int id, const _s0__SubscribeResponse* a, const char* type)
{
  if (((_s0__SubscribeResponse*)a)->ServerSubHandle)
    soap_set_attr(soap, "ServerSubHandle",
        ((_s0__SubscribeResponse*)a)->ServerSubHandle->c_str());
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__SubscribeResponse), type);
  if (a->SubscribeResult)
    soap_element_result(soap, "s0:SubscribeResult");
  soap_out_PointerTos0__ReplyBase(soap, "s0:SubscribeResult", -1,
      &(((_s0__SubscribeResponse*)a)->SubscribeResult), "");
  soap_out_PointerTos0__SubscribeReplyItemList(
      soap, "s0:RItemList", -1, &(((_s0__SubscribeResponse*)a)->RItemList), "");
  soap_out_std__vectorTemplateOfPointerTos0__OPCError(
      soap, "s0:Errors", -1, &(((_s0__SubscribeResponse*)a)->Errors), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__SubscribeResponse::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__SubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscribeResponse* SOAP_FMAC4 soap_get__s0__SubscribeResponse(
    struct soap* soap, _s0__SubscribeResponse* p, const char* tag,
    const char* type)
{
  if ((p = soap_in__s0__SubscribeResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__SubscribeResponse::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__SubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscribeResponse* SOAP_FMAC4 soap_in__s0__SubscribeResponse(
    struct soap* soap, const char* tag, _s0__SubscribeResponse* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__SubscribeResponse*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__SubscribeResponse, sizeof(_s0__SubscribeResponse),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__SubscribeResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__SubscribeResponse*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ServerSubHandle", 0);
    if (t) {
      if (!(((_s0__SubscribeResponse*)a)->ServerSubHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__SubscribeResponse*)a)->ServerSubHandle
            = soap_new_std__string(soap, -1);
        ((_s0__SubscribeResponse*)a)->ServerSubHandle->assign(s);
      }
    }
  }
  short soap_flag_SubscribeResult1 = 1, soap_flag_RItemList1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscribeResult1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReplyBase(soap, "s0:SubscribeResult",
                &(((_s0__SubscribeResponse*)a)->SubscribeResult),
                "s0:ReplyBase")) {
          soap_flag_SubscribeResult1--;
          continue;
        }
      if (soap_flag_RItemList1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__SubscribeReplyItemList(soap, "s0:RItemList",
                &(((_s0__SubscribeResponse*)a)->RItemList),
                "s0:SubscribeReplyItemList")) {
          soap_flag_RItemList1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap,
                "s0:Errors", &(((_s0__SubscribeResponse*)a)->Errors),
                "s0:OPCError"))
          continue;
      /* transient soap skipped */
      soap_check_result(soap, "s0:SubscribeResult");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__SubscribeResponse*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__SubscribeResponse, 0, sizeof(_s0__SubscribeResponse), 0,
        soap_copy__s0__SubscribeResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__SubscribeResponse* SOAP_FMAC6 soap_new__s0__SubscribeResponse(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__SubscribeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscribeResponse(
    struct soap* soap, _s0__SubscribeResponse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscribeResponse* SOAP_FMAC4
soap_instantiate__s0__SubscribeResponse(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate__s0__SubscribeResponse(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE__s0__SubscribeResponse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__SubscribeResponse;
    if (size)
      *size = sizeof(_s0__SubscribeResponse);
    ((_s0__SubscribeResponse*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__SubscribeResponse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__SubscribeResponse);
    for (int i = 0; i < n; i++)
      ((_s0__SubscribeResponse*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__SubscribeResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscribeResponse(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying _s0__SubscribeResponse %p -> %p\n", q, p));
  *(_s0__SubscribeResponse*)p = *(_s0__SubscribeResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__Subscribe::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__Subscribe*)this)->Options = NULL;
  ((_s0__Subscribe*)this)->ItemList = NULL;
  soap_default_bool(soap, &((_s0__Subscribe*)this)->ReturnValuesOnReply);
  ((_s0__Subscribe*)this)->SubscriptionPingRate = NULL;
  /* transient soap skipped */
}

void _s0__Subscribe::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__RequestOptions(
      soap, &((_s0__Subscribe*)this)->Options);
  soap_serialize_PointerTos0__SubscribeRequestItemList(
      soap, &((_s0__Subscribe*)this)->ItemList);
  /* transient soap skipped */
}

int _s0__Subscribe::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__Subscribe);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__Subscribe::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__Subscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__Subscribe(struct soap* soap,
    const char* tag, int id, const _s0__Subscribe* a, const char* type)
{
  soap_set_attr(soap, "ReturnValuesOnReply",
      soap_bool2s(soap, ((_s0__Subscribe*)a)->ReturnValuesOnReply));
  if (((_s0__Subscribe*)a)->SubscriptionPingRate)
    soap_set_attr(soap, "SubscriptionPingRate",
        soap_int2s(soap, *((_s0__Subscribe*)a)->SubscriptionPingRate));
  soap_element_begin_out(
      soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__Subscribe), type);
  soap_out_PointerTos0__RequestOptions(
      soap, "s0:Options", -1, &(((_s0__Subscribe*)a)->Options), "");
  soap_out_PointerTos0__SubscribeRequestItemList(
      soap, "s0:ItemList", -1, &(((_s0__Subscribe*)a)->ItemList), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__Subscribe::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__Subscribe(soap, this, tag, type);
}

SOAP_FMAC3 _s0__Subscribe* SOAP_FMAC4 soap_get__s0__Subscribe(
    struct soap* soap, _s0__Subscribe* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__Subscribe(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__Subscribe::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__Subscribe(soap, tag, this, type);
}

SOAP_FMAC3 _s0__Subscribe* SOAP_FMAC4 soap_in__s0__Subscribe(
    struct soap* soap, const char* tag, _s0__Subscribe* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__Subscribe*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__Subscribe, sizeof(_s0__Subscribe), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__Subscribe) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__Subscribe*)a->soap_in(soap, tag, type);
    }
  }
  if (soap_s2bool(soap, soap_attr_value(soap, "ReturnValuesOnReply", 1),
          &((_s0__Subscribe*)a)->ReturnValuesOnReply))
    return NULL;
  {
    const char* t = soap_attr_value(soap, "SubscriptionPingRate", 0);
    if (t) {
      if (!(((_s0__Subscribe*)a)->SubscriptionPingRate
              = (int*)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(soap, t, ((_s0__Subscribe*)a)->SubscriptionPingRate))
        return NULL;
    }
  }
  short soap_flag_Options1 = 1, soap_flag_ItemList1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__RequestOptions(soap, "s0:Options",
                &(((_s0__Subscribe*)a)->Options), "s0:RequestOptions")) {
          soap_flag_Options1--;
          continue;
        }
      if (soap_flag_ItemList1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__SubscribeRequestItemList(soap, "s0:ItemList",
                &(((_s0__Subscribe*)a)->ItemList),
                "s0:SubscribeRequestItemList")) {
          soap_flag_ItemList1--;
          continue;
        }
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__Subscribe*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__Subscribe, 0, sizeof(_s0__Subscribe), 0,
        soap_copy__s0__Subscribe);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__Subscribe* SOAP_FMAC6 soap_new__s0__Subscribe(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__Subscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__Subscribe(
    struct soap* soap, _s0__Subscribe* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__Subscribe* SOAP_FMAC4 soap_instantiate__s0__Subscribe(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate__s0__Subscribe(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE__s0__Subscribe, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__Subscribe;
    if (size)
      *size = sizeof(_s0__Subscribe);
    ((_s0__Subscribe*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__Subscribe[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__Subscribe);
    for (int i = 0; i < n; i++)
      ((_s0__Subscribe*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__Subscribe*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__Subscribe(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__Subscribe %p -> %p\n", q, p));
  *(_s0__Subscribe*)p = *(_s0__Subscribe*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__WriteResponse::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__WriteResponse*)this)->WriteResult = NULL;
  ((_s0__WriteResponse*)this)->RItemList = NULL;
  soap_default_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__WriteResponse*)this)->Errors);
  /* transient soap skipped */
}

void _s0__WriteResponse::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__ReplyBase(
      soap, &((_s0__WriteResponse*)this)->WriteResult);
  soap_serialize_PointerTos0__ReplyItemList(
      soap, &((_s0__WriteResponse*)this)->RItemList);
  soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__WriteResponse*)this)->Errors);
  /* transient soap skipped */
}

int _s0__WriteResponse::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__WriteResponse);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__WriteResponse::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__WriteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__WriteResponse(struct soap* soap,
    const char* tag, int id, const _s0__WriteResponse* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__WriteResponse), type);
  if (a->WriteResult)
    soap_element_result(soap, "s0:WriteResult");
  soap_out_PointerTos0__ReplyBase(
      soap, "s0:WriteResult", -1, &(((_s0__WriteResponse*)a)->WriteResult), "");
  soap_out_PointerTos0__ReplyItemList(
      soap, "s0:RItemList", -1, &(((_s0__WriteResponse*)a)->RItemList), "");
  soap_out_std__vectorTemplateOfPointerTos0__OPCError(
      soap, "s0:Errors", -1, &(((_s0__WriteResponse*)a)->Errors), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__WriteResponse::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__WriteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__WriteResponse* SOAP_FMAC4 soap_get__s0__WriteResponse(
    struct soap* soap, _s0__WriteResponse* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__WriteResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__WriteResponse::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__WriteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__WriteResponse* SOAP_FMAC4 soap_in__s0__WriteResponse(
    struct soap* soap, const char* tag, _s0__WriteResponse* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__WriteResponse*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__WriteResponse, sizeof(_s0__WriteResponse), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__WriteResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__WriteResponse*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag_WriteResult1 = 1, soap_flag_RItemList1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_WriteResult1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReplyBase(soap, "s0:WriteResult",
                &(((_s0__WriteResponse*)a)->WriteResult), "s0:ReplyBase")) {
          soap_flag_WriteResult1--;
          continue;
        }
      if (soap_flag_RItemList1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReplyItemList(soap, "s0:RItemList",
                &(((_s0__WriteResponse*)a)->RItemList), "s0:ReplyItemList")) {
          soap_flag_RItemList1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap,
                "s0:Errors", &(((_s0__WriteResponse*)a)->Errors),
                "s0:OPCError"))
          continue;
      /* transient soap skipped */
      soap_check_result(soap, "s0:WriteResult");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__WriteResponse*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__WriteResponse, 0, sizeof(_s0__WriteResponse), 0,
        soap_copy__s0__WriteResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__WriteResponse* SOAP_FMAC6 soap_new__s0__WriteResponse(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__WriteResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__WriteResponse(
    struct soap* soap, _s0__WriteResponse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__WriteResponse* SOAP_FMAC4 soap_instantiate__s0__WriteResponse(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate__s0__WriteResponse(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE__s0__WriteResponse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__WriteResponse;
    if (size)
      *size = sizeof(_s0__WriteResponse);
    ((_s0__WriteResponse*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__WriteResponse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__WriteResponse);
    for (int i = 0; i < n; i++)
      ((_s0__WriteResponse*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__WriteResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__WriteResponse(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying _s0__WriteResponse %p -> %p\n", q, p));
  *(_s0__WriteResponse*)p = *(_s0__WriteResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__Write::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__Write*)this)->Options = NULL;
  ((_s0__Write*)this)->ItemList = NULL;
  soap_default_bool(soap, &((_s0__Write*)this)->ReturnValuesOnReply);
  /* transient soap skipped */
}

void _s0__Write::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__RequestOptions(
      soap, &((_s0__Write*)this)->Options);
  soap_serialize_PointerTos0__WriteRequestItemList(
      soap, &((_s0__Write*)this)->ItemList);
  /* transient soap skipped */
}

int _s0__Write::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__Write);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__Write::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__Write(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__Write(struct soap* soap,
    const char* tag, int id, const _s0__Write* a, const char* type)
{
  soap_set_attr(soap, "ReturnValuesOnReply",
      soap_bool2s(soap, ((_s0__Write*)a)->ReturnValuesOnReply));
  soap_element_begin_out(
      soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__Write), type);
  soap_out_PointerTos0__RequestOptions(
      soap, "s0:Options", -1, &(((_s0__Write*)a)->Options), "");
  soap_out_PointerTos0__WriteRequestItemList(
      soap, "s0:ItemList", -1, &(((_s0__Write*)a)->ItemList), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__Write::soap_get(struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__Write(soap, this, tag, type);
}

SOAP_FMAC3 _s0__Write* SOAP_FMAC4 soap_get__s0__Write(
    struct soap* soap, _s0__Write* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__Write(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__Write::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__Write(soap, tag, this, type);
}

SOAP_FMAC3 _s0__Write* SOAP_FMAC4 soap_in__s0__Write(
    struct soap* soap, const char* tag, _s0__Write* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__Write*)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__Write,
      sizeof(_s0__Write), soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__Write) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__Write*)a->soap_in(soap, tag, type);
    }
  }
  if (soap_s2bool(soap, soap_attr_value(soap, "ReturnValuesOnReply", 1),
          &((_s0__Write*)a)->ReturnValuesOnReply))
    return NULL;
  short soap_flag_Options1 = 1, soap_flag_ItemList1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__RequestOptions(soap, "s0:Options",
                &(((_s0__Write*)a)->Options), "s0:RequestOptions")) {
          soap_flag_Options1--;
          continue;
        }
      if (soap_flag_ItemList1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__WriteRequestItemList(soap, "s0:ItemList",
                &(((_s0__Write*)a)->ItemList), "s0:WriteRequestItemList")) {
          soap_flag_ItemList1--;
          continue;
        }
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__Write*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__Write, 0, sizeof(_s0__Write), 0, soap_copy__s0__Write);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__Write* SOAP_FMAC6 soap_new__s0__Write(struct soap* soap, int n)
{
  return soap_instantiate__s0__Write(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__Write(
    struct soap* soap, _s0__Write* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__Write* SOAP_FMAC4 soap_instantiate__s0__Write(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__Write(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE__s0__Write, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__Write;
    if (size)
      *size = sizeof(_s0__Write);
    ((_s0__Write*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__Write[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__Write);
    for (int i = 0; i < n; i++)
      ((_s0__Write*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__Write*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__Write(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__Write %p -> %p\n", q, p));
  *(_s0__Write*)p = *(_s0__Write*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__ReadResponse::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__ReadResponse*)this)->ReadResult = NULL;
  ((_s0__ReadResponse*)this)->RItemList = NULL;
  soap_default_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__ReadResponse*)this)->Errors);
  /* transient soap skipped */
}

void _s0__ReadResponse::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__ReplyBase(
      soap, &((_s0__ReadResponse*)this)->ReadResult);
  soap_serialize_PointerTos0__ReplyItemList(
      soap, &((_s0__ReadResponse*)this)->RItemList);
  soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(
      soap, &((_s0__ReadResponse*)this)->Errors);
  /* transient soap skipped */
}

int _s0__ReadResponse::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__ReadResponse);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__ReadResponse::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__ReadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__ReadResponse(struct soap* soap,
    const char* tag, int id, const _s0__ReadResponse* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__ReadResponse), type);
  if (a->ReadResult)
    soap_element_result(soap, "s0:ReadResult");
  soap_out_PointerTos0__ReplyBase(
      soap, "s0:ReadResult", -1, &(((_s0__ReadResponse*)a)->ReadResult), "");
  soap_out_PointerTos0__ReplyItemList(
      soap, "s0:RItemList", -1, &(((_s0__ReadResponse*)a)->RItemList), "");
  soap_out_std__vectorTemplateOfPointerTos0__OPCError(
      soap, "s0:Errors", -1, &(((_s0__ReadResponse*)a)->Errors), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__ReadResponse::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__ReadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__ReadResponse* SOAP_FMAC4 soap_get__s0__ReadResponse(
    struct soap* soap, _s0__ReadResponse* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__ReadResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__ReadResponse::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__ReadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__ReadResponse* SOAP_FMAC4 soap_in__s0__ReadResponse(
    struct soap* soap, const char* tag, _s0__ReadResponse* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__ReadResponse*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__ReadResponse, sizeof(_s0__ReadResponse), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__ReadResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__ReadResponse*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag_ReadResult1 = 1, soap_flag_RItemList1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ReadResult1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReplyBase(soap, "s0:ReadResult",
                &(((_s0__ReadResponse*)a)->ReadResult), "s0:ReplyBase")) {
          soap_flag_ReadResult1--;
          continue;
        }
      if (soap_flag_RItemList1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReplyItemList(soap, "s0:RItemList",
                &(((_s0__ReadResponse*)a)->RItemList), "s0:ReplyItemList")) {
          soap_flag_RItemList1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap,
                "s0:Errors", &(((_s0__ReadResponse*)a)->Errors), "s0:OPCError"))
          continue;
      /* transient soap skipped */
      soap_check_result(soap, "s0:ReadResult");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__ReadResponse*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__ReadResponse, 0, sizeof(_s0__ReadResponse), 0,
        soap_copy__s0__ReadResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__ReadResponse* SOAP_FMAC6 soap_new__s0__ReadResponse(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__ReadResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__ReadResponse(
    struct soap* soap, _s0__ReadResponse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__ReadResponse* SOAP_FMAC4 soap_instantiate__s0__ReadResponse(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate__s0__ReadResponse(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE__s0__ReadResponse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__ReadResponse;
    if (size)
      *size = sizeof(_s0__ReadResponse);
    ((_s0__ReadResponse*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__ReadResponse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__ReadResponse);
    for (int i = 0; i < n; i++)
      ((_s0__ReadResponse*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__ReadResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__ReadResponse(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying _s0__ReadResponse %p -> %p\n", q, p));
  *(_s0__ReadResponse*)p = *(_s0__ReadResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__Read::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__Read*)this)->Options = NULL;
  ((_s0__Read*)this)->ItemList = NULL;
  /* transient soap skipped */
}

void _s0__Read::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__RequestOptions(
      soap, &((_s0__Read*)this)->Options);
  soap_serialize_PointerTos0__ReadRequestItemList(
      soap, &((_s0__Read*)this)->ItemList);
  /* transient soap skipped */
}

int _s0__Read::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__Read);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__Read::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__Read(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__Read(struct soap* soap, const char* tag,
    int id, const _s0__Read* a, const char* type)
{
  soap_element_begin_out(
      soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__Read), type);
  soap_out_PointerTos0__RequestOptions(
      soap, "s0:Options", -1, &(((_s0__Read*)a)->Options), "");
  soap_out_PointerTos0__ReadRequestItemList(
      soap, "s0:ItemList", -1, &(((_s0__Read*)a)->ItemList), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__Read::soap_get(struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__Read(soap, this, tag, type);
}

SOAP_FMAC3 _s0__Read* SOAP_FMAC4 soap_get__s0__Read(
    struct soap* soap, _s0__Read* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__Read(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__Read::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__Read(soap, tag, this, type);
}

SOAP_FMAC3 _s0__Read* SOAP_FMAC4 soap_in__s0__Read(
    struct soap* soap, const char* tag, _s0__Read* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__Read*)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__Read,
      sizeof(_s0__Read), soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__Read) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__Read*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag_Options1 = 1, soap_flag_ItemList1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__RequestOptions(soap, "s0:Options",
                &(((_s0__Read*)a)->Options), "s0:RequestOptions")) {
          soap_flag_Options1--;
          continue;
        }
      if (soap_flag_ItemList1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReadRequestItemList(soap, "s0:ItemList",
                &(((_s0__Read*)a)->ItemList), "s0:ReadRequestItemList")) {
          soap_flag_ItemList1--;
          continue;
        }
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__Read*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__Read, 0, sizeof(_s0__Read), 0, soap_copy__s0__Read);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__Read* SOAP_FMAC6 soap_new__s0__Read(struct soap* soap, int n)
{
  return soap_instantiate__s0__Read(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__Read(
    struct soap* soap, _s0__Read* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__Read* SOAP_FMAC4 soap_instantiate__s0__Read(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__Read(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE__s0__Read, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__Read;
    if (size)
      *size = sizeof(_s0__Read);
    ((_s0__Read*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__Read[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__Read);
    for (int i = 0; i < n; i++)
      ((_s0__Read*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__Read*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__Read(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__Read %p -> %p\n", q, p));
  *(_s0__Read*)p = *(_s0__Read*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__GetStatusResponse::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__GetStatusResponse*)this)->GetStatusResult = NULL;
  ((_s0__GetStatusResponse*)this)->Status = NULL;
  /* transient soap skipped */
}

void _s0__GetStatusResponse::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__ReplyBase(
      soap, &((_s0__GetStatusResponse*)this)->GetStatusResult);
  soap_serialize_PointerTos0__ServerStatus(
      soap, &((_s0__GetStatusResponse*)this)->Status);
  /* transient soap skipped */
}

int _s0__GetStatusResponse::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__GetStatusResponse);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__GetStatusResponse::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__GetStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__GetStatusResponse(struct soap* soap,
    const char* tag, int id, const _s0__GetStatusResponse* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE__s0__GetStatusResponse), type);
  if (a->GetStatusResult)
    soap_element_result(soap, "s0:GetStatusResult");
  soap_out_PointerTos0__ReplyBase(soap, "s0:GetStatusResult", -1,
      &(((_s0__GetStatusResponse*)a)->GetStatusResult), "");
  soap_out_PointerTos0__ServerStatus(
      soap, "s0:Status", -1, &(((_s0__GetStatusResponse*)a)->Status), "");
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__GetStatusResponse::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__GetStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__GetStatusResponse* SOAP_FMAC4 soap_get__s0__GetStatusResponse(
    struct soap* soap, _s0__GetStatusResponse* p, const char* tag,
    const char* type)
{
  if ((p = soap_in__s0__GetStatusResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__GetStatusResponse::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__GetStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__GetStatusResponse* SOAP_FMAC4 soap_in__s0__GetStatusResponse(
    struct soap* soap, const char* tag, _s0__GetStatusResponse* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__GetStatusResponse*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__GetStatusResponse, sizeof(_s0__GetStatusResponse),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__GetStatusResponse) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__GetStatusResponse*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag_GetStatusResult1 = 1, soap_flag_Status1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_GetStatusResult1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ReplyBase(soap, "s0:GetStatusResult",
                &(((_s0__GetStatusResponse*)a)->GetStatusResult),
                "s0:ReplyBase")) {
          soap_flag_GetStatusResult1--;
          continue;
        }
      if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ServerStatus(soap, "s0:Status",
                &(((_s0__GetStatusResponse*)a)->Status), "s0:ServerStatus")) {
          soap_flag_Status1--;
          continue;
        }
      /* transient soap skipped */
      soap_check_result(soap, "s0:GetStatusResult");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__GetStatusResponse*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__GetStatusResponse, 0, sizeof(_s0__GetStatusResponse), 0,
        soap_copy__s0__GetStatusResponse);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__GetStatusResponse* SOAP_FMAC6 soap_new__s0__GetStatusResponse(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__GetStatusResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__GetStatusResponse(
    struct soap* soap, _s0__GetStatusResponse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__GetStatusResponse* SOAP_FMAC4
soap_instantiate__s0__GetStatusResponse(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate__s0__GetStatusResponse(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE__s0__GetStatusResponse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__GetStatusResponse;
    if (size)
      *size = sizeof(_s0__GetStatusResponse);
    ((_s0__GetStatusResponse*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__GetStatusResponse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__GetStatusResponse);
    for (int i = 0; i < n; i++)
      ((_s0__GetStatusResponse*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__GetStatusResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__GetStatusResponse(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying _s0__GetStatusResponse %p -> %p\n", q, p));
  *(_s0__GetStatusResponse*)p = *(_s0__GetStatusResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__GetStatus::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((_s0__GetStatus*)this)->LocaleID = NULL;
  ((_s0__GetStatus*)this)->ClientRequestHandle = NULL;
  /* transient soap skipped */
}

void _s0__GetStatus::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int _s0__GetStatus::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__GetStatus);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int _s0__GetStatus::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out__s0__GetStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__GetStatus(struct soap* soap,
    const char* tag, int id, const _s0__GetStatus* a, const char* type)
{
  if (((_s0__GetStatus*)a)->LocaleID)
    soap_set_attr(soap, "LocaleID", ((_s0__GetStatus*)a)->LocaleID->c_str());
  if (((_s0__GetStatus*)a)->ClientRequestHandle)
    soap_set_attr(soap, "ClientRequestHandle",
        ((_s0__GetStatus*)a)->ClientRequestHandle->c_str());
  soap_element_begin_out(
      soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__GetStatus), type);
  /* transient soap skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* _s0__GetStatus::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get__s0__GetStatus(soap, this, tag, type);
}

SOAP_FMAC3 _s0__GetStatus* SOAP_FMAC4 soap_get__s0__GetStatus(
    struct soap* soap, _s0__GetStatus* p, const char* tag, const char* type)
{
  if ((p = soap_in__s0__GetStatus(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* _s0__GetStatus::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in__s0__GetStatus(soap, tag, this, type);
}

SOAP_FMAC3 _s0__GetStatus* SOAP_FMAC4 soap_in__s0__GetStatus(
    struct soap* soap, const char* tag, _s0__GetStatus* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (_s0__GetStatus*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE__s0__GetStatus, sizeof(_s0__GetStatus), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE__s0__GetStatus) {
      soap_revert(soap);
      *soap->id = '\0';
      return (_s0__GetStatus*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "LocaleID", 0);
    if (t) {
      if (!(((_s0__GetStatus*)a)->LocaleID
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__GetStatus*)a)->LocaleID = soap_new_std__string(soap, -1);
        ((_s0__GetStatus*)a)->LocaleID->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientRequestHandle", 0);
    if (t) {
      if (!(((_s0__GetStatus*)a)->ClientRequestHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((_s0__GetStatus*)a)->ClientRequestHandle
            = soap_new_std__string(soap, -1);
        ((_s0__GetStatus*)a)->ClientRequestHandle->assign(s);
      }
    }
  };
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (_s0__GetStatus*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE__s0__GetStatus, 0, sizeof(_s0__GetStatus), 0,
        soap_copy__s0__GetStatus);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 _s0__GetStatus* SOAP_FMAC6 soap_new__s0__GetStatus(
    struct soap* soap, int n)
{
  return soap_instantiate__s0__GetStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__GetStatus(
    struct soap* soap, _s0__GetStatus* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 _s0__GetStatus* SOAP_FMAC4 soap_instantiate__s0__GetStatus(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate__s0__GetStatus(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE__s0__GetStatus, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new _s0__GetStatus;
    if (size)
      *size = sizeof(_s0__GetStatus);
    ((_s0__GetStatus*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new _s0__GetStatus[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(_s0__GetStatus);
    for (int i = 0; i < n; i++)
      ((_s0__GetStatus*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (_s0__GetStatus*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__GetStatus(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__GetStatus %p -> %p\n", q, p));
  *(_s0__GetStatus*)p = *(_s0__GetStatus*)q;
}
#ifdef __cplusplus
}
#endif

void s0__PropertyReplyList::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTos0__ItemProperty(
      soap, &((s0__PropertyReplyList*)this)->Properties);
  ((s0__PropertyReplyList*)this)->ItemPath = NULL;
  ((s0__PropertyReplyList*)this)->ItemName = NULL;
  ((s0__PropertyReplyList*)this)->ResultID = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__PropertyReplyList::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTos0__ItemProperty(
      soap, &((s0__PropertyReplyList*)this)->Properties);
  /* transient soap skipped */
}

int s0__PropertyReplyList::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__PropertyReplyList);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__PropertyReplyList::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__PropertyReplyList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__PropertyReplyList(struct soap* soap,
    const char* tag, int id, const s0__PropertyReplyList* a, const char* type)
{
  if (((s0__PropertyReplyList*)a)->ItemPath)
    soap_set_attr(
        soap, "ItemPath", ((s0__PropertyReplyList*)a)->ItemPath->c_str());
  if (((s0__PropertyReplyList*)a)->ItemName)
    soap_set_attr(
        soap, "ItemName", ((s0__PropertyReplyList*)a)->ItemName->c_str());
  if (((s0__PropertyReplyList*)a)->ResultID)
    soap_set_attr(soap, "ResultID",
        soap_QName2s(soap, ((s0__PropertyReplyList*)a)->ResultID->c_str()));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__PropertyReplyList),
      "s0:PropertyReplyList");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfPointerTos0__ItemProperty(soap, "s0:Properties",
      -1, &(((s0__PropertyReplyList*)a)->Properties), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__PropertyReplyList::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__PropertyReplyList(soap, this, tag, type);
}

SOAP_FMAC3 s0__PropertyReplyList* SOAP_FMAC4 soap_get_s0__PropertyReplyList(
    struct soap* soap, s0__PropertyReplyList* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__PropertyReplyList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__PropertyReplyList::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__PropertyReplyList(soap, tag, this, type);
}

SOAP_FMAC3 s0__PropertyReplyList* SOAP_FMAC4 soap_in_s0__PropertyReplyList(
    struct soap* soap, const char* tag, s0__PropertyReplyList* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__PropertyReplyList*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__PropertyReplyList, sizeof(s0__PropertyReplyList),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__PropertyReplyList) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__PropertyReplyList*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__PropertyReplyList*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__PropertyReplyList*)a)->ItemPath = soap_new_std__string(soap, -1);
        ((s0__PropertyReplyList*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemName", 0);
    if (t) {
      if (!(((s0__PropertyReplyList*)a)->ItemName
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__PropertyReplyList*)a)->ItemName = soap_new_std__string(soap, -1);
        ((s0__PropertyReplyList*)a)->ItemName->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ResultID", 0);
    if (t) {
      if (!(((s0__PropertyReplyList*)a)->ResultID
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__PropertyReplyList*)a)->ResultID = soap_new_std__string(soap, -1);
        ((s0__PropertyReplyList*)a)->ResultID->assign(s);
      }
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__ItemProperty(soap,
                "s0:Properties", &(((s0__PropertyReplyList*)a)->Properties),
                "s0:ItemProperty"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__PropertyReplyList*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__PropertyReplyList, 0, sizeof(s0__PropertyReplyList), 0,
        soap_copy_s0__PropertyReplyList);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__PropertyReplyList* SOAP_FMAC6 soap_new_s0__PropertyReplyList(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__PropertyReplyList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__PropertyReplyList(
    struct soap* soap, s0__PropertyReplyList* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__PropertyReplyList* SOAP_FMAC4
soap_instantiate_s0__PropertyReplyList(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__PropertyReplyList(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__PropertyReplyList, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__PropertyReplyList;
    if (size)
      *size = sizeof(s0__PropertyReplyList);
    ((s0__PropertyReplyList*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__PropertyReplyList[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__PropertyReplyList);
    for (int i = 0; i < n; i++)
      ((s0__PropertyReplyList*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__PropertyReplyList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__PropertyReplyList(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__PropertyReplyList %p -> %p\n", q, p));
  *(s0__PropertyReplyList*)p = *(s0__PropertyReplyList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ItemIdentifier::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__ItemIdentifier*)this)->ItemPath = NULL;
  ((s0__ItemIdentifier*)this)->ItemName = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ItemIdentifier::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int s0__ItemIdentifier::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ItemIdentifier);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ItemIdentifier::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ItemIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ItemIdentifier(struct soap* soap,
    const char* tag, int id, const s0__ItemIdentifier* a, const char* type)
{
  if (((s0__ItemIdentifier*)a)->ItemPath)
    soap_set_attr(
        soap, "ItemPath", ((s0__ItemIdentifier*)a)->ItemPath->c_str());
  if (((s0__ItemIdentifier*)a)->ItemName)
    soap_set_attr(
        soap, "ItemName", ((s0__ItemIdentifier*)a)->ItemName->c_str());
  return soap_outliteral(
      soap, tag, &(((xsd__anyType*)a)->__item), "s0:ItemIdentifier");
}

void* s0__ItemIdentifier::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ItemIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 s0__ItemIdentifier* SOAP_FMAC4 soap_get_s0__ItemIdentifier(
    struct soap* soap, s0__ItemIdentifier* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ItemIdentifier(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ItemIdentifier::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ItemIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 s0__ItemIdentifier* SOAP_FMAC4 soap_in_s0__ItemIdentifier(
    struct soap* soap, const char* tag, s0__ItemIdentifier* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__ItemIdentifier*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__ItemIdentifier, sizeof(s0__ItemIdentifier),
            soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ItemIdentifier)
      return (s0__ItemIdentifier*)a->soap_in(soap, tag, type);
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__ItemIdentifier*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemIdentifier*)a)->ItemPath = soap_new_std__string(soap, -1);
        ((s0__ItemIdentifier*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemName", 0);
    if (t) {
      if (!(((s0__ItemIdentifier*)a)->ItemName
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemIdentifier*)a)->ItemName = soap_new_std__string(soap, -1);
        ((s0__ItemIdentifier*)a)->ItemName->assign(s);
      }
    }
  }
  if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__ItemIdentifier* SOAP_FMAC6 soap_new_s0__ItemIdentifier(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ItemIdentifier(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ItemIdentifier(
    struct soap* soap, s0__ItemIdentifier* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ItemIdentifier* SOAP_FMAC4 soap_instantiate_s0__ItemIdentifier(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ItemIdentifier(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ItemIdentifier, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ItemIdentifier;
    if (size)
      *size = sizeof(s0__ItemIdentifier);
    ((s0__ItemIdentifier*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ItemIdentifier[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ItemIdentifier);
    for (int i = 0; i < n; i++)
      ((s0__ItemIdentifier*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ItemIdentifier*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ItemIdentifier(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__ItemIdentifier %p -> %p\n", q, p));
  *(s0__ItemIdentifier*)p = *(s0__ItemIdentifier*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ItemProperty::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__ItemProperty*)this)->Value = NULL;
  soap_default_xsd__QName(soap, &((s0__ItemProperty*)this)->Name);
  ((s0__ItemProperty*)this)->Description = NULL;
  ((s0__ItemProperty*)this)->ItemPath = NULL;
  ((s0__ItemProperty*)this)->ItemName = NULL;
  ((s0__ItemProperty*)this)->ResultID = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ItemProperty::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerToxsd__anyType(soap, &((s0__ItemProperty*)this)->Value);
  /* transient soap skipped */
}

int s0__ItemProperty::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ItemProperty);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ItemProperty::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ItemProperty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ItemProperty(struct soap* soap,
    const char* tag, int id, const s0__ItemProperty* a, const char* type)
{
  if (!((s0__ItemProperty*)a)->Name.empty())
    soap_set_attr(
        soap, "Name", soap_QName2s(soap, ((s0__ItemProperty*)a)->Name.c_str()));
  if (((s0__ItemProperty*)a)->Description)
    soap_set_attr(
        soap, "Description", ((s0__ItemProperty*)a)->Description->c_str());
  if (((s0__ItemProperty*)a)->ItemPath)
    soap_set_attr(soap, "ItemPath", ((s0__ItemProperty*)a)->ItemPath->c_str());
  if (((s0__ItemProperty*)a)->ItemName)
    soap_set_attr(soap, "ItemName", ((s0__ItemProperty*)a)->ItemName->c_str());
  if (((s0__ItemProperty*)a)->ResultID)
    soap_set_attr(soap, "ResultID",
        soap_QName2s(soap, ((s0__ItemProperty*)a)->ResultID->c_str()));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ItemProperty),
      "s0:ItemProperty");
  /* transient soap skipped */
  soap_out_PointerToxsd__anyType(
      soap, "s0:Value", -1, &(((s0__ItemProperty*)a)->Value), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ItemProperty::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ItemProperty(soap, this, tag, type);
}

SOAP_FMAC3 s0__ItemProperty* SOAP_FMAC4 soap_get_s0__ItemProperty(
    struct soap* soap, s0__ItemProperty* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ItemProperty(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ItemProperty::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ItemProperty(soap, tag, this, type);
}

SOAP_FMAC3 s0__ItemProperty* SOAP_FMAC4 soap_in_s0__ItemProperty(
    struct soap* soap, const char* tag, s0__ItemProperty* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ItemProperty*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ItemProperty, sizeof(s0__ItemProperty), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ItemProperty) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ItemProperty*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "Name", 1);
    if (t) {
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      ((s0__ItemProperty*)a)->Name.assign(s);
    }
  }
  {
    const char* t = soap_attr_value(soap, "Description", 0);
    if (t) {
      if (!(((s0__ItemProperty*)a)->Description
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemProperty*)a)->Description = soap_new_std__string(soap, -1);
        ((s0__ItemProperty*)a)->Description->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__ItemProperty*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemProperty*)a)->ItemPath = soap_new_std__string(soap, -1);
        ((s0__ItemProperty*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemName", 0);
    if (t) {
      if (!(((s0__ItemProperty*)a)->ItemName
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemProperty*)a)->ItemName = soap_new_std__string(soap, -1);
        ((s0__ItemProperty*)a)->ItemName->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ResultID", 0);
    if (t) {
      if (!(((s0__ItemProperty*)a)->ResultID
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemProperty*)a)->ResultID = soap_new_std__string(soap, -1);
        ((s0__ItemProperty*)a)->ResultID->assign(s);
      }
    }
  }
  short soap_flag___item2 = 1, soap_flag_Value1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxsd__anyType(soap, "s0:Value",
                &(((s0__ItemProperty*)a)->Value), "xsd:anyType")) {
          soap_flag_Value1--;
          continue;
        }
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ItemProperty*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ItemProperty, 0, sizeof(s0__ItemProperty), 0,
        soap_copy_s0__ItemProperty);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ItemProperty* SOAP_FMAC6 soap_new_s0__ItemProperty(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ItemProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ItemProperty(
    struct soap* soap, s0__ItemProperty* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ItemProperty* SOAP_FMAC4 soap_instantiate_s0__ItemProperty(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ItemProperty(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ItemProperty, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ItemProperty;
    if (size)
      *size = sizeof(s0__ItemProperty);
    ((s0__ItemProperty*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ItemProperty[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ItemProperty);
    for (int i = 0; i < n; i++)
      ((s0__ItemProperty*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ItemProperty*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ItemProperty(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__ItemProperty %p -> %p\n", q, p));
  *(s0__ItemProperty*)p = *(s0__ItemProperty*)q;
}
#ifdef __cplusplus
}
#endif

void s0__BrowseElement::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTos0__ItemProperty(
      soap, &((s0__BrowseElement*)this)->Properties);
  ((s0__BrowseElement*)this)->Name = NULL;
  ((s0__BrowseElement*)this)->ItemPath = NULL;
  ((s0__BrowseElement*)this)->ItemName = NULL;
  soap_default_bool(soap, &((s0__BrowseElement*)this)->IsItem);
  soap_default_bool(soap, &((s0__BrowseElement*)this)->HasChildren);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__BrowseElement::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTos0__ItemProperty(
      soap, &((s0__BrowseElement*)this)->Properties);
  /* transient soap skipped */
}

int s0__BrowseElement::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__BrowseElement);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__BrowseElement::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__BrowseElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__BrowseElement(struct soap* soap,
    const char* tag, int id, const s0__BrowseElement* a, const char* type)
{
  if (((s0__BrowseElement*)a)->Name)
    soap_set_attr(soap, "Name", ((s0__BrowseElement*)a)->Name->c_str());
  if (((s0__BrowseElement*)a)->ItemPath)
    soap_set_attr(soap, "ItemPath", ((s0__BrowseElement*)a)->ItemPath->c_str());
  if (((s0__BrowseElement*)a)->ItemName)
    soap_set_attr(soap, "ItemName", ((s0__BrowseElement*)a)->ItemName->c_str());
  soap_set_attr(
      soap, "IsItem", soap_bool2s(soap, ((s0__BrowseElement*)a)->IsItem));
  soap_set_attr(soap, "HasChildren",
      soap_bool2s(soap, ((s0__BrowseElement*)a)->HasChildren));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__BrowseElement),
      "s0:BrowseElement");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfPointerTos0__ItemProperty(
      soap, "s0:Properties", -1, &(((s0__BrowseElement*)a)->Properties), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__BrowseElement::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__BrowseElement(soap, this, tag, type);
}

SOAP_FMAC3 s0__BrowseElement* SOAP_FMAC4 soap_get_s0__BrowseElement(
    struct soap* soap, s0__BrowseElement* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__BrowseElement(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__BrowseElement::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__BrowseElement(soap, tag, this, type);
}

SOAP_FMAC3 s0__BrowseElement* SOAP_FMAC4 soap_in_s0__BrowseElement(
    struct soap* soap, const char* tag, s0__BrowseElement* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__BrowseElement*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__BrowseElement, sizeof(s0__BrowseElement), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__BrowseElement) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__BrowseElement*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "Name", 0);
    if (t) {
      if (!(((s0__BrowseElement*)a)->Name
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__BrowseElement*)a)->Name = soap_new_std__string(soap, -1);
        ((s0__BrowseElement*)a)->Name->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__BrowseElement*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__BrowseElement*)a)->ItemPath = soap_new_std__string(soap, -1);
        ((s0__BrowseElement*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemName", 0);
    if (t) {
      if (!(((s0__BrowseElement*)a)->ItemName
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__BrowseElement*)a)->ItemName = soap_new_std__string(soap, -1);
        ((s0__BrowseElement*)a)->ItemName->assign(s);
      }
    }
  }
  if (soap_s2bool(soap, soap_attr_value(soap, "IsItem", 1),
          &((s0__BrowseElement*)a)->IsItem))
    return NULL;
  if (soap_s2bool(soap, soap_attr_value(soap, "HasChildren", 1),
          &((s0__BrowseElement*)a)->HasChildren))
    return NULL;
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__ItemProperty(soap,
                "s0:Properties", &(((s0__BrowseElement*)a)->Properties),
                "s0:ItemProperty"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__BrowseElement*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__BrowseElement, 0, sizeof(s0__BrowseElement), 0,
        soap_copy_s0__BrowseElement);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__BrowseElement* SOAP_FMAC6 soap_new_s0__BrowseElement(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__BrowseElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__BrowseElement(
    struct soap* soap, s0__BrowseElement* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__BrowseElement* SOAP_FMAC4 soap_instantiate_s0__BrowseElement(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__BrowseElement(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__BrowseElement, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__BrowseElement;
    if (size)
      *size = sizeof(s0__BrowseElement);
    ((s0__BrowseElement*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__BrowseElement[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__BrowseElement);
    for (int i = 0; i < n; i++)
      ((s0__BrowseElement*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__BrowseElement*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__BrowseElement(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__BrowseElement %p -> %p\n", q, p));
  *(s0__BrowseElement*)p = *(s0__BrowseElement*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribePolledRefreshReplyItemList::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTos0__ItemValue(
      soap, &((s0__SubscribePolledRefreshReplyItemList*)this)->Items);
  ((s0__SubscribePolledRefreshReplyItemList*)this)->SubscriptionHandle = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__SubscribePolledRefreshReplyItemList::soap_serialize(
    struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTos0__ItemValue(
      soap, &((s0__SubscribePolledRefreshReplyItemList*)this)->Items);
  /* transient soap skipped */
}

int s0__SubscribePolledRefreshReplyItemList::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(soap, (void*)this, NULL, 0, tag,
      SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__SubscribePolledRefreshReplyItemList::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__SubscribePolledRefreshReplyItemList(
      soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, const char* tag, int id,
    const s0__SubscribePolledRefreshReplyItemList* a, const char* type)
{
  if (((s0__SubscribePolledRefreshReplyItemList*)a)->SubscriptionHandle)
    soap_set_attr(soap, "SubscriptionHandle",
        ((s0__SubscribePolledRefreshReplyItemList*)a)
            ->SubscriptionHandle->c_str());
  soap_element_begin_out(soap, tag,
      soap_embedded_id(
          soap, id, a, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList),
      "s0:SubscribePolledRefreshReplyItemList");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfPointerTos0__ItemValue(soap, "s0:Items", -1,
      &(((s0__SubscribePolledRefreshReplyItemList*)a)->Items), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__SubscribePolledRefreshReplyItemList::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__SubscribePolledRefreshReplyItemList(
      soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList* SOAP_FMAC4
soap_get_s0__SubscribePolledRefreshReplyItemList(struct soap* soap,
    s0__SubscribePolledRefreshReplyItemList* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__SubscribePolledRefreshReplyItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__SubscribePolledRefreshReplyItemList::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__SubscribePolledRefreshReplyItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList* SOAP_FMAC4
soap_in_s0__SubscribePolledRefreshReplyItemList(struct soap* soap,
    const char* tag, s0__SubscribePolledRefreshReplyItemList* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__SubscribePolledRefreshReplyItemList*)soap_class_id_enter(soap,
      soap->id, a, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList,
      sizeof(s0__SubscribePolledRefreshReplyItemList), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type
        != SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__SubscribePolledRefreshReplyItemList*)a->soap_in(
          soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "SubscriptionHandle", 0);
    if (t) {
      if (!(((s0__SubscribePolledRefreshReplyItemList*)a)->SubscriptionHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__SubscribePolledRefreshReplyItemList*)a)->SubscriptionHandle
            = soap_new_std__string(soap, -1);
        ((s0__SubscribePolledRefreshReplyItemList*)a)
            ->SubscriptionHandle->assign(s);
      }
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__ItemValue(soap,
                "s0:Items",
                &(((s0__SubscribePolledRefreshReplyItemList*)a)->Items),
                "s0:ItemValue"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__SubscribePolledRefreshReplyItemList*)soap_id_forward(soap,
        soap->href, (void*)a, 0,
        SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList, 0,
        sizeof(s0__SubscribePolledRefreshReplyItemList), 0,
        soap_copy_s0__SubscribePolledRefreshReplyItemList);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__SubscribePolledRefreshReplyItemList* SOAP_FMAC6
soap_new_s0__SubscribePolledRefreshReplyItemList(struct soap* soap, int n)
{
  return soap_instantiate_s0__SubscribePolledRefreshReplyItemList(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, s0__SubscribePolledRefreshReplyItemList* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList* SOAP_FMAC4
soap_instantiate_s0__SubscribePolledRefreshReplyItemList(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__"
                           "SubscribePolledRefreshReplyItemList(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__SubscribePolledRefreshReplyItemList;
    if (size)
      *size = sizeof(s0__SubscribePolledRefreshReplyItemList);
    ((s0__SubscribePolledRefreshReplyItemList*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__SubscribePolledRefreshReplyItemList[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__SubscribePolledRefreshReplyItemList);
    for (int i = 0; i < n; i++)
      ((s0__SubscribePolledRefreshReplyItemList*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__SubscribePolledRefreshReplyItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "Copying s0__SubscribePolledRefreshReplyItemList %p -> %p\n", q, p));
  *(s0__SubscribePolledRefreshReplyItemList*)p
      = *(s0__SubscribePolledRefreshReplyItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribeItemValue::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__SubscribeItemValue*)this)->ItemValue = NULL;
  ((s0__SubscribeItemValue*)this)->RevisedSamplingRate = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__SubscribeItemValue::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTos0__ItemValue(
      soap, &((s0__SubscribeItemValue*)this)->ItemValue);
  /* transient soap skipped */
}

int s0__SubscribeItemValue::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__SubscribeItemValue);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__SubscribeItemValue::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__SubscribeItemValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribeItemValue(struct soap* soap,
    const char* tag, int id, const s0__SubscribeItemValue* a, const char* type)
{
  if (((s0__SubscribeItemValue*)a)->RevisedSamplingRate)
    soap_set_attr(soap, "RevisedSamplingRate",
        soap_int2s(soap, *((s0__SubscribeItemValue*)a)->RevisedSamplingRate));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__SubscribeItemValue),
      "s0:SubscribeItemValue");
  /* transient soap skipped */
  soap_out_PointerTos0__ItemValue(
      soap, "s0:ItemValue", -1, &(((s0__SubscribeItemValue*)a)->ItemValue), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__SubscribeItemValue::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__SubscribeItemValue(soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribeItemValue* SOAP_FMAC4 soap_get_s0__SubscribeItemValue(
    struct soap* soap, s0__SubscribeItemValue* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__SubscribeItemValue(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__SubscribeItemValue::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__SubscribeItemValue(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribeItemValue* SOAP_FMAC4 soap_in_s0__SubscribeItemValue(
    struct soap* soap, const char* tag, s0__SubscribeItemValue* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__SubscribeItemValue*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__SubscribeItemValue, sizeof(s0__SubscribeItemValue),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__SubscribeItemValue) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__SubscribeItemValue*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "RevisedSamplingRate", 0);
    if (t) {
      if (!(((s0__SubscribeItemValue*)a)->RevisedSamplingRate
              = (int*)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(
              soap, t, ((s0__SubscribeItemValue*)a)->RevisedSamplingRate))
        return NULL;
    }
  }
  short soap_flag___item2 = 1, soap_flag_ItemValue1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_ItemValue1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__ItemValue(soap, "s0:ItemValue",
                &(((s0__SubscribeItemValue*)a)->ItemValue), "s0:ItemValue")) {
          soap_flag_ItemValue1--;
          continue;
        }
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__SubscribeItemValue*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__SubscribeItemValue, 0, sizeof(s0__SubscribeItemValue), 0,
        soap_copy_s0__SubscribeItemValue);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__SubscribeItemValue* SOAP_FMAC6 soap_new_s0__SubscribeItemValue(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__SubscribeItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribeItemValue(
    struct soap* soap, s0__SubscribeItemValue* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribeItemValue* SOAP_FMAC4
soap_instantiate_s0__SubscribeItemValue(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__SubscribeItemValue(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_s0__SubscribeItemValue, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__SubscribeItemValue;
    if (size)
      *size = sizeof(s0__SubscribeItemValue);
    ((s0__SubscribeItemValue*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__SubscribeItemValue[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__SubscribeItemValue);
    for (int i = 0; i < n; i++)
      ((s0__SubscribeItemValue*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__SubscribeItemValue*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribeItemValue(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__SubscribeItemValue %p -> %p\n", q, p));
  *(s0__SubscribeItemValue*)p = *(s0__SubscribeItemValue*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribeReplyItemList::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
      soap, &((s0__SubscribeReplyItemList*)this)->Items);
  ((s0__SubscribeReplyItemList*)this)->RevisedSamplingRate = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__SubscribeReplyItemList::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
      soap, &((s0__SubscribeReplyItemList*)this)->Items);
  /* transient soap skipped */
}

int s0__SubscribeReplyItemList::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__SubscribeReplyItemList);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__SubscribeReplyItemList::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__SubscribeReplyItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribeReplyItemList(struct soap* soap,
    const char* tag, int id, const s0__SubscribeReplyItemList* a,
    const char* type)
{
  if (((s0__SubscribeReplyItemList*)a)->RevisedSamplingRate)
    soap_set_attr(soap, "RevisedSamplingRate",
        soap_int2s(
            soap, *((s0__SubscribeReplyItemList*)a)->RevisedSamplingRate));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__SubscribeReplyItemList),
      "s0:SubscribeReplyItemList");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
      soap, "s0:Items", -1, &(((s0__SubscribeReplyItemList*)a)->Items), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__SubscribeReplyItemList::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__SubscribeReplyItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribeReplyItemList* SOAP_FMAC4
soap_get_s0__SubscribeReplyItemList(struct soap* soap,
    s0__SubscribeReplyItemList* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__SubscribeReplyItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__SubscribeReplyItemList::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__SubscribeReplyItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribeReplyItemList* SOAP_FMAC4
soap_in_s0__SubscribeReplyItemList(struct soap* soap, const char* tag,
    s0__SubscribeReplyItemList* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__SubscribeReplyItemList*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__SubscribeReplyItemList, sizeof(s0__SubscribeReplyItemList),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__SubscribeReplyItemList) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__SubscribeReplyItemList*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "RevisedSamplingRate", 0);
    if (t) {
      if (!(((s0__SubscribeReplyItemList*)a)->RevisedSamplingRate
              = (int*)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(
              soap, t, ((s0__SubscribeReplyItemList*)a)->RevisedSamplingRate))
        return NULL;
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__SubscribeItemValue(soap,
                "s0:Items", &(((s0__SubscribeReplyItemList*)a)->Items),
                "s0:SubscribeItemValue"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__SubscribeReplyItemList*)soap_id_forward(soap, soap->href, (void*)a,
        0, SOAP_TYPE_s0__SubscribeReplyItemList, 0,
        sizeof(s0__SubscribeReplyItemList), 0,
        soap_copy_s0__SubscribeReplyItemList);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__SubscribeReplyItemList* SOAP_FMAC6
soap_new_s0__SubscribeReplyItemList(struct soap* soap, int n)
{
  return soap_instantiate_s0__SubscribeReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribeReplyItemList(
    struct soap* soap, s0__SubscribeReplyItemList* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribeReplyItemList* SOAP_FMAC4
soap_instantiate_s0__SubscribeReplyItemList(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__SubscribeReplyItemList(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_s0__SubscribeReplyItemList, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__SubscribeReplyItemList;
    if (size)
      *size = sizeof(s0__SubscribeReplyItemList);
    ((s0__SubscribeReplyItemList*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__SubscribeReplyItemList[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__SubscribeReplyItemList);
    for (int i = 0; i < n; i++)
      ((s0__SubscribeReplyItemList*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__SubscribeReplyItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribeReplyItemList(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying s0__SubscribeReplyItemList %p -> %p\n", q, p));
  *(s0__SubscribeReplyItemList*)p = *(s0__SubscribeReplyItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribeRequestItem::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__SubscribeRequestItem*)this)->ItemPath = NULL;
  ((s0__SubscribeRequestItem*)this)->ReqType = NULL;
  ((s0__SubscribeRequestItem*)this)->ItemName = NULL;
  ((s0__SubscribeRequestItem*)this)->ClientItemHandle = NULL;
  ((s0__SubscribeRequestItem*)this)->Deadband = NULL;
  ((s0__SubscribeRequestItem*)this)->RequestedSamplingRate = NULL;
  ((s0__SubscribeRequestItem*)this)->EnableBuffering = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__SubscribeRequestItem::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int s0__SubscribeRequestItem::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__SubscribeRequestItem);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__SubscribeRequestItem::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__SubscribeRequestItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribeRequestItem(struct soap* soap,
    const char* tag, int id, const s0__SubscribeRequestItem* a,
    const char* type)
{
  if (((s0__SubscribeRequestItem*)a)->ItemPath)
    soap_set_attr(
        soap, "ItemPath", ((s0__SubscribeRequestItem*)a)->ItemPath->c_str());
  if (((s0__SubscribeRequestItem*)a)->ReqType)
    soap_set_attr(soap, "ReqType",
        soap_QName2s(soap, ((s0__SubscribeRequestItem*)a)->ReqType->c_str()));
  if (((s0__SubscribeRequestItem*)a)->ItemName)
    soap_set_attr(
        soap, "ItemName", ((s0__SubscribeRequestItem*)a)->ItemName->c_str());
  if (((s0__SubscribeRequestItem*)a)->ClientItemHandle)
    soap_set_attr(soap, "ClientItemHandle",
        ((s0__SubscribeRequestItem*)a)->ClientItemHandle->c_str());
  if (((s0__SubscribeRequestItem*)a)->Deadband)
    soap_set_attr(soap, "Deadband",
        soap_float2s(soap, *((s0__SubscribeRequestItem*)a)->Deadband));
  if (((s0__SubscribeRequestItem*)a)->RequestedSamplingRate)
    soap_set_attr(soap, "RequestedSamplingRate",
        soap_int2s(
            soap, *((s0__SubscribeRequestItem*)a)->RequestedSamplingRate));
  if (((s0__SubscribeRequestItem*)a)->EnableBuffering)
    soap_set_attr(soap, "EnableBuffering",
        soap_bool2s(soap, *((s0__SubscribeRequestItem*)a)->EnableBuffering));
  return soap_outliteral(
      soap, tag, &(((xsd__anyType*)a)->__item), "s0:SubscribeRequestItem");
}

void* s0__SubscribeRequestItem::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__SubscribeRequestItem(soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribeRequestItem* SOAP_FMAC4
soap_get_s0__SubscribeRequestItem(struct soap* soap,
    s0__SubscribeRequestItem* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__SubscribeRequestItem(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__SubscribeRequestItem::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__SubscribeRequestItem(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribeRequestItem* SOAP_FMAC4
soap_in_s0__SubscribeRequestItem(struct soap* soap, const char* tag,
    s0__SubscribeRequestItem* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__SubscribeRequestItem*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__SubscribeRequestItem,
            sizeof(s0__SubscribeRequestItem), soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__SubscribeRequestItem)
      return (s0__SubscribeRequestItem*)a->soap_in(soap, tag, type);
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItem*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__SubscribeRequestItem*)a)->ItemPath
            = soap_new_std__string(soap, -1);
        ((s0__SubscribeRequestItem*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReqType", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItem*)a)->ReqType
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__SubscribeRequestItem*)a)->ReqType
            = soap_new_std__string(soap, -1);
        ((s0__SubscribeRequestItem*)a)->ReqType->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemName", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItem*)a)->ItemName
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__SubscribeRequestItem*)a)->ItemName
            = soap_new_std__string(soap, -1);
        ((s0__SubscribeRequestItem*)a)->ItemName->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientItemHandle", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItem*)a)->ClientItemHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__SubscribeRequestItem*)a)->ClientItemHandle
            = soap_new_std__string(soap, -1);
        ((s0__SubscribeRequestItem*)a)->ClientItemHandle->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "Deadband", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItem*)a)->Deadband
              = (float*)soap_malloc(soap, sizeof(float)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2float(soap, t, ((s0__SubscribeRequestItem*)a)->Deadband))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "RequestedSamplingRate", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItem*)a)->RequestedSamplingRate
              = (int*)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(
              soap, t, ((s0__SubscribeRequestItem*)a)->RequestedSamplingRate))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "EnableBuffering", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItem*)a)->EnableBuffering
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((s0__SubscribeRequestItem*)a)->EnableBuffering))
        return NULL;
    }
  }
  if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__SubscribeRequestItem* SOAP_FMAC6
soap_new_s0__SubscribeRequestItem(struct soap* soap, int n)
{
  return soap_instantiate_s0__SubscribeRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribeRequestItem(
    struct soap* soap, s0__SubscribeRequestItem* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribeRequestItem* SOAP_FMAC4
soap_instantiate_s0__SubscribeRequestItem(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__SubscribeRequestItem(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_s0__SubscribeRequestItem, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__SubscribeRequestItem;
    if (size)
      *size = sizeof(s0__SubscribeRequestItem);
    ((s0__SubscribeRequestItem*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__SubscribeRequestItem[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__SubscribeRequestItem);
    for (int i = 0; i < n; i++)
      ((s0__SubscribeRequestItem*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__SubscribeRequestItem*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribeRequestItem(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying s0__SubscribeRequestItem %p -> %p\n", q, p));
  *(s0__SubscribeRequestItem*)p = *(s0__SubscribeRequestItem*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribeRequestItemList::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
      soap, &((s0__SubscribeRequestItemList*)this)->Items);
  ((s0__SubscribeRequestItemList*)this)->ItemPath = NULL;
  ((s0__SubscribeRequestItemList*)this)->ReqType = NULL;
  ((s0__SubscribeRequestItemList*)this)->Deadband = NULL;
  ((s0__SubscribeRequestItemList*)this)->RequestedSamplingRate = NULL;
  ((s0__SubscribeRequestItemList*)this)->EnableBuffering = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__SubscribeRequestItemList::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
      soap, &((s0__SubscribeRequestItemList*)this)->Items);
  /* transient soap skipped */
}

int s0__SubscribeRequestItemList::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__SubscribeRequestItemList);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__SubscribeRequestItemList::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__SubscribeRequestItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribeRequestItemList(
    struct soap* soap, const char* tag, int id,
    const s0__SubscribeRequestItemList* a, const char* type)
{
  if (((s0__SubscribeRequestItemList*)a)->ItemPath)
    soap_set_attr(soap, "ItemPath",
        ((s0__SubscribeRequestItemList*)a)->ItemPath->c_str());
  if (((s0__SubscribeRequestItemList*)a)->ReqType)
    soap_set_attr(soap, "ReqType",
        soap_QName2s(
            soap, ((s0__SubscribeRequestItemList*)a)->ReqType->c_str()));
  if (((s0__SubscribeRequestItemList*)a)->Deadband)
    soap_set_attr(soap, "Deadband",
        soap_float2s(soap, *((s0__SubscribeRequestItemList*)a)->Deadband));
  if (((s0__SubscribeRequestItemList*)a)->RequestedSamplingRate)
    soap_set_attr(soap, "RequestedSamplingRate",
        soap_int2s(
            soap, *((s0__SubscribeRequestItemList*)a)->RequestedSamplingRate));
  if (((s0__SubscribeRequestItemList*)a)->EnableBuffering)
    soap_set_attr(soap, "EnableBuffering",
        soap_bool2s(
            soap, *((s0__SubscribeRequestItemList*)a)->EnableBuffering));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__SubscribeRequestItemList),
      "s0:SubscribeRequestItemList");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
      soap, "s0:Items", -1, &(((s0__SubscribeRequestItemList*)a)->Items), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__SubscribeRequestItemList::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__SubscribeRequestItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribeRequestItemList* SOAP_FMAC4
soap_get_s0__SubscribeRequestItemList(struct soap* soap,
    s0__SubscribeRequestItemList* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__SubscribeRequestItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__SubscribeRequestItemList::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__SubscribeRequestItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribeRequestItemList* SOAP_FMAC4
soap_in_s0__SubscribeRequestItemList(struct soap* soap, const char* tag,
    s0__SubscribeRequestItemList* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__SubscribeRequestItemList*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__SubscribeRequestItemList,
      sizeof(s0__SubscribeRequestItemList), soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__SubscribeRequestItemList) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__SubscribeRequestItemList*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItemList*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__SubscribeRequestItemList*)a)->ItemPath
            = soap_new_std__string(soap, -1);
        ((s0__SubscribeRequestItemList*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReqType", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItemList*)a)->ReqType
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__SubscribeRequestItemList*)a)->ReqType
            = soap_new_std__string(soap, -1);
        ((s0__SubscribeRequestItemList*)a)->ReqType->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "Deadband", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItemList*)a)->Deadband
              = (float*)soap_malloc(soap, sizeof(float)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2float(soap, t, ((s0__SubscribeRequestItemList*)a)->Deadband))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "RequestedSamplingRate", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItemList*)a)->RequestedSamplingRate
              = (int*)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(soap, t,
              ((s0__SubscribeRequestItemList*)a)->RequestedSamplingRate))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "EnableBuffering", 0);
    if (t) {
      if (!(((s0__SubscribeRequestItemList*)a)->EnableBuffering
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(
              soap, t, ((s0__SubscribeRequestItemList*)a)->EnableBuffering))
        return NULL;
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(soap,
                "s0:Items", &(((s0__SubscribeRequestItemList*)a)->Items),
                "s0:SubscribeRequestItem"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__SubscribeRequestItemList*)soap_id_forward(soap, soap->href,
        (void*)a, 0, SOAP_TYPE_s0__SubscribeRequestItemList, 0,
        sizeof(s0__SubscribeRequestItemList), 0,
        soap_copy_s0__SubscribeRequestItemList);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__SubscribeRequestItemList* SOAP_FMAC6
soap_new_s0__SubscribeRequestItemList(struct soap* soap, int n)
{
  return soap_instantiate_s0__SubscribeRequestItemList(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribeRequestItemList(
    struct soap* soap, s0__SubscribeRequestItemList* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribeRequestItemList* SOAP_FMAC4
soap_instantiate_s0__SubscribeRequestItemList(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug,
                "soap_instantiate_s0__SubscribeRequestItemList(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_s0__SubscribeRequestItemList, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__SubscribeRequestItemList;
    if (size)
      *size = sizeof(s0__SubscribeRequestItemList);
    ((s0__SubscribeRequestItemList*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__SubscribeRequestItemList[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__SubscribeRequestItemList);
    for (int i = 0; i < n; i++)
      ((s0__SubscribeRequestItemList*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__SubscribeRequestItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribeRequestItemList(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying s0__SubscribeRequestItemList %p -> %p\n", q, p));
  *(s0__SubscribeRequestItemList*)p = *(s0__SubscribeRequestItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__WriteRequestItemList::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTos0__ItemValue(
      soap, &((s0__WriteRequestItemList*)this)->Items);
  ((s0__WriteRequestItemList*)this)->ItemPath = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__WriteRequestItemList::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTos0__ItemValue(
      soap, &((s0__WriteRequestItemList*)this)->Items);
  /* transient soap skipped */
}

int s0__WriteRequestItemList::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__WriteRequestItemList);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__WriteRequestItemList::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__WriteRequestItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__WriteRequestItemList(struct soap* soap,
    const char* tag, int id, const s0__WriteRequestItemList* a,
    const char* type)
{
  if (((s0__WriteRequestItemList*)a)->ItemPath)
    soap_set_attr(
        soap, "ItemPath", ((s0__WriteRequestItemList*)a)->ItemPath->c_str());
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__WriteRequestItemList),
      "s0:WriteRequestItemList");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfPointerTos0__ItemValue(
      soap, "s0:Items", -1, &(((s0__WriteRequestItemList*)a)->Items), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__WriteRequestItemList::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__WriteRequestItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__WriteRequestItemList* SOAP_FMAC4
soap_get_s0__WriteRequestItemList(struct soap* soap,
    s0__WriteRequestItemList* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__WriteRequestItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__WriteRequestItemList::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__WriteRequestItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__WriteRequestItemList* SOAP_FMAC4
soap_in_s0__WriteRequestItemList(struct soap* soap, const char* tag,
    s0__WriteRequestItemList* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__WriteRequestItemList*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__WriteRequestItemList, sizeof(s0__WriteRequestItemList),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__WriteRequestItemList) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__WriteRequestItemList*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__WriteRequestItemList*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__WriteRequestItemList*)a)->ItemPath
            = soap_new_std__string(soap, -1);
        ((s0__WriteRequestItemList*)a)->ItemPath->assign(s);
      }
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__ItemValue(soap,
                "s0:Items", &(((s0__WriteRequestItemList*)a)->Items),
                "s0:ItemValue"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__WriteRequestItemList*)soap_id_forward(soap, soap->href, (void*)a,
        0, SOAP_TYPE_s0__WriteRequestItemList, 0,
        sizeof(s0__WriteRequestItemList), 0,
        soap_copy_s0__WriteRequestItemList);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__WriteRequestItemList* SOAP_FMAC6
soap_new_s0__WriteRequestItemList(struct soap* soap, int n)
{
  return soap_instantiate_s0__WriteRequestItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__WriteRequestItemList(
    struct soap* soap, s0__WriteRequestItemList* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__WriteRequestItemList* SOAP_FMAC4
soap_instantiate_s0__WriteRequestItemList(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__WriteRequestItemList(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_s0__WriteRequestItemList, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__WriteRequestItemList;
    if (size)
      *size = sizeof(s0__WriteRequestItemList);
    ((s0__WriteRequestItemList*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__WriteRequestItemList[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__WriteRequestItemList);
    for (int i = 0; i < n; i++)
      ((s0__WriteRequestItemList*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__WriteRequestItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__WriteRequestItemList(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying s0__WriteRequestItemList %p -> %p\n", q, p));
  *(s0__WriteRequestItemList*)p = *(s0__WriteRequestItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfShort::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfshort(
      soap, &((s0__ArrayOfShort*)this)->short_);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfShort::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfshort(
      soap, &((s0__ArrayOfShort*)this)->short_);
  /* transient soap skipped */
}

int s0__ArrayOfShort::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfShort);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfShort::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfShort(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfShort* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfShort),
      "s0:ArrayOfShort");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfshort(
      soap, "s0:short", -1, &(((s0__ArrayOfShort*)a)->short_), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfShort::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfShort(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfShort* SOAP_FMAC4 soap_get_s0__ArrayOfShort(
    struct soap* soap, s0__ArrayOfShort* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfShort(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfShort::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfShort(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfShort* SOAP_FMAC4 soap_in_s0__ArrayOfShort(
    struct soap* soap, const char* tag, s0__ArrayOfShort* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfShort*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfShort, sizeof(s0__ArrayOfShort), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfShort) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfShort*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfshort(soap, "s0:short",
                &(((s0__ArrayOfShort*)a)->short_), "xsd:short"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfShort*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfShort, 0, sizeof(s0__ArrayOfShort), 0,
        soap_copy_s0__ArrayOfShort);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfShort* SOAP_FMAC6 soap_new_s0__ArrayOfShort(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfShort(
    struct soap* soap, s0__ArrayOfShort* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfShort* SOAP_FMAC4 soap_instantiate_s0__ArrayOfShort(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfShort(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfShort, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfShort;
    if (size)
      *size = sizeof(s0__ArrayOfShort);
    ((s0__ArrayOfShort*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfShort[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfShort);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfShort*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfShort*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfShort(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfShort %p -> %p\n", q, p));
  *(s0__ArrayOfShort*)p = *(s0__ArrayOfShort*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfByte::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfbyte(soap, &((s0__ArrayOfByte*)this)->byte);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfByte::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfbyte(
      soap, &((s0__ArrayOfByte*)this)->byte);
  /* transient soap skipped */
}

int s0__ArrayOfByte::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfByte);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfByte::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfByte(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfByte(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfByte* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfByte),
      "s0:ArrayOfByte");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfbyte(
      soap, "s0:byte", -1, &(((s0__ArrayOfByte*)a)->byte), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfByte::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfByte(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfByte* SOAP_FMAC4 soap_get_s0__ArrayOfByte(
    struct soap* soap, s0__ArrayOfByte* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfByte(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfByte::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfByte(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfByte* SOAP_FMAC4 soap_in_s0__ArrayOfByte(
    struct soap* soap, const char* tag, s0__ArrayOfByte* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfByte*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfByte, sizeof(s0__ArrayOfByte), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfByte) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfByte*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfbyte(
                soap, "s0:byte", &(((s0__ArrayOfByte*)a)->byte), "xsd:byte"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfByte*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfByte, 0, sizeof(s0__ArrayOfByte), 0,
        soap_copy_s0__ArrayOfByte);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfByte* SOAP_FMAC6 soap_new_s0__ArrayOfByte(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfByte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfByte(
    struct soap* soap, s0__ArrayOfByte* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfByte* SOAP_FMAC4 soap_instantiate_s0__ArrayOfByte(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfByte(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfByte, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfByte;
    if (size)
      *size = sizeof(s0__ArrayOfByte);
    ((s0__ArrayOfByte*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfByte[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfByte);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfByte*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfByte*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfByte(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfByte %p -> %p\n", q, p));
  *(s0__ArrayOfByte*)p = *(s0__ArrayOfByte*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfDecimal::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfxsd__decimal(
      soap, &((s0__ArrayOfDecimal*)this)->decimal);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfDecimal::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfxsd__decimal(
      soap, &((s0__ArrayOfDecimal*)this)->decimal);
  /* transient soap skipped */
}

int s0__ArrayOfDecimal::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfDecimal);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfDecimal::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfDecimal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfDecimal(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfDecimal* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfDecimal),
      "s0:ArrayOfDecimal");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfxsd__decimal(
      soap, "s0:decimal", -1, &(((s0__ArrayOfDecimal*)a)->decimal), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfDecimal::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfDecimal(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfDecimal* SOAP_FMAC4 soap_get_s0__ArrayOfDecimal(
    struct soap* soap, s0__ArrayOfDecimal* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfDecimal(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfDecimal::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfDecimal(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfDecimal* SOAP_FMAC4 soap_in_s0__ArrayOfDecimal(
    struct soap* soap, const char* tag, s0__ArrayOfDecimal* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfDecimal*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfDecimal, sizeof(s0__ArrayOfDecimal), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfDecimal) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfDecimal*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfxsd__decimal(soap, "s0:decimal",
                &(((s0__ArrayOfDecimal*)a)->decimal), "xsd:decimal"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfDecimal*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfDecimal, 0, sizeof(s0__ArrayOfDecimal), 0,
        soap_copy_s0__ArrayOfDecimal);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfDecimal* SOAP_FMAC6 soap_new_s0__ArrayOfDecimal(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfDecimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfDecimal(
    struct soap* soap, s0__ArrayOfDecimal* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfDecimal* SOAP_FMAC4 soap_instantiate_s0__ArrayOfDecimal(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfDecimal(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfDecimal, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfDecimal;
    if (size)
      *size = sizeof(s0__ArrayOfDecimal);
    ((s0__ArrayOfDecimal*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfDecimal[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfDecimal);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfDecimal*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfDecimal*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfDecimal(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfDecimal %p -> %p\n", q, p));
  *(s0__ArrayOfDecimal*)p = *(s0__ArrayOfDecimal*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfAnyType::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOf_XML(
      soap, &((s0__ArrayOfAnyType*)this)->anyType);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfAnyType::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOf_XML(
      soap, &((s0__ArrayOfAnyType*)this)->anyType);
  /* transient soap skipped */
}

int s0__ArrayOfAnyType::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfAnyType);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfAnyType::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfAnyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfAnyType(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfAnyType* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfAnyType),
      "s0:ArrayOfAnyType");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOf_XML(
      soap, "s0:anyType", -1, &(((s0__ArrayOfAnyType*)a)->anyType), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfAnyType::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfAnyType(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfAnyType* SOAP_FMAC4 soap_get_s0__ArrayOfAnyType(
    struct soap* soap, s0__ArrayOfAnyType* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfAnyType(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfAnyType::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfAnyType(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfAnyType* SOAP_FMAC4 soap_in_s0__ArrayOfAnyType(
    struct soap* soap, const char* tag, s0__ArrayOfAnyType* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfAnyType*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfAnyType, sizeof(s0__ArrayOfAnyType), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfAnyType) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfAnyType*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOf_XML(
                soap, "s0:anyType", &(((s0__ArrayOfAnyType*)a)->anyType), ""))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfAnyType*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfAnyType, 0, sizeof(s0__ArrayOfAnyType), 0,
        soap_copy_s0__ArrayOfAnyType);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfAnyType* SOAP_FMAC6 soap_new_s0__ArrayOfAnyType(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfAnyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfAnyType(
    struct soap* soap, s0__ArrayOfAnyType* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfAnyType* SOAP_FMAC4 soap_instantiate_s0__ArrayOfAnyType(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfAnyType(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfAnyType, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfAnyType;
    if (size)
      *size = sizeof(s0__ArrayOfAnyType);
    ((s0__ArrayOfAnyType*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfAnyType[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfAnyType);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfAnyType*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfAnyType*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfAnyType(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfAnyType %p -> %p\n", q, p));
  *(s0__ArrayOfAnyType*)p = *(s0__ArrayOfAnyType*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfDateTime::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfstd__string(
      soap, &((s0__ArrayOfDateTime*)this)->dateTime);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfDateTime::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfstd__string(
      soap, &((s0__ArrayOfDateTime*)this)->dateTime);
  /* transient soap skipped */
}

int s0__ArrayOfDateTime::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfDateTime);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfDateTime::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfDateTime(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfDateTime* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfDateTime),
      "s0:ArrayOfDateTime");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfstd__string(
      soap, "s0:dateTime", -1, &(((s0__ArrayOfDateTime*)a)->dateTime), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfDateTime::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfDateTime(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfDateTime* SOAP_FMAC4 soap_get_s0__ArrayOfDateTime(
    struct soap* soap, s0__ArrayOfDateTime* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__ArrayOfDateTime(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfDateTime::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfDateTime(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfDateTime* SOAP_FMAC4 soap_in_s0__ArrayOfDateTime(
    struct soap* soap, const char* tag, s0__ArrayOfDateTime* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfDateTime*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfDateTime, sizeof(s0__ArrayOfDateTime), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfDateTime) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfDateTime*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap, "s0:dateTime",
                &(((s0__ArrayOfDateTime*)a)->dateTime), "xsd:string"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfDateTime*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfDateTime, 0, sizeof(s0__ArrayOfDateTime), 0,
        soap_copy_s0__ArrayOfDateTime);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfDateTime* SOAP_FMAC6 soap_new_s0__ArrayOfDateTime(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfDateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfDateTime(
    struct soap* soap, s0__ArrayOfDateTime* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfDateTime* SOAP_FMAC4 soap_instantiate_s0__ArrayOfDateTime(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfDateTime(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfDateTime, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfDateTime;
    if (size)
      *size = sizeof(s0__ArrayOfDateTime);
    ((s0__ArrayOfDateTime*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfDateTime[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfDateTime);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfDateTime*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfDateTime*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfDateTime(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfDateTime %p -> %p\n", q, p));
  *(s0__ArrayOfDateTime*)p = *(s0__ArrayOfDateTime*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfString::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfstd__string(
      soap, &((s0__ArrayOfString*)this)->string);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfString::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfstd__string(
      soap, &((s0__ArrayOfString*)this)->string);
  /* transient soap skipped */
}

int s0__ArrayOfString::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfString);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfString::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfString(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfString* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfString),
      "s0:ArrayOfString");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfstd__string(
      soap, "s0:string", -1, &(((s0__ArrayOfString*)a)->string), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfString::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfString* SOAP_FMAC4 soap_get_s0__ArrayOfString(
    struct soap* soap, s0__ArrayOfString* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfString(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfString::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfString* SOAP_FMAC4 soap_in_s0__ArrayOfString(
    struct soap* soap, const char* tag, s0__ArrayOfString* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfString*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfString, sizeof(s0__ArrayOfString), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfString) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfString*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap, "s0:string",
                &(((s0__ArrayOfString*)a)->string), "xsd:string"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfString*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfString, 0, sizeof(s0__ArrayOfString), 0,
        soap_copy_s0__ArrayOfString);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfString* SOAP_FMAC6 soap_new_s0__ArrayOfString(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfString(
    struct soap* soap, s0__ArrayOfString* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfString* SOAP_FMAC4 soap_instantiate_s0__ArrayOfString(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfString(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfString, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfString;
    if (size)
      *size = sizeof(s0__ArrayOfString);
    ((s0__ArrayOfString*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfString[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfString);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfString*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfString*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfString(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfString %p -> %p\n", q, p));
  *(s0__ArrayOfString*)p = *(s0__ArrayOfString*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfBoolean::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfbool(
      soap, &((s0__ArrayOfBoolean*)this)->boolean);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfBoolean::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfbool(
      soap, &((s0__ArrayOfBoolean*)this)->boolean);
  /* transient soap skipped */
}

int s0__ArrayOfBoolean::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfBoolean);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfBoolean::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfBoolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfBoolean(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfBoolean* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfBoolean),
      "s0:ArrayOfBoolean");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfbool(
      soap, "s0:boolean", -1, &(((s0__ArrayOfBoolean*)a)->boolean), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfBoolean::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfBoolean(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfBoolean* SOAP_FMAC4 soap_get_s0__ArrayOfBoolean(
    struct soap* soap, s0__ArrayOfBoolean* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfBoolean(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfBoolean::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfBoolean(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfBoolean* SOAP_FMAC4 soap_in_s0__ArrayOfBoolean(
    struct soap* soap, const char* tag, s0__ArrayOfBoolean* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfBoolean*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfBoolean, sizeof(s0__ArrayOfBoolean), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfBoolean) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfBoolean*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfbool(soap, "s0:boolean",
                &(((s0__ArrayOfBoolean*)a)->boolean), "xsd:boolean"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfBoolean*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfBoolean, 0, sizeof(s0__ArrayOfBoolean), 0,
        soap_copy_s0__ArrayOfBoolean);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfBoolean* SOAP_FMAC6 soap_new_s0__ArrayOfBoolean(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfBoolean(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfBoolean(
    struct soap* soap, s0__ArrayOfBoolean* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfBoolean* SOAP_FMAC4 soap_instantiate_s0__ArrayOfBoolean(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfBoolean(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfBoolean, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfBoolean;
    if (size)
      *size = sizeof(s0__ArrayOfBoolean);
    ((s0__ArrayOfBoolean*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfBoolean[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfBoolean);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfBoolean*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfBoolean*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfBoolean(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfBoolean %p -> %p\n", q, p));
  *(s0__ArrayOfBoolean*)p = *(s0__ArrayOfBoolean*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfUnsignedShort::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfunsignedShort(
      soap, &((s0__ArrayOfUnsignedShort*)this)->unsignedShort);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfUnsignedShort::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfunsignedShort(
      soap, &((s0__ArrayOfUnsignedShort*)this)->unsignedShort);
  /* transient soap skipped */
}

int s0__ArrayOfUnsignedShort::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfUnsignedShort);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfUnsignedShort::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfUnsignedShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfUnsignedShort(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfUnsignedShort* a,
    const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfUnsignedShort),
      "s0:ArrayOfUnsignedShort");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfunsignedShort(soap, "s0:unsignedShort", -1,
      &(((s0__ArrayOfUnsignedShort*)a)->unsignedShort), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfUnsignedShort::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfUnsignedShort(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedShort* SOAP_FMAC4
soap_get_s0__ArrayOfUnsignedShort(struct soap* soap,
    s0__ArrayOfUnsignedShort* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfUnsignedShort(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfUnsignedShort::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfUnsignedShort(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedShort* SOAP_FMAC4
soap_in_s0__ArrayOfUnsignedShort(struct soap* soap, const char* tag,
    s0__ArrayOfUnsignedShort* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfUnsignedShort*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfUnsignedShort, sizeof(s0__ArrayOfUnsignedShort),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfUnsignedShort) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfUnsignedShort*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfunsignedShort(soap, "s0:unsignedShort",
                &(((s0__ArrayOfUnsignedShort*)a)->unsignedShort),
                "xsd:unsignedShort"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfUnsignedShort*)soap_id_forward(soap, soap->href, (void*)a,
        0, SOAP_TYPE_s0__ArrayOfUnsignedShort, 0,
        sizeof(s0__ArrayOfUnsignedShort), 0,
        soap_copy_s0__ArrayOfUnsignedShort);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfUnsignedShort* SOAP_FMAC6
soap_new_s0__ArrayOfUnsignedShort(struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfUnsignedShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfUnsignedShort(
    struct soap* soap, s0__ArrayOfUnsignedShort* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfUnsignedShort* SOAP_FMAC4
soap_instantiate_s0__ArrayOfUnsignedShort(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__ArrayOfUnsignedShort(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_s0__ArrayOfUnsignedShort, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfUnsignedShort;
    if (size)
      *size = sizeof(s0__ArrayOfUnsignedShort);
    ((s0__ArrayOfUnsignedShort*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfUnsignedShort[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfUnsignedShort);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfUnsignedShort*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfUnsignedShort*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfUnsignedShort(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying s0__ArrayOfUnsignedShort %p -> %p\n", q, p));
  *(s0__ArrayOfUnsignedShort*)p = *(s0__ArrayOfUnsignedShort*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfDouble::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfdouble(
      soap, &((s0__ArrayOfDouble*)this)->double_);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfDouble::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfdouble(
      soap, &((s0__ArrayOfDouble*)this)->double_);
  /* transient soap skipped */
}

int s0__ArrayOfDouble::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfDouble);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfDouble::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfDouble(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfDouble(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfDouble* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfDouble),
      "s0:ArrayOfDouble");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfdouble(
      soap, "s0:double", -1, &(((s0__ArrayOfDouble*)a)->double_), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfDouble::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfDouble(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfDouble* SOAP_FMAC4 soap_get_s0__ArrayOfDouble(
    struct soap* soap, s0__ArrayOfDouble* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfDouble(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfDouble::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfDouble(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfDouble* SOAP_FMAC4 soap_in_s0__ArrayOfDouble(
    struct soap* soap, const char* tag, s0__ArrayOfDouble* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfDouble*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfDouble, sizeof(s0__ArrayOfDouble), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfDouble) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfDouble*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfdouble(soap, "s0:double",
                &(((s0__ArrayOfDouble*)a)->double_), "xsd:double"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfDouble*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfDouble, 0, sizeof(s0__ArrayOfDouble), 0,
        soap_copy_s0__ArrayOfDouble);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfDouble* SOAP_FMAC6 soap_new_s0__ArrayOfDouble(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfDouble(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfDouble(
    struct soap* soap, s0__ArrayOfDouble* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfDouble* SOAP_FMAC4 soap_instantiate_s0__ArrayOfDouble(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfDouble(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfDouble, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfDouble;
    if (size)
      *size = sizeof(s0__ArrayOfDouble);
    ((s0__ArrayOfDouble*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfDouble[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfDouble);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfDouble*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfDouble*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfDouble(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfDouble %p -> %p\n", q, p));
  *(s0__ArrayOfDouble*)p = *(s0__ArrayOfDouble*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfUnsignedLong::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfunsignedLONG64(
      soap, &((s0__ArrayOfUnsignedLong*)this)->unsignedLong);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfUnsignedLong::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfunsignedLONG64(
      soap, &((s0__ArrayOfUnsignedLong*)this)->unsignedLong);
  /* transient soap skipped */
}

int s0__ArrayOfUnsignedLong::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfUnsignedLong);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfUnsignedLong::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfUnsignedLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfUnsignedLong(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfUnsignedLong* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfUnsignedLong),
      "s0:ArrayOfUnsignedLong");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfunsignedLONG64(soap, "s0:unsignedLong", -1,
      &(((s0__ArrayOfUnsignedLong*)a)->unsignedLong), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfUnsignedLong::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfUnsignedLong(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedLong* SOAP_FMAC4 soap_get_s0__ArrayOfUnsignedLong(
    struct soap* soap, s0__ArrayOfUnsignedLong* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__ArrayOfUnsignedLong(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfUnsignedLong::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfUnsignedLong(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedLong* SOAP_FMAC4 soap_in_s0__ArrayOfUnsignedLong(
    struct soap* soap, const char* tag, s0__ArrayOfUnsignedLong* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfUnsignedLong*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfUnsignedLong, sizeof(s0__ArrayOfUnsignedLong),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfUnsignedLong) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfUnsignedLong*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfunsignedLONG64(soap, "s0:unsignedLong",
                &(((s0__ArrayOfUnsignedLong*)a)->unsignedLong),
                "xsd:unsignedLong"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfUnsignedLong*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfUnsignedLong, 0, sizeof(s0__ArrayOfUnsignedLong),
        0, soap_copy_s0__ArrayOfUnsignedLong);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfUnsignedLong* SOAP_FMAC6 soap_new_s0__ArrayOfUnsignedLong(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfUnsignedLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfUnsignedLong(
    struct soap* soap, s0__ArrayOfUnsignedLong* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfUnsignedLong* SOAP_FMAC4
soap_instantiate_s0__ArrayOfUnsignedLong(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__ArrayOfUnsignedLong(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_s0__ArrayOfUnsignedLong, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfUnsignedLong;
    if (size)
      *size = sizeof(s0__ArrayOfUnsignedLong);
    ((s0__ArrayOfUnsignedLong*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfUnsignedLong[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfUnsignedLong);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfUnsignedLong*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfUnsignedLong*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfUnsignedLong(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfUnsignedLong %p -> %p\n", q, p));
  *(s0__ArrayOfUnsignedLong*)p = *(s0__ArrayOfUnsignedLong*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfLong::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfLONG64(
      soap, &((s0__ArrayOfLong*)this)->long_);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfLong::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfLONG64(
      soap, &((s0__ArrayOfLong*)this)->long_);
  /* transient soap skipped */
}

int s0__ArrayOfLong::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfLong);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfLong::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfLong(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfLong* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfLong),
      "s0:ArrayOfLong");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfLONG64(
      soap, "s0:long", -1, &(((s0__ArrayOfLong*)a)->long_), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfLong::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfLong(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfLong* SOAP_FMAC4 soap_get_s0__ArrayOfLong(
    struct soap* soap, s0__ArrayOfLong* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfLong(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfLong::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfLong(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfLong* SOAP_FMAC4 soap_in_s0__ArrayOfLong(
    struct soap* soap, const char* tag, s0__ArrayOfLong* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfLong*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfLong, sizeof(s0__ArrayOfLong), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfLong) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfLong*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfLONG64(
                soap, "s0:long", &(((s0__ArrayOfLong*)a)->long_), "xsd:long"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfLong*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfLong, 0, sizeof(s0__ArrayOfLong), 0,
        soap_copy_s0__ArrayOfLong);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfLong* SOAP_FMAC6 soap_new_s0__ArrayOfLong(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfLong(
    struct soap* soap, s0__ArrayOfLong* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfLong* SOAP_FMAC4 soap_instantiate_s0__ArrayOfLong(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfLong(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfLong, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfLong;
    if (size)
      *size = sizeof(s0__ArrayOfLong);
    ((s0__ArrayOfLong*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfLong[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfLong);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfLong*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfLong*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfLong(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfLong %p -> %p\n", q, p));
  *(s0__ArrayOfLong*)p = *(s0__ArrayOfLong*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfUnsignedInt::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfunsignedInt(
      soap, &((s0__ArrayOfUnsignedInt*)this)->unsignedInt);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfUnsignedInt::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfunsignedInt(
      soap, &((s0__ArrayOfUnsignedInt*)this)->unsignedInt);
  /* transient soap skipped */
}

int s0__ArrayOfUnsignedInt::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfUnsignedInt);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfUnsignedInt::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfUnsignedInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfUnsignedInt(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfUnsignedInt* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfUnsignedInt),
      "s0:ArrayOfUnsignedInt");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfunsignedInt(soap, "s0:unsignedInt", -1,
      &(((s0__ArrayOfUnsignedInt*)a)->unsignedInt), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfUnsignedInt::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfUnsignedInt(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedInt* SOAP_FMAC4 soap_get_s0__ArrayOfUnsignedInt(
    struct soap* soap, s0__ArrayOfUnsignedInt* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__ArrayOfUnsignedInt(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfUnsignedInt::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfUnsignedInt(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedInt* SOAP_FMAC4 soap_in_s0__ArrayOfUnsignedInt(
    struct soap* soap, const char* tag, s0__ArrayOfUnsignedInt* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfUnsignedInt*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfUnsignedInt, sizeof(s0__ArrayOfUnsignedInt),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfUnsignedInt) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfUnsignedInt*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfunsignedInt(soap, "s0:unsignedInt",
                &(((s0__ArrayOfUnsignedInt*)a)->unsignedInt),
                "xsd:unsignedInt"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfUnsignedInt*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfUnsignedInt, 0, sizeof(s0__ArrayOfUnsignedInt), 0,
        soap_copy_s0__ArrayOfUnsignedInt);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfUnsignedInt* SOAP_FMAC6 soap_new_s0__ArrayOfUnsignedInt(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfUnsignedInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfUnsignedInt(
    struct soap* soap, s0__ArrayOfUnsignedInt* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfUnsignedInt* SOAP_FMAC4
soap_instantiate_s0__ArrayOfUnsignedInt(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__ArrayOfUnsignedInt(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_s0__ArrayOfUnsignedInt, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfUnsignedInt;
    if (size)
      *size = sizeof(s0__ArrayOfUnsignedInt);
    ((s0__ArrayOfUnsignedInt*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfUnsignedInt[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfUnsignedInt);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfUnsignedInt*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfUnsignedInt*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfUnsignedInt(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfUnsignedInt %p -> %p\n", q, p));
  *(s0__ArrayOfUnsignedInt*)p = *(s0__ArrayOfUnsignedInt*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfInt::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfint(soap, &((s0__ArrayOfInt*)this)->int_);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfInt::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfint(soap, &((s0__ArrayOfInt*)this)->int_);
  /* transient soap skipped */
}

int s0__ArrayOfInt::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfInt);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfInt::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfInt(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfInt* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfInt), "s0:ArrayOfInt");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfint(
      soap, "s0:int", -1, &(((s0__ArrayOfInt*)a)->int_), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfInt::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfInt(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfInt* SOAP_FMAC4 soap_get_s0__ArrayOfInt(
    struct soap* soap, s0__ArrayOfInt* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfInt(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfInt::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfInt(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfInt* SOAP_FMAC4 soap_in_s0__ArrayOfInt(
    struct soap* soap, const char* tag, s0__ArrayOfInt* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfInt*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfInt, sizeof(s0__ArrayOfInt), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfInt) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfInt*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfint(
                soap, "s0:int", &(((s0__ArrayOfInt*)a)->int_), "xsd:int"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfInt*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfInt, 0, sizeof(s0__ArrayOfInt), 0,
        soap_copy_s0__ArrayOfInt);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfInt* SOAP_FMAC6 soap_new_s0__ArrayOfInt(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfInt(
    struct soap* soap, s0__ArrayOfInt* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfInt* SOAP_FMAC4 soap_instantiate_s0__ArrayOfInt(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfInt(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfInt, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfInt;
    if (size)
      *size = sizeof(s0__ArrayOfInt);
    ((s0__ArrayOfInt*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfInt[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfInt);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfInt*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfInt*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfInt(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfInt %p -> %p\n", q, p));
  *(s0__ArrayOfInt*)p = *(s0__ArrayOfInt*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfFloat::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOffloat(
      soap, &((s0__ArrayOfFloat*)this)->float_);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ArrayOfFloat::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOffloat(
      soap, &((s0__ArrayOfFloat*)this)->float_);
  /* transient soap skipped */
}

int s0__ArrayOfFloat::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfFloat);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ArrayOfFloat::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ArrayOfFloat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfFloat(struct soap* soap,
    const char* tag, int id, const s0__ArrayOfFloat* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfFloat),
      "s0:ArrayOfFloat");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOffloat(
      soap, "s0:float", -1, &(((s0__ArrayOfFloat*)a)->float_), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ArrayOfFloat::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ArrayOfFloat(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfFloat* SOAP_FMAC4 soap_get_s0__ArrayOfFloat(
    struct soap* soap, s0__ArrayOfFloat* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ArrayOfFloat(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ArrayOfFloat::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ArrayOfFloat(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfFloat* SOAP_FMAC4 soap_in_s0__ArrayOfFloat(
    struct soap* soap, const char* tag, s0__ArrayOfFloat* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ArrayOfFloat*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ArrayOfFloat, sizeof(s0__ArrayOfFloat), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ArrayOfFloat) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ArrayOfFloat*)a->soap_in(soap, tag, type);
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOffloat(soap, "s0:float",
                &(((s0__ArrayOfFloat*)a)->float_), "xsd:float"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ArrayOfFloat*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ArrayOfFloat, 0, sizeof(s0__ArrayOfFloat), 0,
        soap_copy_s0__ArrayOfFloat);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ArrayOfFloat* SOAP_FMAC6 soap_new_s0__ArrayOfFloat(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ArrayOfFloat(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfFloat(
    struct soap* soap, s0__ArrayOfFloat* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfFloat* SOAP_FMAC4 soap_instantiate_s0__ArrayOfFloat(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfFloat(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfFloat, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ArrayOfFloat;
    if (size)
      *size = sizeof(s0__ArrayOfFloat);
    ((s0__ArrayOfFloat*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ArrayOfFloat[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ArrayOfFloat);
    for (int i = 0; i < n; i++)
      ((s0__ArrayOfFloat*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ArrayOfFloat*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfFloat(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfFloat %p -> %p\n", q, p));
  *(s0__ArrayOfFloat*)p = *(s0__ArrayOfFloat*)q;
}
#ifdef __cplusplus
}
#endif

void s0__OPCError::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__OPCError*)this)->Text = NULL;
  soap_default_xsd__QName(soap, &((s0__OPCError*)this)->ID);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__OPCError::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(soap, &((s0__OPCError*)this)->Text);
  /* transient soap skipped */
}

int s0__OPCError::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__OPCError);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__OPCError::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__OPCError(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__OPCError(struct soap* soap,
    const char* tag, int id, const s0__OPCError* a, const char* type)
{
  if (!((s0__OPCError*)a)->ID.empty())
    soap_set_attr(
        soap, "ID", soap_QName2s(soap, ((s0__OPCError*)a)->ID.c_str()));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__OPCError), "s0:OPCError");
  /* transient soap skipped */
  soap_out_PointerTostd__string(
      soap, "s0:Text", -1, &(((s0__OPCError*)a)->Text), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__OPCError::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__OPCError(soap, this, tag, type);
}

SOAP_FMAC3 s0__OPCError* SOAP_FMAC4 soap_get_s0__OPCError(
    struct soap* soap, s0__OPCError* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__OPCError(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__OPCError::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__OPCError(soap, tag, this, type);
}

SOAP_FMAC3 s0__OPCError* SOAP_FMAC4 soap_in_s0__OPCError(
    struct soap* soap, const char* tag, s0__OPCError* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__OPCError*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__OPCError, sizeof(s0__OPCError), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__OPCError) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__OPCError*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ID", 1);
    if (t) {
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      ((s0__OPCError*)a)->ID.assign(s);
    }
  }
  short soap_flag___item2 = 1, soap_flag_Text1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_Text1
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(
                soap, "s0:Text", &(((s0__OPCError*)a)->Text), "xsd:string")) {
          soap_flag_Text1--;
          continue;
        }
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__OPCError*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__OPCError, 0, sizeof(s0__OPCError), 0,
        soap_copy_s0__OPCError);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__OPCError* SOAP_FMAC6 soap_new_s0__OPCError(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__OPCError(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__OPCError(
    struct soap* soap, s0__OPCError* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__OPCError* SOAP_FMAC4 soap_instantiate_s0__OPCError(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__OPCError(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__OPCError, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__OPCError;
    if (size)
      *size = sizeof(s0__OPCError);
    ((s0__OPCError*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__OPCError[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__OPCError);
    for (int i = 0; i < n; i++)
      ((s0__OPCError*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__OPCError*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__OPCError(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__OPCError %p -> %p\n", q, p));
  *(s0__OPCError*)p = *(s0__OPCError*)q;
}
#ifdef __cplusplus
}
#endif

void s0__OPCQuality::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__OPCQuality*)this)->QualityField = NULL;
  ((s0__OPCQuality*)this)->LimitField = NULL;
  ((s0__OPCQuality*)this)->VendorField = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__OPCQuality::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int s0__OPCQuality::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__OPCQuality);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__OPCQuality::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__OPCQuality(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__OPCQuality(struct soap* soap,
    const char* tag, int id, const s0__OPCQuality* a, const char* type)
{
  if (((s0__OPCQuality*)a)->QualityField)
    soap_set_attr(soap, "QualityField",
        soap_s0__qualityBits2s(soap, *((s0__OPCQuality*)a)->QualityField));
  if (((s0__OPCQuality*)a)->LimitField)
    soap_set_attr(soap, "LimitField",
        soap_s0__limitBits2s(soap, *((s0__OPCQuality*)a)->LimitField));
  if (((s0__OPCQuality*)a)->VendorField)
    soap_set_attr(soap, "VendorField",
        soap_unsignedShort2s(soap, *((s0__OPCQuality*)a)->VendorField));
  return soap_outliteral(
      soap, tag, &(((xsd__anyType*)a)->__item), "s0:OPCQuality");
}

void* s0__OPCQuality::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__OPCQuality(soap, this, tag, type);
}

SOAP_FMAC3 s0__OPCQuality* SOAP_FMAC4 soap_get_s0__OPCQuality(
    struct soap* soap, s0__OPCQuality* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__OPCQuality(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__OPCQuality::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__OPCQuality(soap, tag, this, type);
}

SOAP_FMAC3 s0__OPCQuality* SOAP_FMAC4 soap_in_s0__OPCQuality(
    struct soap* soap, const char* tag, s0__OPCQuality* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__OPCQuality*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__OPCQuality, sizeof(s0__OPCQuality), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__OPCQuality)
      return (s0__OPCQuality*)a->soap_in(soap, tag, type);
  }
  {
    const char* t = soap_attr_value(soap, "QualityField", 0);
    if (t) {
      if (!(((s0__OPCQuality*)a)->QualityField
              = (enum s0__qualityBits*)soap_malloc(
                  soap, sizeof(enum s0__qualityBits)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2s0__qualityBits(soap, t, ((s0__OPCQuality*)a)->QualityField))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "LimitField", 0);
    if (t) {
      if (!(((s0__OPCQuality*)a)->LimitField = (enum s0__limitBits*)soap_malloc(
                soap, sizeof(enum s0__limitBits)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2s0__limitBits(soap, t, ((s0__OPCQuality*)a)->LimitField))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "VendorField", 0);
    if (t) {
      if (!(((s0__OPCQuality*)a)->VendorField
              = (unsigned short*)soap_malloc(soap, sizeof(unsigned short)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2unsignedShort(soap, t, ((s0__OPCQuality*)a)->VendorField))
        return NULL;
    }
  }
  if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__OPCQuality* SOAP_FMAC6 soap_new_s0__OPCQuality(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__OPCQuality(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__OPCQuality(
    struct soap* soap, s0__OPCQuality* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__OPCQuality* SOAP_FMAC4 soap_instantiate_s0__OPCQuality(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__OPCQuality(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__OPCQuality, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__OPCQuality;
    if (size)
      *size = sizeof(s0__OPCQuality);
    ((s0__OPCQuality*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__OPCQuality[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__OPCQuality);
    for (int i = 0; i < n; i++)
      ((s0__OPCQuality*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__OPCQuality*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__OPCQuality(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__OPCQuality %p -> %p\n", q, p));
  *(s0__OPCQuality*)p = *(s0__OPCQuality*)q;
}
#ifdef __cplusplus
}
#endif

void s0__Value::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__Value*)this)->xsi__type = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__Value::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int s0__Value::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__Value);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__Value::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__Value(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__Value(struct soap* soap, const char* tag,
    int id, const s0__Value* a, const char* type)
{
  if (((s0__Value*)a)->xsi__type)
    soap_set_attr(soap, "xsi:type",
        soap_QName2s(soap, ((s0__Value*)a)->xsi__type->c_str()));
  return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), "s0:Value");
}

void* s0__Value::soap_get(struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__Value(soap, this, tag, type);
}

SOAP_FMAC3 s0__Value* SOAP_FMAC4 soap_get_s0__Value(
    struct soap* soap, s0__Value* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__Value(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__Value::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__Value(soap, tag, this, type);
}

SOAP_FMAC3 s0__Value* SOAP_FMAC4 soap_in_s0__Value(
    struct soap* soap, const char* tag, s0__Value* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__Value*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__Value, sizeof(s0__Value), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__Value)
      return (s0__Value*)a->soap_in(soap, tag, type);
  }
  {
    const char* t = soap_attr_value(soap, "xsi:type", 0);
    if (t) {
      if (!(((s0__Value*)a)->xsi__type
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__Value*)a)->xsi__type = soap_new_std__string(soap, -1);
        ((s0__Value*)a)->xsi__type->assign(s);
      }
    }
  }
  if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__Value* SOAP_FMAC6 soap_new_s0__Value(struct soap* soap, int n)
{
  return soap_instantiate_s0__Value(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__Value(
    struct soap* soap, s0__Value* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__Value* SOAP_FMAC4 soap_instantiate_s0__Value(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__Value(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__Value, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__Value;
    if (size)
      *size = sizeof(s0__Value);
    ((s0__Value*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__Value[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__Value);
    for (int i = 0; i < n; i++)
      ((s0__Value*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__Value*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__Value(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__Value %p -> %p\n", q, p));
  *(s0__Value*)p = *(s0__Value*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ItemValue::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__ItemValue*)this)->DiagnosticInfo = NULL;
  ((s0__ItemValue*)this)->Value = NULL;
  ((s0__ItemValue*)this)->Quality = NULL;
  ((s0__ItemValue*)this)->ValueTypeQualifier = NULL;
  ((s0__ItemValue*)this)->ItemPath = NULL;
  ((s0__ItemValue*)this)->ItemName = NULL;
  ((s0__ItemValue*)this)->ClientItemHandle = NULL;
  ((s0__ItemValue*)this)->Timestamp = NULL;
  ((s0__ItemValue*)this)->ResultID = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ItemValue::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(
      soap, &((s0__ItemValue*)this)->DiagnosticInfo);
  soap_serialize_PointerToxsd__anyType(soap, &((s0__ItemValue*)this)->Value);
  soap_serialize_PointerTos0__OPCQuality(
      soap, &((s0__ItemValue*)this)->Quality);
  /* transient soap skipped */
}

int s0__ItemValue::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ItemValue);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ItemValue::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ItemValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ItemValue(struct soap* soap,
    const char* tag, int id, const s0__ItemValue* a, const char* type)
{
  if (((s0__ItemValue*)a)->ValueTypeQualifier)
    soap_set_attr(soap, "ValueTypeQualifier",
        soap_QName2s(soap, ((s0__ItemValue*)a)->ValueTypeQualifier->c_str()));
  if (((s0__ItemValue*)a)->ItemPath)
    soap_set_attr(soap, "ItemPath", ((s0__ItemValue*)a)->ItemPath->c_str());
  if (((s0__ItemValue*)a)->ItemName)
    soap_set_attr(soap, "ItemName", ((s0__ItemValue*)a)->ItemName->c_str());
  if (((s0__ItemValue*)a)->ClientItemHandle)
    soap_set_attr(soap, "ClientItemHandle",
        ((s0__ItemValue*)a)->ClientItemHandle->c_str());
  if (((s0__ItemValue*)a)->Timestamp)
    soap_set_attr(soap, "Timestamp", ((s0__ItemValue*)a)->Timestamp->c_str());
  if (((s0__ItemValue*)a)->ResultID)
    soap_set_attr(soap, "ResultID",
        soap_QName2s(soap, ((s0__ItemValue*)a)->ResultID->c_str()));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ItemValue), "s0:ItemValue");
  /* transient soap skipped */
  soap_out_PointerTostd__string(soap, "s0:DiagnosticInfo", -1,
      &(((s0__ItemValue*)a)->DiagnosticInfo), "");
  soap_out_PointerToxsd__anyType(
      soap, "s0:Value", -1, &(((s0__ItemValue*)a)->Value), "");
  soap_out_PointerTos0__OPCQuality(
      soap, "s0:Quality", -1, &(((s0__ItemValue*)a)->Quality), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ItemValue::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ItemValue(soap, this, tag, type);
}

SOAP_FMAC3 s0__ItemValue* SOAP_FMAC4 soap_get_s0__ItemValue(
    struct soap* soap, s0__ItemValue* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ItemValue(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ItemValue::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ItemValue(soap, tag, this, type);
}

SOAP_FMAC3 s0__ItemValue* SOAP_FMAC4 soap_in_s0__ItemValue(
    struct soap* soap, const char* tag, s0__ItemValue* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ItemValue*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ItemValue, sizeof(s0__ItemValue), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ItemValue) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ItemValue*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ValueTypeQualifier", 0);
    if (t) {
      if (!(((s0__ItemValue*)a)->ValueTypeQualifier
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemValue*)a)->ValueTypeQualifier
            = soap_new_std__string(soap, -1);
        ((s0__ItemValue*)a)->ValueTypeQualifier->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__ItemValue*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemValue*)a)->ItemPath = soap_new_std__string(soap, -1);
        ((s0__ItemValue*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemName", 0);
    if (t) {
      if (!(((s0__ItemValue*)a)->ItemName
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemValue*)a)->ItemName = soap_new_std__string(soap, -1);
        ((s0__ItemValue*)a)->ItemName->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientItemHandle", 0);
    if (t) {
      if (!(((s0__ItemValue*)a)->ClientItemHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemValue*)a)->ClientItemHandle = soap_new_std__string(soap, -1);
        ((s0__ItemValue*)a)->ClientItemHandle->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "Timestamp", 0);
    if (t) {
      if (!(((s0__ItemValue*)a)->Timestamp
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemValue*)a)->Timestamp = soap_new_std__string(soap, -1);
        ((s0__ItemValue*)a)->Timestamp->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ResultID", 0);
    if (t) {
      if (!(((s0__ItemValue*)a)->ResultID
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ItemValue*)a)->ResultID = soap_new_std__string(soap, -1);
        ((s0__ItemValue*)a)->ResultID->assign(s);
      }
    }
  }
  short soap_flag___item2 = 1, soap_flag_DiagnosticInfo1 = 1,
        soap_flag_Value1 = 1, soap_flag_Quality1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_DiagnosticInfo1
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "s0:DiagnosticInfo",
                &(((s0__ItemValue*)a)->DiagnosticInfo), "xsd:string")) {
          soap_flag_DiagnosticInfo1--;
          continue;
        }
      if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxsd__anyType(soap, "s0:Value",
                &(((s0__ItemValue*)a)->Value), "xsd:anyType")) {
          soap_flag_Value1--;
          continue;
        }
      if (soap_flag_Quality1 && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTos0__OPCQuality(soap, "s0:Quality",
                &(((s0__ItemValue*)a)->Quality), "s0:OPCQuality")) {
          soap_flag_Quality1--;
          continue;
        }
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ItemValue*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ItemValue, 0, sizeof(s0__ItemValue), 0,
        soap_copy_s0__ItemValue);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ItemValue* SOAP_FMAC6 soap_new_s0__ItemValue(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ItemValue(
    struct soap* soap, s0__ItemValue* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ItemValue* SOAP_FMAC4 soap_instantiate_s0__ItemValue(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ItemValue(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ItemValue, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ItemValue;
    if (size)
      *size = sizeof(s0__ItemValue);
    ((s0__ItemValue*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ItemValue[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ItemValue);
    for (int i = 0; i < n; i++)
      ((s0__ItemValue*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ItemValue*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ItemValue(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ItemValue %p -> %p\n", q, p));
  *(s0__ItemValue*)p = *(s0__ItemValue*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ReplyItemList::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTos0__ItemValue(
      soap, &((s0__ReplyItemList*)this)->Items);
  ((s0__ReplyItemList*)this)->Reserved = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ReplyItemList::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTos0__ItemValue(
      soap, &((s0__ReplyItemList*)this)->Items);
  /* transient soap skipped */
}

int s0__ReplyItemList::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ReplyItemList);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ReplyItemList::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ReplyItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ReplyItemList(struct soap* soap,
    const char* tag, int id, const s0__ReplyItemList* a, const char* type)
{
  if (((s0__ReplyItemList*)a)->Reserved)
    soap_set_attr(soap, "Reserved", ((s0__ReplyItemList*)a)->Reserved->c_str());
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ReplyItemList),
      "s0:ReplyItemList");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfPointerTos0__ItemValue(
      soap, "s0:Items", -1, &(((s0__ReplyItemList*)a)->Items), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ReplyItemList::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ReplyItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__ReplyItemList* SOAP_FMAC4 soap_get_s0__ReplyItemList(
    struct soap* soap, s0__ReplyItemList* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ReplyItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ReplyItemList::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ReplyItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__ReplyItemList* SOAP_FMAC4 soap_in_s0__ReplyItemList(
    struct soap* soap, const char* tag, s0__ReplyItemList* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ReplyItemList*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ReplyItemList, sizeof(s0__ReplyItemList), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ReplyItemList) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ReplyItemList*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "Reserved", 0);
    if (t) {
      if (!(((s0__ReplyItemList*)a)->Reserved
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ReplyItemList*)a)->Reserved = soap_new_std__string(soap, -1);
        ((s0__ReplyItemList*)a)->Reserved->assign(s);
      }
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__ItemValue(soap,
                "s0:Items", &(((s0__ReplyItemList*)a)->Items), "s0:ItemValue"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ReplyItemList*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ReplyItemList, 0, sizeof(s0__ReplyItemList), 0,
        soap_copy_s0__ReplyItemList);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ReplyItemList* SOAP_FMAC6 soap_new_s0__ReplyItemList(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ReplyItemList(
    struct soap* soap, s0__ReplyItemList* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ReplyItemList* SOAP_FMAC4 soap_instantiate_s0__ReplyItemList(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ReplyItemList(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ReplyItemList, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ReplyItemList;
    if (size)
      *size = sizeof(s0__ReplyItemList);
    ((s0__ReplyItemList*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ReplyItemList[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ReplyItemList);
    for (int i = 0; i < n; i++)
      ((s0__ReplyItemList*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ReplyItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ReplyItemList(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__ReplyItemList %p -> %p\n", q, p));
  *(s0__ReplyItemList*)p = *(s0__ReplyItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ReadRequestItem::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__ReadRequestItem*)this)->ItemPath = NULL;
  ((s0__ReadRequestItem*)this)->ReqType = NULL;
  ((s0__ReadRequestItem*)this)->ItemName = NULL;
  ((s0__ReadRequestItem*)this)->ClientItemHandle = NULL;
  ((s0__ReadRequestItem*)this)->MaxAge = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ReadRequestItem::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int s0__ReadRequestItem::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ReadRequestItem);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ReadRequestItem::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ReadRequestItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ReadRequestItem(struct soap* soap,
    const char* tag, int id, const s0__ReadRequestItem* a, const char* type)
{
  if (((s0__ReadRequestItem*)a)->ItemPath)
    soap_set_attr(
        soap, "ItemPath", ((s0__ReadRequestItem*)a)->ItemPath->c_str());
  if (((s0__ReadRequestItem*)a)->ReqType)
    soap_set_attr(soap, "ReqType",
        soap_QName2s(soap, ((s0__ReadRequestItem*)a)->ReqType->c_str()));
  if (((s0__ReadRequestItem*)a)->ItemName)
    soap_set_attr(
        soap, "ItemName", ((s0__ReadRequestItem*)a)->ItemName->c_str());
  if (((s0__ReadRequestItem*)a)->ClientItemHandle)
    soap_set_attr(soap, "ClientItemHandle",
        ((s0__ReadRequestItem*)a)->ClientItemHandle->c_str());
  if (((s0__ReadRequestItem*)a)->MaxAge)
    soap_set_attr(
        soap, "MaxAge", soap_int2s(soap, *((s0__ReadRequestItem*)a)->MaxAge));
  return soap_outliteral(
      soap, tag, &(((xsd__anyType*)a)->__item), "s0:ReadRequestItem");
}

void* s0__ReadRequestItem::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ReadRequestItem(soap, this, tag, type);
}

SOAP_FMAC3 s0__ReadRequestItem* SOAP_FMAC4 soap_get_s0__ReadRequestItem(
    struct soap* soap, s0__ReadRequestItem* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__ReadRequestItem(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ReadRequestItem::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ReadRequestItem(soap, tag, this, type);
}

SOAP_FMAC3 s0__ReadRequestItem* SOAP_FMAC4 soap_in_s0__ReadRequestItem(
    struct soap* soap, const char* tag, s0__ReadRequestItem* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__ReadRequestItem*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__ReadRequestItem, sizeof(s0__ReadRequestItem),
            soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ReadRequestItem)
      return (s0__ReadRequestItem*)a->soap_in(soap, tag, type);
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__ReadRequestItem*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ReadRequestItem*)a)->ItemPath = soap_new_std__string(soap, -1);
        ((s0__ReadRequestItem*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReqType", 0);
    if (t) {
      if (!(((s0__ReadRequestItem*)a)->ReqType
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ReadRequestItem*)a)->ReqType = soap_new_std__string(soap, -1);
        ((s0__ReadRequestItem*)a)->ReqType->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemName", 0);
    if (t) {
      if (!(((s0__ReadRequestItem*)a)->ItemName
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ReadRequestItem*)a)->ItemName = soap_new_std__string(soap, -1);
        ((s0__ReadRequestItem*)a)->ItemName->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientItemHandle", 0);
    if (t) {
      if (!(((s0__ReadRequestItem*)a)->ClientItemHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ReadRequestItem*)a)->ClientItemHandle
            = soap_new_std__string(soap, -1);
        ((s0__ReadRequestItem*)a)->ClientItemHandle->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "MaxAge", 0);
    if (t) {
      if (!(((s0__ReadRequestItem*)a)->MaxAge
              = (int*)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(soap, t, ((s0__ReadRequestItem*)a)->MaxAge))
        return NULL;
    }
  }
  if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__ReadRequestItem* SOAP_FMAC6 soap_new_s0__ReadRequestItem(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ReadRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ReadRequestItem(
    struct soap* soap, s0__ReadRequestItem* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ReadRequestItem* SOAP_FMAC4 soap_instantiate_s0__ReadRequestItem(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ReadRequestItem(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ReadRequestItem, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ReadRequestItem;
    if (size)
      *size = sizeof(s0__ReadRequestItem);
    ((s0__ReadRequestItem*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ReadRequestItem[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ReadRequestItem);
    for (int i = 0; i < n; i++)
      ((s0__ReadRequestItem*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ReadRequestItem*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ReadRequestItem(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__ReadRequestItem %p -> %p\n", q, p));
  *(s0__ReadRequestItem*)p = *(s0__ReadRequestItem*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ReadRequestItemList::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTos0__ReadRequestItem(
      soap, &((s0__ReadRequestItemList*)this)->Items);
  ((s0__ReadRequestItemList*)this)->ItemPath = NULL;
  ((s0__ReadRequestItemList*)this)->ReqType = NULL;
  ((s0__ReadRequestItemList*)this)->MaxAge = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ReadRequestItemList::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_std__vectorTemplateOfPointerTos0__ReadRequestItem(
      soap, &((s0__ReadRequestItemList*)this)->Items);
  /* transient soap skipped */
}

int s0__ReadRequestItemList::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ReadRequestItemList);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ReadRequestItemList::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ReadRequestItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ReadRequestItemList(struct soap* soap,
    const char* tag, int id, const s0__ReadRequestItemList* a, const char* type)
{
  if (((s0__ReadRequestItemList*)a)->ItemPath)
    soap_set_attr(
        soap, "ItemPath", ((s0__ReadRequestItemList*)a)->ItemPath->c_str());
  if (((s0__ReadRequestItemList*)a)->ReqType)
    soap_set_attr(soap, "ReqType",
        soap_QName2s(soap, ((s0__ReadRequestItemList*)a)->ReqType->c_str()));
  if (((s0__ReadRequestItemList*)a)->MaxAge)
    soap_set_attr(soap, "MaxAge",
        soap_int2s(soap, *((s0__ReadRequestItemList*)a)->MaxAge));
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ReadRequestItemList),
      "s0:ReadRequestItemList");
  /* transient soap skipped */
  soap_out_std__vectorTemplateOfPointerTos0__ReadRequestItem(
      soap, "s0:Items", -1, &(((s0__ReadRequestItemList*)a)->Items), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ReadRequestItemList::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ReadRequestItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__ReadRequestItemList* SOAP_FMAC4 soap_get_s0__ReadRequestItemList(
    struct soap* soap, s0__ReadRequestItemList* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_s0__ReadRequestItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ReadRequestItemList::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ReadRequestItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__ReadRequestItemList* SOAP_FMAC4 soap_in_s0__ReadRequestItemList(
    struct soap* soap, const char* tag, s0__ReadRequestItemList* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ReadRequestItemList*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ReadRequestItemList, sizeof(s0__ReadRequestItemList),
      soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ReadRequestItemList) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ReadRequestItemList*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ItemPath", 0);
    if (t) {
      if (!(((s0__ReadRequestItemList*)a)->ItemPath
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ReadRequestItemList*)a)->ItemPath
            = soap_new_std__string(soap, -1);
        ((s0__ReadRequestItemList*)a)->ItemPath->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReqType", 0);
    if (t) {
      if (!(((s0__ReadRequestItemList*)a)->ReqType
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2QName(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ReadRequestItemList*)a)->ReqType = soap_new_std__string(soap, -1);
        ((s0__ReadRequestItemList*)a)->ReqType->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "MaxAge", 0);
    if (t) {
      if (!(((s0__ReadRequestItemList*)a)->MaxAge
              = (int*)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(soap, t, ((s0__ReadRequestItemList*)a)->MaxAge))
        return NULL;
    }
  }
  short soap_flag___item2 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfPointerTos0__ReadRequestItem(soap,
                "s0:Items", &(((s0__ReadRequestItemList*)a)->Items),
                "s0:ReadRequestItem"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ReadRequestItemList*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ReadRequestItemList, 0, sizeof(s0__ReadRequestItemList),
        0, soap_copy_s0__ReadRequestItemList);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ReadRequestItemList* SOAP_FMAC6 soap_new_s0__ReadRequestItemList(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ReadRequestItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ReadRequestItemList(
    struct soap* soap, s0__ReadRequestItemList* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ReadRequestItemList* SOAP_FMAC4
soap_instantiate_s0__ReadRequestItemList(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_s0__ReadRequestItemList(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_s0__ReadRequestItemList, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ReadRequestItemList;
    if (size)
      *size = sizeof(s0__ReadRequestItemList);
    ((s0__ReadRequestItemList*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ReadRequestItemList[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ReadRequestItemList);
    for (int i = 0; i < n; i++)
      ((s0__ReadRequestItemList*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ReadRequestItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ReadRequestItemList(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__ReadRequestItemList %p -> %p\n", q, p));
  *(s0__ReadRequestItemList*)p = *(s0__ReadRequestItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__RequestOptions::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__RequestOptions*)this)->ReturnErrorText = NULL;
  ((s0__RequestOptions*)this)->ReturnDiagnosticInfo = NULL;
  ((s0__RequestOptions*)this)->ReturnItemTime = NULL;
  ((s0__RequestOptions*)this)->ReturnItemPath = NULL;
  ((s0__RequestOptions*)this)->ReturnItemName = NULL;
  ((s0__RequestOptions*)this)->RequestDeadline = NULL;
  ((s0__RequestOptions*)this)->ClientRequestHandle = NULL;
  ((s0__RequestOptions*)this)->LocaleID = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__RequestOptions::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int s0__RequestOptions::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__RequestOptions);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__RequestOptions::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__RequestOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__RequestOptions(struct soap* soap,
    const char* tag, int id, const s0__RequestOptions* a, const char* type)
{
  if (((s0__RequestOptions*)a)->ReturnErrorText)
    soap_set_attr(soap, "ReturnErrorText",
        soap_bool2s(soap, *((s0__RequestOptions*)a)->ReturnErrorText));
  if (((s0__RequestOptions*)a)->ReturnDiagnosticInfo)
    soap_set_attr(soap, "ReturnDiagnosticInfo",
        soap_bool2s(soap, *((s0__RequestOptions*)a)->ReturnDiagnosticInfo));
  if (((s0__RequestOptions*)a)->ReturnItemTime)
    soap_set_attr(soap, "ReturnItemTime",
        soap_bool2s(soap, *((s0__RequestOptions*)a)->ReturnItemTime));
  if (((s0__RequestOptions*)a)->ReturnItemPath)
    soap_set_attr(soap, "ReturnItemPath",
        soap_bool2s(soap, *((s0__RequestOptions*)a)->ReturnItemPath));
  if (((s0__RequestOptions*)a)->ReturnItemName)
    soap_set_attr(soap, "ReturnItemName",
        soap_bool2s(soap, *((s0__RequestOptions*)a)->ReturnItemName));
  if (((s0__RequestOptions*)a)->RequestDeadline)
    soap_set_attr(soap, "RequestDeadline",
        ((s0__RequestOptions*)a)->RequestDeadline->c_str());
  if (((s0__RequestOptions*)a)->ClientRequestHandle)
    soap_set_attr(soap, "ClientRequestHandle",
        ((s0__RequestOptions*)a)->ClientRequestHandle->c_str());
  if (((s0__RequestOptions*)a)->LocaleID)
    soap_set_attr(
        soap, "LocaleID", ((s0__RequestOptions*)a)->LocaleID->c_str());
  return soap_outliteral(
      soap, tag, &(((xsd__anyType*)a)->__item), "s0:RequestOptions");
}

void* s0__RequestOptions::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__RequestOptions(soap, this, tag, type);
}

SOAP_FMAC3 s0__RequestOptions* SOAP_FMAC4 soap_get_s0__RequestOptions(
    struct soap* soap, s0__RequestOptions* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__RequestOptions(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__RequestOptions::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__RequestOptions(soap, tag, this, type);
}

SOAP_FMAC3 s0__RequestOptions* SOAP_FMAC4 soap_in_s0__RequestOptions(
    struct soap* soap, const char* tag, s0__RequestOptions* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__RequestOptions*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__RequestOptions, sizeof(s0__RequestOptions),
            soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__RequestOptions)
      return (s0__RequestOptions*)a->soap_in(soap, tag, type);
  }
  {
    const char* t = soap_attr_value(soap, "ReturnErrorText", 0);
    if (t) {
      if (!(((s0__RequestOptions*)a)->ReturnErrorText
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((s0__RequestOptions*)a)->ReturnErrorText))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnDiagnosticInfo", 0);
    if (t) {
      if (!(((s0__RequestOptions*)a)->ReturnDiagnosticInfo
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((s0__RequestOptions*)a)->ReturnDiagnosticInfo))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnItemTime", 0);
    if (t) {
      if (!(((s0__RequestOptions*)a)->ReturnItemTime
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((s0__RequestOptions*)a)->ReturnItemTime))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnItemPath", 0);
    if (t) {
      if (!(((s0__RequestOptions*)a)->ReturnItemPath
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((s0__RequestOptions*)a)->ReturnItemPath))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReturnItemName", 0);
    if (t) {
      if (!(((s0__RequestOptions*)a)->ReturnItemName
              = (bool*)soap_malloc(soap, sizeof(bool)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2bool(soap, t, ((s0__RequestOptions*)a)->ReturnItemName))
        return NULL;
    }
  }
  {
    const char* t = soap_attr_value(soap, "RequestDeadline", 0);
    if (t) {
      if (!(((s0__RequestOptions*)a)->RequestDeadline
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__RequestOptions*)a)->RequestDeadline
            = soap_new_std__string(soap, -1);
        ((s0__RequestOptions*)a)->RequestDeadline->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientRequestHandle", 0);
    if (t) {
      if (!(((s0__RequestOptions*)a)->ClientRequestHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__RequestOptions*)a)->ClientRequestHandle
            = soap_new_std__string(soap, -1);
        ((s0__RequestOptions*)a)->ClientRequestHandle->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "LocaleID", 0);
    if (t) {
      if (!(((s0__RequestOptions*)a)->LocaleID
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__RequestOptions*)a)->LocaleID = soap_new_std__string(soap, -1);
        ((s0__RequestOptions*)a)->LocaleID->assign(s);
      }
    }
  }
  if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__RequestOptions* SOAP_FMAC6 soap_new_s0__RequestOptions(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__RequestOptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__RequestOptions(
    struct soap* soap, s0__RequestOptions* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__RequestOptions* SOAP_FMAC4 soap_instantiate_s0__RequestOptions(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__RequestOptions(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__RequestOptions, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__RequestOptions;
    if (size)
      *size = sizeof(s0__RequestOptions);
    ((s0__RequestOptions*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__RequestOptions[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__RequestOptions);
    for (int i = 0; i < n; i++)
      ((s0__RequestOptions*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__RequestOptions*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__RequestOptions(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying s0__RequestOptions %p -> %p\n", q, p));
  *(s0__RequestOptions*)p = *(s0__RequestOptions*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ServerStatus::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((s0__ServerStatus*)this)->StatusInfo = NULL;
  ((s0__ServerStatus*)this)->VendorInfo = NULL;
  soap_default_std__vectorTemplateOfstd__string(
      soap, &((s0__ServerStatus*)this)->SupportedLocaleIDs);
  soap_default_std__vectorTemplateOfs0__interfaceVersion(
      soap, &((s0__ServerStatus*)this)->SupportedInterfaceVersions);
  soap_default_std__string(soap, &((s0__ServerStatus*)this)->StartTime);
  ((s0__ServerStatus*)this)->ProductVersion = NULL;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ServerStatus::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_PointerTostd__string(
      soap, &((s0__ServerStatus*)this)->StatusInfo);
  soap_serialize_PointerTostd__string(
      soap, &((s0__ServerStatus*)this)->VendorInfo);
  soap_serialize_std__vectorTemplateOfstd__string(
      soap, &((s0__ServerStatus*)this)->SupportedLocaleIDs);
  soap_serialize_std__vectorTemplateOfs0__interfaceVersion(
      soap, &((s0__ServerStatus*)this)->SupportedInterfaceVersions);
  /* transient soap skipped */
}

int s0__ServerStatus::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ServerStatus);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ServerStatus::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ServerStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ServerStatus(struct soap* soap,
    const char* tag, int id, const s0__ServerStatus* a, const char* type)
{
  if (!((s0__ServerStatus*)a)->StartTime.empty())
    soap_set_attr(soap, "StartTime", ((s0__ServerStatus*)a)->StartTime.c_str());
  if (((s0__ServerStatus*)a)->ProductVersion)
    soap_set_attr(soap, "ProductVersion",
        ((s0__ServerStatus*)a)->ProductVersion->c_str());
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ServerStatus),
      "s0:ServerStatus");
  /* transient soap skipped */
  soap_out_PointerTostd__string(
      soap, "s0:StatusInfo", -1, &(((s0__ServerStatus*)a)->StatusInfo), "");
  soap_out_PointerTostd__string(
      soap, "s0:VendorInfo", -1, &(((s0__ServerStatus*)a)->VendorInfo), "");
  soap_out_std__vectorTemplateOfstd__string(soap, "s0:SupportedLocaleIDs", -1,
      &(((s0__ServerStatus*)a)->SupportedLocaleIDs), "");
  soap_out_std__vectorTemplateOfs0__interfaceVersion(soap,
      "s0:SupportedInterfaceVersions", -1,
      &(((s0__ServerStatus*)a)->SupportedInterfaceVersions), "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

void* s0__ServerStatus::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ServerStatus(soap, this, tag, type);
}

SOAP_FMAC3 s0__ServerStatus* SOAP_FMAC4 soap_get_s0__ServerStatus(
    struct soap* soap, s0__ServerStatus* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ServerStatus(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ServerStatus::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ServerStatus(soap, tag, this, type);
}

SOAP_FMAC3 s0__ServerStatus* SOAP_FMAC4 soap_in_s0__ServerStatus(
    struct soap* soap, const char* tag, s0__ServerStatus* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (s0__ServerStatus*)soap_class_id_enter(soap, soap->id, a,
      SOAP_TYPE_s0__ServerStatus, sizeof(s0__ServerStatus), soap->type,
      soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ServerStatus) {
      soap_revert(soap);
      *soap->id = '\0';
      return (s0__ServerStatus*)a->soap_in(soap, tag, type);
    }
  }
  {
    const char* t = soap_attr_value(soap, "StartTime", 1);
    if (t) {
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      ((s0__ServerStatus*)a)->StartTime.assign(s);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ProductVersion", 0);
    if (t) {
      if (!(((s0__ServerStatus*)a)->ProductVersion
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ServerStatus*)a)->ProductVersion = soap_new_std__string(soap, -1);
        ((s0__ServerStatus*)a)->ProductVersion->assign(s);
      }
    }
  }
  short soap_flag___item2 = 1, soap_flag_StatusInfo1 = 1,
        soap_flag_VendorInfo1 = 1;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient soap skipped */
      if (soap_flag_StatusInfo1
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "s0:StatusInfo",
                &(((s0__ServerStatus*)a)->StatusInfo), "xsd:string")) {
          soap_flag_StatusInfo1--;
          continue;
        }
      if (soap_flag_VendorInfo1
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_PointerTostd__string(soap, "s0:VendorInfo",
                &(((s0__ServerStatus*)a)->VendorInfo), "xsd:string")) {
          soap_flag_VendorInfo1--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfstd__string(soap,
                "s0:SupportedLocaleIDs",
                &(((s0__ServerStatus*)a)->SupportedLocaleIDs), "xsd:string"))
          continue;
      if (soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_std__vectorTemplateOfs0__interfaceVersion(soap,
                "s0:SupportedInterfaceVersions",
                &(((s0__ServerStatus*)a)->SupportedInterfaceVersions),
                "s0:interfaceVersion"))
          continue;
      if (soap_flag___item2
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item))) {
          soap_flag___item2--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (s0__ServerStatus*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_s0__ServerStatus, 0, sizeof(s0__ServerStatus), 0,
        soap_copy_s0__ServerStatus);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 s0__ServerStatus* SOAP_FMAC6 soap_new_s0__ServerStatus(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ServerStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ServerStatus(
    struct soap* soap, s0__ServerStatus* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ServerStatus* SOAP_FMAC4 soap_instantiate_s0__ServerStatus(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ServerStatus(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ServerStatus, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ServerStatus;
    if (size)
      *size = sizeof(s0__ServerStatus);
    ((s0__ServerStatus*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ServerStatus[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ServerStatus);
    for (int i = 0; i < n; i++)
      ((s0__ServerStatus*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ServerStatus*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ServerStatus(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying s0__ServerStatus %p -> %p\n", q, p));
  *(s0__ServerStatus*)p = *(s0__ServerStatus*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ReplyBase::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__string(soap, &((s0__ReplyBase*)this)->RcvTime);
  soap_default_std__string(soap, &((s0__ReplyBase*)this)->ReplyTime);
  ((s0__ReplyBase*)this)->ClientRequestHandle = NULL;
  ((s0__ReplyBase*)this)->RevisedLocaleID = NULL;
  soap_default_s0__serverState(soap, &((s0__ReplyBase*)this)->ServerState);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void s0__ReplyBase::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int s0__ReplyBase::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ReplyBase);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int s0__ReplyBase::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_s0__ReplyBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ReplyBase(struct soap* soap,
    const char* tag, int id, const s0__ReplyBase* a, const char* type)
{
  if (!((s0__ReplyBase*)a)->RcvTime.empty())
    soap_set_attr(soap, "RcvTime", ((s0__ReplyBase*)a)->RcvTime.c_str());
  if (!((s0__ReplyBase*)a)->ReplyTime.empty())
    soap_set_attr(soap, "ReplyTime", ((s0__ReplyBase*)a)->ReplyTime.c_str());
  if (((s0__ReplyBase*)a)->ClientRequestHandle)
    soap_set_attr(soap, "ClientRequestHandle",
        ((s0__ReplyBase*)a)->ClientRequestHandle->c_str());
  if (((s0__ReplyBase*)a)->RevisedLocaleID)
    soap_set_attr(
        soap, "RevisedLocaleID", ((s0__ReplyBase*)a)->RevisedLocaleID->c_str());
  soap_set_attr(soap, "ServerState",
      soap_s0__serverState2s(soap, ((s0__ReplyBase*)a)->ServerState));
  return soap_outliteral(
      soap, tag, &(((xsd__anyType*)a)->__item), "s0:ReplyBase");
}

void* s0__ReplyBase::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_s0__ReplyBase(soap, this, tag, type);
}

SOAP_FMAC3 s0__ReplyBase* SOAP_FMAC4 soap_get_s0__ReplyBase(
    struct soap* soap, s0__ReplyBase* p, const char* tag, const char* type)
{
  if ((p = soap_in_s0__ReplyBase(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* s0__ReplyBase::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_s0__ReplyBase(soap, tag, this, type);
}

SOAP_FMAC3 s0__ReplyBase* SOAP_FMAC4 soap_in_s0__ReplyBase(
    struct soap* soap, const char* tag, s0__ReplyBase* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (s0__ReplyBase*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_s0__ReplyBase, sizeof(s0__ReplyBase), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_s0__ReplyBase)
      return (s0__ReplyBase*)a->soap_in(soap, tag, type);
  }
  {
    const char* t = soap_attr_value(soap, "RcvTime", 1);
    if (t) {
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      ((s0__ReplyBase*)a)->RcvTime.assign(s);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ReplyTime", 1);
    if (t) {
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      ((s0__ReplyBase*)a)->ReplyTime.assign(s);
    }
  }
  {
    const char* t = soap_attr_value(soap, "ClientRequestHandle", 0);
    if (t) {
      if (!(((s0__ReplyBase*)a)->ClientRequestHandle
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ReplyBase*)a)->ClientRequestHandle
            = soap_new_std__string(soap, -1);
        ((s0__ReplyBase*)a)->ClientRequestHandle->assign(s);
      }
    }
  }
  {
    const char* t = soap_attr_value(soap, "RevisedLocaleID", 0);
    if (t) {
      if (!(((s0__ReplyBase*)a)->RevisedLocaleID
              = (std::string*)soap_malloc(soap, sizeof(std::string)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      char* s;
      if (soap_s2string(soap, t, &s))
        return NULL;
      if (s) {
        ((s0__ReplyBase*)a)->RevisedLocaleID = soap_new_std__string(soap, -1);
        ((s0__ReplyBase*)a)->RevisedLocaleID->assign(s);
      }
    }
  }
  if (soap_s2s0__serverState(soap, soap_attr_value(soap, "ServerState", 1),
          &((s0__ReplyBase*)a)->ServerState))
    return NULL;
  if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
    return NULL;
  return a;
}

SOAP_FMAC5 s0__ReplyBase* SOAP_FMAC6 soap_new_s0__ReplyBase(
    struct soap* soap, int n)
{
  return soap_instantiate_s0__ReplyBase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ReplyBase(
    struct soap* soap, s0__ReplyBase* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 s0__ReplyBase* SOAP_FMAC4 soap_instantiate_s0__ReplyBase(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ReplyBase(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_s0__ReplyBase, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new s0__ReplyBase;
    if (size)
      *size = sizeof(s0__ReplyBase);
    ((s0__ReplyBase*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new s0__ReplyBase[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(s0__ReplyBase);
    for (int i = 0; i < n; i++)
      ((s0__ReplyBase*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (s0__ReplyBase*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ReplyBase(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ReplyBase %p -> %p\n", q, p));
  *(s0__ReplyBase*)p = *(s0__ReplyBase*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__unsignedShort::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_unsignedShort(soap, &((xsd__unsignedShort*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__unsignedShort::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(
      soap, &((xsd__unsignedShort*)this)->__item, SOAP_TYPE_unsignedShort);
  /* transient soap skipped */
}

int xsd__unsignedShort::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedShort);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__unsignedShort::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__unsignedShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedShort(struct soap* soap,
    const char* tag, int id, const xsd__unsignedShort* a, const char* type)
{
  return soap_out_unsignedShort(
      soap, tag, id, &(((xsd__unsignedShort*)a)->__item), "xsd:unsignedShort");
}

void* xsd__unsignedShort::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__unsignedShort(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedShort* SOAP_FMAC4 soap_get_xsd__unsignedShort(
    struct soap* soap, xsd__unsignedShort* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__unsignedShort(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__unsignedShort::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__unsignedShort(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedShort* SOAP_FMAC4 soap_in_xsd__unsignedShort(
    struct soap* soap, const char* tag, xsd__unsignedShort* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__unsignedShort*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__unsignedShort, sizeof(xsd__unsignedShort),
            soap->type, soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__unsignedShort)
      return (xsd__unsignedShort*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_unsignedShort(
          soap, tag, &(((xsd__unsignedShort*)a)->__item), "xsd:unsignedShort"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__unsignedShort* SOAP_FMAC6 soap_new_xsd__unsignedShort(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__unsignedShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedShort(
    struct soap* soap, xsd__unsignedShort* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedShort* SOAP_FMAC4 soap_instantiate_xsd__unsignedShort(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedShort(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedShort, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__unsignedShort;
    if (size)
      *size = sizeof(xsd__unsignedShort);
    ((xsd__unsignedShort*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__unsignedShort[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__unsignedShort);
    for (int i = 0; i < n; i++)
      ((xsd__unsignedShort*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__unsignedShort*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedShort(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying xsd__unsignedShort %p -> %p\n", q, p));
  *(xsd__unsignedShort*)p = *(xsd__unsignedShort*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__unsignedLong::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_unsignedLONG64(soap, &((xsd__unsignedLong*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__unsignedLong::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int xsd__unsignedLong::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__unsignedLong::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__unsignedLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap* soap,
    const char* tag, int id, const xsd__unsignedLong* a, const char* type)
{
  return soap_out_unsignedLONG64(
      soap, tag, id, &(((xsd__unsignedLong*)a)->__item), "xsd:unsignedLong");
}

void* xsd__unsignedLong::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__unsignedLong(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedLong* SOAP_FMAC4 soap_get_xsd__unsignedLong(
    struct soap* soap, xsd__unsignedLong* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__unsignedLong::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__unsignedLong(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedLong* SOAP_FMAC4 soap_in_xsd__unsignedLong(
    struct soap* soap, const char* tag, xsd__unsignedLong* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__unsignedLong*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__unsignedLong, sizeof(xsd__unsignedLong), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__unsignedLong)
      return (xsd__unsignedLong*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_unsignedLONG64(
          soap, tag, &(((xsd__unsignedLong*)a)->__item), "xsd:unsignedLong"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__unsignedLong* SOAP_FMAC6 soap_new_xsd__unsignedLong(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__unsignedLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedLong(
    struct soap* soap, xsd__unsignedLong* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedLong* SOAP_FMAC4 soap_instantiate_xsd__unsignedLong(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedLong(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedLong, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__unsignedLong;
    if (size)
      *size = sizeof(xsd__unsignedLong);
    ((xsd__unsignedLong*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__unsignedLong[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__unsignedLong);
    for (int i = 0; i < n; i++)
      ((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__unsignedLong*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedLong(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedLong %p -> %p\n", q, p));
  *(xsd__unsignedLong*)p = *(xsd__unsignedLong*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__unsignedInt::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_unsignedInt(soap, &((xsd__unsignedInt*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__unsignedInt::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int xsd__unsignedInt::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__unsignedInt::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__unsignedInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap* soap,
    const char* tag, int id, const xsd__unsignedInt* a, const char* type)
{
  return soap_out_unsignedInt(
      soap, tag, id, &(((xsd__unsignedInt*)a)->__item), "xsd:unsignedInt");
}

void* xsd__unsignedInt::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__unsignedInt(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedInt* SOAP_FMAC4 soap_get_xsd__unsignedInt(
    struct soap* soap, xsd__unsignedInt* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__unsignedInt::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__unsignedInt(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedInt* SOAP_FMAC4 soap_in_xsd__unsignedInt(
    struct soap* soap, const char* tag, xsd__unsignedInt* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__unsignedInt*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__unsignedInt, sizeof(xsd__unsignedInt), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__unsignedInt)
      return (xsd__unsignedInt*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_unsignedInt(
          soap, tag, &(((xsd__unsignedInt*)a)->__item), "xsd:unsignedInt"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__unsignedInt* SOAP_FMAC6 soap_new_xsd__unsignedInt(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__unsignedInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedInt(
    struct soap* soap, xsd__unsignedInt* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedInt* SOAP_FMAC4 soap_instantiate_xsd__unsignedInt(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedInt(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedInt, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__unsignedInt;
    if (size)
      *size = sizeof(xsd__unsignedInt);
    ((xsd__unsignedInt*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__unsignedInt[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__unsignedInt);
    for (int i = 0; i < n; i++)
      ((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__unsignedInt*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedInt(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedInt %p -> %p\n", q, p));
  *(xsd__unsignedInt*)p = *(xsd__unsignedInt*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__unsignedByte::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_unsignedByte(soap, &((xsd__unsignedByte*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__unsignedByte::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int xsd__unsignedByte::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id = soap_embed(
      soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__unsignedByte::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__unsignedByte(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap* soap,
    const char* tag, int id, const xsd__unsignedByte* a, const char* type)
{
  return soap_out_unsignedByte(
      soap, tag, id, &(((xsd__unsignedByte*)a)->__item), "xsd:unsignedByte");
}

void* xsd__unsignedByte::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__unsignedByte(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedByte* SOAP_FMAC4 soap_get_xsd__unsignedByte(
    struct soap* soap, xsd__unsignedByte* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__unsignedByte::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__unsignedByte(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedByte* SOAP_FMAC4 soap_in_xsd__unsignedByte(
    struct soap* soap, const char* tag, xsd__unsignedByte* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__unsignedByte*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__unsignedByte, sizeof(xsd__unsignedByte), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__unsignedByte)
      return (xsd__unsignedByte*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_unsignedByte(
          soap, tag, &(((xsd__unsignedByte*)a)->__item), "xsd:unsignedByte"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__unsignedByte* SOAP_FMAC6 soap_new_xsd__unsignedByte(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__unsignedByte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedByte(
    struct soap* soap, xsd__unsignedByte* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedByte* SOAP_FMAC4 soap_instantiate_xsd__unsignedByte(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedByte(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedByte, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__unsignedByte;
    if (size)
      *size = sizeof(xsd__unsignedByte);
    ((xsd__unsignedByte*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__unsignedByte[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__unsignedByte);
    for (int i = 0; i < n; i++)
      ((xsd__unsignedByte*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__unsignedByte*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedByte(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedByte %p -> %p\n", q, p));
  *(xsd__unsignedByte*)p = *(xsd__unsignedByte*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__string::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__string(soap, &((xsd__string*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__string::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &((xsd__string*)this)->__item, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &((xsd__string*)this)->__item);
  /* transient soap skipped */
}

int xsd__string::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__string::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap* soap,
    const char* tag, int id, const xsd__string* a, const char* type)
{
  return soap_out_std__string(
      soap, tag, id, &(((xsd__string*)a)->__item), "xsd:string");
}

void* xsd__string::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string* SOAP_FMAC4 soap_get_xsd__string(
    struct soap* soap, xsd__string* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__string(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__string::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string* SOAP_FMAC4 soap_in_xsd__string(
    struct soap* soap, const char* tag, xsd__string* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__string*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__string)
      return (xsd__string*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_std__string(
          soap, tag, &(((xsd__string*)a)->__item), "xsd:string"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__string* SOAP_FMAC6 soap_new_xsd__string(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__string(
    struct soap* soap, xsd__string* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__string* SOAP_FMAC4 soap_instantiate_xsd__string(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__string;
    if (size)
      *size = sizeof(xsd__string);
    ((xsd__string*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__string[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__string);
    for (int i = 0; i < n; i++)
      ((xsd__string*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
  *(xsd__string*)p = *(xsd__string*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__short::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_short(soap, &((xsd__short*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__short::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int xsd__short::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__short);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__short::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__short(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__short(struct soap* soap,
    const char* tag, int id, const xsd__short* a, const char* type)
{
  return soap_out_short(
      soap, tag, id, &(((xsd__short*)a)->__item), "xsd:short");
}

void* xsd__short::soap_get(struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__short(soap, this, tag, type);
}

SOAP_FMAC3 xsd__short* SOAP_FMAC4 soap_get_xsd__short(
    struct soap* soap, xsd__short* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__short(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__short::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__short(soap, tag, this, type);
}

SOAP_FMAC3 xsd__short* SOAP_FMAC4 soap_in_xsd__short(
    struct soap* soap, const char* tag, xsd__short* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__short*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__short, sizeof(xsd__short), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__short)
      return (xsd__short*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_short(soap, tag, &(((xsd__short*)a)->__item), "xsd:short"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__short* SOAP_FMAC6 soap_new_xsd__short(struct soap* soap, int n)
{
  return soap_instantiate_xsd__short(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__short(
    struct soap* soap, xsd__short* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__short* SOAP_FMAC4 soap_instantiate_xsd__short(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__short(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__short, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__short;
    if (size)
      *size = sizeof(xsd__short);
    ((xsd__short*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__short[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__short);
    for (int i = 0; i < n; i++)
      ((xsd__short*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__short*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__short(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__short %p -> %p\n", q, p));
  *(xsd__short*)p = *(xsd__short*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__long::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_LONG64(soap, &((xsd__long*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__long::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int xsd__long::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__long::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap* soap, const char* tag,
    int id, const xsd__long* a, const char* type)
{
  return soap_out_LONG64(soap, tag, id, &(((xsd__long*)a)->__item), "xsd:long");
}

void* xsd__long::soap_get(struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long* SOAP_FMAC4 soap_get_xsd__long(
    struct soap* soap, xsd__long* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__long(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__long::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long* SOAP_FMAC4 soap_in_xsd__long(
    struct soap* soap, const char* tag, xsd__long* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__long*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__long)
      return (xsd__long*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_LONG64(soap, tag, &(((xsd__long*)a)->__item), "xsd:long"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__long* SOAP_FMAC6 soap_new_xsd__long(struct soap* soap, int n)
{
  return soap_instantiate_xsd__long(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__long(
    struct soap* soap, xsd__long* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__long* SOAP_FMAC4 soap_instantiate_xsd__long(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__long;
    if (size)
      *size = sizeof(xsd__long);
    ((xsd__long*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__long[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__long);
    for (int i = 0; i < n; i++)
      ((xsd__long*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__long*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
  *(xsd__long*)p = *(xsd__long*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__int::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_int(soap, &((xsd__int*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__int::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &((xsd__int*)this)->__item, SOAP_TYPE_int);
  /* transient soap skipped */
}

int xsd__int::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__int::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap* soap, const char* tag,
    int id, const xsd__int* a, const char* type)
{
  return soap_out_int(soap, tag, id, &(((xsd__int*)a)->__item), "xsd:int");
}

void* xsd__int::soap_get(struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int* SOAP_FMAC4 soap_get_xsd__int(
    struct soap* soap, xsd__int* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__int(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__int::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int* SOAP_FMAC4 soap_in_xsd__int(
    struct soap* soap, const char* tag, xsd__int* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__int*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__int)
      return (xsd__int*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_int(soap, tag, &(((xsd__int*)a)->__item), "xsd:int"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__int* SOAP_FMAC6 soap_new_xsd__int(struct soap* soap, int n)
{
  return soap_instantiate_xsd__int(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__int(struct soap* soap, xsd__int* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__int* SOAP_FMAC4 soap_instantiate_xsd__int(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__int;
    if (size)
      *size = sizeof(xsd__int);
    ((xsd__int*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__int[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__int);
    for (int i = 0; i < n; i++)
      ((xsd__int*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__int*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap* soap, int st, int tt,
    void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
  *(xsd__int*)p = *(xsd__int*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__float::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_float(soap, &((xsd__float*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__float::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &((xsd__float*)this)->__item, SOAP_TYPE_float);
  /* transient soap skipped */
}

int xsd__float::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__float);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__float::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__float(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float(struct soap* soap,
    const char* tag, int id, const xsd__float* a, const char* type)
{
  return soap_out_float(
      soap, tag, id, &(((xsd__float*)a)->__item), "xsd:float");
}

void* xsd__float::soap_get(struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__float(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float* SOAP_FMAC4 soap_get_xsd__float(
    struct soap* soap, xsd__float* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__float(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__float::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__float(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float* SOAP_FMAC4 soap_in_xsd__float(
    struct soap* soap, const char* tag, xsd__float* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__float*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__float, sizeof(xsd__float), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__float)
      return (xsd__float*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_float(soap, tag, &(((xsd__float*)a)->__item), "xsd:float"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__float* SOAP_FMAC6 soap_new_xsd__float(struct soap* soap, int n)
{
  return soap_instantiate_xsd__float(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__float(
    struct soap* soap, xsd__float* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__float* SOAP_FMAC4 soap_instantiate_xsd__float(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__float, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__float;
    if (size)
      *size = sizeof(xsd__float);
    ((xsd__float*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__float[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__float);
    for (int i = 0; i < n; i++)
      ((xsd__float*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__float*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__float(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__float %p -> %p\n", q, p));
  *(xsd__float*)p = *(xsd__float*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__double::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_double(soap, &((xsd__double*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__double::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int xsd__double::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__double::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap* soap,
    const char* tag, int id, const xsd__double* a, const char* type)
{
  return soap_out_double(
      soap, tag, id, &(((xsd__double*)a)->__item), "xsd:double");
}

void* xsd__double::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double* SOAP_FMAC4 soap_get_xsd__double(
    struct soap* soap, xsd__double* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__double(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__double::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double* SOAP_FMAC4 soap_in_xsd__double(
    struct soap* soap, const char* tag, xsd__double* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__double*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__double, sizeof(xsd__double), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__double)
      return (xsd__double*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_double(soap, tag, &(((xsd__double*)a)->__item), "xsd:double"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__double* SOAP_FMAC6 soap_new_xsd__double(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__double(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__double(
    struct soap* soap, xsd__double* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__double* SOAP_FMAC4 soap_instantiate_xsd__double(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__double, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__double;
    if (size)
      *size = sizeof(xsd__double);
    ((xsd__double*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__double[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__double);
    for (int i = 0; i < n; i++)
      ((xsd__double*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__double*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
  *(xsd__double*)p = *(xsd__double*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__decimal_::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__decimal_::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_serialize_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
  /* transient soap skipped */
}

int xsd__decimal_::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__decimal_);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__decimal_::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__decimal_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal_(struct soap* soap,
    const char* tag, int id, const xsd__decimal_* a, const char* type)
{
  return soap_out_xsd__decimal(
      soap, tag, id, &(((xsd__decimal_*)a)->__item), "xsd:decimal");
}

void* xsd__decimal_::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__decimal_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__decimal_* SOAP_FMAC4 soap_get_xsd__decimal_(
    struct soap* soap, xsd__decimal_* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__decimal_(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__decimal_::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__decimal_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__decimal_* SOAP_FMAC4 soap_in_xsd__decimal_(
    struct soap* soap, const char* tag, xsd__decimal_* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__decimal_*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__decimal_, sizeof(xsd__decimal_), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__decimal_)
      return (xsd__decimal_*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_xsd__decimal(
          soap, tag, &(((xsd__decimal_*)a)->__item), "xsd:decimal"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__decimal_* SOAP_FMAC6 soap_new_xsd__decimal_(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__decimal_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal_(
    struct soap* soap, xsd__decimal_* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__decimal_* SOAP_FMAC4 soap_instantiate_xsd__decimal_(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal_(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal_, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__decimal_;
    if (size)
      *size = sizeof(xsd__decimal_);
    ((xsd__decimal_*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__decimal_[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__decimal_);
    for (int i = 0; i < n; i++)
      ((xsd__decimal_*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__decimal_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__decimal_(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__decimal_ %p -> %p\n", q, p));
  *(xsd__decimal_*)p = *(xsd__decimal_*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__decimal(
    struct soap* soap, std::string* a)
{
  soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(
    struct soap* soap, std::string const* a)
{
  soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(
    struct soap* soap, const std::string* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
  if (soap_out_xsd__decimal(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap* soap,
    const char* tag, int id, const std::string* s, const char* type)
{
  if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
    return soap_element_null(soap, tag, id, type);
  if (soap_element_begin_out(soap, tag,
          soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type)
      || soap_string_out(soap, s->c_str(), 0)
      || soap_element_end_out(soap, tag))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 std::string* SOAP_FMAC4 soap_get_xsd__decimal(
    struct soap* soap, std::string* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC1 std::string* SOAP_FMAC2 soap_in_xsd__decimal(
    struct soap* soap, const char* tag, std::string* s, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, type))
    return NULL;
  if (!s)
    s = soap_new_std__string(soap, -1);
  if (soap->null)
    if (s)
      s->erase();
  if (soap->body && !*soap->href) {
    char* t;
    s = (std::string*)soap_class_id_enter(soap, soap->id, s,
        SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type,
        soap->arrayType);
    if (s) {
      if ((t = soap_string_in(soap, 1, -1, -1)))
        s->assign(t);
      else
        return NULL;
    }
  } else
    s = (std::string*)soap_id_forward(soap, soap->href,
        soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal,
            sizeof(std::string), soap->type, soap->arrayType),
        0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0,
        soap_copy_xsd__decimal);
  if (soap->body && soap_element_end_in(soap, tag))
    return NULL;
  return s;
}

SOAP_FMAC5 std::string* SOAP_FMAC6 soap_new_xsd__decimal(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__decimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal(
    struct soap* soap, std::string* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::string* SOAP_FMAC4 soap_instantiate_xsd__decimal(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::string;
    if (size)
      *size = sizeof(std::string);
  } else {
    cp->ptr = (void*)new std::string[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::string);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__decimal(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
  *(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__duration::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__string(soap, &((xsd__duration*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__duration::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &((xsd__duration*)this)->__item, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &((xsd__duration*)this)->__item);
  /* transient soap skipped */
}

int xsd__duration::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__duration);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__duration::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__duration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap* soap,
    const char* tag, int id, const xsd__duration* a, const char* type)
{
  return soap_out_std__string(
      soap, tag, id, &(((xsd__duration*)a)->__item), "xsd:duration");
}

void* xsd__duration::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__duration(soap, this, tag, type);
}

SOAP_FMAC3 xsd__duration* SOAP_FMAC4 soap_get_xsd__duration(
    struct soap* soap, xsd__duration* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__duration(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__duration::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__duration(soap, tag, this, type);
}

SOAP_FMAC3 xsd__duration* SOAP_FMAC4 soap_in_xsd__duration(
    struct soap* soap, const char* tag, xsd__duration* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__duration*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__duration, sizeof(xsd__duration), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__duration)
      return (xsd__duration*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_std__string(
          soap, tag, &(((xsd__duration*)a)->__item), "xsd:duration"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__duration* SOAP_FMAC6 soap_new_xsd__duration(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__duration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__duration(
    struct soap* soap, xsd__duration* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__duration* SOAP_FMAC4 soap_instantiate_xsd__duration(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__duration(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__duration, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__duration;
    if (size)
      *size = sizeof(xsd__duration);
    ((xsd__duration*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__duration[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__duration);
    for (int i = 0; i < n; i++)
      ((xsd__duration*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__duration*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__duration(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__duration %p -> %p\n", q, p));
  *(xsd__duration*)p = *(xsd__duration*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__dateTime::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_std__string(soap, &((xsd__dateTime*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__dateTime::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &((xsd__dateTime*)this)->__item, SOAP_TYPE_std__string);
  soap_serialize_std__string(soap, &((xsd__dateTime*)this)->__item);
  /* transient soap skipped */
}

int xsd__dateTime::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__dateTime::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap* soap,
    const char* tag, int id, const xsd__dateTime* a, const char* type)
{
  return soap_out_std__string(
      soap, tag, id, &(((xsd__dateTime*)a)->__item), "xsd:dateTime");
}

void* xsd__dateTime::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime* SOAP_FMAC4 soap_get_xsd__dateTime(
    struct soap* soap, xsd__dateTime* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__dateTime::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime* SOAP_FMAC4 soap_in_xsd__dateTime(
    struct soap* soap, const char* tag, xsd__dateTime* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__dateTime*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
      return (xsd__dateTime*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_std__string(
          soap, tag, &(((xsd__dateTime*)a)->__item), "xsd:dateTime"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__dateTime* SOAP_FMAC6 soap_new_xsd__dateTime(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__dateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__dateTime(
    struct soap* soap, xsd__dateTime* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__dateTime* SOAP_FMAC4 soap_instantiate_xsd__dateTime(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__dateTime;
    if (size)
      *size = sizeof(xsd__dateTime);
    ((xsd__dateTime*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__dateTime[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__dateTime);
    for (int i = 0; i < n; i++)
      ((xsd__dateTime*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__dateTime*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
  *(xsd__dateTime*)p = *(xsd__dateTime*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__byte::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_byte(soap, &((xsd__byte*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__byte::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &((xsd__byte*)this)->__item, SOAP_TYPE_byte);
  /* transient soap skipped */
}

int xsd__byte::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__byte);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__byte::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__byte(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap* soap, const char* tag,
    int id, const xsd__byte* a, const char* type)
{
  return soap_out_byte(soap, tag, id, &(((xsd__byte*)a)->__item), "xsd:byte");
}

void* xsd__byte::soap_get(struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__byte(soap, this, tag, type);
}

SOAP_FMAC3 xsd__byte* SOAP_FMAC4 soap_get_xsd__byte(
    struct soap* soap, xsd__byte* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__byte(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__byte::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__byte(soap, tag, this, type);
}

SOAP_FMAC3 xsd__byte* SOAP_FMAC4 soap_in_xsd__byte(
    struct soap* soap, const char* tag, xsd__byte* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__byte*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__byte, sizeof(xsd__byte), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__byte)
      return (xsd__byte*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_byte(soap, tag, &(((xsd__byte*)a)->__item), "xsd:byte"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__byte* SOAP_FMAC6 soap_new_xsd__byte(struct soap* soap, int n)
{
  return soap_instantiate_xsd__byte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__byte(
    struct soap* soap, xsd__byte* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__byte* SOAP_FMAC4 soap_instantiate_xsd__byte(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__byte(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__byte, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__byte;
    if (size)
      *size = sizeof(xsd__byte);
    ((xsd__byte*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__byte[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__byte);
    for (int i = 0; i < n; i++)
      ((xsd__byte*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__byte*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__byte(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__byte %p -> %p\n", q, p));
  *(xsd__byte*)p = *(xsd__byte*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__boolean::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_bool(soap, &((xsd__boolean*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__boolean::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &((xsd__boolean*)this)->__item, SOAP_TYPE_bool);
  /* transient soap skipped */
}

int xsd__boolean::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__boolean::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap* soap,
    const char* tag, int id, const xsd__boolean* a, const char* type)
{
  return soap_out_bool(
      soap, tag, id, &(((xsd__boolean*)a)->__item), "xsd:boolean");
}

void* xsd__boolean::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean* SOAP_FMAC4 soap_get_xsd__boolean(
    struct soap* soap, xsd__boolean* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__boolean::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean* SOAP_FMAC4 soap_in_xsd__boolean(
    struct soap* soap, const char* tag, xsd__boolean* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__boolean*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__boolean)
      return (xsd__boolean*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_bool(soap, tag, &(((xsd__boolean*)a)->__item), "xsd:boolean"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__boolean* SOAP_FMAC6 soap_new_xsd__boolean(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__boolean(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__boolean(
    struct soap* soap, xsd__boolean* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__boolean* SOAP_FMAC4 soap_instantiate_xsd__boolean(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__boolean;
    if (size)
      *size = sizeof(xsd__boolean);
    ((xsd__boolean*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__boolean[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__boolean);
    for (int i = 0; i < n; i++)
      ((xsd__boolean*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__boolean*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
  *(xsd__boolean*)p = *(xsd__boolean*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__QName_::soap_default(struct soap* soap)
{
  this->soap = soap;
  soap_default_xsd__QName(soap, &((xsd__QName_*)this)->__item);
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__QName_::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  soap_embedded(soap, &((xsd__QName_*)this)->__item, SOAP_TYPE_xsd__QName);
  soap_serialize_xsd__QName(soap, &((xsd__QName_*)this)->__item);
  /* transient soap skipped */
}

int xsd__QName_::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__QName_);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__QName_::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__QName_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName_(struct soap* soap,
    const char* tag, int id, const xsd__QName_* a, const char* type)
{
  std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
  return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "xsd:QName");
}

void* xsd__QName_::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__QName_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName_* SOAP_FMAC4 soap_get_xsd__QName_(
    struct soap* soap, xsd__QName_* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__QName_(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__QName_::soap_in(struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__QName_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName_* SOAP_FMAC4 soap_in_xsd__QName_(
    struct soap* soap, const char* tag, xsd__QName_* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__QName_*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__QName_, sizeof(xsd__QName_), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__QName_)
      return (xsd__QName_*)a->soap_in(soap, tag, type);
  }
  if (!soap_in_xsd__QName(soap, tag, &(((xsd__QName_*)a)->__item), "xsd:QName"))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__QName_* SOAP_FMAC6 soap_new_xsd__QName_(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__QName_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__QName_(
    struct soap* soap, xsd__QName_* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__QName_* SOAP_FMAC4 soap_instantiate_xsd__QName_(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName_(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__QName_, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new xsd__QName_;
    if (size)
      *size = sizeof(xsd__QName_);
    ((xsd__QName_*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__QName_[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__QName_);
    for (int i = 0; i < n; i++)
      ((xsd__QName_*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__QName_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName_(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__QName_ %p -> %p\n", q, p));
  *(xsd__QName_*)p = *(xsd__QName_*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(
    struct soap* soap, std::string* a)
{
  soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(
    struct soap* soap, std::string const* a)
{
  soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(
    struct soap* soap, const std::string* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
  if (soap_out_xsd__QName(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap* soap,
    const char* tag, int id, const std::string* s, const char* type)
{
  if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
    return soap_element_null(soap, tag, id, type);
  if (soap_element_begin_out(
          soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type)
      || soap_string_out(soap, s->c_str(), 0)
      || soap_element_end_out(soap, tag))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 std::string* SOAP_FMAC4 soap_get_xsd__QName(
    struct soap* soap, std::string* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__QName(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC1 std::string* SOAP_FMAC2 soap_in_xsd__QName(
    struct soap* soap, const char* tag, std::string* s, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, type))
    return NULL;
  if (!s)
    s = soap_new_std__string(soap, -1);
  if (soap->null)
    if (s)
      s->erase();
  if (soap->body && !*soap->href) {
    char* t;
    s = (std::string*)soap_class_id_enter(soap, soap->id, s,
        SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
    if (s) {
      if ((t = soap_string_in(soap, 2, -1, -1)))
        s->assign(t);
      else
        return NULL;
    }
  } else
    s = (std::string*)soap_id_forward(soap, soap->href,
        soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName,
            sizeof(std::string), soap->type, soap->arrayType),
        0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0,
        soap_copy_xsd__QName);
  if (soap->body && soap_element_end_in(soap, tag))
    return NULL;
  return s;
}

SOAP_FMAC5 std::string* SOAP_FMAC6 soap_new_xsd__QName(struct soap* soap, int n)
{
  return soap_instantiate_xsd__QName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__QName(
    struct soap* soap, std::string* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::string* SOAP_FMAC4 soap_instantiate_xsd__QName(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::string;
    if (size)
      *size = sizeof(std::string);
  } else {
    cp->ptr = (void*)new std::string[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::string);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
  *(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(
    struct soap* soap, std::string* p)
{
  (void)soap; /* appease -Wall -Werror */
  p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(
    struct soap* soap, const std::string* p)
{
  (void)soap;
  (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(
    struct soap* soap, const std::string* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
  if (soap_out_std__string(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap* soap,
    const char* tag, int id, const std::string* s, const char* type)
{
  if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
    return soap_element_null(soap, tag, id, type);
  if (soap_element_begin_out(
          soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type)
      || soap_string_out(soap, s->c_str(), 0)
      || soap_element_end_out(soap, tag))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 std::string* SOAP_FMAC4 soap_get_std__string(
    struct soap* soap, std::string* p, const char* tag, const char* type)
{
  if ((p = soap_in_std__string(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC1 std::string* SOAP_FMAC2 soap_in_std__string(
    struct soap* soap, const char* tag, std::string* s, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, type))
    return NULL;
  if (!s)
    s = soap_new_std__string(soap, -1);
  if (soap->null)
    if (s)
      s->erase();
  if (soap->body && !*soap->href) {
    char* t;
    s = (std::string*)soap_class_id_enter(soap, soap->id, s,
        SOAP_TYPE_std__string, sizeof(std::string), soap->type,
        soap->arrayType);
    if (s) {
      if ((t = soap_string_in(soap, 1, -1, -1)))
        s->assign(t);
      else
        return NULL;
    }
  } else
    s = (std::string*)soap_id_forward(soap, soap->href,
        soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string,
            sizeof(std::string), soap->type, soap->arrayType),
        0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0,
        soap_copy_std__string);
  if (soap->body && soap_element_end_in(soap, tag))
    return NULL;
  return s;
}

SOAP_FMAC5 std::string* SOAP_FMAC6 soap_new_std__string(
    struct soap* soap, int n)
{
  return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(
    struct soap* soap, std::string* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::string* SOAP_FMAC4 soap_instantiate_std__string(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::string;
    if (size)
      *size = sizeof(std::string);
  } else {
    cp->ptr = (void*)new std::string[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::string);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
  *(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__anyType::soap_default(struct soap* soap)
{
  this->soap = soap;
  ((xsd__anyType*)this)->__item = NULL;
  /* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap* soap) const
{
  (void)soap; /* appease -Wall -Werror */
  /* transient soap skipped */
}

int xsd__anyType::soap_put(
    struct soap* soap, const char* tag, const char* type) const
{
  register int id
      = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
  if (this->soap_out(soap, tag, id, type))
    return soap->error;
  return soap_putindependent(soap);
}

int xsd__anyType::soap_out(
    struct soap* soap, const char* tag, int id, const char* type) const
{
  return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap* soap,
    const char* tag, int id, const xsd__anyType* a, const char* type)
{
  return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), NULL);
}

void* xsd__anyType::soap_get(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType* SOAP_FMAC4 soap_get_xsd__anyType(
    struct soap* soap, xsd__anyType* p, const char* tag, const char* type)
{
  if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

void* xsd__anyType::soap_in(
    struct soap* soap, const char* tag, const char* type)
{
  return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType* SOAP_FMAC4 soap_in_xsd__anyType(
    struct soap* soap, const char* tag, xsd__anyType* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (xsd__anyType*)soap_class_id_enter(soap, soap->id, a,
            SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type,
            soap->arrayType))) {
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
  }
  soap_revert(soap);
  *soap->id = '\0';
  if (soap->alloced) {
    a->soap_default(soap);
    if (soap->clist->type != SOAP_TYPE_xsd__anyType)
      return (xsd__anyType*)a->soap_in(soap, tag, type);
  }
  if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
    return NULL;
  return a;
}

SOAP_FMAC5 xsd__anyType* SOAP_FMAC6 soap_new_xsd__anyType(
    struct soap* soap, int n)
{
  return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyType(
    struct soap* soap, xsd__anyType* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 xsd__anyType* SOAP_FMAC4 soap_instantiate_xsd__anyType(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (type && !soap_match_tag(soap, type, "xsd:QName")) {
    cp->type = SOAP_TYPE_xsd__QName_;
    if (n < 0) {
      cp->ptr = (void*)new xsd__QName_;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__QName_);
      ((xsd__QName_*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__QName_[n];
      if (size)
        *size = n * sizeof(xsd__QName_);
      for (int i = 0; i < n; i++)
        ((xsd__QName_*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__QName_*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:boolean")) {
    cp->type = SOAP_TYPE_xsd__boolean;
    if (n < 0) {
      cp->ptr = (void*)new xsd__boolean;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__boolean);
      ((xsd__boolean*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__boolean[n];
      if (size)
        *size = n * sizeof(xsd__boolean);
      for (int i = 0; i < n; i++)
        ((xsd__boolean*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__boolean*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:byte")) {
    cp->type = SOAP_TYPE_xsd__byte;
    if (n < 0) {
      cp->ptr = (void*)new xsd__byte;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__byte);
      ((xsd__byte*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__byte[n];
      if (size)
        *size = n * sizeof(xsd__byte);
      for (int i = 0; i < n; i++)
        ((xsd__byte*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__byte*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:dateTime")) {
    cp->type = SOAP_TYPE_xsd__dateTime;
    if (n < 0) {
      cp->ptr = (void*)new xsd__dateTime;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__dateTime);
      ((xsd__dateTime*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__dateTime[n];
      if (size)
        *size = n * sizeof(xsd__dateTime);
      for (int i = 0; i < n; i++)
        ((xsd__dateTime*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__dateTime*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:duration")) {
    cp->type = SOAP_TYPE_xsd__duration;
    if (n < 0) {
      cp->ptr = (void*)new xsd__duration;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__duration);
      ((xsd__duration*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__duration[n];
      if (size)
        *size = n * sizeof(xsd__duration);
      for (int i = 0; i < n; i++)
        ((xsd__duration*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__duration*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:decimal")) {
    cp->type = SOAP_TYPE_xsd__decimal_;
    if (n < 0) {
      cp->ptr = (void*)new xsd__decimal_;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__decimal_);
      ((xsd__decimal_*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__decimal_[n];
      if (size)
        *size = n * sizeof(xsd__decimal_);
      for (int i = 0; i < n; i++)
        ((xsd__decimal_*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__decimal_*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:double")) {
    cp->type = SOAP_TYPE_xsd__double;
    if (n < 0) {
      cp->ptr = (void*)new xsd__double;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__double);
      ((xsd__double*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__double[n];
      if (size)
        *size = n * sizeof(xsd__double);
      for (int i = 0; i < n; i++)
        ((xsd__double*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__double*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:float")) {
    cp->type = SOAP_TYPE_xsd__float;
    if (n < 0) {
      cp->ptr = (void*)new xsd__float;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__float);
      ((xsd__float*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__float[n];
      if (size)
        *size = n * sizeof(xsd__float);
      for (int i = 0; i < n; i++)
        ((xsd__float*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__float*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:int")) {
    cp->type = SOAP_TYPE_xsd__int;
    if (n < 0) {
      cp->ptr = (void*)new xsd__int;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__int);
      ((xsd__int*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__int[n];
      if (size)
        *size = n * sizeof(xsd__int);
      for (int i = 0; i < n; i++)
        ((xsd__int*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__int*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:long")) {
    cp->type = SOAP_TYPE_xsd__long;
    if (n < 0) {
      cp->ptr = (void*)new xsd__long;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__long);
      ((xsd__long*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__long[n];
      if (size)
        *size = n * sizeof(xsd__long);
      for (int i = 0; i < n; i++)
        ((xsd__long*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__long*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:short")) {
    cp->type = SOAP_TYPE_xsd__short;
    if (n < 0) {
      cp->ptr = (void*)new xsd__short;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__short);
      ((xsd__short*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__short[n];
      if (size)
        *size = n * sizeof(xsd__short);
      for (int i = 0; i < n; i++)
        ((xsd__short*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__short*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:string")) {
    cp->type = SOAP_TYPE_xsd__string;
    if (n < 0) {
      cp->ptr = (void*)new xsd__string;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__string);
      ((xsd__string*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__string[n];
      if (size)
        *size = n * sizeof(xsd__string);
      for (int i = 0; i < n; i++)
        ((xsd__string*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__string*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:unsignedByte")) {
    cp->type = SOAP_TYPE_xsd__unsignedByte;
    if (n < 0) {
      cp->ptr = (void*)new xsd__unsignedByte;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__unsignedByte);
      ((xsd__unsignedByte*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__unsignedByte[n];
      if (size)
        *size = n * sizeof(xsd__unsignedByte);
      for (int i = 0; i < n; i++)
        ((xsd__unsignedByte*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__unsignedByte*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:unsignedInt")) {
    cp->type = SOAP_TYPE_xsd__unsignedInt;
    if (n < 0) {
      cp->ptr = (void*)new xsd__unsignedInt;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__unsignedInt);
      ((xsd__unsignedInt*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__unsignedInt[n];
      if (size)
        *size = n * sizeof(xsd__unsignedInt);
      for (int i = 0; i < n; i++)
        ((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__unsignedInt*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:unsignedLong")) {
    cp->type = SOAP_TYPE_xsd__unsignedLong;
    if (n < 0) {
      cp->ptr = (void*)new xsd__unsignedLong;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__unsignedLong);
      ((xsd__unsignedLong*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__unsignedLong[n];
      if (size)
        *size = n * sizeof(xsd__unsignedLong);
      for (int i = 0; i < n; i++)
        ((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__unsignedLong*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "xsd:unsignedShort")) {
    cp->type = SOAP_TYPE_xsd__unsignedShort;
    if (n < 0) {
      cp->ptr = (void*)new xsd__unsignedShort;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(xsd__unsignedShort);
      ((xsd__unsignedShort*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new xsd__unsignedShort[n];
      if (size)
        *size = n * sizeof(xsd__unsignedShort);
      for (int i = 0; i < n; i++)
        ((xsd__unsignedShort*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (xsd__unsignedShort*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:serverState")) {
    cp->type = SOAP_TYPE_s0__serverState_;
    if (n < 0) {
      cp->ptr = (void*)new s0__serverState_;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__serverState_);
      ((s0__serverState_*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__serverState_[n];
      if (size)
        *size = n * sizeof(s0__serverState_);
      for (int i = 0; i < n; i++)
        ((s0__serverState_*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__serverState_*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:interfaceVersion")) {
    cp->type = SOAP_TYPE_s0__interfaceVersion_;
    if (n < 0) {
      cp->ptr = (void*)new s0__interfaceVersion_;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__interfaceVersion_);
      ((s0__interfaceVersion_*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__interfaceVersion_[n];
      if (size)
        *size = n * sizeof(s0__interfaceVersion_);
      for (int i = 0; i < n; i++)
        ((s0__interfaceVersion_*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__interfaceVersion_*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:qualityBits")) {
    cp->type = SOAP_TYPE_s0__qualityBits_;
    if (n < 0) {
      cp->ptr = (void*)new s0__qualityBits_;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__qualityBits_);
      ((s0__qualityBits_*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__qualityBits_[n];
      if (size)
        *size = n * sizeof(s0__qualityBits_);
      for (int i = 0; i < n; i++)
        ((s0__qualityBits_*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__qualityBits_*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:limitBits")) {
    cp->type = SOAP_TYPE_s0__limitBits_;
    if (n < 0) {
      cp->ptr = (void*)new s0__limitBits_;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__limitBits_);
      ((s0__limitBits_*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__limitBits_[n];
      if (size)
        *size = n * sizeof(s0__limitBits_);
      for (int i = 0; i < n; i++)
        ((s0__limitBits_*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__limitBits_*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:browseFilter")) {
    cp->type = SOAP_TYPE_s0__browseFilter_;
    if (n < 0) {
      cp->ptr = (void*)new s0__browseFilter_;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__browseFilter_);
      ((s0__browseFilter_*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__browseFilter_[n];
      if (size)
        *size = n * sizeof(s0__browseFilter_);
      for (int i = 0; i < n; i++)
        ((s0__browseFilter_*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__browseFilter_*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ReplyBase")) {
    cp->type = SOAP_TYPE_s0__ReplyBase;
    if (n < 0) {
      cp->ptr = (void*)new s0__ReplyBase;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ReplyBase);
      ((s0__ReplyBase*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ReplyBase[n];
      if (size)
        *size = n * sizeof(s0__ReplyBase);
      for (int i = 0; i < n; i++)
        ((s0__ReplyBase*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ReplyBase*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ServerStatus")) {
    cp->type = SOAP_TYPE_s0__ServerStatus;
    if (n < 0) {
      cp->ptr = (void*)new s0__ServerStatus;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ServerStatus);
      ((s0__ServerStatus*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ServerStatus[n];
      if (size)
        *size = n * sizeof(s0__ServerStatus);
      for (int i = 0; i < n; i++)
        ((s0__ServerStatus*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ServerStatus*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:RequestOptions")) {
    cp->type = SOAP_TYPE_s0__RequestOptions;
    if (n < 0) {
      cp->ptr = (void*)new s0__RequestOptions;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__RequestOptions);
      ((s0__RequestOptions*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__RequestOptions[n];
      if (size)
        *size = n * sizeof(s0__RequestOptions);
      for (int i = 0; i < n; i++)
        ((s0__RequestOptions*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__RequestOptions*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ReadRequestItemList")) {
    cp->type = SOAP_TYPE_s0__ReadRequestItemList;
    if (n < 0) {
      cp->ptr = (void*)new s0__ReadRequestItemList;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ReadRequestItemList);
      ((s0__ReadRequestItemList*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ReadRequestItemList[n];
      if (size)
        *size = n * sizeof(s0__ReadRequestItemList);
      for (int i = 0; i < n; i++)
        ((s0__ReadRequestItemList*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ReadRequestItemList*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ReadRequestItem")) {
    cp->type = SOAP_TYPE_s0__ReadRequestItem;
    if (n < 0) {
      cp->ptr = (void*)new s0__ReadRequestItem;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ReadRequestItem);
      ((s0__ReadRequestItem*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ReadRequestItem[n];
      if (size)
        *size = n * sizeof(s0__ReadRequestItem);
      for (int i = 0; i < n; i++)
        ((s0__ReadRequestItem*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ReadRequestItem*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ReplyItemList")) {
    cp->type = SOAP_TYPE_s0__ReplyItemList;
    if (n < 0) {
      cp->ptr = (void*)new s0__ReplyItemList;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ReplyItemList);
      ((s0__ReplyItemList*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ReplyItemList[n];
      if (size)
        *size = n * sizeof(s0__ReplyItemList);
      for (int i = 0; i < n; i++)
        ((s0__ReplyItemList*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ReplyItemList*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ItemValue")) {
    cp->type = SOAP_TYPE_s0__ItemValue;
    if (n < 0) {
      cp->ptr = (void*)new s0__ItemValue;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ItemValue);
      ((s0__ItemValue*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ItemValue[n];
      if (size)
        *size = n * sizeof(s0__ItemValue);
      for (int i = 0; i < n; i++)
        ((s0__ItemValue*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ItemValue*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:Value")) {
    cp->type = SOAP_TYPE_s0__Value;
    if (n < 0) {
      cp->ptr = (void*)new s0__Value;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__Value);
      ((s0__Value*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__Value[n];
      if (size)
        *size = n * sizeof(s0__Value);
      for (int i = 0; i < n; i++)
        ((s0__Value*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__Value*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:OPCQuality")) {
    cp->type = SOAP_TYPE_s0__OPCQuality;
    if (n < 0) {
      cp->ptr = (void*)new s0__OPCQuality;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__OPCQuality);
      ((s0__OPCQuality*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__OPCQuality[n];
      if (size)
        *size = n * sizeof(s0__OPCQuality);
      for (int i = 0; i < n; i++)
        ((s0__OPCQuality*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__OPCQuality*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:OPCError")) {
    cp->type = SOAP_TYPE_s0__OPCError;
    if (n < 0) {
      cp->ptr = (void*)new s0__OPCError;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__OPCError);
      ((s0__OPCError*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__OPCError[n];
      if (size)
        *size = n * sizeof(s0__OPCError);
      for (int i = 0; i < n; i++)
        ((s0__OPCError*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__OPCError*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfFloat")) {
    cp->type = SOAP_TYPE_s0__ArrayOfFloat;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfFloat;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfFloat);
      ((s0__ArrayOfFloat*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfFloat[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfFloat);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfFloat*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfFloat*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfInt")) {
    cp->type = SOAP_TYPE_s0__ArrayOfInt;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfInt;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfInt);
      ((s0__ArrayOfInt*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfInt[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfInt);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfInt*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfInt*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfUnsignedInt")) {
    cp->type = SOAP_TYPE_s0__ArrayOfUnsignedInt;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfUnsignedInt;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfUnsignedInt);
      ((s0__ArrayOfUnsignedInt*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfUnsignedInt[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfUnsignedInt);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfUnsignedInt*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfUnsignedInt*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfLong")) {
    cp->type = SOAP_TYPE_s0__ArrayOfLong;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfLong;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfLong);
      ((s0__ArrayOfLong*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfLong[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfLong);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfLong*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfLong*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfUnsignedLong")) {
    cp->type = SOAP_TYPE_s0__ArrayOfUnsignedLong;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfUnsignedLong;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfUnsignedLong);
      ((s0__ArrayOfUnsignedLong*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfUnsignedLong[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfUnsignedLong);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfUnsignedLong*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfUnsignedLong*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfDouble")) {
    cp->type = SOAP_TYPE_s0__ArrayOfDouble;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfDouble;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfDouble);
      ((s0__ArrayOfDouble*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfDouble[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfDouble);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfDouble*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfDouble*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfUnsignedShort")) {
    cp->type = SOAP_TYPE_s0__ArrayOfUnsignedShort;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfUnsignedShort;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfUnsignedShort);
      ((s0__ArrayOfUnsignedShort*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfUnsignedShort[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfUnsignedShort);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfUnsignedShort*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfUnsignedShort*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfBoolean")) {
    cp->type = SOAP_TYPE_s0__ArrayOfBoolean;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfBoolean;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfBoolean);
      ((s0__ArrayOfBoolean*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfBoolean[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfBoolean);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfBoolean*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfBoolean*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfString")) {
    cp->type = SOAP_TYPE_s0__ArrayOfString;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfString;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfString);
      ((s0__ArrayOfString*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfString[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfString);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfString*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfString*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfDateTime")) {
    cp->type = SOAP_TYPE_s0__ArrayOfDateTime;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfDateTime;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfDateTime);
      ((s0__ArrayOfDateTime*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfDateTime[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfDateTime);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfDateTime*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfDateTime*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfAnyType")) {
    cp->type = SOAP_TYPE_s0__ArrayOfAnyType;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfAnyType;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfAnyType);
      ((s0__ArrayOfAnyType*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfAnyType[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfAnyType);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfAnyType*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfAnyType*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfDecimal")) {
    cp->type = SOAP_TYPE_s0__ArrayOfDecimal;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfDecimal;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfDecimal);
      ((s0__ArrayOfDecimal*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfDecimal[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfDecimal);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfDecimal*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfDecimal*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfByte")) {
    cp->type = SOAP_TYPE_s0__ArrayOfByte;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfByte;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfByte);
      ((s0__ArrayOfByte*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfByte[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfByte);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfByte*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfByte*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ArrayOfShort")) {
    cp->type = SOAP_TYPE_s0__ArrayOfShort;
    if (n < 0) {
      cp->ptr = (void*)new s0__ArrayOfShort;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ArrayOfShort);
      ((s0__ArrayOfShort*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ArrayOfShort[n];
      if (size)
        *size = n * sizeof(s0__ArrayOfShort);
      for (int i = 0; i < n; i++)
        ((s0__ArrayOfShort*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ArrayOfShort*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:WriteRequestItemList")) {
    cp->type = SOAP_TYPE_s0__WriteRequestItemList;
    if (n < 0) {
      cp->ptr = (void*)new s0__WriteRequestItemList;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__WriteRequestItemList);
      ((s0__WriteRequestItemList*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__WriteRequestItemList[n];
      if (size)
        *size = n * sizeof(s0__WriteRequestItemList);
      for (int i = 0; i < n; i++)
        ((s0__WriteRequestItemList*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__WriteRequestItemList*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:SubscribeRequestItemList")) {
    cp->type = SOAP_TYPE_s0__SubscribeRequestItemList;
    if (n < 0) {
      cp->ptr = (void*)new s0__SubscribeRequestItemList;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__SubscribeRequestItemList);
      ((s0__SubscribeRequestItemList*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__SubscribeRequestItemList[n];
      if (size)
        *size = n * sizeof(s0__SubscribeRequestItemList);
      for (int i = 0; i < n; i++)
        ((s0__SubscribeRequestItemList*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__SubscribeRequestItemList*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:SubscribeRequestItem")) {
    cp->type = SOAP_TYPE_s0__SubscribeRequestItem;
    if (n < 0) {
      cp->ptr = (void*)new s0__SubscribeRequestItem;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__SubscribeRequestItem);
      ((s0__SubscribeRequestItem*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__SubscribeRequestItem[n];
      if (size)
        *size = n * sizeof(s0__SubscribeRequestItem);
      for (int i = 0; i < n; i++)
        ((s0__SubscribeRequestItem*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__SubscribeRequestItem*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:SubscribeReplyItemList")) {
    cp->type = SOAP_TYPE_s0__SubscribeReplyItemList;
    if (n < 0) {
      cp->ptr = (void*)new s0__SubscribeReplyItemList;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__SubscribeReplyItemList);
      ((s0__SubscribeReplyItemList*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__SubscribeReplyItemList[n];
      if (size)
        *size = n * sizeof(s0__SubscribeReplyItemList);
      for (int i = 0; i < n; i++)
        ((s0__SubscribeReplyItemList*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__SubscribeReplyItemList*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:SubscribeItemValue")) {
    cp->type = SOAP_TYPE_s0__SubscribeItemValue;
    if (n < 0) {
      cp->ptr = (void*)new s0__SubscribeItemValue;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__SubscribeItemValue);
      ((s0__SubscribeItemValue*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__SubscribeItemValue[n];
      if (size)
        *size = n * sizeof(s0__SubscribeItemValue);
      for (int i = 0; i < n; i++)
        ((s0__SubscribeItemValue*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__SubscribeItemValue*)cp->ptr;
  }
  if (type
      && !soap_match_tag(
             soap, type, "s0:SubscribePolledRefreshReplyItemList")) {
    cp->type = SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList;
    if (n < 0) {
      cp->ptr = (void*)new s0__SubscribePolledRefreshReplyItemList;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__SubscribePolledRefreshReplyItemList);
      ((s0__SubscribePolledRefreshReplyItemList*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__SubscribePolledRefreshReplyItemList[n];
      if (size)
        *size = n * sizeof(s0__SubscribePolledRefreshReplyItemList);
      for (int i = 0; i < n; i++)
        ((s0__SubscribePolledRefreshReplyItemList*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__SubscribePolledRefreshReplyItemList*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:BrowseElement")) {
    cp->type = SOAP_TYPE_s0__BrowseElement;
    if (n < 0) {
      cp->ptr = (void*)new s0__BrowseElement;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__BrowseElement);
      ((s0__BrowseElement*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__BrowseElement[n];
      if (size)
        *size = n * sizeof(s0__BrowseElement);
      for (int i = 0; i < n; i++)
        ((s0__BrowseElement*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__BrowseElement*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ItemProperty")) {
    cp->type = SOAP_TYPE_s0__ItemProperty;
    if (n < 0) {
      cp->ptr = (void*)new s0__ItemProperty;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ItemProperty);
      ((s0__ItemProperty*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ItemProperty[n];
      if (size)
        *size = n * sizeof(s0__ItemProperty);
      for (int i = 0; i < n; i++)
        ((s0__ItemProperty*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ItemProperty*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:ItemIdentifier")) {
    cp->type = SOAP_TYPE_s0__ItemIdentifier;
    if (n < 0) {
      cp->ptr = (void*)new s0__ItemIdentifier;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__ItemIdentifier);
      ((s0__ItemIdentifier*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__ItemIdentifier[n];
      if (size)
        *size = n * sizeof(s0__ItemIdentifier);
      for (int i = 0; i < n; i++)
        ((s0__ItemIdentifier*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__ItemIdentifier*)cp->ptr;
  }
  if (type && !soap_match_tag(soap, type, "s0:PropertyReplyList")) {
    cp->type = SOAP_TYPE_s0__PropertyReplyList;
    if (n < 0) {
      cp->ptr = (void*)new s0__PropertyReplyList;
      if (!cp->ptr) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (size)
        *size = sizeof(s0__PropertyReplyList);
      ((s0__PropertyReplyList*)cp->ptr)->soap = soap;
    } else {
      cp->ptr = (void*)new s0__PropertyReplyList[n];
      if (size)
        *size = n * sizeof(s0__PropertyReplyList);
      for (int i = 0; i < n; i++)
        ((s0__PropertyReplyList*)cp->ptr)[i].soap = soap;
    }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (s0__PropertyReplyList*)cp->ptr;
  }
  if (n < 0) {
    cp->ptr = (void*)new xsd__anyType;
    if (size)
      *size = sizeof(xsd__anyType);
    ((xsd__anyType*)cp->ptr)->soap = soap;
  } else {
    cp->ptr = (void*)new xsd__anyType[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(xsd__anyType);
    for (int i = 0; i < n; i++)
      ((xsd__anyType*)cp->ptr)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (xsd__anyType*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
  *(xsd__anyType*)p = *(xsd__anyType*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(
    struct soap* soap, struct SOAP_ENV__Fault* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->faultcode);
  soap_default_string(soap, &a->faultstring);
  soap_default_string(soap, &a->faultactor);
  a->detail = NULL;
  a->SOAP_ENV__Code = NULL;
  a->SOAP_ENV__Reason = NULL;
  soap_default_string(soap, &a->SOAP_ENV__Node);
  soap_default_string(soap, &a->SOAP_ENV__Role);
  a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(
    struct soap* soap, const struct SOAP_ENV__Fault* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->faultcode);
  soap_serialize_string(soap, &a->faultstring);
  soap_serialize_string(soap, &a->faultactor);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
  soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
  soap_serialize_string(soap, &a->SOAP_ENV__Node);
  soap_serialize_string(soap, &a->SOAP_ENV__Role);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap* soap,
    const struct SOAP_ENV__Fault* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
  if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap* soap,
    const char* tag, int id, const struct SOAP_ENV__Fault* a, const char* type)
{
  const char* soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
  soap_out__QName(soap, "faultcode", -1, (char* const*)&soap_tmp_faultcode, "");
  soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
  soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
  soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
  soap_out_PointerToSOAP_ENV__Code(
      soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
  soap_out_PointerToSOAP_ENV__Reason(
      soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
  soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
  soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
  soap_out_PointerToSOAP_ENV__Detail(
      soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault* SOAP_FMAC4 soap_get_SOAP_ENV__Fault(
    struct soap* soap, struct SOAP_ENV__Fault* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault* SOAP_FMAC4 soap_in_SOAP_ENV__Fault(
    struct soap* soap, const char* tag, struct SOAP_ENV__Fault* a,
    const char* type)
{
  short soap_flag_faultcode = 1, soap_flag_faultstring = 1,
        soap_flag_faultactor = 1, soap_flag_detail = 1,
        soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1,
        soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1,
        soap_flag_SOAP_ENV__Detail = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL,
      NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Fault(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_faultcode
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__QName(soap, "faultcode", &a->faultcode, "")) {
          soap_flag_faultcode--;
          continue;
        }
      if (soap_flag_faultstring
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(
                soap, "faultstring", &a->faultstring, "xsd:string")) {
          soap_flag_faultstring--;
          continue;
        }
      if (soap_flag_faultactor
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string")) {
          soap_flag_faultactor--;
          continue;
        }
      if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, "")) {
          soap_flag_detail--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Code(
                soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, "")) {
          soap_flag_SOAP_ENV__Code--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Reason(
                soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, "")) {
          soap_flag_SOAP_ENV__Reason--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Node
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(
                soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string")) {
          soap_flag_SOAP_ENV__Node--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Role
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(
                soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string")) {
          soap_flag_SOAP_ENV__Role--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Detail(
                soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, "")) {
          soap_flag_SOAP_ENV__Detail--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Fault*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault* SOAP_FMAC6 soap_new_SOAP_ENV__Fault(
    struct soap* soap, int n)
{
  return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(
    struct soap* soap, struct SOAP_ENV__Fault* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault* SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct SOAP_ENV__Fault;
    if (size)
      *size = sizeof(struct SOAP_ENV__Fault);
  } else {
    cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Fault);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Fault*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
  *(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(
    struct soap* soap, struct SOAP_ENV__Reason* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(
    struct soap* soap, const struct SOAP_ENV__Reason* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap* soap,
    const struct SOAP_ENV__Reason* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
  if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap* soap,
    const char* tag, int id, const struct SOAP_ENV__Reason* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
  soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason* SOAP_FMAC4 soap_get_SOAP_ENV__Reason(
    struct soap* soap, struct SOAP_ENV__Reason* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason* SOAP_FMAC4 soap_in_SOAP_ENV__Reason(
    struct soap* soap, const char* tag, struct SOAP_ENV__Reason* a,
    const char* type)
{
  short soap_flag_SOAP_ENV__Text = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL,
      NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Reason(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SOAP_ENV__Text
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(
                soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string")) {
          soap_flag_SOAP_ENV__Text--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Reason*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0,
        NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason* SOAP_FMAC6 soap_new_SOAP_ENV__Reason(
    struct soap* soap, int n)
{
  return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(
    struct soap* soap, struct SOAP_ENV__Reason* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason* SOAP_FMAC4
soap_instantiate_SOAP_ENV__Reason(struct soap* soap, int n, const char* type,
    const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct SOAP_ENV__Reason;
    if (size)
      *size = sizeof(struct SOAP_ENV__Reason);
  } else {
    cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Reason);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Reason*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
  *(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(
    struct soap* soap, struct SOAP_ENV__Detail* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__type = 0;
  a->fault = NULL;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(
    struct soap* soap, const struct SOAP_ENV__Detail* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap* soap,
    const struct SOAP_ENV__Detail* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
  if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap* soap,
    const char* tag, int id, const struct SOAP_ENV__Detail* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
  soap_putelement(soap, a->fault, "fault", -1, a->__type);
  soap_outliteral(soap, "-any", &a->__any, NULL);
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail* SOAP_FMAC4 soap_get_SOAP_ENV__Detail(
    struct soap* soap, struct SOAP_ENV__Detail* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail* SOAP_FMAC4 soap_in_SOAP_ENV__Detail(
    struct soap* soap, const char* tag, struct SOAP_ENV__Detail* a,
    const char* type)
{
  short soap_flag_fault = 1, soap_flag___any = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL,
      NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Detail(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
        if ((a->fault = soap_getelement(soap, &a->__type))) {
          soap_flag_fault = 0;
          continue;
        }
      if (soap_flag___any
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-any", &a->__any)) {
          soap_flag___any--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Detail*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0,
        NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail* SOAP_FMAC6 soap_new_SOAP_ENV__Detail(
    struct soap* soap, int n)
{
  return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(
    struct soap* soap, struct SOAP_ENV__Detail* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail* SOAP_FMAC4
soap_instantiate_SOAP_ENV__Detail(struct soap* soap, int n, const char* type,
    const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct SOAP_ENV__Detail;
    if (size)
      *size = sizeof(struct SOAP_ENV__Detail);
  } else {
    cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Detail);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Detail*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
  *(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(
    struct soap* soap, struct SOAP_ENV__Code* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->SOAP_ENV__Value);
  a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(
    struct soap* soap, const struct SOAP_ENV__Code* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->SOAP_ENV__Value);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap* soap,
    const struct SOAP_ENV__Code* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
  if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap* soap,
    const char* tag, int id, const struct SOAP_ENV__Code* a, const char* type)
{
  const char* soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
  soap_element_begin_out(
      soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
  soap_out__QName(
      soap, "SOAP-ENV:Value", -1, (char* const*)&soap_tmp_SOAP_ENV__Value, "");
  soap_out_PointerToSOAP_ENV__Code(
      soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code* SOAP_FMAC4 soap_get_SOAP_ENV__Code(
    struct soap* soap, struct SOAP_ENV__Code* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code* SOAP_FMAC4 soap_in_SOAP_ENV__Code(
    struct soap* soap, const char* tag, struct SOAP_ENV__Code* a,
    const char* type)
{
  short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL,
      NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Code(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SOAP_ENV__Value
          && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, "")) {
          soap_flag_SOAP_ENV__Value--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Code(
                soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, "")) {
          soap_flag_SOAP_ENV__Subcode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Code*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code* SOAP_FMAC6 soap_new_SOAP_ENV__Code(
    struct soap* soap, int n)
{
  return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(
    struct soap* soap, struct SOAP_ENV__Code* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code* SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct SOAP_ENV__Code;
    if (size)
      *size = sizeof(struct SOAP_ENV__Code);
  } else {
    cp->ptr = (void*)new struct SOAP_ENV__Code[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Code);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Code*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
  *(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(
    struct soap* soap, struct SOAP_ENV__Header* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  /* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(
    struct soap* soap, const struct SOAP_ENV__Header* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  /* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap* soap,
    const struct SOAP_ENV__Header* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
  if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap* soap,
    const char* tag, int id, const struct SOAP_ENV__Header* a, const char* type)
{
  soap_element_begin_out(soap, tag,
      soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
  /* transient dummy skipped */
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header* SOAP_FMAC4 soap_get_SOAP_ENV__Header(
    struct soap* soap, struct SOAP_ENV__Header* p, const char* tag,
    const char* type)
{
  if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header* SOAP_FMAC4 soap_in_SOAP_ENV__Header(
    struct soap* soap, const char* tag, struct SOAP_ENV__Header* a,
    const char* type)
{
  ;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL,
      NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Header(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      /* transient dummy skipped */
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Header*)soap_id_forward(soap, soap->href, (void*)a, 0,
        SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0,
        NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header* SOAP_FMAC6 soap_new_SOAP_ENV__Header(
    struct soap* soap, int n)
{
  return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(
    struct soap* soap, struct SOAP_ENV__Header* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header* SOAP_FMAC4
soap_instantiate_SOAP_ENV__Header(struct soap* soap, int n, const char* type,
    const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct SOAP_ENV__Header;
    if (size)
      *size = sizeof(struct SOAP_ENV__Header);
  } else {
    cp->ptr = (void*)new struct SOAP_ENV__Header[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct SOAP_ENV__Header);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct SOAP_ENV__Header*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
  *(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}
#ifdef __cplusplus
}
#endif

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__GetProperties(
    struct soap* soap, struct __s0__GetProperties* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->s0__GetProperties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__GetProperties(
    struct soap* soap, const struct __s0__GetProperties* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_s0__GetProperties(soap, &a->s0__GetProperties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__GetProperties(struct soap* soap,
    const struct __s0__GetProperties* a, const char* tag, const char* type)
{
  register int id = 0;
  if (soap_out___s0__GetProperties(soap, tag, id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__GetProperties(struct soap* soap,
    const char* tag, int id, const struct __s0__GetProperties* a,
    const char* type)
{
  soap_out_PointerTo_s0__GetProperties(
      soap, "s0:GetProperties", -1, &a->s0__GetProperties, "");
  return SOAP_OK;
}

SOAP_FMAC3 struct __s0__GetProperties* SOAP_FMAC4 soap_get___s0__GetProperties(
    struct soap* soap, struct __s0__GetProperties* p, const char* tag,
    const char* type)
{
  if ((p = soap_in___s0__GetProperties(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct __s0__GetProperties* SOAP_FMAC4 soap_in___s0__GetProperties(
    struct soap* soap, const char* tag, struct __s0__GetProperties* a,
    const char* type)
{
  short soap_flag_s0__GetProperties = 1;
  int soap_flag;
  a = (struct __s0__GetProperties*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE___s0__GetProperties, sizeof(struct __s0__GetProperties), 0,
      NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___s0__GetProperties(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_s0__GetProperties && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTo_s0__GetProperties(
              soap, "s0:GetProperties", &a->s0__GetProperties, "")) {
        soap_flag_s0__GetProperties--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct __s0__GetProperties* SOAP_FMAC6 soap_new___s0__GetProperties(
    struct soap* soap, int n)
{
  return soap_instantiate___s0__GetProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__GetProperties(
    struct soap* soap, struct __s0__GetProperties* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__GetProperties* SOAP_FMAC4
soap_instantiate___s0__GetProperties(struct soap* soap, int n, const char* type,
    const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate___s0__GetProperties(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE___s0__GetProperties, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct __s0__GetProperties;
    if (size)
      *size = sizeof(struct __s0__GetProperties);
  } else {
    cp->ptr = (void*)new struct __s0__GetProperties[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct __s0__GetProperties);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct __s0__GetProperties*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__GetProperties(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying struct __s0__GetProperties %p -> %p\n", q, p));
  *(struct __s0__GetProperties*)p = *(struct __s0__GetProperties*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__Browse(
    struct soap* soap, struct __s0__Browse* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->s0__Browse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__Browse(
    struct soap* soap, const struct __s0__Browse* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_s0__Browse(soap, &a->s0__Browse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__Browse(struct soap* soap,
    const struct __s0__Browse* a, const char* tag, const char* type)
{
  register int id = 0;
  if (soap_out___s0__Browse(soap, tag, id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__Browse(struct soap* soap,
    const char* tag, int id, const struct __s0__Browse* a, const char* type)
{
  soap_out_PointerTo_s0__Browse(soap, "s0:Browse", -1, &a->s0__Browse, "");
  return SOAP_OK;
}

SOAP_FMAC3 struct __s0__Browse* SOAP_FMAC4 soap_get___s0__Browse(
    struct soap* soap, struct __s0__Browse* p, const char* tag,
    const char* type)
{
  if ((p = soap_in___s0__Browse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct __s0__Browse* SOAP_FMAC4 soap_in___s0__Browse(
    struct soap* soap, const char* tag, struct __s0__Browse* a,
    const char* type)
{
  short soap_flag_s0__Browse = 1;
  int soap_flag;
  a = (struct __s0__Browse*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE___s0__Browse, sizeof(struct __s0__Browse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___s0__Browse(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_s0__Browse && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTo_s0__Browse(soap, "s0:Browse", &a->s0__Browse, "")) {
        soap_flag_s0__Browse--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct __s0__Browse* SOAP_FMAC6 soap_new___s0__Browse(
    struct soap* soap, int n)
{
  return soap_instantiate___s0__Browse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__Browse(
    struct soap* soap, struct __s0__Browse* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__Browse* SOAP_FMAC4 soap_instantiate___s0__Browse(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__Browse(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE___s0__Browse, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct __s0__Browse;
    if (size)
      *size = sizeof(struct __s0__Browse);
  } else {
    cp->ptr = (void*)new struct __s0__Browse[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct __s0__Browse);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct __s0__Browse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__Browse(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying struct __s0__Browse %p -> %p\n", q, p));
  *(struct __s0__Browse*)p = *(struct __s0__Browse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__SubscriptionCancel(
    struct soap* soap, struct __s0__SubscriptionCancel* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->s0__SubscriptionCancel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__SubscriptionCancel(
    struct soap* soap, const struct __s0__SubscriptionCancel* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_s0__SubscriptionCancel(
      soap, &a->s0__SubscriptionCancel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__SubscriptionCancel(struct soap* soap,
    const struct __s0__SubscriptionCancel* a, const char* tag, const char* type)
{
  register int id = 0;
  if (soap_out___s0__SubscriptionCancel(soap, tag, id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__SubscriptionCancel(struct soap* soap,
    const char* tag, int id, const struct __s0__SubscriptionCancel* a,
    const char* type)
{
  soap_out_PointerTo_s0__SubscriptionCancel(
      soap, "s0:SubscriptionCancel", -1, &a->s0__SubscriptionCancel, "");
  return SOAP_OK;
}

SOAP_FMAC3 struct __s0__SubscriptionCancel* SOAP_FMAC4
soap_get___s0__SubscriptionCancel(struct soap* soap,
    struct __s0__SubscriptionCancel* p, const char* tag, const char* type)
{
  if ((p = soap_in___s0__SubscriptionCancel(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct __s0__SubscriptionCancel* SOAP_FMAC4
soap_in___s0__SubscriptionCancel(struct soap* soap, const char* tag,
    struct __s0__SubscriptionCancel* a, const char* type)
{
  short soap_flag_s0__SubscriptionCancel = 1;
  int soap_flag;
  a = (struct __s0__SubscriptionCancel*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE___s0__SubscriptionCancel,
      sizeof(struct __s0__SubscriptionCancel), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___s0__SubscriptionCancel(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_s0__SubscriptionCancel && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTo_s0__SubscriptionCancel(
              soap, "s0:SubscriptionCancel", &a->s0__SubscriptionCancel, "")) {
        soap_flag_s0__SubscriptionCancel--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct __s0__SubscriptionCancel* SOAP_FMAC6
soap_new___s0__SubscriptionCancel(struct soap* soap, int n)
{
  return soap_instantiate___s0__SubscriptionCancel(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__SubscriptionCancel(
    struct soap* soap, struct __s0__SubscriptionCancel* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__SubscriptionCancel* SOAP_FMAC4
soap_instantiate___s0__SubscriptionCancel(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate___s0__SubscriptionCancel(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE___s0__SubscriptionCancel, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct __s0__SubscriptionCancel;
    if (size)
      *size = sizeof(struct __s0__SubscriptionCancel);
  } else {
    cp->ptr = (void*)new struct __s0__SubscriptionCancel[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct __s0__SubscriptionCancel);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct __s0__SubscriptionCancel*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__SubscriptionCancel(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying struct __s0__SubscriptionCancel %p -> %p\n", q, p));
  *(struct __s0__SubscriptionCancel*)p = *(struct __s0__SubscriptionCancel*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__SubscriptionPolledRefresh(
    struct soap* soap, struct __s0__SubscriptionPolledRefresh* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->s0__SubscriptionPolledRefresh = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__SubscriptionPolledRefresh(
    struct soap* soap, const struct __s0__SubscriptionPolledRefresh* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_s0__SubscriptionPolledRefresh(
      soap, &a->s0__SubscriptionPolledRefresh);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__SubscriptionPolledRefresh(
    struct soap* soap, const struct __s0__SubscriptionPolledRefresh* a,
    const char* tag, const char* type)
{
  register int id = 0;
  if (soap_out___s0__SubscriptionPolledRefresh(soap, tag, id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__SubscriptionPolledRefresh(
    struct soap* soap, const char* tag, int id,
    const struct __s0__SubscriptionPolledRefresh* a, const char* type)
{
  soap_out_PointerTo_s0__SubscriptionPolledRefresh(soap,
      "s0:SubscriptionPolledRefresh", -1, &a->s0__SubscriptionPolledRefresh,
      "");
  return SOAP_OK;
}

SOAP_FMAC3 struct __s0__SubscriptionPolledRefresh* SOAP_FMAC4
soap_get___s0__SubscriptionPolledRefresh(struct soap* soap,
    struct __s0__SubscriptionPolledRefresh* p, const char* tag,
    const char* type)
{
  if ((p = soap_in___s0__SubscriptionPolledRefresh(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct __s0__SubscriptionPolledRefresh* SOAP_FMAC4
soap_in___s0__SubscriptionPolledRefresh(struct soap* soap, const char* tag,
    struct __s0__SubscriptionPolledRefresh* a, const char* type)
{
  short soap_flag_s0__SubscriptionPolledRefresh = 1;
  int soap_flag;
  a = (struct __s0__SubscriptionPolledRefresh*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE___s0__SubscriptionPolledRefresh,
      sizeof(struct __s0__SubscriptionPolledRefresh), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___s0__SubscriptionPolledRefresh(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_s0__SubscriptionPolledRefresh
        && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTo_s0__SubscriptionPolledRefresh(soap,
              "s0:SubscriptionPolledRefresh", &a->s0__SubscriptionPolledRefresh,
              "")) {
        soap_flag_s0__SubscriptionPolledRefresh--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct __s0__SubscriptionPolledRefresh* SOAP_FMAC6
soap_new___s0__SubscriptionPolledRefresh(struct soap* soap, int n)
{
  return soap_instantiate___s0__SubscriptionPolledRefresh(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__SubscriptionPolledRefresh(
    struct soap* soap, struct __s0__SubscriptionPolledRefresh* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__SubscriptionPolledRefresh* SOAP_FMAC4
soap_instantiate___s0__SubscriptionPolledRefresh(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "soap_instantiate___s0__SubscriptionPolledRefresh(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE___s0__SubscriptionPolledRefresh, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct __s0__SubscriptionPolledRefresh;
    if (size)
      *size = sizeof(struct __s0__SubscriptionPolledRefresh);
  } else {
    cp->ptr = (void*)new struct __s0__SubscriptionPolledRefresh[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct __s0__SubscriptionPolledRefresh);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct __s0__SubscriptionPolledRefresh*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__SubscriptionPolledRefresh(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "Copying struct __s0__SubscriptionPolledRefresh %p -> %p\n", q, p));
  *(struct __s0__SubscriptionPolledRefresh*)p
      = *(struct __s0__SubscriptionPolledRefresh*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__Subscribe(
    struct soap* soap, struct __s0__Subscribe* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->s0__Subscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__Subscribe(
    struct soap* soap, const struct __s0__Subscribe* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_s0__Subscribe(soap, &a->s0__Subscribe);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__Subscribe(struct soap* soap,
    const struct __s0__Subscribe* a, const char* tag, const char* type)
{
  register int id = 0;
  if (soap_out___s0__Subscribe(soap, tag, id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__Subscribe(struct soap* soap,
    const char* tag, int id, const struct __s0__Subscribe* a, const char* type)
{
  soap_out_PointerTo_s0__Subscribe(
      soap, "s0:Subscribe", -1, &a->s0__Subscribe, "");
  return SOAP_OK;
}

SOAP_FMAC3 struct __s0__Subscribe* SOAP_FMAC4 soap_get___s0__Subscribe(
    struct soap* soap, struct __s0__Subscribe* p, const char* tag,
    const char* type)
{
  if ((p = soap_in___s0__Subscribe(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct __s0__Subscribe* SOAP_FMAC4 soap_in___s0__Subscribe(
    struct soap* soap, const char* tag, struct __s0__Subscribe* a,
    const char* type)
{
  short soap_flag_s0__Subscribe = 1;
  int soap_flag;
  a = (struct __s0__Subscribe*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE___s0__Subscribe, sizeof(struct __s0__Subscribe), 0, NULL, NULL,
      NULL);
  if (!a)
    return NULL;
  soap_default___s0__Subscribe(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_s0__Subscribe && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTo_s0__Subscribe(
              soap, "s0:Subscribe", &a->s0__Subscribe, "")) {
        soap_flag_s0__Subscribe--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct __s0__Subscribe* SOAP_FMAC6 soap_new___s0__Subscribe(
    struct soap* soap, int n)
{
  return soap_instantiate___s0__Subscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__Subscribe(
    struct soap* soap, struct __s0__Subscribe* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__Subscribe* SOAP_FMAC4 soap_instantiate___s0__Subscribe(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate___s0__Subscribe(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE___s0__Subscribe, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct __s0__Subscribe;
    if (size)
      *size = sizeof(struct __s0__Subscribe);
  } else {
    cp->ptr = (void*)new struct __s0__Subscribe[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct __s0__Subscribe);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct __s0__Subscribe*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__Subscribe(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying struct __s0__Subscribe %p -> %p\n", q, p));
  *(struct __s0__Subscribe*)p = *(struct __s0__Subscribe*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__Write(
    struct soap* soap, struct __s0__Write* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->s0__Write = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__Write(
    struct soap* soap, const struct __s0__Write* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_s0__Write(soap, &a->s0__Write);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__Write(struct soap* soap,
    const struct __s0__Write* a, const char* tag, const char* type)
{
  register int id = 0;
  if (soap_out___s0__Write(soap, tag, id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__Write(struct soap* soap,
    const char* tag, int id, const struct __s0__Write* a, const char* type)
{
  soap_out_PointerTo_s0__Write(soap, "s0:Write", -1, &a->s0__Write, "");
  return SOAP_OK;
}

SOAP_FMAC3 struct __s0__Write* SOAP_FMAC4 soap_get___s0__Write(
    struct soap* soap, struct __s0__Write* p, const char* tag, const char* type)
{
  if ((p = soap_in___s0__Write(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct __s0__Write* SOAP_FMAC4 soap_in___s0__Write(
    struct soap* soap, const char* tag, struct __s0__Write* a, const char* type)
{
  short soap_flag_s0__Write = 1;
  int soap_flag;
  a = (struct __s0__Write*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE___s0__Write, sizeof(struct __s0__Write), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___s0__Write(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_s0__Write && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTo_s0__Write(soap, "s0:Write", &a->s0__Write, "")) {
        soap_flag_s0__Write--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct __s0__Write* SOAP_FMAC6 soap_new___s0__Write(
    struct soap* soap, int n)
{
  return soap_instantiate___s0__Write(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__Write(
    struct soap* soap, struct __s0__Write* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__Write* SOAP_FMAC4 soap_instantiate___s0__Write(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__Write(%d, %s, %s)\n",
                n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE___s0__Write, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct __s0__Write;
    if (size)
      *size = sizeof(struct __s0__Write);
  } else {
    cp->ptr = (void*)new struct __s0__Write[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct __s0__Write);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct __s0__Write*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__Write(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying struct __s0__Write %p -> %p\n", q, p));
  *(struct __s0__Write*)p = *(struct __s0__Write*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__Read(
    struct soap* soap, struct __s0__Read* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->s0__Read = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__Read(
    struct soap* soap, const struct __s0__Read* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_s0__Read(soap, &a->s0__Read);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__Read(struct soap* soap,
    const struct __s0__Read* a, const char* tag, const char* type)
{
  register int id = 0;
  if (soap_out___s0__Read(soap, tag, id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__Read(struct soap* soap,
    const char* tag, int id, const struct __s0__Read* a, const char* type)
{
  soap_out_PointerTo_s0__Read(soap, "s0:Read", -1, &a->s0__Read, "");
  return SOAP_OK;
}

SOAP_FMAC3 struct __s0__Read* SOAP_FMAC4 soap_get___s0__Read(
    struct soap* soap, struct __s0__Read* p, const char* tag, const char* type)
{
  if ((p = soap_in___s0__Read(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct __s0__Read* SOAP_FMAC4 soap_in___s0__Read(
    struct soap* soap, const char* tag, struct __s0__Read* a, const char* type)
{
  short soap_flag_s0__Read = 1;
  int soap_flag;
  a = (struct __s0__Read*)soap_id_enter(soap, soap->id, a, SOAP_TYPE___s0__Read,
      sizeof(struct __s0__Read), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___s0__Read(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_s0__Read && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTo_s0__Read(soap, "s0:Read", &a->s0__Read, "")) {
        soap_flag_s0__Read--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct __s0__Read* SOAP_FMAC6 soap_new___s0__Read(
    struct soap* soap, int n)
{
  return soap_instantiate___s0__Read(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__Read(
    struct soap* soap, struct __s0__Read* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__Read* SOAP_FMAC4 soap_instantiate___s0__Read(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__Read(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE___s0__Read, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct __s0__Read;
    if (size)
      *size = sizeof(struct __s0__Read);
  } else {
    cp->ptr = (void*)new struct __s0__Read[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct __s0__Read);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct __s0__Read*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__Read(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying struct __s0__Read %p -> %p\n", q, p));
  *(struct __s0__Read*)p = *(struct __s0__Read*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__GetStatus(
    struct soap* soap, struct __s0__GetStatus* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->s0__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__GetStatus(
    struct soap* soap, const struct __s0__GetStatus* a)
{
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_s0__GetStatus(soap, &a->s0__GetStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__GetStatus(struct soap* soap,
    const struct __s0__GetStatus* a, const char* tag, const char* type)
{
  register int id = 0;
  if (soap_out___s0__GetStatus(soap, tag, id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__GetStatus(struct soap* soap,
    const char* tag, int id, const struct __s0__GetStatus* a, const char* type)
{
  soap_out_PointerTo_s0__GetStatus(
      soap, "s0:GetStatus", -1, &a->s0__GetStatus, "");
  return SOAP_OK;
}

SOAP_FMAC3 struct __s0__GetStatus* SOAP_FMAC4 soap_get___s0__GetStatus(
    struct soap* soap, struct __s0__GetStatus* p, const char* tag,
    const char* type)
{
  if ((p = soap_in___s0__GetStatus(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct __s0__GetStatus* SOAP_FMAC4 soap_in___s0__GetStatus(
    struct soap* soap, const char* tag, struct __s0__GetStatus* a,
    const char* type)
{
  short soap_flag_s0__GetStatus = 1;
  int soap_flag;
  a = (struct __s0__GetStatus*)soap_id_enter(soap, soap->id, a,
      SOAP_TYPE___s0__GetStatus, sizeof(struct __s0__GetStatus), 0, NULL, NULL,
      NULL);
  if (!a)
    return NULL;
  soap_default___s0__GetStatus(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_s0__GetStatus && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTo_s0__GetStatus(
              soap, "s0:GetStatus", &a->s0__GetStatus, "")) {
        soap_flag_s0__GetStatus--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC5 struct __s0__GetStatus* SOAP_FMAC6 soap_new___s0__GetStatus(
    struct soap* soap, int n)
{
  return soap_instantiate___s0__GetStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__GetStatus(
    struct soap* soap, struct __s0__GetStatus* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__GetStatus* SOAP_FMAC4 soap_instantiate___s0__GetStatus(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate___s0__GetStatus(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp
      = soap_link(soap, NULL, SOAP_TYPE___s0__GetStatus, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new struct __s0__GetStatus;
    if (size)
      *size = sizeof(struct __s0__GetStatus);
  } else {
    cp->ptr = (void*)new struct __s0__GetStatus[n];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(struct __s0__GetStatus);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (struct __s0__GetStatus*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__GetStatus(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying struct __s0__GetStatus %p -> %p\n", q, p));
  *(struct __s0__GetStatus*)p = *(struct __s0__GetStatus*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(
    struct soap* soap, struct SOAP_ENV__Reason* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
    soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap* soap,
    struct SOAP_ENV__Reason* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
  if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap* soap,
    const char* tag, int id, struct SOAP_ENV__Reason* const* a,
    const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason** SOAP_FMAC4
soap_get_PointerToSOAP_ENV__Reason(struct soap* soap,
    struct SOAP_ENV__Reason** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason** SOAP_FMAC4
soap_in_PointerToSOAP_ENV__Reason(struct soap* soap, const char* tag,
    struct SOAP_ENV__Reason** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct SOAP_ENV__Reason**)soap_malloc(
              soap, sizeof(struct SOAP_ENV__Reason*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Reason**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(
    struct soap* soap, struct SOAP_ENV__Detail* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
    soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap* soap,
    struct SOAP_ENV__Detail* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
  if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap* soap,
    const char* tag, int id, struct SOAP_ENV__Detail* const* a,
    const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail** SOAP_FMAC4
soap_get_PointerToSOAP_ENV__Detail(struct soap* soap,
    struct SOAP_ENV__Detail** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail** SOAP_FMAC4
soap_in_PointerToSOAP_ENV__Detail(struct soap* soap, const char* tag,
    struct SOAP_ENV__Detail** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct SOAP_ENV__Detail**)soap_malloc(
              soap, sizeof(struct SOAP_ENV__Detail*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Detail**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(
    struct soap* soap, struct SOAP_ENV__Code* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
    soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap* soap,
    struct SOAP_ENV__Code* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
  if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap* soap,
    const char* tag, int id, struct SOAP_ENV__Code* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(
    struct soap* soap, struct SOAP_ENV__Code** p, const char* tag,
    const char* type)
{
  if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(
    struct soap* soap, const char* tag, struct SOAP_ENV__Code** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct SOAP_ENV__Code**)soap_malloc(
              soap, sizeof(struct SOAP_ENV__Code*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (struct SOAP_ENV__Code**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__GetPropertiesResponse(
    struct soap* soap, _s0__GetPropertiesResponse* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__GetPropertiesResponse))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__GetPropertiesResponse(
    struct soap* soap, _s0__GetPropertiesResponse* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag,
      SOAP_TYPE_PointerTo_s0__GetPropertiesResponse);
  if (soap_out_PointerTo_s0__GetPropertiesResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__GetPropertiesResponse(
    struct soap* soap, const char* tag, int id,
    _s0__GetPropertiesResponse* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__GetPropertiesResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__GetPropertiesResponse** SOAP_FMAC4
soap_get_PointerTo_s0__GetPropertiesResponse(struct soap* soap,
    _s0__GetPropertiesResponse** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__GetPropertiesResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__GetPropertiesResponse** SOAP_FMAC4
soap_in_PointerTo_s0__GetPropertiesResponse(struct soap* soap, const char* tag,
    _s0__GetPropertiesResponse** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__GetPropertiesResponse**)soap_malloc(
              soap, sizeof(_s0__GetPropertiesResponse*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__GetPropertiesResponse*)
                soap_instantiate__s0__GetPropertiesResponse(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__GetPropertiesResponse**)soap_id_lookup(soap, soap->href,
        (void**)a, SOAP_TYPE__s0__GetPropertiesResponse,
        sizeof(_s0__GetPropertiesResponse), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__GetProperties(
    struct soap* soap, _s0__GetProperties* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__GetProperties))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__GetProperties(
    struct soap* soap, _s0__GetProperties* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__GetProperties);
  if (soap_out_PointerTo_s0__GetProperties(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__GetProperties(
    struct soap* soap, const char* tag, int id, _s0__GetProperties* const* a,
    const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__GetProperties);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__GetProperties** SOAP_FMAC4 soap_get_PointerTo_s0__GetProperties(
    struct soap* soap, _s0__GetProperties** p, const char* tag,
    const char* type)
{
  if ((p = soap_in_PointerTo_s0__GetProperties(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__GetProperties** SOAP_FMAC4 soap_in_PointerTo_s0__GetProperties(
    struct soap* soap, const char* tag, _s0__GetProperties** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__GetProperties**)soap_malloc(
              soap, sizeof(_s0__GetProperties*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__GetProperties*)soap_instantiate__s0__GetProperties(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__GetProperties**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__GetProperties, sizeof(_s0__GetProperties), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__BrowseResponse(
    struct soap* soap, _s0__BrowseResponse* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__BrowseResponse))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__BrowseResponse(
    struct soap* soap, _s0__BrowseResponse* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__BrowseResponse);
  if (soap_out_PointerTo_s0__BrowseResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__BrowseResponse(
    struct soap* soap, const char* tag, int id, _s0__BrowseResponse* const* a,
    const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__BrowseResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__BrowseResponse** SOAP_FMAC4
soap_get_PointerTo_s0__BrowseResponse(struct soap* soap,
    _s0__BrowseResponse** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__BrowseResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__BrowseResponse** SOAP_FMAC4
soap_in_PointerTo_s0__BrowseResponse(struct soap* soap, const char* tag,
    _s0__BrowseResponse** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__BrowseResponse**)soap_malloc(
              soap, sizeof(_s0__BrowseResponse*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__BrowseResponse*)soap_instantiate__s0__BrowseResponse(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__BrowseResponse**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__BrowseResponse, sizeof(_s0__BrowseResponse), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__Browse(
    struct soap* soap, _s0__Browse* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__Browse))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__Browse(
    struct soap* soap, _s0__Browse* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__Browse);
  if (soap_out_PointerTo_s0__Browse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__Browse(struct soap* soap,
    const char* tag, int id, _s0__Browse* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__Browse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__Browse** SOAP_FMAC4 soap_get_PointerTo_s0__Browse(
    struct soap* soap, _s0__Browse** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__Browse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__Browse** SOAP_FMAC4 soap_in_PointerTo_s0__Browse(
    struct soap* soap, const char* tag, _s0__Browse** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__Browse**)soap_malloc(soap, sizeof(_s0__Browse*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__Browse*)soap_instantiate__s0__Browse(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__Browse**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__Browse, sizeof(_s0__Browse), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_s0__SubscriptionCancelResponse(
    struct soap* soap, _s0__SubscriptionCancelResponse* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__SubscriptionCancelResponse))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__SubscriptionCancelResponse(
    struct soap* soap, _s0__SubscriptionCancelResponse* const* a,
    const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag,
      SOAP_TYPE_PointerTo_s0__SubscriptionCancelResponse);
  if (soap_out_PointerTo_s0__SubscriptionCancelResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__SubscriptionCancelResponse(
    struct soap* soap, const char* tag, int id,
    _s0__SubscriptionCancelResponse* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type,
      SOAP_TYPE__s0__SubscriptionCancelResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse** SOAP_FMAC4
soap_get_PointerTo_s0__SubscriptionCancelResponse(struct soap* soap,
    _s0__SubscriptionCancelResponse** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__SubscriptionCancelResponse(
           soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse** SOAP_FMAC4
soap_in_PointerTo_s0__SubscriptionCancelResponse(struct soap* soap,
    const char* tag, _s0__SubscriptionCancelResponse** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__SubscriptionCancelResponse**)soap_malloc(
              soap, sizeof(_s0__SubscriptionCancelResponse*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__SubscriptionCancelResponse*)
                soap_instantiate__s0__SubscriptionCancelResponse(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__SubscriptionCancelResponse**)soap_id_lookup(soap, soap->href,
        (void**)a, SOAP_TYPE__s0__SubscriptionCancelResponse,
        sizeof(_s0__SubscriptionCancelResponse), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__SubscriptionCancel(
    struct soap* soap, _s0__SubscriptionCancel* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__SubscriptionCancel))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__SubscriptionCancel(
    struct soap* soap, _s0__SubscriptionCancel* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__SubscriptionCancel);
  if (soap_out_PointerTo_s0__SubscriptionCancel(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__SubscriptionCancel(
    struct soap* soap, const char* tag, int id,
    _s0__SubscriptionCancel* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__SubscriptionCancel);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscriptionCancel** SOAP_FMAC4
soap_get_PointerTo_s0__SubscriptionCancel(struct soap* soap,
    _s0__SubscriptionCancel** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__SubscriptionCancel(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__SubscriptionCancel** SOAP_FMAC4
soap_in_PointerTo_s0__SubscriptionCancel(struct soap* soap, const char* tag,
    _s0__SubscriptionCancel** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__SubscriptionCancel**)soap_malloc(
              soap, sizeof(_s0__SubscriptionCancel*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__SubscriptionCancel*)
                soap_instantiate__s0__SubscriptionCancel(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__SubscriptionCancel**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__SubscriptionCancel, sizeof(_s0__SubscriptionCancel), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_s0__SubscriptionPolledRefreshResponse(
    struct soap* soap, _s0__SubscriptionPolledRefreshResponse* const* a)
{
  if (!soap_reference(
          soap, *a, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTo_s0__SubscriptionPolledRefreshResponse(struct soap* soap,
    _s0__SubscriptionPolledRefreshResponse* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag,
      SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefreshResponse);
  if (soap_out_PointerTo_s0__SubscriptionPolledRefreshResponse(
          soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTo_s0__SubscriptionPolledRefreshResponse(struct soap* soap,
    const char* tag, int id, _s0__SubscriptionPolledRefreshResponse* const* a,
    const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type,
      SOAP_TYPE__s0__SubscriptionPolledRefreshResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse** SOAP_FMAC4
soap_get_PointerTo_s0__SubscriptionPolledRefreshResponse(struct soap* soap,
    _s0__SubscriptionPolledRefreshResponse** p, const char* tag,
    const char* type)
{
  if ((p = soap_in_PointerTo_s0__SubscriptionPolledRefreshResponse(
           soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse** SOAP_FMAC4
soap_in_PointerTo_s0__SubscriptionPolledRefreshResponse(struct soap* soap,
    const char* tag, _s0__SubscriptionPolledRefreshResponse** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__SubscriptionPolledRefreshResponse**)soap_malloc(
              soap, sizeof(_s0__SubscriptionPolledRefreshResponse*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__SubscriptionPolledRefreshResponse*)
                soap_instantiate__s0__SubscriptionPolledRefreshResponse(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__SubscriptionPolledRefreshResponse**)soap_id_lookup(soap,
        soap->href, (void**)a, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse,
        sizeof(_s0__SubscriptionPolledRefreshResponse), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTo_s0__SubscriptionPolledRefresh(
    struct soap* soap, _s0__SubscriptionPolledRefresh* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__SubscriptionPolledRefresh))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__SubscriptionPolledRefresh(
    struct soap* soap, _s0__SubscriptionPolledRefresh* const* a,
    const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag,
      SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefresh);
  if (soap_out_PointerTo_s0__SubscriptionPolledRefresh(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__SubscriptionPolledRefresh(
    struct soap* soap, const char* tag, int id,
    _s0__SubscriptionPolledRefresh* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type,
      SOAP_TYPE__s0__SubscriptionPolledRefresh);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh** SOAP_FMAC4
soap_get_PointerTo_s0__SubscriptionPolledRefresh(struct soap* soap,
    _s0__SubscriptionPolledRefresh** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__SubscriptionPolledRefresh(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh** SOAP_FMAC4
soap_in_PointerTo_s0__SubscriptionPolledRefresh(struct soap* soap,
    const char* tag, _s0__SubscriptionPolledRefresh** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__SubscriptionPolledRefresh**)soap_malloc(
              soap, sizeof(_s0__SubscriptionPolledRefresh*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__SubscriptionPolledRefresh*)
                soap_instantiate__s0__SubscriptionPolledRefresh(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__SubscriptionPolledRefresh**)soap_id_lookup(soap, soap->href,
        (void**)a, SOAP_TYPE__s0__SubscriptionPolledRefresh,
        sizeof(_s0__SubscriptionPolledRefresh), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__SubscribeResponse(
    struct soap* soap, _s0__SubscribeResponse* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__SubscribeResponse))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__SubscribeResponse(
    struct soap* soap, _s0__SubscribeResponse* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__SubscribeResponse);
  if (soap_out_PointerTo_s0__SubscribeResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__SubscribeResponse(
    struct soap* soap, const char* tag, int id,
    _s0__SubscribeResponse* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__SubscribeResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscribeResponse** SOAP_FMAC4
soap_get_PointerTo_s0__SubscribeResponse(struct soap* soap,
    _s0__SubscribeResponse** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__SubscribeResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__SubscribeResponse** SOAP_FMAC4
soap_in_PointerTo_s0__SubscribeResponse(struct soap* soap, const char* tag,
    _s0__SubscribeResponse** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__SubscribeResponse**)soap_malloc(
              soap, sizeof(_s0__SubscribeResponse*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__SubscribeResponse*)soap_instantiate__s0__SubscribeResponse(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__SubscribeResponse**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__SubscribeResponse, sizeof(_s0__SubscribeResponse), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__Subscribe(
    struct soap* soap, _s0__Subscribe* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__Subscribe))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__Subscribe(struct soap* soap,
    _s0__Subscribe* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__Subscribe);
  if (soap_out_PointerTo_s0__Subscribe(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__Subscribe(struct soap* soap,
    const char* tag, int id, _s0__Subscribe* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__Subscribe);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__Subscribe** SOAP_FMAC4 soap_get_PointerTo_s0__Subscribe(
    struct soap* soap, _s0__Subscribe** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__Subscribe(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__Subscribe** SOAP_FMAC4 soap_in_PointerTo_s0__Subscribe(
    struct soap* soap, const char* tag, _s0__Subscribe** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__Subscribe**)soap_malloc(soap, sizeof(_s0__Subscribe*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__Subscribe*)soap_instantiate__s0__Subscribe(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__Subscribe**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__Subscribe, sizeof(_s0__Subscribe), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__WriteResponse(
    struct soap* soap, _s0__WriteResponse* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__WriteResponse))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__WriteResponse(
    struct soap* soap, _s0__WriteResponse* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__WriteResponse);
  if (soap_out_PointerTo_s0__WriteResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__WriteResponse(
    struct soap* soap, const char* tag, int id, _s0__WriteResponse* const* a,
    const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__WriteResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__WriteResponse** SOAP_FMAC4 soap_get_PointerTo_s0__WriteResponse(
    struct soap* soap, _s0__WriteResponse** p, const char* tag,
    const char* type)
{
  if ((p = soap_in_PointerTo_s0__WriteResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__WriteResponse** SOAP_FMAC4 soap_in_PointerTo_s0__WriteResponse(
    struct soap* soap, const char* tag, _s0__WriteResponse** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__WriteResponse**)soap_malloc(
              soap, sizeof(_s0__WriteResponse*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__WriteResponse*)soap_instantiate__s0__WriteResponse(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__WriteResponse**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__WriteResponse, sizeof(_s0__WriteResponse), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__Write(
    struct soap* soap, _s0__Write* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__Write))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__Write(
    struct soap* soap, _s0__Write* const* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__Write);
  if (soap_out_PointerTo_s0__Write(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__Write(struct soap* soap,
    const char* tag, int id, _s0__Write* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__Write);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__Write** SOAP_FMAC4 soap_get_PointerTo_s0__Write(
    struct soap* soap, _s0__Write** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__Write(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__Write** SOAP_FMAC4 soap_in_PointerTo_s0__Write(
    struct soap* soap, const char* tag, _s0__Write** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__Write**)soap_malloc(soap, sizeof(_s0__Write*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__Write*)soap_instantiate__s0__Write(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__Write**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__Write, sizeof(_s0__Write), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__ReadResponse(
    struct soap* soap, _s0__ReadResponse* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__ReadResponse))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__ReadResponse(struct soap* soap,
    _s0__ReadResponse* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__ReadResponse);
  if (soap_out_PointerTo_s0__ReadResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__ReadResponse(struct soap* soap,
    const char* tag, int id, _s0__ReadResponse* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__ReadResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__ReadResponse** SOAP_FMAC4 soap_get_PointerTo_s0__ReadResponse(
    struct soap* soap, _s0__ReadResponse** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__ReadResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__ReadResponse** SOAP_FMAC4 soap_in_PointerTo_s0__ReadResponse(
    struct soap* soap, const char* tag, _s0__ReadResponse** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__ReadResponse**)soap_malloc(
              soap, sizeof(_s0__ReadResponse*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__ReadResponse*)soap_instantiate__s0__ReadResponse(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__ReadResponse**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__ReadResponse, sizeof(_s0__ReadResponse), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__Read(
    struct soap* soap, _s0__Read* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__Read))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__Read(
    struct soap* soap, _s0__Read* const* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__Read);
  if (soap_out_PointerTo_s0__Read(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__Read(struct soap* soap,
    const char* tag, int id, _s0__Read* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__Read);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__Read** SOAP_FMAC4 soap_get_PointerTo_s0__Read(
    struct soap* soap, _s0__Read** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__Read(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__Read** SOAP_FMAC4 soap_in_PointerTo_s0__Read(
    struct soap* soap, const char* tag, _s0__Read** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__Read**)soap_malloc(soap, sizeof(_s0__Read*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__Read*)soap_instantiate__s0__Read(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__Read**)soap_id_lookup(
        soap, soap->href, (void**)a, SOAP_TYPE__s0__Read, sizeof(_s0__Read), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__GetStatusResponse(
    struct soap* soap, _s0__GetStatusResponse* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__GetStatusResponse))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__GetStatusResponse(
    struct soap* soap, _s0__GetStatusResponse* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__GetStatusResponse);
  if (soap_out_PointerTo_s0__GetStatusResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__GetStatusResponse(
    struct soap* soap, const char* tag, int id,
    _s0__GetStatusResponse* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__GetStatusResponse);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__GetStatusResponse** SOAP_FMAC4
soap_get_PointerTo_s0__GetStatusResponse(struct soap* soap,
    _s0__GetStatusResponse** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__GetStatusResponse(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__GetStatusResponse** SOAP_FMAC4
soap_in_PointerTo_s0__GetStatusResponse(struct soap* soap, const char* tag,
    _s0__GetStatusResponse** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__GetStatusResponse**)soap_malloc(
              soap, sizeof(_s0__GetStatusResponse*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__GetStatusResponse*)soap_instantiate__s0__GetStatusResponse(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__GetStatusResponse**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__GetStatusResponse, sizeof(_s0__GetStatusResponse), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__GetStatus(
    struct soap* soap, _s0__GetStatus* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE__s0__GetStatus))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__GetStatus(struct soap* soap,
    _s0__GetStatus* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__GetStatus);
  if (soap_out_PointerTo_s0__GetStatus(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__GetStatus(struct soap* soap,
    const char* tag, int id, _s0__GetStatus* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__GetStatus);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__GetStatus** SOAP_FMAC4 soap_get_PointerTo_s0__GetStatus(
    struct soap* soap, _s0__GetStatus** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTo_s0__GetStatus(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 _s0__GetStatus** SOAP_FMAC4 soap_in_PointerTo_s0__GetStatus(
    struct soap* soap, const char* tag, _s0__GetStatus** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (_s0__GetStatus**)soap_malloc(soap, sizeof(_s0__GetStatus*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (_s0__GetStatus*)soap_instantiate__s0__GetStatus(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (_s0__GetStatus**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE__s0__GetStatus, sizeof(_s0__GetStatus), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__PropertyReplyList(
    struct soap* soap, s0__PropertyReplyList* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__PropertyReplyList))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__PropertyReplyList(
    struct soap* soap, s0__PropertyReplyList* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__PropertyReplyList);
  if (soap_out_PointerTos0__PropertyReplyList(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__PropertyReplyList(
    struct soap* soap, const char* tag, int id, s0__PropertyReplyList* const* a,
    const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__PropertyReplyList);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__PropertyReplyList** SOAP_FMAC4
soap_get_PointerTos0__PropertyReplyList(struct soap* soap,
    s0__PropertyReplyList** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__PropertyReplyList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__PropertyReplyList** SOAP_FMAC4
soap_in_PointerTos0__PropertyReplyList(struct soap* soap, const char* tag,
    s0__PropertyReplyList** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__PropertyReplyList**)soap_malloc(
              soap, sizeof(s0__PropertyReplyList*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__PropertyReplyList*)soap_instantiate_s0__PropertyReplyList(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__PropertyReplyList**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__PropertyReplyList, sizeof(s0__PropertyReplyList), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ItemIdentifier(
    struct soap* soap, s0__ItemIdentifier* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__ItemIdentifier))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ItemIdentifier(
    struct soap* soap, s0__ItemIdentifier* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ItemIdentifier);
  if (soap_out_PointerTos0__ItemIdentifier(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ItemIdentifier(
    struct soap* soap, const char* tag, int id, s0__ItemIdentifier* const* a,
    const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ItemIdentifier);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ItemIdentifier** SOAP_FMAC4 soap_get_PointerTos0__ItemIdentifier(
    struct soap* soap, s0__ItemIdentifier** p, const char* tag,
    const char* type)
{
  if ((p = soap_in_PointerTos0__ItemIdentifier(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__ItemIdentifier** SOAP_FMAC4 soap_in_PointerTos0__ItemIdentifier(
    struct soap* soap, const char* tag, s0__ItemIdentifier** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__ItemIdentifier**)soap_malloc(
              soap, sizeof(s0__ItemIdentifier*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__ItemIdentifier*)soap_instantiate_s0__ItemIdentifier(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__ItemIdentifier**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__ItemIdentifier, sizeof(s0__ItemIdentifier), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__BrowseElement(
    struct soap* soap, s0__BrowseElement* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__BrowseElement))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__BrowseElement(struct soap* soap,
    s0__BrowseElement* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__BrowseElement);
  if (soap_out_PointerTos0__BrowseElement(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__BrowseElement(struct soap* soap,
    const char* tag, int id, s0__BrowseElement* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__BrowseElement);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__BrowseElement** SOAP_FMAC4 soap_get_PointerTos0__BrowseElement(
    struct soap* soap, s0__BrowseElement** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__BrowseElement(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__BrowseElement** SOAP_FMAC4 soap_in_PointerTos0__BrowseElement(
    struct soap* soap, const char* tag, s0__BrowseElement** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__BrowseElement**)soap_malloc(
              soap, sizeof(s0__BrowseElement*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__BrowseElement*)soap_instantiate_s0__BrowseElement(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__BrowseElement**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__BrowseElement, sizeof(s0__BrowseElement), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__browseFilter(
    struct soap* soap, enum s0__browseFilter* const* a)
{
  soap_reference(soap, *a, SOAP_TYPE_s0__browseFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__browseFilter(struct soap* soap,
    enum s0__browseFilter* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__browseFilter);
  if (soap_out_PointerTos0__browseFilter(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__browseFilter(struct soap* soap,
    const char* tag, int id, enum s0__browseFilter* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__browseFilter);
  if (id < 0)
    return soap->error;
  return soap_out_s0__browseFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum s0__browseFilter** SOAP_FMAC4
soap_get_PointerTos0__browseFilter(struct soap* soap, enum s0__browseFilter** p,
    const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__browseFilter(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 enum s0__browseFilter** SOAP_FMAC4 soap_in_PointerTos0__browseFilter(
    struct soap* soap, const char* tag, enum s0__browseFilter** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (enum s0__browseFilter**)soap_malloc(
              soap, sizeof(enum s0__browseFilter*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_s0__browseFilter(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (enum s0__browseFilter**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__browseFilter, sizeof(enum s0__browseFilter), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_PointerTos0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, s0__SubscribePolledRefreshReplyItemList* const* a)
{
  if (!soap_reference(
          soap, *a, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_put_PointerTos0__SubscribePolledRefreshReplyItemList(struct soap* soap,
    s0__SubscribePolledRefreshReplyItemList* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag,
      SOAP_TYPE_PointerTos0__SubscribePolledRefreshReplyItemList);
  if (soap_out_PointerTos0__SubscribePolledRefreshReplyItemList(
          soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_PointerTos0__SubscribePolledRefreshReplyItemList(struct soap* soap,
    const char* tag, int id, s0__SubscribePolledRefreshReplyItemList* const* a,
    const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type,
      SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList** SOAP_FMAC4
soap_get_PointerTos0__SubscribePolledRefreshReplyItemList(struct soap* soap,
    s0__SubscribePolledRefreshReplyItemList** p, const char* tag,
    const char* type)
{
  if ((p = soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(
           soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList** SOAP_FMAC4
soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(struct soap* soap,
    const char* tag, s0__SubscribePolledRefreshReplyItemList** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__SubscribePolledRefreshReplyItemList**)soap_malloc(
              soap, sizeof(s0__SubscribePolledRefreshReplyItemList*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__SubscribePolledRefreshReplyItemList*)
                soap_instantiate_s0__SubscribePolledRefreshReplyItemList(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__SubscribePolledRefreshReplyItemList**)soap_id_lookup(soap,
        soap->href, (void**)a,
        SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList,
        sizeof(s0__SubscribePolledRefreshReplyItemList), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__SubscribeReplyItemList(
    struct soap* soap, s0__SubscribeReplyItemList* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__SubscribeReplyItemList))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__SubscribeReplyItemList(
    struct soap* soap, s0__SubscribeReplyItemList* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag,
      SOAP_TYPE_PointerTos0__SubscribeReplyItemList);
  if (soap_out_PointerTos0__SubscribeReplyItemList(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__SubscribeReplyItemList(
    struct soap* soap, const char* tag, int id,
    s0__SubscribeReplyItemList* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__SubscribeReplyItemList);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribeReplyItemList** SOAP_FMAC4
soap_get_PointerTos0__SubscribeReplyItemList(struct soap* soap,
    s0__SubscribeReplyItemList** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__SubscribeReplyItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__SubscribeReplyItemList** SOAP_FMAC4
soap_in_PointerTos0__SubscribeReplyItemList(struct soap* soap, const char* tag,
    s0__SubscribeReplyItemList** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__SubscribeReplyItemList**)soap_malloc(
              soap, sizeof(s0__SubscribeReplyItemList*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__SubscribeReplyItemList*)
                soap_instantiate_s0__SubscribeReplyItemList(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__SubscribeReplyItemList**)soap_id_lookup(soap, soap->href,
        (void**)a, SOAP_TYPE_s0__SubscribeReplyItemList,
        sizeof(s0__SubscribeReplyItemList), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__SubscribeRequestItemList(
    struct soap* soap, s0__SubscribeRequestItemList* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__SubscribeRequestItemList))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__SubscribeRequestItemList(
    struct soap* soap, s0__SubscribeRequestItemList* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag,
      SOAP_TYPE_PointerTos0__SubscribeRequestItemList);
  if (soap_out_PointerTos0__SubscribeRequestItemList(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__SubscribeRequestItemList(
    struct soap* soap, const char* tag, int id,
    s0__SubscribeRequestItemList* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__SubscribeRequestItemList);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribeRequestItemList** SOAP_FMAC4
soap_get_PointerTos0__SubscribeRequestItemList(struct soap* soap,
    s0__SubscribeRequestItemList** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__SubscribeRequestItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__SubscribeRequestItemList** SOAP_FMAC4
soap_in_PointerTos0__SubscribeRequestItemList(struct soap* soap,
    const char* tag, s0__SubscribeRequestItemList** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__SubscribeRequestItemList**)soap_malloc(
              soap, sizeof(s0__SubscribeRequestItemList*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__SubscribeRequestItemList*)
                soap_instantiate_s0__SubscribeRequestItemList(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__SubscribeRequestItemList**)soap_id_lookup(soap, soap->href,
        (void**)a, SOAP_TYPE_s0__SubscribeRequestItemList,
        sizeof(s0__SubscribeRequestItemList), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__WriteRequestItemList(
    struct soap* soap, s0__WriteRequestItemList* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__WriteRequestItemList))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__WriteRequestItemList(
    struct soap* soap, s0__WriteRequestItemList* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag,
      SOAP_TYPE_PointerTos0__WriteRequestItemList);
  if (soap_out_PointerTos0__WriteRequestItemList(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__WriteRequestItemList(
    struct soap* soap, const char* tag, int id,
    s0__WriteRequestItemList* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__WriteRequestItemList);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__WriteRequestItemList** SOAP_FMAC4
soap_get_PointerTos0__WriteRequestItemList(struct soap* soap,
    s0__WriteRequestItemList** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__WriteRequestItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__WriteRequestItemList** SOAP_FMAC4
soap_in_PointerTos0__WriteRequestItemList(struct soap* soap, const char* tag,
    s0__WriteRequestItemList** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__WriteRequestItemList**)soap_malloc(
              soap, sizeof(s0__WriteRequestItemList*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__WriteRequestItemList*)
                soap_instantiate_s0__WriteRequestItemList(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__WriteRequestItemList**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__WriteRequestItemList, sizeof(s0__WriteRequestItemList),
        0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__OPCError(
    struct soap* soap, s0__OPCError* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__OPCError))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__OPCError(struct soap* soap,
    s0__OPCError* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__OPCError);
  if (soap_out_PointerTos0__OPCError(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__OPCError(struct soap* soap,
    const char* tag, int id, s0__OPCError* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__OPCError);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__OPCError** SOAP_FMAC4 soap_get_PointerTos0__OPCError(
    struct soap* soap, s0__OPCError** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__OPCError(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__OPCError** SOAP_FMAC4 soap_in_PointerTos0__OPCError(
    struct soap* soap, const char* tag, s0__OPCError** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__OPCError**)soap_malloc(soap, sizeof(s0__OPCError*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__OPCError*)soap_instantiate_s0__OPCError(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__OPCError**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__OPCError, sizeof(s0__OPCError), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ReplyItemList(
    struct soap* soap, s0__ReplyItemList* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__ReplyItemList))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ReplyItemList(struct soap* soap,
    s0__ReplyItemList* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ReplyItemList);
  if (soap_out_PointerTos0__ReplyItemList(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ReplyItemList(struct soap* soap,
    const char* tag, int id, s0__ReplyItemList* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ReplyItemList);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ReplyItemList** SOAP_FMAC4 soap_get_PointerTos0__ReplyItemList(
    struct soap* soap, s0__ReplyItemList** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__ReplyItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__ReplyItemList** SOAP_FMAC4 soap_in_PointerTos0__ReplyItemList(
    struct soap* soap, const char* tag, s0__ReplyItemList** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__ReplyItemList**)soap_malloc(
              soap, sizeof(s0__ReplyItemList*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__ReplyItemList*)soap_instantiate_s0__ReplyItemList(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__ReplyItemList**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__ReplyItemList, sizeof(s0__ReplyItemList), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ReadRequestItemList(
    struct soap* soap, s0__ReadRequestItemList* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__ReadRequestItemList))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ReadRequestItemList(
    struct soap* soap, s0__ReadRequestItemList* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ReadRequestItemList);
  if (soap_out_PointerTos0__ReadRequestItemList(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ReadRequestItemList(
    struct soap* soap, const char* tag, int id,
    s0__ReadRequestItemList* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ReadRequestItemList);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ReadRequestItemList** SOAP_FMAC4
soap_get_PointerTos0__ReadRequestItemList(struct soap* soap,
    s0__ReadRequestItemList** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__ReadRequestItemList(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__ReadRequestItemList** SOAP_FMAC4
soap_in_PointerTos0__ReadRequestItemList(struct soap* soap, const char* tag,
    s0__ReadRequestItemList** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__ReadRequestItemList**)soap_malloc(
              soap, sizeof(s0__ReadRequestItemList*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__ReadRequestItemList*)
                soap_instantiate_s0__ReadRequestItemList(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__ReadRequestItemList**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__ReadRequestItemList, sizeof(s0__ReadRequestItemList), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__RequestOptions(
    struct soap* soap, s0__RequestOptions* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__RequestOptions))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__RequestOptions(
    struct soap* soap, s0__RequestOptions* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__RequestOptions);
  if (soap_out_PointerTos0__RequestOptions(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__RequestOptions(
    struct soap* soap, const char* tag, int id, s0__RequestOptions* const* a,
    const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__RequestOptions);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__RequestOptions** SOAP_FMAC4 soap_get_PointerTos0__RequestOptions(
    struct soap* soap, s0__RequestOptions** p, const char* tag,
    const char* type)
{
  if ((p = soap_in_PointerTos0__RequestOptions(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__RequestOptions** SOAP_FMAC4 soap_in_PointerTos0__RequestOptions(
    struct soap* soap, const char* tag, s0__RequestOptions** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__RequestOptions**)soap_malloc(
              soap, sizeof(s0__RequestOptions*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__RequestOptions*)soap_instantiate_s0__RequestOptions(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__RequestOptions**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__RequestOptions, sizeof(s0__RequestOptions), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ServerStatus(
    struct soap* soap, s0__ServerStatus* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__ServerStatus))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ServerStatus(struct soap* soap,
    s0__ServerStatus* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ServerStatus);
  if (soap_out_PointerTos0__ServerStatus(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ServerStatus(struct soap* soap,
    const char* tag, int id, s0__ServerStatus* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ServerStatus);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ServerStatus** SOAP_FMAC4 soap_get_PointerTos0__ServerStatus(
    struct soap* soap, s0__ServerStatus** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__ServerStatus(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__ServerStatus** SOAP_FMAC4 soap_in_PointerTos0__ServerStatus(
    struct soap* soap, const char* tag, s0__ServerStatus** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__ServerStatus**)soap_malloc(soap, sizeof(s0__ServerStatus*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__ServerStatus*)soap_instantiate_s0__ServerStatus(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__ServerStatus**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__ServerStatus, sizeof(s0__ServerStatus), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ReplyBase(
    struct soap* soap, s0__ReplyBase* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__ReplyBase))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ReplyBase(struct soap* soap,
    s0__ReplyBase* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ReplyBase);
  if (soap_out_PointerTos0__ReplyBase(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ReplyBase(struct soap* soap,
    const char* tag, int id, s0__ReplyBase* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ReplyBase);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ReplyBase** SOAP_FMAC4 soap_get_PointerTos0__ReplyBase(
    struct soap* soap, s0__ReplyBase** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__ReplyBase(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__ReplyBase** SOAP_FMAC4 soap_in_PointerTos0__ReplyBase(
    struct soap* soap, const char* tag, s0__ReplyBase** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__ReplyBase**)soap_malloc(soap, sizeof(s0__ReplyBase*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__ReplyBase*)soap_instantiate_s0__ReplyBase(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__ReplyBase**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__ReplyBase, sizeof(s0__ReplyBase), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ItemProperty(
    struct soap* soap, s0__ItemProperty* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__ItemProperty))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ItemProperty(struct soap* soap,
    s0__ItemProperty* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ItemProperty);
  if (soap_out_PointerTos0__ItemProperty(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ItemProperty(struct soap* soap,
    const char* tag, int id, s0__ItemProperty* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ItemProperty);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ItemProperty** SOAP_FMAC4 soap_get_PointerTos0__ItemProperty(
    struct soap* soap, s0__ItemProperty** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__ItemProperty(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__ItemProperty** SOAP_FMAC4 soap_in_PointerTos0__ItemProperty(
    struct soap* soap, const char* tag, s0__ItemProperty** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__ItemProperty**)soap_malloc(soap, sizeof(s0__ItemProperty*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__ItemProperty*)soap_instantiate_s0__ItemProperty(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__ItemProperty**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__ItemProperty, sizeof(s0__ItemProperty), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__SubscribeItemValue(
    struct soap* soap, s0__SubscribeItemValue* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__SubscribeItemValue))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__SubscribeItemValue(
    struct soap* soap, s0__SubscribeItemValue* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__SubscribeItemValue);
  if (soap_out_PointerTos0__SubscribeItemValue(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__SubscribeItemValue(
    struct soap* soap, const char* tag, int id,
    s0__SubscribeItemValue* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__SubscribeItemValue);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribeItemValue** SOAP_FMAC4
soap_get_PointerTos0__SubscribeItemValue(struct soap* soap,
    s0__SubscribeItemValue** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__SubscribeItemValue(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__SubscribeItemValue** SOAP_FMAC4
soap_in_PointerTos0__SubscribeItemValue(struct soap* soap, const char* tag,
    s0__SubscribeItemValue** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__SubscribeItemValue**)soap_malloc(
              soap, sizeof(s0__SubscribeItemValue*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__SubscribeItemValue*)soap_instantiate_s0__SubscribeItemValue(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__SubscribeItemValue**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__SubscribeItemValue, sizeof(s0__SubscribeItemValue), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(
    struct soap* soap, float* const* a)
{
  soap_reference(soap, *a, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(
    struct soap* soap, float* const* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
  if (soap_out_PointerTofloat(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap* soap,
    const char* tag, int id, float* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
  if (id < 0)
    return soap->error;
  return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float** SOAP_FMAC4 soap_get_PointerTofloat(
    struct soap* soap, float** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 float** SOAP_FMAC4 soap_in_PointerTofloat(
    struct soap* soap, const char* tag, float** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (float**)soap_malloc(soap, sizeof(float*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_float(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (float**)soap_id_lookup(
        soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__SubscribeRequestItem(
    struct soap* soap, s0__SubscribeRequestItem* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__SubscribeRequestItem))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__SubscribeRequestItem(
    struct soap* soap, s0__SubscribeRequestItem* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag,
      SOAP_TYPE_PointerTos0__SubscribeRequestItem);
  if (soap_out_PointerTos0__SubscribeRequestItem(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__SubscribeRequestItem(
    struct soap* soap, const char* tag, int id,
    s0__SubscribeRequestItem* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__SubscribeRequestItem);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribeRequestItem** SOAP_FMAC4
soap_get_PointerTos0__SubscribeRequestItem(struct soap* soap,
    s0__SubscribeRequestItem** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__SubscribeRequestItem(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__SubscribeRequestItem** SOAP_FMAC4
soap_in_PointerTos0__SubscribeRequestItem(struct soap* soap, const char* tag,
    s0__SubscribeRequestItem** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__SubscribeRequestItem**)soap_malloc(
              soap, sizeof(s0__SubscribeRequestItem*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__SubscribeRequestItem*)
                soap_instantiate_s0__SubscribeRequestItem(
                    soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__SubscribeRequestItem**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__SubscribeRequestItem, sizeof(s0__SubscribeRequestItem),
        0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedShort(
    struct soap* soap, unsigned short* const* a)
{
  soap_reference(soap, *a, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedShort(struct soap* soap,
    unsigned short* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedShort);
  if (soap_out_PointerTounsignedShort(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedShort(struct soap* soap,
    const char* tag, int id, unsigned short* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedShort);
  if (id < 0)
    return soap->error;
  return soap_out_unsignedShort(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned short** SOAP_FMAC4 soap_get_PointerTounsignedShort(
    struct soap* soap, unsigned short** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTounsignedShort(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 unsigned short** SOAP_FMAC4 soap_in_PointerTounsignedShort(
    struct soap* soap, const char* tag, unsigned short** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (unsigned short**)soap_malloc(soap, sizeof(unsigned short*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_unsignedShort(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (unsigned short**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_unsignedShort, sizeof(unsigned short), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__limitBits(
    struct soap* soap, enum s0__limitBits* const* a)
{
  soap_reference(soap, *a, SOAP_TYPE_s0__limitBits);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__limitBits(struct soap* soap,
    enum s0__limitBits* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__limitBits);
  if (soap_out_PointerTos0__limitBits(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__limitBits(struct soap* soap,
    const char* tag, int id, enum s0__limitBits* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__limitBits);
  if (id < 0)
    return soap->error;
  return soap_out_s0__limitBits(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum s0__limitBits** SOAP_FMAC4 soap_get_PointerTos0__limitBits(
    struct soap* soap, enum s0__limitBits** p, const char* tag,
    const char* type)
{
  if ((p = soap_in_PointerTos0__limitBits(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 enum s0__limitBits** SOAP_FMAC4 soap_in_PointerTos0__limitBits(
    struct soap* soap, const char* tag, enum s0__limitBits** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (enum s0__limitBits**)soap_malloc(
              soap, sizeof(enum s0__limitBits*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_s0__limitBits(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (enum s0__limitBits**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__limitBits, sizeof(enum s0__limitBits), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__qualityBits(
    struct soap* soap, enum s0__qualityBits* const* a)
{
  soap_reference(soap, *a, SOAP_TYPE_s0__qualityBits);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__qualityBits(struct soap* soap,
    enum s0__qualityBits* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__qualityBits);
  if (soap_out_PointerTos0__qualityBits(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__qualityBits(struct soap* soap,
    const char* tag, int id, enum s0__qualityBits* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__qualityBits);
  if (id < 0)
    return soap->error;
  return soap_out_s0__qualityBits(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum s0__qualityBits** SOAP_FMAC4 soap_get_PointerTos0__qualityBits(
    struct soap* soap, enum s0__qualityBits** p, const char* tag,
    const char* type)
{
  if ((p = soap_in_PointerTos0__qualityBits(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 enum s0__qualityBits** SOAP_FMAC4 soap_in_PointerTos0__qualityBits(
    struct soap* soap, const char* tag, enum s0__qualityBits** a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (enum s0__qualityBits**)soap_malloc(
              soap, sizeof(enum s0__qualityBits*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_s0__qualityBits(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (enum s0__qualityBits**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__qualityBits, sizeof(enum s0__qualityBits), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__OPCQuality(
    struct soap* soap, s0__OPCQuality* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__OPCQuality))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__OPCQuality(struct soap* soap,
    s0__OPCQuality* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__OPCQuality);
  if (soap_out_PointerTos0__OPCQuality(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__OPCQuality(struct soap* soap,
    const char* tag, int id, s0__OPCQuality* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__OPCQuality);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__OPCQuality** SOAP_FMAC4 soap_get_PointerTos0__OPCQuality(
    struct soap* soap, s0__OPCQuality** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__OPCQuality(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__OPCQuality** SOAP_FMAC4 soap_in_PointerTos0__OPCQuality(
    struct soap* soap, const char* tag, s0__OPCQuality** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__OPCQuality**)soap_malloc(soap, sizeof(s0__OPCQuality*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__OPCQuality*)soap_instantiate_s0__OPCQuality(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__OPCQuality**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__OPCQuality, sizeof(s0__OPCQuality), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(
    struct soap* soap, xsd__anyType* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap* soap,
    xsd__anyType* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
  if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap* soap,
    const char* tag, int id, xsd__anyType* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType** SOAP_FMAC4 soap_get_PointerToxsd__anyType(
    struct soap* soap, xsd__anyType** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 xsd__anyType** SOAP_FMAC4 soap_in_PointerToxsd__anyType(
    struct soap* soap, const char* tag, xsd__anyType** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (xsd__anyType**)soap_malloc(soap, sizeof(xsd__anyType*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (xsd__anyType*)soap_instantiate_xsd__anyType(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (xsd__anyType**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ItemValue(
    struct soap* soap, s0__ItemValue* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__ItemValue))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ItemValue(struct soap* soap,
    s0__ItemValue* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ItemValue);
  if (soap_out_PointerTos0__ItemValue(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ItemValue(struct soap* soap,
    const char* tag, int id, s0__ItemValue* const* a, const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ItemValue);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ItemValue** SOAP_FMAC4 soap_get_PointerTos0__ItemValue(
    struct soap* soap, s0__ItemValue** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__ItemValue(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__ItemValue** SOAP_FMAC4 soap_in_PointerTos0__ItemValue(
    struct soap* soap, const char* tag, s0__ItemValue** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__ItemValue**)soap_malloc(soap, sizeof(s0__ItemValue*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__ItemValue*)soap_instantiate_s0__ItemValue(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__ItemValue**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__ItemValue, sizeof(s0__ItemValue), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(
    struct soap* soap, int* const* a)
{
  soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(
    struct soap* soap, int* const* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
  if (soap_out_PointerToint(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(
    struct soap* soap, const char* tag, int id, int* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
  if (id < 0)
    return soap->error;
  return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int** SOAP_FMAC4 soap_get_PointerToint(
    struct soap* soap, int** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerToint(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 int** SOAP_FMAC4 soap_in_PointerToint(
    struct soap* soap, const char* tag, int** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (int**)soap_malloc(soap, sizeof(int*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_int(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (int**)soap_id_lookup(
        soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(
    struct soap* soap, std::string* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
    soap_serialize_xsd__QName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(
    struct soap* soap, std::string* const* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__QName);
  if (soap_out_PointerToxsd__QName(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap* soap,
    const char* tag, int id, std::string* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName);
  if (id < 0)
    return soap->error;
  return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string** SOAP_FMAC4 soap_get_PointerToxsd__QName(
    struct soap* soap, std::string** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 std::string** SOAP_FMAC4 soap_in_PointerToxsd__QName(
    struct soap* soap, const char* tag, std::string** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (std::string**)soap_malloc(soap, sizeof(std::string*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (std::string**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_xsd__QName, sizeof(std::string), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ReadRequestItem(
    struct soap* soap, s0__ReadRequestItem* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_s0__ReadRequestItem))
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ReadRequestItem(
    struct soap* soap, s0__ReadRequestItem* const* a, const char* tag,
    const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ReadRequestItem);
  if (soap_out_PointerTos0__ReadRequestItem(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ReadRequestItem(
    struct soap* soap, const char* tag, int id, s0__ReadRequestItem* const* a,
    const char* type)
{
  id = soap_element_id(
      soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ReadRequestItem);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ReadRequestItem** SOAP_FMAC4
soap_get_PointerTos0__ReadRequestItem(struct soap* soap,
    s0__ReadRequestItem** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTos0__ReadRequestItem(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 s0__ReadRequestItem** SOAP_FMAC4
soap_in_PointerTos0__ReadRequestItem(struct soap* soap, const char* tag,
    s0__ReadRequestItem** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (s0__ReadRequestItem**)soap_malloc(
              soap, sizeof(s0__ReadRequestItem*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = (s0__ReadRequestItem*)soap_instantiate_s0__ReadRequestItem(
              soap, -1, soap->type, soap->arrayType, NULL)))
      return NULL;
    (*a)->soap_default(soap);
    if (!(*a)->soap_in(soap, tag, NULL))
      return NULL;
  } else {
    a = (s0__ReadRequestItem**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_s0__ReadRequestItem, sizeof(s0__ReadRequestItem), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(
    struct soap* soap, bool* const* a)
{
  soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(
    struct soap* soap, bool* const* a, const char* tag, const char* type)
{
  register int id
      = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
  if (soap_out_PointerTobool(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap* soap,
    const char* tag, int id, bool* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
  if (id < 0)
    return soap->error;
  return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool** SOAP_FMAC4 soap_get_PointerTobool(
    struct soap* soap, bool** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTobool(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 bool** SOAP_FMAC4 soap_in_PointerTobool(
    struct soap* soap, const char* tag, bool** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (bool**)soap_malloc(soap, sizeof(bool*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_bool(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (bool**)soap_id_lookup(
        soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(
    struct soap* soap, std::string* const* a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
    soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(
    struct soap* soap, std::string* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(
      soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
  if (soap_out_PointerTostd__string(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap* soap,
    const char* tag, int id, std::string* const* a, const char* type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
  if (id < 0)
    return soap->error;
  return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string** SOAP_FMAC4 soap_get_PointerTostd__string(
    struct soap* soap, std::string** p, const char* tag, const char* type)
{
  if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 std::string** SOAP_FMAC4 soap_in_PointerTostd__string(
    struct soap* soap, const char* tag, std::string** a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (std::string**)soap_malloc(soap, sizeof(std::string*))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_std__string(soap, tag, *a, type)))
      return NULL;
  } else {
    a = (std::string**)soap_id_lookup(soap, soap->href, (void**)a,
        SOAP_TYPE_std__string, sizeof(std::string), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap* soap, char** a)
{
  soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(
    struct soap* soap, char* const* a)
{
  soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(
    struct soap* soap, char* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
  if (soap_out__QName(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap* soap, const char* tag,
    int id, char* const* a, const char* type)
{
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char** SOAP_FMAC4 soap_get__QName(
    struct soap* soap, char** p, const char* tag, const char* type)
{
  if ((p = soap_in__QName(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 char** SOAP_FMAC4 soap_in__QName(
    struct soap* soap, const char* tag, char** a, const char* type)
{
  return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap* soap, char** a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
  *a = SOAP_DEFAULT_string;
#else
  *a = (char*)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(
    struct soap* soap, char* const* a)
{
  soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(
    struct soap* soap, char* const* a, const char* tag, const char* type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
  if (soap_out_string(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap* soap, const char* tag,
    int id, char* const* a, const char* type)
{
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char** SOAP_FMAC4 soap_get_string(
    struct soap* soap, char** p, const char* tag, const char* type)
{
  if ((p = soap_in_string(soap, tag, p, type)))
    soap_getindependent(soap);
  return p;
}

SOAP_FMAC3 char** SOAP_FMAC4 soap_in_string(
    struct soap* soap, const char* tag, char** a, const char* type)
{
  return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__PropertyReplyList(
    struct soap* soap, std::vector<s0__PropertyReplyList*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__PropertyReplyList(
    struct soap* soap, const std::vector<s0__PropertyReplyList*>* a)
{
  for (std::vector<s0__PropertyReplyList*>::const_iterator i = a->begin();
       i != a->end(); ++i)
    soap_serialize_PointerTos0__PropertyReplyList(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap* soap,
    const char* tag, int id, const std::vector<s0__PropertyReplyList*>* a,
    const char* type)
{
  for (std::vector<s0__PropertyReplyList*>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_PointerTos0__PropertyReplyList(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__PropertyReplyList*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap* soap,
    const char* tag, std::vector<s0__PropertyReplyList*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__PropertyReplyList(
               soap, -1)))
    return NULL;
  s0__PropertyReplyList* n;
  s0__PropertyReplyList** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__PropertyReplyList,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList,
              sizeof(s0__PropertyReplyList), 1))
        break;
      if (!(p = soap_in_PointerTos0__PropertyReplyList(
                soap, tag, NULL, "s0:PropertyReplyList")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__PropertyReplyList(
              soap, tag, &n, "s0:PropertyReplyList"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__PropertyReplyList*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__PropertyReplyList(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__PropertyReplyList(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__PropertyReplyList(
    struct soap* soap, std::vector<s0__PropertyReplyList*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__PropertyReplyList*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__PropertyReplyList(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "PropertyReplyList(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList, n,
      soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__PropertyReplyList*>;
    if (size)
      *size = sizeof(std::vector<s0__PropertyReplyList*>);
  } else {
    cp->ptr = (void*)new std::vector<s0__PropertyReplyList*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__PropertyReplyList*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__PropertyReplyList*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4
soap_copy_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "Copying std::vector<s0__PropertyReplyList * > %p -> %p\n", q, p));
  *(std::vector<s0__PropertyReplyList*>*)p
      = *(std::vector<s0__PropertyReplyList*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__ItemIdentifier(
    struct soap* soap, std::vector<s0__ItemIdentifier*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__ItemIdentifier(
    struct soap* soap, const std::vector<s0__ItemIdentifier*>* a)
{
  for (std::vector<s0__ItemIdentifier*>::const_iterator i = a->begin();
       i != a->end(); ++i)
    soap_serialize_PointerTos0__ItemIdentifier(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap* soap,
    const char* tag, int id, const std::vector<s0__ItemIdentifier*>* a,
    const char* type)
{
  for (std::vector<s0__ItemIdentifier*>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_PointerTos0__ItemIdentifier(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__ItemIdentifier*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap* soap,
    const char* tag, std::vector<s0__ItemIdentifier*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__ItemIdentifier(
               soap, -1)))
    return NULL;
  s0__ItemIdentifier* n;
  s0__ItemIdentifier** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__ItemIdentifier,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier,
              sizeof(s0__ItemIdentifier), 1))
        break;
      if (!(p = soap_in_PointerTos0__ItemIdentifier(
                soap, tag, NULL, "s0:ItemIdentifier")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__ItemIdentifier(
              soap, tag, &n, "s0:ItemIdentifier"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__ItemIdentifier*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__ItemIdentifier(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__ItemIdentifier(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__ItemIdentifier(
    struct soap* soap, std::vector<s0__ItemIdentifier*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__ItemIdentifier*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__ItemIdentifier(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "ItemIdentifier(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier, n,
      soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__ItemIdentifier*>;
    if (size)
      *size = sizeof(std::vector<s0__ItemIdentifier*>);
  } else {
    cp->ptr = (void*)new std::vector<s0__ItemIdentifier*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__ItemIdentifier*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__ItemIdentifier*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4
soap_copy_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug,
                "Copying std::vector<s0__ItemIdentifier * > %p -> %p\n", q, p));
  *(std::vector<s0__ItemIdentifier*>*)p = *(std::vector<s0__ItemIdentifier*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__BrowseElement(
    struct soap* soap, std::vector<s0__BrowseElement*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__BrowseElement(
    struct soap* soap, const std::vector<s0__BrowseElement*>* a)
{
  for (std::vector<s0__BrowseElement*>::const_iterator i = a->begin();
       i != a->end(); ++i)
    soap_serialize_PointerTos0__BrowseElement(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap* soap,
    const char* tag, int id, const std::vector<s0__BrowseElement*>* a,
    const char* type)
{
  for (std::vector<s0__BrowseElement*>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_PointerTos0__BrowseElement(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__BrowseElement*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap* soap,
    const char* tag, std::vector<s0__BrowseElement*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__BrowseElement(
               soap, -1)))
    return NULL;
  s0__BrowseElement* n;
  s0__BrowseElement** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__BrowseElement,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement,
              sizeof(s0__BrowseElement), 1))
        break;
      if (!(p = soap_in_PointerTos0__BrowseElement(
                soap, tag, NULL, "s0:BrowseElement")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__BrowseElement(
              soap, tag, &n, "s0:BrowseElement"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__BrowseElement*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__BrowseElement(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__BrowseElement(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__BrowseElement(
    struct soap* soap, std::vector<s0__BrowseElement*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__BrowseElement*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__BrowseElement(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "BrowseElement(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement, n,
      soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__BrowseElement*>;
    if (size)
      *size = sizeof(std::vector<s0__BrowseElement*>);
  } else {
    cp->ptr = (void*)new std::vector<s0__BrowseElement*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__BrowseElement*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__BrowseElement*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4
soap_copy_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug,
                "Copying std::vector<s0__BrowseElement * > %p -> %p\n", q, p));
  *(std::vector<s0__BrowseElement*>*)p = *(std::vector<s0__BrowseElement*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(
    struct soap* soap, std::vector<std::string>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(
    struct soap* soap, const std::vector<std::string>* a)
{
  for (std::vector<std::string>::const_iterator i = a->begin(); i != a->end();
       ++i)
    soap_serialize_xsd__QName(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(
    struct soap* soap, const char* tag, int id,
    const std::vector<std::string>* a, const char* type)
{
  for (std::vector<std::string>::const_iterator i = a->begin(); i != a->end();
       ++i) {
    if (soap_out_xsd__QName(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string>* SOAP_FMAC4
soap_in_std__vectorTemplateOfxsd__QName(struct soap* soap, const char* tag,
    std::vector<std::string>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap, -1)))
    return NULL;
  std::string n;
  std::string* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_xsd__QName,
              SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string),
              0))
        break;
      if (!(p = soap_in_xsd__QName(soap, tag, NULL, "xsd:QName")))
        break;
    } else {
      soap_default_xsd__QName(soap, &n);
      if (!soap_in_xsd__QName(soap, tag, &n, "xsd:QName"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<std::string>* SOAP_FMAC6
soap_new_std__vectorTemplateOfxsd__QName(struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfxsd__QName(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfxsd__QName(
    struct soap* soap, std::vector<std::string>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "soap_instantiate_std__vectorTemplateOfxsd__QName(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<std::string>;
    if (size)
      *size = sizeof(std::vector<std::string>);
  } else {
    cp->ptr = (void*)new std::vector<std::string>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<std::string>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<std::string>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__QName(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying std::vector<std::string > %p -> %p\n", q, p));
  *(std::vector<std::string>*)p = *(std::vector<std::string>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, std::vector<s0__SubscribePolledRefreshReplyItemList*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
    struct soap* soap,
    const std::vector<s0__SubscribePolledRefreshReplyItemList*>* a)
{
  for (std::vector<s0__SubscribePolledRefreshReplyItemList*>::const_iterator i
       = a->begin();
       i != a->end(); ++i)
    soap_serialize_PointerTos0__SubscribePolledRefreshReplyItemList(
        soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, const char* tag, int id,
    const std::vector<s0__SubscribePolledRefreshReplyItemList*>* a,
    const char* type)
{
  for (std::vector<s0__SubscribePolledRefreshReplyItemList*>::const_iterator i
       = a->begin();
       i != a->end(); ++i) {
    if (soap_out_PointerTos0__SubscribePolledRefreshReplyItemList(
            soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__SubscribePolledRefreshReplyItemList*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, const char* tag,
    std::vector<s0__SubscribePolledRefreshReplyItemList*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
               soap, -1)))
    return NULL;
  s0__SubscribePolledRefreshReplyItemList* n;
  s0__SubscribePolledRefreshReplyItemList** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(),
              SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList,
              sizeof(s0__SubscribePolledRefreshReplyItemList), 1))
        break;
      if (!(p = soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(
                soap, tag, NULL, "s0:SubscribePolledRefreshReplyItemList")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(
              soap, tag, &n, "s0:SubscribePolledRefreshReplyItemList"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__SubscribePolledRefreshReplyItemList*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, std::vector<s0__SubscribePolledRefreshReplyItemList*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__SubscribePolledRefreshReplyItemList*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "SubscribePolledRefreshReplyItemList(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList,
      n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__SubscribePolledRefreshReplyItemList*>;
    if (size)
      *size = sizeof(std::vector<s0__SubscribePolledRefreshReplyItemList*>);
  } else {
    cp->ptr
        = (void*)new std::vector<s0__SubscribePolledRefreshReplyItemList*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__SubscribePolledRefreshReplyItemList*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__SubscribePolledRefreshReplyItemList*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4
soap_copy_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug,
                "Copying std::vector<s0__SubscribePolledRefreshReplyItemList * "
                "> %p -> %p\n",
                q, p));
  *(std::vector<s0__SubscribePolledRefreshReplyItemList*>*)p
      = *(std::vector<s0__SubscribePolledRefreshReplyItemList*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__OPCError(
    struct soap* soap, std::vector<s0__OPCError*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(
    struct soap* soap, const std::vector<s0__OPCError*>* a)
{
  for (std::vector<s0__OPCError*>::const_iterator i = a->begin(); i != a->end();
       ++i)
    soap_serialize_PointerTos0__OPCError(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__OPCError(
    struct soap* soap, const char* tag, int id,
    const std::vector<s0__OPCError*>* a, const char* type)
{
  for (std::vector<s0__OPCError*>::const_iterator i = a->begin(); i != a->end();
       ++i) {
    if (soap_out_PointerTos0__OPCError(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__OPCError*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__OPCError(struct soap* soap,
    const char* tag, std::vector<s0__OPCError*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__OPCError(soap, -1)))
    return NULL;
  s0__OPCError* n;
  s0__OPCError** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__OPCError,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError,
              sizeof(s0__OPCError), 1))
        break;
      if (!(p = soap_in_PointerTos0__OPCError(soap, tag, NULL, "s0:OPCError")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__OPCError(soap, tag, &n, "s0:OPCError"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__OPCError*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__OPCError(struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__OPCError(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__OPCError(
    struct soap* soap, std::vector<s0__OPCError*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__OPCError*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__OPCError(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "OPCError(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__OPCError*>;
    if (size)
      *size = sizeof(std::vector<s0__OPCError*>);
  } else {
    cp->ptr = (void*)new std::vector<s0__OPCError*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__OPCError*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__OPCError*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__OPCError(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying std::vector<s0__OPCError * > %p -> %p\n", q, p));
  *(std::vector<s0__OPCError*>*)p = *(std::vector<s0__OPCError*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__ItemProperty(
    struct soap* soap, std::vector<s0__ItemProperty*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__ItemProperty(
    struct soap* soap, const std::vector<s0__ItemProperty*>* a)
{
  for (std::vector<s0__ItemProperty*>::const_iterator i = a->begin();
       i != a->end(); ++i)
    soap_serialize_PointerTos0__ItemProperty(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap* soap,
    const char* tag, int id, const std::vector<s0__ItemProperty*>* a,
    const char* type)
{
  for (std::vector<s0__ItemProperty*>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_PointerTos0__ItemProperty(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__ItemProperty*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap* soap,
    const char* tag, std::vector<s0__ItemProperty*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__ItemProperty(
               soap, -1)))
    return NULL;
  s0__ItemProperty* n;
  s0__ItemProperty** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__ItemProperty,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty,
              sizeof(s0__ItemProperty), 1))
        break;
      if (!(p = soap_in_PointerTos0__ItemProperty(
                soap, tag, NULL, "s0:ItemProperty")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__ItemProperty(soap, tag, &n, "s0:ItemProperty"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__ItemProperty*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__ItemProperty(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__ItemProperty(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__ItemProperty(
    struct soap* soap, std::vector<s0__ItemProperty*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__ItemProperty*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__ItemProperty(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "ItemProperty(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty, n,
      soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__ItemProperty*>;
    if (size)
      *size = sizeof(std::vector<s0__ItemProperty*>);
  } else {
    cp->ptr = (void*)new std::vector<s0__ItemProperty*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__ItemProperty*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__ItemProperty*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4
soap_copy_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug,
                "Copying std::vector<s0__ItemProperty * > %p -> %p\n", q, p));
  *(std::vector<s0__ItemProperty*>*)p = *(std::vector<s0__ItemProperty*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
    struct soap* soap, std::vector<s0__SubscribeItemValue*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
    struct soap* soap, const std::vector<s0__SubscribeItemValue*>* a)
{
  for (std::vector<s0__SubscribeItemValue*>::const_iterator i = a->begin();
       i != a->end(); ++i)
    soap_serialize_PointerTos0__SubscribeItemValue(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap* soap,
    const char* tag, int id, const std::vector<s0__SubscribeItemValue*>* a,
    const char* type)
{
  for (std::vector<s0__SubscribeItemValue*>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_PointerTos0__SubscribeItemValue(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__SubscribeItemValue*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap* soap,
    const char* tag, std::vector<s0__SubscribeItemValue*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
               soap, -1)))
    return NULL;
  s0__SubscribeItemValue* n;
  s0__SubscribeItemValue** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__SubscribeItemValue,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue,
              sizeof(s0__SubscribeItemValue), 1))
        break;
      if (!(p = soap_in_PointerTos0__SubscribeItemValue(
                soap, tag, NULL, "s0:SubscribeItemValue")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__SubscribeItemValue(
              soap, tag, &n, "s0:SubscribeItemValue"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__SubscribeItemValue*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
    struct soap* soap, std::vector<s0__SubscribeItemValue*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__SubscribeItemValue*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "SubscribeItemValue(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue, n,
      soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__SubscribeItemValue*>;
    if (size)
      *size = sizeof(std::vector<s0__SubscribeItemValue*>);
  } else {
    cp->ptr = (void*)new std::vector<s0__SubscribeItemValue*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__SubscribeItemValue*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__SubscribeItemValue*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4
soap_copy_std__vectorTemplateOfPointerTos0__SubscribeItemValue(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "Copying std::vector<s0__SubscribeItemValue * > %p -> %p\n", q, p));
  *(std::vector<s0__SubscribeItemValue*>*)p
      = *(std::vector<s0__SubscribeItemValue*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
    struct soap* soap, std::vector<s0__SubscribeRequestItem*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
    struct soap* soap, const std::vector<s0__SubscribeRequestItem*>* a)
{
  for (std::vector<s0__SubscribeRequestItem*>::const_iterator i = a->begin();
       i != a->end(); ++i)
    soap_serialize_PointerTos0__SubscribeRequestItem(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
    struct soap* soap, const char* tag, int id,
    const std::vector<s0__SubscribeRequestItem*>* a, const char* type)
{
  for (std::vector<s0__SubscribeRequestItem*>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_PointerTos0__SubscribeRequestItem(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__SubscribeRequestItem*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
    struct soap* soap, const char* tag,
    std::vector<s0__SubscribeRequestItem*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
               soap, -1)))
    return NULL;
  s0__SubscribeRequestItem* n;
  s0__SubscribeRequestItem** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__SubscribeRequestItem,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem,
              sizeof(s0__SubscribeRequestItem), 1))
        break;
      if (!(p = soap_in_PointerTos0__SubscribeRequestItem(
                soap, tag, NULL, "s0:SubscribeRequestItem")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__SubscribeRequestItem(
              soap, tag, &n, "s0:SubscribeRequestItem"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__SubscribeRequestItem*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
    struct soap* soap, std::vector<s0__SubscribeRequestItem*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__SubscribeRequestItem*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "SubscribeRequestItem(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem, n,
      soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__SubscribeRequestItem*>;
    if (size)
      *size = sizeof(std::vector<s0__SubscribeRequestItem*>);
  } else {
    cp->ptr = (void*)new std::vector<s0__SubscribeRequestItem*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__SubscribeRequestItem*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__SubscribeRequestItem*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4
soap_copy_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "Copying std::vector<s0__SubscribeRequestItem * > %p -> %p\n", q, p));
  *(std::vector<s0__SubscribeRequestItem*>*)p
      = *(std::vector<s0__SubscribeRequestItem*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfshort(
    struct soap* soap, std::vector<short>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfshort(
    struct soap* soap, const std::vector<short>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfshort(struct soap* soap,
    const char* tag, int id, const std::vector<short>* a, const char* type)
{
  for (std::vector<short>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_short(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<short>* SOAP_FMAC4 soap_in_std__vectorTemplateOfshort(
    struct soap* soap, const char* tag, std::vector<short>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfshort(soap, -1)))
    return NULL;
  short n;
  short* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_short,
              SOAP_TYPE_std__vectorTemplateOfshort, sizeof(short), 0))
        break;
      if (!(p = soap_in_short(soap, tag, NULL, "xsd:short")))
        break;
    } else {
      soap_default_short(soap, &n);
      if (!soap_in_short(soap, tag, &n, "xsd:short"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<short>* SOAP_FMAC6 soap_new_std__vectorTemplateOfshort(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfshort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfshort(
    struct soap* soap, std::vector<short>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<short>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfshort(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_std__vectorTemplateOfshort(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfshort, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<short>;
    if (size)
      *size = sizeof(std::vector<short>);
  } else {
    cp->ptr = (void*)new std::vector<short>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<short>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<short>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfshort(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying std::vector<short > %p -> %p\n", q, p));
  *(std::vector<short>*)p = *(std::vector<short>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfbyte(
    struct soap* soap, std::vector<char>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfbyte(
    struct soap* soap, const std::vector<char>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfbyte(struct soap* soap,
    const char* tag, int id, const std::vector<char>* a, const char* type)
{
  for (std::vector<char>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_byte(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<char>* SOAP_FMAC4 soap_in_std__vectorTemplateOfbyte(
    struct soap* soap, const char* tag, std::vector<char>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfbyte(soap, -1)))
    return NULL;
  char n;
  char* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_byte,
              SOAP_TYPE_std__vectorTemplateOfbyte, sizeof(char), 0))
        break;
      if (!(p = soap_in_byte(soap, tag, NULL, "xsd:byte")))
        break;
    } else {
      soap_default_byte(soap, &n);
      if (!soap_in_byte(soap, tag, &n, "xsd:byte"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<char>* SOAP_FMAC6 soap_new_std__vectorTemplateOfbyte(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfbyte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfbyte(
    struct soap* soap, std::vector<char>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfbyte(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_std__vectorTemplateOfbyte(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfbyte, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<char>;
    if (size)
      *size = sizeof(std::vector<char>);
  } else {
    cp->ptr = (void*)new std::vector<char>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<char>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<char>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfbyte(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying std::vector<char > %p -> %p\n", q, p));
  *(std::vector<char>*)p = *(std::vector<char>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__decimal(
    struct soap* soap, std::vector<std::string>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__decimal(
    struct soap* soap, const std::vector<std::string>* a)
{
  for (std::vector<std::string>::const_iterator i = a->begin(); i != a->end();
       ++i)
    soap_serialize_xsd__decimal(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__decimal(
    struct soap* soap, const char* tag, int id,
    const std::vector<std::string>* a, const char* type)
{
  for (std::vector<std::string>::const_iterator i = a->begin(); i != a->end();
       ++i) {
    if (soap_out_xsd__decimal(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string>* SOAP_FMAC4
soap_in_std__vectorTemplateOfxsd__decimal(struct soap* soap, const char* tag,
    std::vector<std::string>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfxsd__decimal(soap, -1)))
    return NULL;
  std::string n;
  std::string* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_xsd__decimal,
              SOAP_TYPE_std__vectorTemplateOfxsd__decimal, sizeof(std::string),
              0))
        break;
      if (!(p = soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal")))
        break;
    } else {
      soap_default_xsd__decimal(soap, &n);
      if (!soap_in_xsd__decimal(soap, tag, &n, "xsd:decimal"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<std::string>* SOAP_FMAC6
soap_new_std__vectorTemplateOfxsd__decimal(struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfxsd__decimal(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfxsd__decimal(
    struct soap* soap, std::vector<std::string>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfxsd__decimal(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "soap_instantiate_std__vectorTemplateOfxsd__decimal(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__decimal, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<std::string>;
    if (size)
      *size = sizeof(std::vector<std::string>);
  } else {
    cp->ptr = (void*)new std::vector<std::string>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<std::string>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<std::string>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__decimal(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying std::vector<std::string > %p -> %p\n", q, p));
  *(std::vector<std::string>*)p = *(std::vector<std::string>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(
    struct soap* soap, std::vector<char*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(
    struct soap* soap, const std::vector<char*>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap* soap,
    const char* tag, int id, const std::vector<char*>* a, const char* type)
{
  for (std::vector<char*>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_outliteral(soap, tag, &(*i), NULL))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<char*>* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(
    struct soap* soap, const char* tag, std::vector<char*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
    return NULL;
  char* n;
  char** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE__XML,
              SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char*), 1))
        break;
      if (!(p = soap_inliteral(soap, tag, NULL)))
        break;
    } else {
      n = NULL;
      if (!soap_inliteral(soap, tag, &n))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<char*>* SOAP_FMAC6 soap_new_std__vectorTemplateOf_XML(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOf_XML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOf_XML(
    struct soap* soap, std::vector<char*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOf_XML(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<char*>;
    if (size)
      *size = sizeof(std::vector<char*>);
  } else {
    cp->ptr = (void*)new std::vector<char*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<char*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<char*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
  *(std::vector<char*>*)p = *(std::vector<char*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfbool(
    struct soap* soap, std::vector<bool>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfbool(
    struct soap* soap, const std::vector<bool>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfbool(struct soap* soap,
    const char* tag, int id, const std::vector<bool>* a, const char* type)
{
  for (std::vector<bool>::const_iterator i = a->begin(); i != a->end(); ++i) {
    bool b = (*i);
    if (soap_out_bool(soap, tag, id, &b, ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<bool>* SOAP_FMAC4 soap_in_std__vectorTemplateOfbool(
    struct soap* soap, const char* tag, std::vector<bool>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfbool(soap, -1)))
    return NULL;
  bool n = false;
  bool* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_bool,
              SOAP_TYPE_std__vectorTemplateOfbool, sizeof(bool), 0))
        break;
      if (!(p = soap_in_bool(soap, tag, NULL, "xsd:boolean")))
        break;
    } else {
      soap_default_bool(soap, &n);
      if (!soap_in_bool(soap, tag, &n, "xsd:boolean"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<bool>* SOAP_FMAC6 soap_new_std__vectorTemplateOfbool(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfbool(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfbool(
    struct soap* soap, std::vector<bool>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<bool>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfbool(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_std__vectorTemplateOfbool(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfbool, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<bool>;
    if (size)
      *size = sizeof(std::vector<bool>);
  } else {
    cp->ptr = (void*)new std::vector<bool>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<bool>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<bool>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfbool(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying std::vector<bool > %p -> %p\n", q, p));
  *(std::vector<bool>*)p = *(std::vector<bool>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedShort(
    struct soap* soap, std::vector<unsigned short>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedShort(
    struct soap* soap, const std::vector<unsigned short>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedShort(
    struct soap* soap, const char* tag, int id,
    const std::vector<unsigned short>* a, const char* type)
{
  for (std::vector<unsigned short>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_unsignedShort(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<unsigned short>* SOAP_FMAC4
soap_in_std__vectorTemplateOfunsignedShort(struct soap* soap, const char* tag,
    std::vector<unsigned short>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfunsignedShort(soap, -1)))
    return NULL;
  unsigned short n;
  unsigned short* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_unsignedShort,
              SOAP_TYPE_std__vectorTemplateOfunsignedShort,
              sizeof(unsigned short), 0))
        break;
      if (!(p = soap_in_unsignedShort(soap, tag, NULL, "xsd:unsignedShort")))
        break;
    } else {
      soap_default_unsignedShort(soap, &n);
      if (!soap_in_unsignedShort(soap, tag, &n, "xsd:unsignedShort"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<unsigned short>* SOAP_FMAC6
soap_new_std__vectorTemplateOfunsignedShort(struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfunsignedShort(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfunsignedShort(
    struct soap* soap, std::vector<unsigned short>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<unsigned short>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfunsignedShort(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "soap_instantiate_std__vectorTemplateOfunsignedShort(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfunsignedShort, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<unsigned short>;
    if (size)
      *size = sizeof(std::vector<unsigned short>);
  } else {
    cp->ptr = (void*)new std::vector<unsigned short>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<unsigned short>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<unsigned short>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfunsignedShort(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying std::vector<unsigned short > %p -> %p\n", q, p));
  *(std::vector<unsigned short>*)p = *(std::vector<unsigned short>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfdouble(
    struct soap* soap, std::vector<double>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfdouble(
    struct soap* soap, const std::vector<double>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfdouble(
    struct soap* soap, const char* tag, int id, const std::vector<double>* a,
    const char* type)
{
  for (std::vector<double>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_double(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<double>* SOAP_FMAC4 soap_in_std__vectorTemplateOfdouble(
    struct soap* soap, const char* tag, std::vector<double>* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfdouble(soap, -1)))
    return NULL;
  double n;
  double* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_double,
              SOAP_TYPE_std__vectorTemplateOfdouble, sizeof(double), 0))
        break;
      if (!(p = soap_in_double(soap, tag, NULL, "xsd:double")))
        break;
    } else {
      soap_default_double(soap, &n);
      if (!soap_in_double(soap, tag, &n, "xsd:double"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<double>* SOAP_FMAC6 soap_new_std__vectorTemplateOfdouble(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfdouble(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfdouble(
    struct soap* soap, std::vector<double>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<double>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfdouble(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_std__vectorTemplateOfdouble(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfdouble, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<double>;
    if (size)
      *size = sizeof(std::vector<double>);
  } else {
    cp->ptr = (void*)new std::vector<double>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<double>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<double>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfdouble(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying std::vector<double > %p -> %p\n", q, p));
  *(std::vector<double>*)p = *(std::vector<double>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedLONG64(
    struct soap* soap, std::vector<ULONG64>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedLONG64(
    struct soap* soap, const std::vector<ULONG64>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedLONG64(
    struct soap* soap, const char* tag, int id, const std::vector<ULONG64>* a,
    const char* type)
{
  for (std::vector<ULONG64>::const_iterator i = a->begin(); i != a->end();
       ++i) {
    if (soap_out_unsignedLONG64(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<ULONG64>* SOAP_FMAC4
soap_in_std__vectorTemplateOfunsignedLONG64(struct soap* soap, const char* tag,
    std::vector<ULONG64>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfunsignedLONG64(soap, -1)))
    return NULL;
  ULONG64 n;
  ULONG64* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_unsignedLONG64,
              SOAP_TYPE_std__vectorTemplateOfunsignedLONG64, sizeof(ULONG64),
              0))
        break;
      if (!(p = soap_in_unsignedLONG64(soap, tag, NULL, "xsd:unsignedLong")))
        break;
    } else {
      soap_default_unsignedLONG64(soap, &n);
      if (!soap_in_unsignedLONG64(soap, tag, &n, "xsd:unsignedLong"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<ULONG64>* SOAP_FMAC6
soap_new_std__vectorTemplateOfunsignedLONG64(struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfunsignedLONG64(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfunsignedLONG64(
    struct soap* soap, std::vector<ULONG64>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ULONG64>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfunsignedLONG64(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "soap_instantiate_std__vectorTemplateOfunsignedLONG64(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfunsignedLONG64, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<ULONG64>;
    if (size)
      *size = sizeof(std::vector<ULONG64>);
  } else {
    cp->ptr = (void*)new std::vector<ULONG64>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<ULONG64>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<ULONG64>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfunsignedLONG64(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying std::vector<ULONG64 > %p -> %p\n", q, p));
  *(std::vector<ULONG64>*)p = *(std::vector<ULONG64>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfLONG64(
    struct soap* soap, std::vector<LONG64>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfLONG64(
    struct soap* soap, const std::vector<LONG64>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfLONG64(
    struct soap* soap, const char* tag, int id, const std::vector<LONG64>* a,
    const char* type)
{
  for (std::vector<LONG64>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_LONG64(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<LONG64>* SOAP_FMAC4 soap_in_std__vectorTemplateOfLONG64(
    struct soap* soap, const char* tag, std::vector<LONG64>* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfLONG64(soap, -1)))
    return NULL;
  LONG64 n;
  LONG64* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_LONG64,
              SOAP_TYPE_std__vectorTemplateOfLONG64, sizeof(LONG64), 0))
        break;
      if (!(p = soap_in_LONG64(soap, tag, NULL, "xsd:long")))
        break;
    } else {
      soap_default_LONG64(soap, &n);
      if (!soap_in_LONG64(soap, tag, &n, "xsd:long"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<LONG64>* SOAP_FMAC6 soap_new_std__vectorTemplateOfLONG64(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfLONG64(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfLONG64(
    struct soap* soap, std::vector<LONG64>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<LONG64>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfLONG64(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_std__vectorTemplateOfLONG64(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfLONG64, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<LONG64>;
    if (size)
      *size = sizeof(std::vector<LONG64>);
  } else {
    cp->ptr = (void*)new std::vector<LONG64>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<LONG64>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<LONG64>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfLONG64(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying std::vector<LONG64 > %p -> %p\n", q, p));
  *(std::vector<LONG64>*)p = *(std::vector<LONG64>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedInt(
    struct soap* soap, std::vector<unsigned int>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedInt(
    struct soap* soap, const std::vector<unsigned int>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedInt(
    struct soap* soap, const char* tag, int id,
    const std::vector<unsigned int>* a, const char* type)
{
  for (std::vector<unsigned int>::const_iterator i = a->begin(); i != a->end();
       ++i) {
    if (soap_out_unsignedInt(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<unsigned int>* SOAP_FMAC4
soap_in_std__vectorTemplateOfunsignedInt(struct soap* soap, const char* tag,
    std::vector<unsigned int>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfunsignedInt(soap, -1)))
    return NULL;
  unsigned int n;
  unsigned int* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_unsignedInt,
              SOAP_TYPE_std__vectorTemplateOfunsignedInt, sizeof(unsigned int),
              0))
        break;
      if (!(p = soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt")))
        break;
    } else {
      soap_default_unsignedInt(soap, &n);
      if (!soap_in_unsignedInt(soap, tag, &n, "xsd:unsignedInt"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<unsigned int>* SOAP_FMAC6
soap_new_std__vectorTemplateOfunsignedInt(struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfunsignedInt(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfunsignedInt(
    struct soap* soap, std::vector<unsigned int>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<unsigned int>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfunsignedInt(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "soap_instantiate_std__vectorTemplateOfunsignedInt(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfunsignedInt, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<unsigned int>;
    if (size)
      *size = sizeof(std::vector<unsigned int>);
  } else {
    cp->ptr = (void*)new std::vector<unsigned int>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<unsigned int>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<unsigned int>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfunsignedInt(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying std::vector<unsigned int > %p -> %p\n", q, p));
  *(std::vector<unsigned int>*)p = *(std::vector<unsigned int>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(
    struct soap* soap, std::vector<int>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(
    struct soap* soap, const std::vector<int>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap* soap,
    const char* tag, int id, const std::vector<int>* a, const char* type)
{
  for (std::vector<int>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_int(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<int>* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(
    struct soap* soap, const char* tag, std::vector<int>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
    return NULL;
  int n;
  int* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_int,
              SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
        break;
      if (!(p = soap_in_int(soap, tag, NULL, "xsd:int")))
        break;
    } else {
      soap_default_int(soap, &n);
      if (!soap_in_int(soap, tag, &n, "xsd:int"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<int>* SOAP_FMAC6 soap_new_std__vectorTemplateOfint(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfint(
    struct soap* soap, std::vector<int>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<int>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfint(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n,
                   type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<int>;
    if (size)
      *size = sizeof(std::vector<int>);
  } else {
    cp->ptr = (void*)new std::vector<int>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<int>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<int>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(
      TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
  *(std::vector<int>*)p = *(std::vector<int>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOffloat(
    struct soap* soap, std::vector<float>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOffloat(
    struct soap* soap, const std::vector<float>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOffloat(struct soap* soap,
    const char* tag, int id, const std::vector<float>* a, const char* type)
{
  for (std::vector<float>::const_iterator i = a->begin(); i != a->end(); ++i) {
    if (soap_out_float(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<float>* SOAP_FMAC4 soap_in_std__vectorTemplateOffloat(
    struct soap* soap, const char* tag, std::vector<float>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOffloat(soap, -1)))
    return NULL;
  float n;
  float* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_float,
              SOAP_TYPE_std__vectorTemplateOffloat, sizeof(float), 0))
        break;
      if (!(p = soap_in_float(soap, tag, NULL, "xsd:float")))
        break;
    } else {
      soap_default_float(soap, &n);
      if (!soap_in_float(soap, tag, &n, "xsd:float"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<float>* SOAP_FMAC6 soap_new_std__vectorTemplateOffloat(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOffloat(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOffloat(
    struct soap* soap, std::vector<float>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<float>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOffloat(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "soap_instantiate_std__vectorTemplateOffloat(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOffloat, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<float>;
    if (size)
      *size = sizeof(std::vector<float>);
  } else {
    cp->ptr = (void*)new std::vector<float>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<float>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<float>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOffloat(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "Copying std::vector<float > %p -> %p\n", q, p));
  *(std::vector<float>*)p = *(std::vector<float>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__ItemValue(
    struct soap* soap, std::vector<s0__ItemValue*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__ItemValue(
    struct soap* soap, const std::vector<s0__ItemValue*>* a)
{
  for (std::vector<s0__ItemValue*>::const_iterator i = a->begin();
       i != a->end(); ++i)
    soap_serialize_PointerTos0__ItemValue(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__ItemValue(
    struct soap* soap, const char* tag, int id,
    const std::vector<s0__ItemValue*>* a, const char* type)
{
  for (std::vector<s0__ItemValue*>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_PointerTos0__ItemValue(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__ItemValue*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__ItemValue(struct soap* soap,
    const char* tag, std::vector<s0__ItemValue*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__ItemValue(soap, -1)))
    return NULL;
  s0__ItemValue* n;
  s0__ItemValue** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__ItemValue,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue,
              sizeof(s0__ItemValue), 1))
        break;
      if (!(p = soap_in_PointerTos0__ItemValue(
                soap, tag, NULL, "s0:ItemValue")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__ItemValue(soap, tag, &n, "s0:ItemValue"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__ItemValue*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__ItemValue(struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__ItemValue(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__ItemValue(
    struct soap* soap, std::vector<s0__ItemValue*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__ItemValue*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__ItemValue(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "ItemValue(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__ItemValue*>;
    if (size)
      *size = sizeof(std::vector<s0__ItemValue*>);
  } else {
    cp->ptr = (void*)new std::vector<s0__ItemValue*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__ItemValue*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__ItemValue*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4
soap_copy_std__vectorTemplateOfPointerTos0__ItemValue(struct soap* soap, int st,
    int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying std::vector<s0__ItemValue * > %p -> %p\n", q, p));
  *(std::vector<s0__ItemValue*>*)p = *(std::vector<s0__ItemValue*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfPointerTos0__ReadRequestItem(
    struct soap* soap, std::vector<s0__ReadRequestItem*>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfPointerTos0__ReadRequestItem(
    struct soap* soap, const std::vector<s0__ReadRequestItem*>* a)
{
  for (std::vector<s0__ReadRequestItem*>::const_iterator i = a->begin();
       i != a->end(); ++i)
    soap_serialize_PointerTos0__ReadRequestItem(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4
soap_out_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap* soap,
    const char* tag, int id, const std::vector<s0__ReadRequestItem*>* a,
    const char* type)
{
  for (std::vector<s0__ReadRequestItem*>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_PointerTos0__ReadRequestItem(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__ReadRequestItem*>* SOAP_FMAC4
soap_in_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap* soap,
    const char* tag, std::vector<s0__ReadRequestItem*>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a
      && !(a = soap_new_std__vectorTemplateOfPointerTos0__ReadRequestItem(
               soap, -1)))
    return NULL;
  s0__ReadRequestItem* n;
  s0__ReadRequestItem** p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__ReadRequestItem,
              SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem,
              sizeof(s0__ReadRequestItem), 1))
        break;
      if (!(p = soap_in_PointerTos0__ReadRequestItem(
                soap, tag, NULL, "s0:ReadRequestItem")))
        break;
    } else {
      n = NULL;
      if (!soap_in_PointerTos0__ReadRequestItem(
              soap, tag, &n, "s0:ReadRequestItem"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<s0__ReadRequestItem*>* SOAP_FMAC6
soap_new_std__vectorTemplateOfPointerTos0__ReadRequestItem(
    struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfPointerTos0__ReadRequestItem(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfPointerTos0__ReadRequestItem(
    struct soap* soap, std::vector<s0__ReadRequestItem*>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__ReadRequestItem*>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfPointerTos0__ReadRequestItem(
    struct soap* soap, int n, const char* type, const char* arrayType,
    size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__"
                           "ReadRequestItem(%d, %s, %s)\n",
          n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem, n,
      soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<s0__ReadRequestItem*>;
    if (size)
      *size = sizeof(std::vector<s0__ReadRequestItem*>);
  } else {
    cp->ptr = (void*)new std::vector<s0__ReadRequestItem*>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<s0__ReadRequestItem*>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<s0__ReadRequestItem*>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4
soap_copy_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap* soap,
    int st, int tt, void* p, size_t len, const void* q, size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "Copying std::vector<s0__ReadRequestItem * > %p -> %p\n", q, p));
  *(std::vector<s0__ReadRequestItem*>*)p
      = *(std::vector<s0__ReadRequestItem*>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4
soap_default_std__vectorTemplateOfs0__interfaceVersion(
    struct soap* soap, std::vector<enum s0__interfaceVersion>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4
soap_serialize_std__vectorTemplateOfs0__interfaceVersion(
    struct soap* soap, const std::vector<enum s0__interfaceVersion>* a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfs0__interfaceVersion(
    struct soap* soap, const char* tag, int id,
    const std::vector<enum s0__interfaceVersion>* a, const char* type)
{
  for (std::vector<enum s0__interfaceVersion>::const_iterator i = a->begin();
       i != a->end(); ++i) {
    if (soap_out_s0__interfaceVersion(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum s0__interfaceVersion>* SOAP_FMAC4
soap_in_std__vectorTemplateOfs0__interfaceVersion(struct soap* soap,
    const char* tag, std::vector<enum s0__interfaceVersion>* a,
    const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfs0__interfaceVersion(soap, -1)))
    return NULL;
  enum s0__interfaceVersion n;
  enum s0__interfaceVersion* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_s0__interfaceVersion,
              SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion,
              sizeof(enum s0__interfaceVersion), 0))
        break;
      if (!(p = soap_in_s0__interfaceVersion(
                soap, tag, NULL, "s0:interfaceVersion")))
        break;
    } else {
      soap_default_s0__interfaceVersion(soap, &n);
      if (!soap_in_s0__interfaceVersion(soap, tag, &n, "s0:interfaceVersion"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<enum s0__interfaceVersion>* SOAP_FMAC6
soap_new_std__vectorTemplateOfs0__interfaceVersion(struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfs0__interfaceVersion(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6
soap_delete_std__vectorTemplateOfs0__interfaceVersion(
    struct soap* soap, std::vector<enum s0__interfaceVersion>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<enum s0__interfaceVersion>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfs0__interfaceVersion(struct soap* soap,
    int n, const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfs0__"
                                    "interfaceVersion(%d, %s, %s)\n",
                   n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(soap, NULL,
      SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<enum s0__interfaceVersion>;
    if (size)
      *size = sizeof(std::vector<enum s0__interfaceVersion>);
  } else {
    cp->ptr = (void*)new std::vector<enum s0__interfaceVersion>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<enum s0__interfaceVersion>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<enum s0__interfaceVersion>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfs0__interfaceVersion(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "Copying std::vector<enum s0__interfaceVersion > %p -> %p\n", q, p));
  *(std::vector<enum s0__interfaceVersion>*)p
      = *(std::vector<enum s0__interfaceVersion>*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(
    struct soap* soap, std::vector<std::string>* p)
{
  p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(
    struct soap* soap, const std::vector<std::string>* a)
{
  for (std::vector<std::string>::const_iterator i = a->begin(); i != a->end();
       ++i)
    soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(
    struct soap* soap, const char* tag, int id,
    const std::vector<std::string>* a, const char* type)
{
  for (std::vector<std::string>::const_iterator i = a->begin(); i != a->end();
       ++i) {
    if (soap_out_std__string(soap, tag, id, &(*i), ""))
      return soap->error;
  }
  return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string>* SOAP_FMAC4
soap_in_std__vectorTemplateOfstd__string(struct soap* soap, const char* tag,
    std::vector<std::string>* a, const char* type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
    return NULL;
  std::string n;
  std::string* p;
  do {
    soap_revert(soap);
    if (*soap->id || *soap->href) {
      if (!soap_container_id_forward(soap, *soap->id ? soap->id : soap->href, a,
              (size_t)a->size(), SOAP_TYPE_std__string,
              SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string),
              0))
        break;
      if (!(p = soap_in_std__string(soap, tag, NULL, "xsd:string")))
        break;
    } else {
      soap_default_std__string(soap, &n);
      if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
        break;
    }
    a->push_back(n);
  } while (!soap_element_begin_in(soap, tag, 1, NULL));
  if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG) {
    soap->error = SOAP_OK;
    return a;
  }
  return NULL;
}

SOAP_FMAC5 std::vector<std::string>* SOAP_FMAC6
soap_new_std__vectorTemplateOfstd__string(struct soap* soap, int n)
{
  return soap_instantiate_std__vectorTemplateOfstd__string(
      soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(
    struct soap* soap, std::vector<std::string>* p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string>* SOAP_FMAC4
soap_instantiate_std__vectorTemplateOfstd__string(struct soap* soap, int n,
    const char* type, const char* arrayType, size_t* size)
{
  DBGLOG(TEST,
      SOAP_MESSAGE(fdebug,
          "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n,
          type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist* cp = soap_link(
      soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0) {
    cp->ptr = (void*)new std::vector<std::string>;
    if (size)
      *size = sizeof(std::vector<std::string>);
  } else {
    cp->ptr = (void*)new std::vector<std::string>[ n ];
    if (!cp->ptr) {
      soap->error = SOAP_EOM;
      return NULL;
    }
    if (size)
      *size = n * sizeof(std::vector<std::string>);
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (std::vector<std::string>*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(
    struct soap* soap, int st, int tt, void* p, size_t len, const void* q,
    size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug,
                   "Copying std::vector<std::string > %p -> %p\n", q, p));
  *(std::vector<std::string>*)p = *(std::vector<std::string>*)q;
}
#ifdef __cplusplus
}
#endif

/* End of opc_soap_C.cpp */
